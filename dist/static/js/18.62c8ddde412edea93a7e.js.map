{"version":3,"sources":["webpack:///static/js/18.62c8ddde412edea93a7e.js","webpack:///markdown.vue","webpack:///./~/codemirror-spell-checker/src/js/spell-checker.js","webpack:///./~/codemirror/addon/display/fullscreen.js","webpack:///./~/codemirror/addon/display/placeholder.js","webpack:///./~/codemirror/addon/edit/continuelist.js","webpack:///./~/codemirror/addon/selection/mark-selection.js","webpack:///./~/codemirror/mode/gfm/gfm.js","webpack:///./~/codemirror/mode/meta.js","webpack:///./~/simplemde/dist/simplemde.min.css","webpack:///./src/components/MdEditor/index.vue?cc92","webpack:///./~/simplemde/dist/simplemde.min.css?c3b4","webpack:///./src/components/MdEditor/index.vue?2e45","webpack:///./~/marked/lib/marked.js","webpack:///./~/simplemde/src/js/codemirror/tablist.js","webpack:///./~/simplemde/src/js/simplemde.js","webpack:///./~/typo-js/typo.js","webpack:///./src/components/MdEditor/index.vue","webpack:///./src/components/MdEditor/index.vue?6a56","webpack:///./src/views/components/markdown.vue?1616","webpack:///./src/views/components/markdown.vue","webpack:///./~/codemirror/lib/codemirror.js","webpack:///./~/base64-js/index.js?2add","webpack:///./~/buffer/index.js?1a55","webpack:///./~/ieee754/index.js?70fe","webpack:///./~/isarray/index.js?eabc","webpack:///./~/codemirror/addon/mode/overlay.js","webpack:///./~/codemirror/mode/markdown/markdown.js","webpack:///./~/codemirror/mode/xml/xml.js","webpack:///index.vue?b471"],"names":["webpackJsonp","1000","module","__webpack_exports__","__webpack_require__","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_0_components_MdEditor__","__WEBPACK_IMPORTED_MODULE_0_components_MdEditor___default","n","components","MdEditor","a","data","content","html","methods","markdown2Html","_this","this","e","then","bind","showdown","converter","Converter","makeHtml","1070","exports","CodeMirrorSpellChecker","options","codeMirrorInstance","defineMode","console","log","String","prototype","includes","indexOf","apply","arguments","config","aff_loading","xhr_aff","XMLHttpRequest","open","onload","readyState","status","aff_data","responseText","num_loaded","typo","Typo","dic_data","platform","send","dic_loading","xhr_dic","rx_word","overlay","token","stream","ch","peek","word","next","check","mode","getMode","backdrop","overlayMode","1071","mod","CodeMirror","setFullscreen","cm","wrap","getWrapperElement","state","fullScreenRestore","scrollTop","window","pageYOffset","scrollLeft","pageXOffset","width","style","height","className","document","documentElement","overflow","refresh","setNormal","replace","info","scrollTo","defineOption","val","old","Init","1072","clearPlaceholder","placeholder","parentNode","removeChild","setPlaceholder","elt","createElement","cssText","placeHolder","getOption","createTextNode","appendChild","display","lineSpace","insertBefore","firstChild","onBlur","isEmpty","onChange","wrapper","empty","lineCount","getLine","prev","on","off","hasFocus","1073","listRE","emptyListRE","unorderedListRE","commands","newlineAndIndentContinueMarkdownList","Pass","ranges","listSelections","replacements","i","length","pos","head","eolState","getStateAfter","line","inList","list","inQuote","quote","match","exec","execCommand","test","replaceRange","indent","after","bullet","parseInt","replaceSelections","1076","onCursorActivity","markedSelection","operation","update","clear","coverRange","from","to","addAt","cmp","array","cls","markedSelectionStyle","start","Pos","endLine","CHUNK_SIZE","atEnd","end","mark","markText","push","splice","reset","somethingSelected","getCursor","coverStart","find","coverEnd","shift","pop","cmpPos","1077","urlRE","modeConfig","blankLine","code","codeDepth","gfmOverlay","startState","codeBlock","ateSpace","copyState","s","combineTokens","skipToEnd","sol","before","eatWhile","difference","eatSpace","gitHubSpice","string","slice","charAt","markdownConfig","taskLists","fencedCodeBlocks","strikethrough","attr","name","defineMIME","1079","modeInfo","mime","ext","mimes","file","alias","findModeByMIME","toLowerCase","j","findModeByExtension","findModeByFileName","filename","dot","lastIndexOf","substring","findModeByName","1084","version","sources","names","mappings","sourcesContent","sourceRoot","1123","1180","locals","1219","1271","global","Lexer","tokens","links","marked","defaults","rules","block","normal","gfm","tables","InlineLexer","inline","renderer","Renderer","Error","breaks","pedantic","Parser","escape","encode","unescape","_","fromCharCode","regex","opt","source","self","RegExp","noop","merge","obj","target","key","hasOwnProperty","call","src","callback","pending","highlight","lex","done","err","out","parse","type","text","lang","escaped","message","silent","newline","fences","hr","heading","nptable","lheading","blockquote","def","table","paragraph","item","_tag","top","bq","loose","cap","bull","b","space","l","depth","header","split","align","cells","ordered","smartLists","join","sanitize","pre","sanitizer","href","title","charCodeAt","autolink","url","tag","link","reflink","nolink","strong","em","br","del","_inside","_href","output","mangle","inLink","outputLink","codespan","smartypants","image","Math","random","toString","langPrefix","level","raw","headerPrefix","xhtml","body","listitem","tablerow","tablecell","flags","prot","decodeURIComponent","reverse","tok","parseText","row","cell","setOptions","parser","lexer","inlineLexer","1281","tabAndIndentMarkdownList","indentWithTabs","spaces","Array","tabSize","replaceSelection","shiftTabAndUnindentMarkdownList","1282","fixShortcut","isMac","createIcon","enableTooltips","shortcuts","el","undefined","createTootlip","action","tabIndex","createSep","innerHTML","actionName","tooltip","getBindingName","getState","stat","getTokenAt","types","ret","bold","italic","toggleFullScreen","editor","codemirror","setOption","saved_overflow","previousSibling","toolbarButton","toolbarElements","fullscreen","nextSibling","toggleSideBySide","toggleBold","_toggleBlock","blockStyles","toggleItalic","toggleStrikethrough","toggleCodeBlock","fencing_line","styles","token_state","base","code_type","line_num","firstTok","lastTok","getLineHandle","indentedCode","fencedChars","block_start","block_end","fenceCharsToInsert","cur_start","cur_end","is_code","setSelection","focus","start_text","start_line","end_text","end_line","fencedTok","fence_chars","search_from","next_line","next_line_last_tok","next_line_indented","indentLine","no_sel_and_starting_of_line","sel_multi","start_line_sel","end_line_sel","repl_start","repl_end","_replaceSelection","toggleBlockquote","_toggleLine","toggleHeadingSmaller","_toggleHeading","toggleHeadingBigger","toggleHeading1","toggleHeading2","toggleHeading3","toggleUnorderedList","toggleOrderedList","cleanBlock","_cleanBlock","drawLink","promptURLs","prompt","promptTexts","insertTexts","drawImage","drawTable","drawHorizontalRule","horizontalRule","undo","redo","preview","useSideBySideListener","setTimeout","previewNormal","lastChild","toolbar","toolbar_div","sideBySideRenderingFunction","previewRender","togglePreview","active","startEnd","startPoint","endPoint","getSelection","direction","size","currHeadingLevel","search","substr","repl","unordered-list","ordered-list","map","start_chars","end_chars","_mergeProperties","property","concat","constructor","extend","wordCount","pattern","m","count","SimpleMDE","parent","autoDownloadFA","autoDownloadFontAwesome","styleSheets","rel","getElementsByTagName","element","toolbarBuiltInButtons","default","showIcons","plainText","markdown","parsingConfig","highlightFormatting","autosave","unique_id","uniqueId","render","initialValue","foundSavedValue","isLocalStorageAvailable","localStorage","setItem","removeItem","navigator","bindings","f","isMobile","userAgent","vendor","opera","heading-smaller","heading-bigger","heading-1","heading-2","heading-3","separator-1","clean-block","separator-2","horizontal-rule","separator-3","side-by-side","separator-4","guide","separator-5","markedOptions","renderingConfig","singleLineBreaks","codeSyntaxHighlighting","hljs","highlightAuto","_rendered","keyMaps","addEventListener","event","keyCode","spellChecker","fromTextArea","theme","indentUnit","lineNumbers","autofocus","extraKeys","lineWrapping","allowDropFileTypes","getAttribute","styleSelectedText","forceSync","save","gui","createToolbar","statusbar","createStatusbar","enabled","sideBySide","createSideBySide","temp_cm","simplemde","form","loaded","getItem","setValue","getElementById","d","Date","hh","getHours","getMinutes","dd","h","autosaveTimeoutId","delay","clearAutosavedValue","cScroll","pScroll","v","getScrollInfo","clientHeight","ratio","parseFloat","move","scrollHeight","onscroll","items","bar","toolbarData","toolbarGuideIcon","hideIcons","nonSeparatorIconsFollow","x","toolbarTips","onclick","preventDefault","cmWrapper","onUpdate","defaultValue","getValue","setAttribute","getDoc","isPreviewActive","isSideBySideActive","isFullscreenActive","toTextArea","clearTimeout","1284","__dirname","Buffer","dictionary","affData","wordsData","settings","readDataFile","setFunc","response","_readFile","asyncLoad","setAffData","setup","setWordsData","_parseAFF","compoundRuleCodes","_len","compoundRules","rule","_jlen","ONLYINCOMPOUND","dictionaryTable","_parseDIC","ruleText","expressionText","character","loadedCallback","replacementTable","memoized","path","chrome","extension","dictionaryPath","getURL","load","charset","async","promise","req","Promise","resolve","reject","statusText","onerror","overrideMimeType","fs","existsSync","stats","statSync","fileDescriptor","openSync","buffer","readSync","subline","numEntries","lineParts","_removeAffixComments","lines","definitionParts","ruleType","ruleCode","combineable","entries","charactersToRemove","additionParts","charactersToAdd","continuationClasses","parseRuleCodes","regexToMatch","entry","add","remove","addWord","_removeDicComments","parts","ruleCodesArray","NEEDAFFIX","newWords","_applyRule","ii","_iilen","newWord","k","combineCode","combineRule","otherNewWords","iii","_iiilen","otherNewWord","trim","textCodes","FLAG","continuationRule","aWord","trimmedWord","checkExact","toUpperCase","capitalizedWord","hasFlag","lowercaseWord","ruleCodes","COMPOUNDMIN","flag","wordFlags","alphabet","suggest","limit","edits1","words","rv","known","memoizedLimit","replacementEntry","correctedWord","suggestions","sorter","ed1","ed2","corrections","weighted_corrections","sorted_corrections","sort","capitalization_scheme","min","1295","injectStyle","ssrContext","Component","1358","_vm","_h","$createElement","_c","_self","staticClass","zIndex","attrs","id","staticRenderFns","1398","_m","_v","ref","model","$$v","expression","staticStyle","margin-top","click","domProps","_s","1421","761","877","factory","classTest","removeChildren","childNodes","removeChildrenAndAdd","eltP","contains","child","nodeType","host","activeElt","activeElement","shadowRoot","addClass","node","current","joinClasses","as","args","copyObj","overwrite","prop","countColumn","startIndex","startValue","nextTab","findColumn","goal","col","skipped","spaceStr","spaceStrs","lst","arr","insertSorted","score","priority","nothing","createObj","props","inst","create","isWordCharBasic","nonASCIISingleCaseWordChar","isWordChar","helper","isExtendingChar","extendingChars","skipExtendingChars","str","dir","findFirst","pred","abs","mid","floor","Display","place","doc","input","scrollbarFiller","gutterFiller","lineDiv","selectionDiv","cursorDiv","measure","lineMeasure","mover","sizer","sizerWidth","heightForcer","scrollerGap","gutters","lineGutter","scroller","ie","ie_version","paddingRight","webkit","gecko","mobile","draggable","viewFrom","viewTo","first","reportedViewFrom","reportedViewTo","view","renderedView","externalMeasured","viewOffset","lastWrapHeight","lastWrapWidth","updateLineNumbers","nativeBarWidth","barHeight","barWidth","scrollbarsClipped","lineNumWidth","lineNumInnerWidth","lineNumChars","alignWidgets","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","selForContextMenu","activeTouch","init","chunk","children","sz","chunkSize","getBetween","iter","getLines","updateLineHeight","diff","lineNo","cur","no","lineAtHeight","outer","i$1","lh","isLine","lineNumberFor","lineNumberFormatter","firstLineNumber","sticky","equalCursorPos","copyPos","maxPos","minPos","clipLine","max","clipPos","last","clipToLen","linelen","clipPosArray","seeReadOnlySpans","sawReadOnlySpans","seeCollapsedSpans","sawCollapsedSpans","MarkedSpan","marker","getMarkedSpanFor","spans","span","removeMarkedSpan","r","addMarkedSpan","markedSpans","attachLine","markedSpansBefore","startCh","isInsert","nw","startsBefore","inclusiveLeft","insertLeft","endsAfter","inclusiveRight","markedSpansAfter","endCh","stretchSpansOverChange","change","full","oldFirst","oldLast","sameLine","offset","found","span$1","found$1","clearEmptySpans","newMarkers","gapMarkers","gap","i$2","i$3","clearWhenEmpty","removeReadOnlyRanges","markers","readOnly","mk","p","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","sp","collapsed","collapsedSpanAtStart","collapsedSpanAtEnd","conflictingCollapsedRange","lineNo$$1","visualLine","merged","visualLineEnd","visualLineContinued","visualLineNo","lineN","vis","visualLineEndNo","lastLine","lineIsHidden","widgetNode","lineIsHiddenInner","heightAtLine","lineObj","lineLength","len","findMaxLine","iterateBidiSections","order","part","getBidiPartAt","bidiOther","getOrder","bidiOrdering","moveCharLogically","moveLogically","endOfLine","visually","moveInStorageOrder","prep","prepareMeasureForLine","targetTop","measureCharPrepared","moveVisually","bidi","partPos","mv","getWrappedLineExtent","wrappedLineExtentChar","begin","wrappedLineExtent","searchInVisualLine","getRes","res","nextCh","getHandlers","emitter","_handlers","noHandlers","removeEventListener","detachEvent","map$$1","index","signal","handlers","signalDOMEvent","override","defaultPrevented","e_defaultPrevented","codemirrorIgnore","signalCursorActivity","cursorActivity","set","curOp","cursorActivityHandlers","hasHandler","eventMixin","ctor","e_preventDefault","returnValue","e_stopPropagation","stopPropagation","cancelBubble","e_stop","e_target","srcElement","e_button","which","button","mac","ctrlKey","zeroWidthElement","zwspSupported","offsetHeight","offsetWidth","hasBadBidiRects","badBidiRects","txt","r0","range","getBoundingClientRect","r1","left","right","hasBadZoomedRects","badZoomedRects","fromRange","dependencies","modes","spec","mimeModes","resolveMode","mfactory","modeObj","modeExtensions","exts","helperType","modeProps","prop$1","extendMode","properties","nstate","innerMode","a1","a2","highlightLine","forceToEnd","st","modeGen","lineClasses","runMode","o","overlays","at","i_end","opaque","classes","bgClass","textClass","getLineStyles","updateFrontier","getStateBefore","result","maxHighlightLength","stateAfter","styleClasses","frontier","precise","findStartLine","processLine","startAt","StringStream","callBlankLine","eol","readToken","inner","takeToken","asArray","getObj","copy","extractLineClasses","lineClass","flattenSpans","curStart","curStyle","addModeClass","mName","minindent","minline","lim","indented","updateLine","estimateHeight","estHeight","cleanUpLine","interpretTokenStyle","cache","styleToClassCacheWithMode","styleToClassCache","buildLineContent","lineView","builder","trailingSpace","splitSpaces","rest","addToken","buildToken","buildTokenBadBidi","insertLineContent","maps","caches","querySelector","defaultSpecialCharPlaceholder","startStyle","endStyle","css","displayText","special","specialChars","mustWrap","createDocumentFragment","lastIndex","txt$1","tabWidth","specialCharPlaceholder","fullStyle","trailingBefore","spaceBefore","buildCollapsedSpan","ignoreWidget","widget","needsContentAttribute","setUneditable","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","Infinity","foundBookmarks","endStyles","j$1","j$2","upto","tokenText","LineView","hidden","buildViewArray","nextPos","pushOperation","op","operationGroup","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","group","callbacks","cursorActivityCalled","finishOperation","endCb","signalLater","orphanDelayedCallbacks","fireOrphanDelayed","delayed","updateLineForChanges","dims","changes","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","updateLineBackground","background","getLineContent","built","wrapClass","gutter","gutterBackground","gutterClass","fixedGutter","fixedPos","gutterTotalWidth","gutterMarkers","wrap$1","gutterWrap","lineNumber","gutterLeft","gutterWidth","alignable","insertLineWidgets","buildLineElement","insertLineWidgetsFor","allowAbove","widgets","ws","handleMouseEvents","positionLineWidget","above","noHScroll","wrapperWidth","coverGutter","paddingLeft","position","marginLeft","widgetHeight","parentStyle","clientWidth","eventInWidget","paddingTop","offsetTop","paddingVert","paddingH","getComputedStyle","currentStyle","isNaN","scrollGap","displayWidth","displayHeight","ensureLineHeights","rect","wrapping","curWidth","heights","rects","getClientRects","bottom","mapFromLineView","updateExternalMeasurement","measureChar","bias","findViewForLine","findViewIndex","getDimensions","forceUpdate","hasHeights","prepared","varHeight","measureCharInner","bogus","rtop","rbottom","nodeAndOffsetInLineMap","collapse","mStart","mEnd","getUsefulRect","nullRect","maybeUpdateRectForZooming","rSpan","charWidth","rbot","bot","singleCursorHeightPerLine","screen","logicalXDPI","deviceXDPI","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","clearCaches","pageScrollX","android","pageScrollY","marginTop","intoCoordSystem","context","includeWidgets","yOff","lOff","xOff","fromCoordSystem","coords","localBox","lineSpaceBox","charCoords","cursorCoords","preparedMeasure","get","getBidi","invert","other","estimateCoords","PosWithInfo","outside","xRel","coordsChar","y","coordsCharInner","mergedPos","assign","prevDiff","prevPos","beginLeft","box","textHeight","measureText","anchor","clientLeft","offsetLeft","compensateForHScroll","th","perLine","widgetsHeight","ceil","estimateLineHeights","est","posFromMouse","liberal","forRect","clientX","clientY","colDiff","round","updateSelection","showSelection","prepareSelection","primary","curFragment","cursors","selFragment","selection","sel","primIndex","range$$1","showCursorWhenSelecting","drawSelectionCursor","drawSelectionRange","cursor","cursorHeight","otherCursor","fragment","rightSide","drawForLine","fromArg","toArg","lineLen","rightPos","leftPos","tmp","leftSide","padding","sFrom","sTo","fromLine","toLine","singleVLine","leftEnd","rightStart","restartBlink","focused","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","ensureFocus","onFocus","delayBlurEvent","delayingBlurEvent","receivedFocus","rmClass","updateHeightsInViewport","prevBottom","updateWidgetHeight","visibleLines","viewport","ensure","ensureFrom","ensureTo","alignHorizontally","comp","gutterW","maybeUpdateLineNumberWidth","innerW","updateGutterSpace","maybeScrollWindow","doScroll","innerHeight","phantom","scrollNode","scrollIntoView","scrollPosIntoView","margin","changed","endCoords","scrollPos","calculateScrollPos","startTop","startLeft","updateScrollTop","setScrollLeft","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollTop","resolveScrollToPos","ensureCursorVisible","scrollToPos","cursorScrollMargin","scrollToCoords","scrollToRange","scrollToCoordsRange","sPos","updateDisplaySimple","setScrollTop","startWorker","forceScroll","scrollbars","isScroller","scrollWidth","measureForScrollbars","docH","viewHeight","viewWidth","barLeft","docHeight","updateScrollbars","startWidth","startHeight","updateScrollbarsInner","sizes","paddingBottom","borderBottom","coverGutterNextToScrollbar","initScrollbars","scrollbarModel","scrollbarStyle","axis","startOperation","viewChanged","updateInput","typing","changeObjs","selectionChanged","updateMaxLine","nextOpId","endOperation","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","i$4","endOperation_finish","maybeClipScrollbars","mustUpdate","DisplayUpdate","updatedDisplay","updateDisplayIfNeeded","barMeasure","adjustWidthTo","maxScrollLeft","preparedSelection","minWidth","takeFocus","setDocumentHeight","postUpdateDisplay","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","finish","runInOp","methodOp","docMethodOp","regChange","lendiff","resetView","cut","viewCuttingPoint","cut$1","cutTop","cutBot","regLineChange","oldN","newN","adjustView","countDirtyView","dirty","time","highlightWorker","workTime","changedLines","oldStyles","tooLong","highlighted","oldCls","newCls","ischange","workDelay","marginBottom","borderRightWidth","selectionSnapshot","anchorNode","anchorOffset","focusNode","focusOffset","restoreSelection","snapshot","createRange","setEnd","removeAllRanges","addRange","editorIsHidden","force","visible","viewportMargin","different","wrapperHeight","toUpdate","selSnapshot","patchDisplay","minHeight","oldDisplayWidth","updateNumbersFrom","rm","currentWheelTarget","container","updateNumber","updateGutters","specs","gElt","setGuttersForLineNumbers","wheelEventDelta","dx","wheelDeltaX","dy","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","delta","wheelPixelsPerUnit","onScrollWheel","scroll","canScrollX","canScrollY","presto","pixels","wheelSamples","movedX","movedY","sample","normalizeSelection","prim","inv","Range","Selection","simpleSelection","changeEnd","adjustForChange","computeSelAfterChange","offsetPos","computeReplacedSel","hint","oldPrev","newPrev","loadMode","modeOption","resetModeState","isWholeLineUpdate","wholeLineUpdateBefore","updateDoc","estimateHeight$$1","spansFor","linesFor","Line","firstLine","lastText","lastSpans","nlines","insert","added","added$1","added$2","linkedDocs","sharedHistOnly","propagate","skip","sharedHist","linked","shared","attachDoc","setDirectionClass","directionChanged","History","startGen","undone","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","historyChangeFromChange","histChange","attachLocalSpans","clearSelectionEvents","lastChangeEvent","hist","addChangeToHistory","selAfter","opId","history","origin","historyEventDelay","pushSelectionToHistory","selectionEventCanBeMerged","addSelectionToHistory","clearRedo","dest","equals","existing","removeClearedSpans","explicitlyCleared","getOldSpans","mergeOldSpans","stretched","oldCur","stretchCur","copyHistoryArray","events","newGroup","instantiateSel","deepCopy","newChanges","Number","extendRange","posBefore","extendSelection","extendSelections","heads","replaceOneSelection","setSimpleSelection","filterSelectionChange","this$1","setSelectionReplaceHistory","setSelectionNoUndo","NaN","setSelectionInner","skipAtomicInSelection","reCheckSelection","mayClear","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","atomic","near","movePos","far","cantEdit","selectAll","sel_dontScroll","filterChange","canceled","cancel","makeChange","ignoreReadOnly","suppressEdits","makeChangeInner","makeChangeSingleDoc","rebased","rebaseHist","makeChangeFromHistory","allowSelectionOnly","antiChanges","filter","returned","shiftDoc","distance","removed","makeChangeSingleDocInEditor","recomputeMaxLength","checkWidthStart","changesHandler","changeHandler","splitLines","rebaseHistSelSingle","rebaseHistArray","sub","ok","copied","changeLine","handle","changeType","adjustScrollWhenAboveVisible","addLineWidget","LineWidget","insertAt","aboveVisible","markTextShared","TextMarker","replacedWith","addToHistory","curLine","clearOnEnter","clearHistory","nextMarkerId","cloneNode","isParent","SharedTextMarker","findSharedMarkers","findMarks","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","onDrop","clearDragCursor","lastDrop","files","dataTransfer","isReadOnly","FileReader","File","read","reader","lineSeparator","readAsText","draggingText","text$1","getData","selected","onDragStart","setData","effectAllowed","setDragImage","safari","img","_top","onDragOver","frag","dragCursor","forEachCodeMirror","getElementsByClassName","byClass","ensureGlobalHandlers","globalsRegistered","registerGlobalHandlers","resizeTimer","onResize","setSize","normalizeKeyName","alt","ctrl","cmd","normalizeKeyMap","keymap","keyname","keys","lookupKey","getKeyMap","fallthrough","isModifierKey","keyNames","keyName","noShift","altGraphKey","altKey","flipCtrlCmd","metaKey","shiftKey","keyMap","deleteNearSelection","compute","kill","toKill","replaced","lineStart","visual","lineEnd","lineStartSmart","firstNonWS","inWS","doHandleBinding","bound","dropShift","ensurePolled","prevShift","lookupKeyForEditor","dispatchKey","seq","keySeq","stopSeq","handleKeyBinding","motion","handleCharBinding","onKeyDown","handled","lastStoppedKey","hasCopyEvent","showCrossHair","up","onKeyUp","onKeyPress","charCode","onMouseDown","supportsTouch","clickInGutter","selectingText","leftButtonDown","lastMiddleDown","captureRightClick","onContextMenu","now","lastDoubleClick","lastClick","contained","modifier","dragDrop","dragAndDrop","leftButtonStartDrag","leftButtonSelect","moved","dragEnd","mouseMove","dragStart","e2","addNew","extendTo","lastPos","startCol","posCol","startSel","ourIndex","oldRange","ourRange","findWordAt","ranges$1","sel_mouse","curCount","counter","editorSize","chromeOS","gutterEvent","prevent","mX","mY","lineBox","g","contextMenuInGutter","themeChanged","guttersChanged","dragDropChanged","funcs","dragFunctions","toggle","enter","over","leave","drop","wrappingChanged","CodeMirror$1","Doc","inputStyles","inputStyle","pasteIncoming","cutIncoming","Delayed","registerEventHandlers","optionHandlers","finishInit","initHooks","textRendering","finishTouch","touchFinished","prevTouch","isMouseLikeTouchEvent","touches","touch","radiusX","radiusY","farAway","pageX","pageY","inp","getField","how","aggressive","curSpace","indentation","curSpaceString","indentString","pos$1","setLastCopied","newLastCopied","lastCopied","applyTextInput","inserted","deleted","paste","textLines","splitLinesAuto","multiPaste","lineWise","changeEvent","triggerElectric","handlePaste","pasted","clipboardData","disableInput","electricChars","smartIndent","getModeAt","electricInput","copyableRanges","lineRange","getRange","disableBrowserMagic","field","spellcheck","hiddenTextarea","te","div","ios","border","findPosH","unit","findNextLine","moveOnce","boundToLine","origDir","sawType","getHelper","hitSide","findPosV","pageSize","moveAmount","posToDOM","side","isInGutter","scan","badPos","bad","domTextBetween","recognizeMarker","close","closing","lineSep","addText","walk","cmText","textContent","markerID","isBlock","nodeName","nodeValue","domToPos","lineNode","locateNodeInLineView","textNode","topNode","curNode","dist","dist$1","textarea","tabindex","realSubmit","leaveSubmitMethodAlone","submit","wrappedSubmit","getTextArea","ie_upto10","ie_11up","edge","documentMode","qtwebkit","mac_geMountainLion","windows","presto_version","endNode","setStart","createTextRange","moveToElementText","moveEnd","moveStart","selectInput","select","selectionStart","selectionEnd","_e","ms","sel_move","charType","lowTypes","arabicTypes","BidiSpan","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","type$1","prev$1","type$2","type$3","i$5","cur$1","type$4","i$6","end$1","replace$1","i$7","nstart","unshift","attachEvent","nl","rt","hasSelection","ownerDocument","parentElement","compareEndPoints","oncopy","lastColumnPos","lastColumnValue","eat","skipTo","backUp","column","consume","caseInsensitive","cased","hideFirstChars","NativeScrollbars","vert","horiz","checkedZeroWidth","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","w","pointerEvents","maybeDisable","elementFromPoint","NullScrollbars","native","null","here","there","LeafChunk","removeInner","insertInner","iterN","BranchChunk","oldHeight","remaining","leaf","maybeSpill","me","spilled","sibling","myIndex","used","oldH","withOp","dHeight","nextDocId","cleanGeneration","getLineNumber","getLineHandleVisualStart","setCursor","extendSelectionsBy","setSelections","addSelection","getSelections","dup","newSel","undoSelection","redoSelection","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","setGutterMarker","gutterID","clearGutter","lineInfo","addLineClass","where","removeLineClass","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","sepSize","indexFromPos","copyHistory","linkedDoc","unlinkDoc","splitIds","iterLinkedDocs","getEditor","setDirection","eachLine","3","8","9","13","16","17","18","19","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","93","106","107","109","110","111","127","173","186","187","188","189","190","191","192","219","220","221","222","63232","63233","63234","63235","63272","63273","63275","63276","63277","63302","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","Ctrl-O","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","goDocStart","goDocEnd","goLineStart","goLineStartSmart","goLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","moveV","goLineDown","goPageUp","goPageDown","goCharLeft","moveH","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","deleteH","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentSelection","indentMore","indentLess","insertTab","insertSoftTab","defaultTab","transposeChars","newlineAndIndent","sels","openLine","toggleOverwrite","defineInitHook","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","composing","gracePeriod","readDOMTimeout","onCopyCut","lineWiseCopyCut","clearData","kludge","hadFocus","showPrimarySelection","updateFromDOM","readFromDOMSoon","forceCompositionEnd","showMultipleSelections","curAnchor","curFocus","rng","rangeCount","getRangeAt","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","blur","poll","pollSelection","pollInterval","triggerOnKeyDown","pollContent","fromIndex","fromNode","toNode","toIndex","newText","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","readOnlyChanged","resetPosition","TextareaInput","prevInput","pollingFast","inaccurateSelection","prepareCopyCut","fastPoll","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","minimal","slowPoll","missed","same","prepareSelectAllHack","extval","rehide","oldWrapperCSS","oldCSS","detectingSelectAll","resetSelectionOnContextMenu","wrapperBox","oldScrollY","scrollY","mouseup","option","deflt","notOnInit","newBreaks","getInputField","detach","attach","integer","disabled","helpers","addKeyMap","removeKeyMap","addOverlay","modeSpec","removeOverlay","newRanges","getLineTokens","getTokenTypeAt","getHelpers","help","_global","defaultTextHeight","defaultCharWidth","getViewport","addWidget","vspace","hspace","triggerOnKeyPress","triggerOnKeyUp","amount","rtlMoveVisually","goalColumn","goals","startChar","interpret","swapDoc","getScrollerElement","getGutterElement","registerHelper","registerGlobalHelper","predicate","dontDelegate","method","contenteditable","defineExtension","func","defineDocExtension","932","placeHoldersCount","b64","byteLength","toByteArray","placeHolders","Arr","L","revLookup","tripletToBase64","num","lookup","encodeChunk","uint8","fromByteArray","extraBytes","len2","Uint8Array","933","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","__proto__","arg","encodingOrOffset","allocUnsafe","TypeError","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","alloc","fill","encoding","checked","isEncoding","actual","write","fromArrayLike","byteOffset","isBuffer","isnan","isArray","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","bidirectionalIndexOf","arrayIndexOf","buf","indexSize","readUInt16BE","arrLength","valLength","foundIndex","hexWrite","strLen","parsed","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","base64","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","toHex","bytes","checkOffset","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","stringtrim","INVALID_BASE64_RE","units","leadSurrogate","byteArray","c","hi","lo","dst","INSPECT_MAX_BYTES","foo","subarray","poolSize","_augment","Symbol","species","configurable","allocUnsafeSlow","_isBuffer","compare","swap16","swap32","swap64","inspect","thisStart","thisEnd","thisCopy","targetCopy","isFinite","toJSON","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","944","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","LN2","945","959","combine","basePos","baseCur","overlayPos","overlayCur","streamSeen","textAfter","baseToken","overlayToken","960","cmCfg","modeCfg","switchInline","switchBlock","lineIsEmpty","linkTitle","htmlBlock","inlineNormal","blockNormal","trailingSpaceNewLine","prevLine","thisLine","prevLineIsList","prevLineIsIndentedCode","indentationDiff","tokenTypes","atxHeaderRE","formatting","getType","setextHeaderRE","footnoteLink","hrRE","listType","listStack","taskListRE","taskList","fencedCodeRE","localMode","localState","local","htmlMode","htmlState","htmlModeMissing","tagStart","tokenize","isInText","md_inside","returnType","maxBlockquoteDepth","taskOpen","taskClosed","linkHref","linkText","imageAltText","imageMarker","listMod","list2","list3","list1","handleText","textRE","matchCh","previousFormatting","t","formattingEscape","linkInline","linkEmail","leftFlanking","punctuation","rightFlanking","setEm","setStrong","getLinkHrefInside","endChar","returnState","linkRE","footnoteLinkInside","footnoteUrl","tokenTypeOverrides","tokenType","allowAtxHeaderWithoutSpace",")","]","forceBlankLine","closeBrackets","fold","961","htmlConfig","autoSelfClosers","area","command","embed","frame","keygen","meta","param","track","wbr","menuitem","implicitlyClosed","li","optgroup","rp","tbody","td","tfoot","tr","contextGrabbers","dt","address","article","aside","dl","fieldset","footer","h1","h2","h3","h4","h5","h6","hgroup","menu","nav","ol","section","ul","thead","doNotIndent","allowUnquoted","allowMissing","caseFold","xmlConfig","editorConf","config_","inText","chain","inBlock","doctype","inTag","baseState","tagName","inAttribute","stringStartCol","closure","isInAttribute","terminator","Context","startOfLine","noIndent","popContext","maybePopContext","nextTagName","parentTagName","tagNameState","closeTagNameState","setStyle","attrState","matchClosing","closeState","closeStateErr","_stream","attrEqState","attrValueState","attrContinuedState","baseIndent","fullLine","multilineTagIndentPastTag","multilineTagIndentFactor","alignCDATA","tagAfter","grabbers","blockCommentStart","blockCommentEnd","configuration","skipAttribute","968","__WEBPACK_IMPORTED_MODULE_0_simplemde_dist_simplemde_min_css__","__WEBPACK_IMPORTED_MODULE_1_simplemde__","__WEBPACK_IMPORTED_MODULE_1_simplemde___default","Boolean","hasChange","watch","mounted","$emit","destroyed"],"mappings":"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","file":"static/js/18.62c8ddde412edea93a7e.js","sourcesContent":["webpackJsonp([18],{\n\n/***/ 1000:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_components_MdEditor__ = __webpack_require__(1295);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_components_MdEditor___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_components_MdEditor__);\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  components: { MdEditor: __WEBPACK_IMPORTED_MODULE_0_components_MdEditor___default.a },\n  data: function data() {\n    return {\n      content: '## Simplemde',\n      html: ''\n    };\n  },\n\n  methods: {\n    markdown2Html: function markdown2Html() {\n      var _this = this;\n\n      __webpack_require__.e/* import() */(103).then(__webpack_require__.bind(null, 1280)).then(function (showdown) {\n        var converter = new showdown.Converter();\n        _this.html = converter.makeHtml(_this.content);\n      });\n    }\n  }\n});\n\n/***/ }),\n\n/***/ 1070:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Use strict mode (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)\r\n\r\n\r\n\r\n// Requires\r\nvar Typo = __webpack_require__(1284);\r\n\r\n\r\n// Create function\r\nfunction CodeMirrorSpellChecker(options) {\r\n\t// Initialize\r\n\toptions = options || {};\r\n\r\n\r\n\t// Verify\r\n\tif(typeof options.codeMirrorInstance !== \"function\" || typeof options.codeMirrorInstance.defineMode !== \"function\") {\r\n\t\tconsole.log(\"CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`\");\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\t// Because some browsers don't support this functionality yet\r\n\tif(!String.prototype.includes) {\r\n\t\tString.prototype.includes = function() {\r\n\t\t\t\"use strict\";\r\n\t\t\treturn String.prototype.indexOf.apply(this, arguments) !== -1;\r\n\t\t};\r\n\t}\r\n\r\n\r\n\t// Define the new mode\r\n\toptions.codeMirrorInstance.defineMode(\"spell-checker\", function(config) {\r\n\t\t// Load AFF/DIC data\r\n\t\tif(!CodeMirrorSpellChecker.aff_loading) {\r\n\t\t\tCodeMirrorSpellChecker.aff_loading = true;\r\n\t\t\tvar xhr_aff = new XMLHttpRequest();\r\n\t\t\txhr_aff.open(\"GET\", \"https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff\", true);\r\n\t\t\txhr_aff.onload = function() {\r\n\t\t\t\tif(xhr_aff.readyState === 4 && xhr_aff.status === 200) {\r\n\t\t\t\t\tCodeMirrorSpellChecker.aff_data = xhr_aff.responseText;\r\n\t\t\t\t\tCodeMirrorSpellChecker.num_loaded++;\r\n\r\n\t\t\t\t\tif(CodeMirrorSpellChecker.num_loaded == 2) {\r\n\t\t\t\t\t\tCodeMirrorSpellChecker.typo = new Typo(\"en_US\", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {\r\n\t\t\t\t\t\t\tplatform: \"any\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\txhr_aff.send(null);\r\n\t\t}\r\n\r\n\t\tif(!CodeMirrorSpellChecker.dic_loading) {\r\n\t\t\tCodeMirrorSpellChecker.dic_loading = true;\r\n\t\t\tvar xhr_dic = new XMLHttpRequest();\r\n\t\t\txhr_dic.open(\"GET\", \"https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic\", true);\r\n\t\t\txhr_dic.onload = function() {\r\n\t\t\t\tif(xhr_dic.readyState === 4 && xhr_dic.status === 200) {\r\n\t\t\t\t\tCodeMirrorSpellChecker.dic_data = xhr_dic.responseText;\r\n\t\t\t\t\tCodeMirrorSpellChecker.num_loaded++;\r\n\r\n\t\t\t\t\tif(CodeMirrorSpellChecker.num_loaded == 2) {\r\n\t\t\t\t\t\tCodeMirrorSpellChecker.typo = new Typo(\"en_US\", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {\r\n\t\t\t\t\t\t\tplatform: \"any\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\txhr_dic.send(null);\r\n\t\t}\r\n\r\n\r\n\t\t// Define what separates a word\r\n\t\tvar rx_word = \"!\\\"#$%&()*+,-./:;<=>?@[\\\\]^_`{|}~ \";\r\n\r\n\r\n\t\t// Create the overlay and such\r\n\t\tvar overlay = {\r\n\t\t\ttoken: function(stream) {\r\n\t\t\t\tvar ch = stream.peek();\r\n\t\t\t\tvar word = \"\";\r\n\r\n\t\t\t\tif(rx_word.includes(ch)) {\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhile((ch = stream.peek()) != null && !rx_word.includes(ch)) {\r\n\t\t\t\t\tword += ch;\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(CodeMirrorSpellChecker.typo && !CodeMirrorSpellChecker.typo.check(word))\r\n\t\t\t\t\treturn \"spell-error\"; // CSS class: cm-spell-error\r\n\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar mode = options.codeMirrorInstance.getMode(\r\n\t\t\tconfig, config.backdrop || \"text/plain\"\r\n\t\t);\r\n\r\n\t\treturn options.codeMirrorInstance.overlayMode(mode, overlay, true);\r\n\t});\r\n}\r\n\r\n\r\n// Initialize data globally to reduce memory consumption\r\nCodeMirrorSpellChecker.num_loaded = 0;\r\nCodeMirrorSpellChecker.aff_loading = false;\r\nCodeMirrorSpellChecker.dic_loading = false;\r\nCodeMirrorSpellChecker.aff_data = \"\";\r\nCodeMirrorSpellChecker.dic_data = \"\";\r\nCodeMirrorSpellChecker.typo;\r\n\r\n\r\n// Export\r\nmodule.exports = CodeMirrorSpellChecker;\n\n/***/ }),\n\n/***/ 1071:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (true) // CommonJS\r\n    mod(__webpack_require__(877));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  CodeMirror.defineOption(\"fullScreen\", false, function(cm, val, old) {\r\n    if (old == CodeMirror.Init) old = false;\r\n    if (!old == !val) return;\r\n    if (val) setFullscreen(cm);\r\n    else setNormal(cm);\r\n  });\r\n\r\n  function setFullscreen(cm) {\r\n    var wrap = cm.getWrapperElement();\r\n    cm.state.fullScreenRestore = {scrollTop: window.pageYOffset, scrollLeft: window.pageXOffset,\r\n                                  width: wrap.style.width, height: wrap.style.height};\r\n    wrap.style.width = \"\";\r\n    wrap.style.height = \"auto\";\r\n    wrap.className += \" CodeMirror-fullscreen\";\r\n    document.documentElement.style.overflow = \"hidden\";\r\n    cm.refresh();\r\n  }\r\n\r\n  function setNormal(cm) {\r\n    var wrap = cm.getWrapperElement();\r\n    wrap.className = wrap.className.replace(/\\s*CodeMirror-fullscreen\\b/, \"\");\r\n    document.documentElement.style.overflow = \"\";\r\n    var info = cm.state.fullScreenRestore;\r\n    wrap.style.width = info.width; wrap.style.height = info.height;\r\n    window.scrollTo(info.scrollLeft, info.scrollTop);\r\n    cm.refresh();\r\n  }\r\n});\r\n\n\n/***/ }),\n\n/***/ 1072:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (true) // CommonJS\r\n    mod(__webpack_require__(877));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  CodeMirror.defineOption(\"placeholder\", \"\", function(cm, val, old) {\r\n    var prev = old && old != CodeMirror.Init;\r\n    if (val && !prev) {\r\n      cm.on(\"blur\", onBlur);\r\n      cm.on(\"change\", onChange);\r\n      cm.on(\"swapDoc\", onChange);\r\n      onChange(cm);\r\n    } else if (!val && prev) {\r\n      cm.off(\"blur\", onBlur);\r\n      cm.off(\"change\", onChange);\r\n      cm.off(\"swapDoc\", onChange);\r\n      clearPlaceholder(cm);\r\n      var wrapper = cm.getWrapperElement();\r\n      wrapper.className = wrapper.className.replace(\" CodeMirror-empty\", \"\");\r\n    }\r\n\r\n    if (val && !cm.hasFocus()) onBlur(cm);\r\n  });\r\n\r\n  function clearPlaceholder(cm) {\r\n    if (cm.state.placeholder) {\r\n      cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);\r\n      cm.state.placeholder = null;\r\n    }\r\n  }\r\n  function setPlaceholder(cm) {\r\n    clearPlaceholder(cm);\r\n    var elt = cm.state.placeholder = document.createElement(\"pre\");\r\n    elt.style.cssText = \"height: 0; overflow: visible\";\r\n    elt.className = \"CodeMirror-placeholder\";\r\n    var placeHolder = cm.getOption(\"placeholder\")\r\n    if (typeof placeHolder == \"string\") placeHolder = document.createTextNode(placeHolder)\r\n    elt.appendChild(placeHolder)\r\n    cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);\r\n  }\r\n\r\n  function onBlur(cm) {\r\n    if (isEmpty(cm)) setPlaceholder(cm);\r\n  }\r\n  function onChange(cm) {\r\n    var wrapper = cm.getWrapperElement(), empty = isEmpty(cm);\r\n    wrapper.className = wrapper.className.replace(\" CodeMirror-empty\", \"\") + (empty ? \" CodeMirror-empty\" : \"\");\r\n\r\n    if (empty) setPlaceholder(cm);\r\n    else clearPlaceholder(cm);\r\n  }\r\n\r\n  function isEmpty(cm) {\r\n    return (cm.lineCount() === 1) && (cm.getLine(0) === \"\");\r\n  }\r\n});\r\n\n\n/***/ }),\n\n/***/ 1073:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (true) // CommonJS\r\n    mod(__webpack_require__(877));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  var listRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]\\s|[*+-]\\s|(\\d+)([.)]))(\\s*)/,\r\n      emptyListRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]|[*+-]|(\\d+)[.)])(\\s*)$/,\r\n      unorderedListRE = /[*+-]\\s/;\r\n\r\n  CodeMirror.commands.newlineAndIndentContinueMarkdownList = function(cm) {\r\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\r\n    var ranges = cm.listSelections(), replacements = [];\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var pos = ranges[i].head;\r\n      var eolState = cm.getStateAfter(pos.line);\r\n      var inList = eolState.list !== false;\r\n      var inQuote = eolState.quote !== 0;\r\n\r\n      var line = cm.getLine(pos.line), match = listRE.exec(line);\r\n      if (!ranges[i].empty() || (!inList && !inQuote) || !match) {\r\n        cm.execCommand(\"newlineAndIndent\");\r\n        return;\r\n      }\r\n      if (emptyListRE.test(line)) {\r\n        if (!/>\\s*$/.test(line)) cm.replaceRange(\"\", {\r\n          line: pos.line, ch: 0\r\n        }, {\r\n          line: pos.line, ch: pos.ch + 1\r\n        });\r\n        replacements[i] = \"\\n\";\r\n      } else {\r\n        var indent = match[1], after = match[5];\r\n        var bullet = unorderedListRE.test(match[2]) || match[2].indexOf(\">\") >= 0\r\n          ? match[2].replace(\"x\", \" \")\r\n          : (parseInt(match[3], 10) + 1) + match[4];\r\n\r\n        replacements[i] = \"\\n\" + indent + bullet + after;\r\n      }\r\n    }\r\n\r\n    cm.replaceSelections(replacements);\r\n  };\r\n});\r\n\n\n/***/ }),\n\n/***/ 1076:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// Because sometimes you need to mark the selected *text*.\r\n//\r\n// Adds an option 'styleSelectedText' which, when enabled, gives\r\n// selected text the CSS class given as option value, or\r\n// \"CodeMirror-selectedtext\" when the value is not a string.\r\n\r\n(function(mod) {\r\n  if (true) // CommonJS\r\n    mod(__webpack_require__(877));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  CodeMirror.defineOption(\"styleSelectedText\", false, function(cm, val, old) {\r\n    var prev = old && old != CodeMirror.Init;\r\n    if (val && !prev) {\r\n      cm.state.markedSelection = [];\r\n      cm.state.markedSelectionStyle = typeof val == \"string\" ? val : \"CodeMirror-selectedtext\";\r\n      reset(cm);\r\n      cm.on(\"cursorActivity\", onCursorActivity);\r\n      cm.on(\"change\", onChange);\r\n    } else if (!val && prev) {\r\n      cm.off(\"cursorActivity\", onCursorActivity);\r\n      cm.off(\"change\", onChange);\r\n      clear(cm);\r\n      cm.state.markedSelection = cm.state.markedSelectionStyle = null;\r\n    }\r\n  });\r\n\r\n  function onCursorActivity(cm) {\r\n    if (cm.state.markedSelection)\r\n      cm.operation(function() { update(cm); });\r\n  }\r\n\r\n  function onChange(cm) {\r\n    if (cm.state.markedSelection && cm.state.markedSelection.length)\r\n      cm.operation(function() { clear(cm); });\r\n  }\r\n\r\n  var CHUNK_SIZE = 8;\r\n  var Pos = CodeMirror.Pos;\r\n  var cmp = CodeMirror.cmpPos;\r\n\r\n  function coverRange(cm, from, to, addAt) {\r\n    if (cmp(from, to) == 0) return;\r\n    var array = cm.state.markedSelection;\r\n    var cls = cm.state.markedSelectionStyle;\r\n    for (var line = from.line;;) {\r\n      var start = line == from.line ? from : Pos(line, 0);\r\n      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;\r\n      var end = atEnd ? to : Pos(endLine, 0);\r\n      var mark = cm.markText(start, end, {className: cls});\r\n      if (addAt == null) array.push(mark);\r\n      else array.splice(addAt++, 0, mark);\r\n      if (atEnd) break;\r\n      line = endLine;\r\n    }\r\n  }\r\n\r\n  function clear(cm) {\r\n    var array = cm.state.markedSelection;\r\n    for (var i = 0; i < array.length; ++i) array[i].clear();\r\n    array.length = 0;\r\n  }\r\n\r\n  function reset(cm) {\r\n    clear(cm);\r\n    var ranges = cm.listSelections();\r\n    for (var i = 0; i < ranges.length; i++)\r\n      coverRange(cm, ranges[i].from(), ranges[i].to());\r\n  }\r\n\r\n  function update(cm) {\r\n    if (!cm.somethingSelected()) return clear(cm);\r\n    if (cm.listSelections().length > 1) return reset(cm);\r\n\r\n    var from = cm.getCursor(\"start\"), to = cm.getCursor(\"end\");\r\n\r\n    var array = cm.state.markedSelection;\r\n    if (!array.length) return coverRange(cm, from, to);\r\n\r\n    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();\r\n    if (!coverStart || !coverEnd || to.line - from.line < CHUNK_SIZE ||\r\n        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)\r\n      return reset(cm);\r\n\r\n    while (cmp(from, coverStart.from) > 0) {\r\n      array.shift().clear();\r\n      coverStart = array[0].find();\r\n    }\r\n    if (cmp(from, coverStart.from) < 0) {\r\n      if (coverStart.to.line - from.line < CHUNK_SIZE) {\r\n        array.shift().clear();\r\n        coverRange(cm, from, coverStart.to, 0);\r\n      } else {\r\n        coverRange(cm, from, coverStart.from, 0);\r\n      }\r\n    }\r\n\r\n    while (cmp(to, coverEnd.to) < 0) {\r\n      array.pop().clear();\r\n      coverEnd = array[array.length - 1].find();\r\n    }\r\n    if (cmp(to, coverEnd.to) > 0) {\r\n      if (to.line - coverEnd.from.line < CHUNK_SIZE) {\r\n        array.pop().clear();\r\n        coverRange(cm, coverEnd.from, to);\r\n      } else {\r\n        coverRange(cm, coverEnd.to, to);\r\n      }\r\n    }\r\n  }\r\n});\r\n\n\n/***/ }),\n\n/***/ 1077:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (true) // CommonJS\r\n    mod(__webpack_require__(877), __webpack_require__(960), __webpack_require__(959));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\", \"../markdown/markdown\", \"../../addon/mode/overlay\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n\"use strict\";\r\n\r\nvar urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\\.beep|\\.lwz|\\.xpc|\\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\\.beeps?|xmpp|xri|ymsgr|z39\\.50[rs]?):(?:\\/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]|\\([^\\s()<>]*\\))+(?:\\([^\\s()<>]*\\)|[^\\s`*!()\\[\\]{};:'\".,<>?«»“”‘’]))/i\r\n\r\nCodeMirror.defineMode(\"gfm\", function(config, modeConfig) {\r\n  var codeDepth = 0;\r\n  function blankLine(state) {\r\n    state.code = false;\r\n    return null;\r\n  }\r\n  var gfmOverlay = {\r\n    startState: function() {\r\n      return {\r\n        code: false,\r\n        codeBlock: false,\r\n        ateSpace: false\r\n      };\r\n    },\r\n    copyState: function(s) {\r\n      return {\r\n        code: s.code,\r\n        codeBlock: s.codeBlock,\r\n        ateSpace: s.ateSpace\r\n      };\r\n    },\r\n    token: function(stream, state) {\r\n      state.combineTokens = null;\r\n\r\n      // Hack to prevent formatting override inside code blocks (block and inline)\r\n      if (state.codeBlock) {\r\n        if (stream.match(/^```+/)) {\r\n          state.codeBlock = false;\r\n          return null;\r\n        }\r\n        stream.skipToEnd();\r\n        return null;\r\n      }\r\n      if (stream.sol()) {\r\n        state.code = false;\r\n      }\r\n      if (stream.sol() && stream.match(/^```+/)) {\r\n        stream.skipToEnd();\r\n        state.codeBlock = true;\r\n        return null;\r\n      }\r\n      // If this block is changed, it may need to be updated in Markdown mode\r\n      if (stream.peek() === '`') {\r\n        stream.next();\r\n        var before = stream.pos;\r\n        stream.eatWhile('`');\r\n        var difference = 1 + stream.pos - before;\r\n        if (!state.code) {\r\n          codeDepth = difference;\r\n          state.code = true;\r\n        } else {\r\n          if (difference === codeDepth) { // Must be exact\r\n            state.code = false;\r\n          }\r\n        }\r\n        return null;\r\n      } else if (state.code) {\r\n        stream.next();\r\n        return null;\r\n      }\r\n      // Check if space. If so, links can be formatted later on\r\n      if (stream.eatSpace()) {\r\n        state.ateSpace = true;\r\n        return null;\r\n      }\r\n      if (stream.sol() || state.ateSpace) {\r\n        state.ateSpace = false;\r\n        if (modeConfig.gitHubSpice !== false) {\r\n          if(stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+@)?(?:[a-f0-9]{7,40}\\b)/)) {\r\n            // User/Project@SHA\r\n            // User@SHA\r\n            // SHA\r\n            state.combineTokens = true;\r\n            return \"link\";\r\n          } else if (stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+)?#[0-9]+\\b/)) {\r\n            // User/Project#Num\r\n            // User#Num\r\n            // #Num\r\n            state.combineTokens = true;\r\n            return \"link\";\r\n          }\r\n        }\r\n      }\r\n      if (stream.match(urlRE) &&\r\n          stream.string.slice(stream.start - 2, stream.start) != \"](\" &&\r\n          (stream.start == 0 || /\\W/.test(stream.string.charAt(stream.start - 1)))) {\r\n        // URLs\r\n        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls\r\n        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine\r\n        // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL\r\n        state.combineTokens = true;\r\n        return \"link\";\r\n      }\r\n      stream.next();\r\n      return null;\r\n    },\r\n    blankLine: blankLine\r\n  };\r\n\r\n  var markdownConfig = {\r\n    taskLists: true,\r\n    fencedCodeBlocks: '```',\r\n    strikethrough: true\r\n  };\r\n  for (var attr in modeConfig) {\r\n    markdownConfig[attr] = modeConfig[attr];\r\n  }\r\n  markdownConfig.name = \"markdown\";\r\n  return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);\r\n\r\n}, \"markdown\");\r\n\r\n  CodeMirror.defineMIME(\"text/x-gfm\", \"gfm\");\r\n});\r\n\n\n/***/ }),\n\n/***/ 1079:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (true) // CommonJS\r\n    mod(__webpack_require__(877));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  CodeMirror.modeInfo = [\r\n    {name: \"APL\", mime: \"text/apl\", mode: \"apl\", ext: [\"dyalog\", \"apl\"]},\r\n    {name: \"PGP\", mimes: [\"application/pgp\", \"application/pgp-keys\", \"application/pgp-signature\"], mode: \"asciiarmor\", ext: [\"pgp\"]},\r\n    {name: \"ASN.1\", mime: \"text/x-ttcn-asn\", mode: \"asn.1\", ext: [\"asn\", \"asn1\"]},\r\n    {name: \"Asterisk\", mime: \"text/x-asterisk\", mode: \"asterisk\", file: /^extensions\\.conf$/i},\r\n    {name: \"Brainfuck\", mime: \"text/x-brainfuck\", mode: \"brainfuck\", ext: [\"b\", \"bf\"]},\r\n    {name: \"C\", mime: \"text/x-csrc\", mode: \"clike\", ext: [\"c\", \"h\"]},\r\n    {name: \"C++\", mime: \"text/x-c++src\", mode: \"clike\", ext: [\"cpp\", \"c++\", \"cc\", \"cxx\", \"hpp\", \"h++\", \"hh\", \"hxx\"], alias: [\"cpp\"]},\r\n    {name: \"Cobol\", mime: \"text/x-cobol\", mode: \"cobol\", ext: [\"cob\", \"cpy\"]},\r\n    {name: \"C#\", mime: \"text/x-csharp\", mode: \"clike\", ext: [\"cs\"], alias: [\"csharp\"]},\r\n    {name: \"Clojure\", mime: \"text/x-clojure\", mode: \"clojure\", ext: [\"clj\", \"cljc\", \"cljx\"]},\r\n    {name: \"ClojureScript\", mime: \"text/x-clojurescript\", mode: \"clojure\", ext: [\"cljs\"]},\r\n    {name: \"Closure Stylesheets (GSS)\", mime: \"text/x-gss\", mode: \"css\", ext: [\"gss\"]},\r\n    {name: \"CMake\", mime: \"text/x-cmake\", mode: \"cmake\", ext: [\"cmake\", \"cmake.in\"], file: /^CMakeLists.txt$/},\r\n    {name: \"CoffeeScript\", mime: \"text/x-coffeescript\", mode: \"coffeescript\", ext: [\"coffee\"], alias: [\"coffee\", \"coffee-script\"]},\r\n    {name: \"Common Lisp\", mime: \"text/x-common-lisp\", mode: \"commonlisp\", ext: [\"cl\", \"lisp\", \"el\"], alias: [\"lisp\"]},\r\n    {name: \"Cypher\", mime: \"application/x-cypher-query\", mode: \"cypher\", ext: [\"cyp\", \"cypher\"]},\r\n    {name: \"Cython\", mime: \"text/x-cython\", mode: \"python\", ext: [\"pyx\", \"pxd\", \"pxi\"]},\r\n    {name: \"Crystal\", mime: \"text/x-crystal\", mode: \"crystal\", ext: [\"cr\"]},\r\n    {name: \"CSS\", mime: \"text/css\", mode: \"css\", ext: [\"css\"]},\r\n    {name: \"CQL\", mime: \"text/x-cassandra\", mode: \"sql\", ext: [\"cql\"]},\r\n    {name: \"D\", mime: \"text/x-d\", mode: \"d\", ext: [\"d\"]},\r\n    {name: \"Dart\", mimes: [\"application/dart\", \"text/x-dart\"], mode: \"dart\", ext: [\"dart\"]},\r\n    {name: \"diff\", mime: \"text/x-diff\", mode: \"diff\", ext: [\"diff\", \"patch\"]},\r\n    {name: \"Django\", mime: \"text/x-django\", mode: \"django\"},\r\n    {name: \"Dockerfile\", mime: \"text/x-dockerfile\", mode: \"dockerfile\", file: /^Dockerfile$/},\r\n    {name: \"DTD\", mime: \"application/xml-dtd\", mode: \"dtd\", ext: [\"dtd\"]},\r\n    {name: \"Dylan\", mime: \"text/x-dylan\", mode: \"dylan\", ext: [\"dylan\", \"dyl\", \"intr\"]},\r\n    {name: \"EBNF\", mime: \"text/x-ebnf\", mode: \"ebnf\"},\r\n    {name: \"ECL\", mime: \"text/x-ecl\", mode: \"ecl\", ext: [\"ecl\"]},\r\n    {name: \"edn\", mime: \"application/edn\", mode: \"clojure\", ext: [\"edn\"]},\r\n    {name: \"Eiffel\", mime: \"text/x-eiffel\", mode: \"eiffel\", ext: [\"e\"]},\r\n    {name: \"Elm\", mime: \"text/x-elm\", mode: \"elm\", ext: [\"elm\"]},\r\n    {name: \"Embedded Javascript\", mime: \"application/x-ejs\", mode: \"htmlembedded\", ext: [\"ejs\"]},\r\n    {name: \"Embedded Ruby\", mime: \"application/x-erb\", mode: \"htmlembedded\", ext: [\"erb\"]},\r\n    {name: \"Erlang\", mime: \"text/x-erlang\", mode: \"erlang\", ext: [\"erl\"]},\r\n    {name: \"Factor\", mime: \"text/x-factor\", mode: \"factor\", ext: [\"factor\"]},\r\n    {name: \"FCL\", mime: \"text/x-fcl\", mode: \"fcl\"},\r\n    {name: \"Forth\", mime: \"text/x-forth\", mode: \"forth\", ext: [\"forth\", \"fth\", \"4th\"]},\r\n    {name: \"Fortran\", mime: \"text/x-fortran\", mode: \"fortran\", ext: [\"f\", \"for\", \"f77\", \"f90\"]},\r\n    {name: \"F#\", mime: \"text/x-fsharp\", mode: \"mllike\", ext: [\"fs\"], alias: [\"fsharp\"]},\r\n    {name: \"Gas\", mime: \"text/x-gas\", mode: \"gas\", ext: [\"s\"]},\r\n    {name: \"Gherkin\", mime: \"text/x-feature\", mode: \"gherkin\", ext: [\"feature\"]},\r\n    {name: \"GitHub Flavored Markdown\", mime: \"text/x-gfm\", mode: \"gfm\", file: /^(readme|contributing|history).md$/i},\r\n    {name: \"Go\", mime: \"text/x-go\", mode: \"go\", ext: [\"go\"]},\r\n    {name: \"Groovy\", mime: \"text/x-groovy\", mode: \"groovy\", ext: [\"groovy\", \"gradle\"], file: /^Jenkinsfile$/},\r\n    {name: \"HAML\", mime: \"text/x-haml\", mode: \"haml\", ext: [\"haml\"]},\r\n    {name: \"Haskell\", mime: \"text/x-haskell\", mode: \"haskell\", ext: [\"hs\"]},\r\n    {name: \"Haskell (Literate)\", mime: \"text/x-literate-haskell\", mode: \"haskell-literate\", ext: [\"lhs\"]},\r\n    {name: \"Haxe\", mime: \"text/x-haxe\", mode: \"haxe\", ext: [\"hx\"]},\r\n    {name: \"HXML\", mime: \"text/x-hxml\", mode: \"haxe\", ext: [\"hxml\"]},\r\n    {name: \"ASP.NET\", mime: \"application/x-aspx\", mode: \"htmlembedded\", ext: [\"aspx\"], alias: [\"asp\", \"aspx\"]},\r\n    {name: \"HTML\", mime: \"text/html\", mode: \"htmlmixed\", ext: [\"html\", \"htm\"], alias: [\"xhtml\"]},\r\n    {name: \"HTTP\", mime: \"message/http\", mode: \"http\"},\r\n    {name: \"IDL\", mime: \"text/x-idl\", mode: \"idl\", ext: [\"pro\"]},\r\n    {name: \"Pug\", mime: \"text/x-pug\", mode: \"pug\", ext: [\"jade\", \"pug\"], alias: [\"jade\"]},\r\n    {name: \"Java\", mime: \"text/x-java\", mode: \"clike\", ext: [\"java\"]},\r\n    {name: \"Java Server Pages\", mime: \"application/x-jsp\", mode: \"htmlembedded\", ext: [\"jsp\"], alias: [\"jsp\"]},\r\n    {name: \"JavaScript\", mimes: [\"text/javascript\", \"text/ecmascript\", \"application/javascript\", \"application/x-javascript\", \"application/ecmascript\"],\r\n     mode: \"javascript\", ext: [\"js\"], alias: [\"ecmascript\", \"js\", \"node\"]},\r\n    {name: \"JSON\", mimes: [\"application/json\", \"application/x-json\"], mode: \"javascript\", ext: [\"json\", \"map\"], alias: [\"json5\"]},\r\n    {name: \"JSON-LD\", mime: \"application/ld+json\", mode: \"javascript\", ext: [\"jsonld\"], alias: [\"jsonld\"]},\r\n    {name: \"JSX\", mime: \"text/jsx\", mode: \"jsx\", ext: [\"jsx\"]},\r\n    {name: \"Jinja2\", mime: \"null\", mode: \"jinja2\"},\r\n    {name: \"Julia\", mime: \"text/x-julia\", mode: \"julia\", ext: [\"jl\"]},\r\n    {name: \"Kotlin\", mime: \"text/x-kotlin\", mode: \"clike\", ext: [\"kt\"]},\r\n    {name: \"LESS\", mime: \"text/x-less\", mode: \"css\", ext: [\"less\"]},\r\n    {name: \"LiveScript\", mime: \"text/x-livescript\", mode: \"livescript\", ext: [\"ls\"], alias: [\"ls\"]},\r\n    {name: \"Lua\", mime: \"text/x-lua\", mode: \"lua\", ext: [\"lua\"]},\r\n    {name: \"Markdown\", mime: \"text/x-markdown\", mode: \"markdown\", ext: [\"markdown\", \"md\", \"mkd\"]},\r\n    {name: \"mIRC\", mime: \"text/mirc\", mode: \"mirc\"},\r\n    {name: \"MariaDB SQL\", mime: \"text/x-mariadb\", mode: \"sql\"},\r\n    {name: \"Mathematica\", mime: \"text/x-mathematica\", mode: \"mathematica\", ext: [\"m\", \"nb\"]},\r\n    {name: \"Modelica\", mime: \"text/x-modelica\", mode: \"modelica\", ext: [\"mo\"]},\r\n    {name: \"MUMPS\", mime: \"text/x-mumps\", mode: \"mumps\", ext: [\"mps\"]},\r\n    {name: \"MS SQL\", mime: \"text/x-mssql\", mode: \"sql\"},\r\n    {name: \"mbox\", mime: \"application/mbox\", mode: \"mbox\", ext: [\"mbox\"]},\r\n    {name: \"MySQL\", mime: \"text/x-mysql\", mode: \"sql\"},\r\n    {name: \"Nginx\", mime: \"text/x-nginx-conf\", mode: \"nginx\", file: /nginx.*\\.conf$/i},\r\n    {name: \"NSIS\", mime: \"text/x-nsis\", mode: \"nsis\", ext: [\"nsh\", \"nsi\"]},\r\n    {name: \"NTriples\", mime: \"text/n-triples\", mode: \"ntriples\", ext: [\"nt\"]},\r\n    {name: \"Objective C\", mime: \"text/x-objectivec\", mode: \"clike\", ext: [\"m\", \"mm\"], alias: [\"objective-c\", \"objc\"]},\r\n    {name: \"OCaml\", mime: \"text/x-ocaml\", mode: \"mllike\", ext: [\"ml\", \"mli\", \"mll\", \"mly\"]},\r\n    {name: \"Octave\", mime: \"text/x-octave\", mode: \"octave\", ext: [\"m\"]},\r\n    {name: \"Oz\", mime: \"text/x-oz\", mode: \"oz\", ext: [\"oz\"]},\r\n    {name: \"Pascal\", mime: \"text/x-pascal\", mode: \"pascal\", ext: [\"p\", \"pas\"]},\r\n    {name: \"PEG.js\", mime: \"null\", mode: \"pegjs\", ext: [\"jsonld\"]},\r\n    {name: \"Perl\", mime: \"text/x-perl\", mode: \"perl\", ext: [\"pl\", \"pm\"]},\r\n    {name: \"PHP\", mime: \"application/x-httpd-php\", mode: \"php\", ext: [\"php\", \"php3\", \"php4\", \"php5\", \"phtml\"]},\r\n    {name: \"Pig\", mime: \"text/x-pig\", mode: \"pig\", ext: [\"pig\"]},\r\n    {name: \"Plain Text\", mime: \"text/plain\", mode: \"null\", ext: [\"txt\", \"text\", \"conf\", \"def\", \"list\", \"log\"]},\r\n    {name: \"PLSQL\", mime: \"text/x-plsql\", mode: \"sql\", ext: [\"pls\"]},\r\n    {name: \"PowerShell\", mime: \"application/x-powershell\", mode: \"powershell\", ext: [\"ps1\", \"psd1\", \"psm1\"]},\r\n    {name: \"Properties files\", mime: \"text/x-properties\", mode: \"properties\", ext: [\"properties\", \"ini\", \"in\"], alias: [\"ini\", \"properties\"]},\r\n    {name: \"ProtoBuf\", mime: \"text/x-protobuf\", mode: \"protobuf\", ext: [\"proto\"]},\r\n    {name: \"Python\", mime: \"text/x-python\", mode: \"python\", ext: [\"BUILD\", \"bzl\", \"py\", \"pyw\"], file: /^(BUCK|BUILD)$/},\r\n    {name: \"Puppet\", mime: \"text/x-puppet\", mode: \"puppet\", ext: [\"pp\"]},\r\n    {name: \"Q\", mime: \"text/x-q\", mode: \"q\", ext: [\"q\"]},\r\n    {name: \"R\", mime: \"text/x-rsrc\", mode: \"r\", ext: [\"r\", \"R\"], alias: [\"rscript\"]},\r\n    {name: \"reStructuredText\", mime: \"text/x-rst\", mode: \"rst\", ext: [\"rst\"], alias: [\"rst\"]},\r\n    {name: \"RPM Changes\", mime: \"text/x-rpm-changes\", mode: \"rpm\"},\r\n    {name: \"RPM Spec\", mime: \"text/x-rpm-spec\", mode: \"rpm\", ext: [\"spec\"]},\r\n    {name: \"Ruby\", mime: \"text/x-ruby\", mode: \"ruby\", ext: [\"rb\"], alias: [\"jruby\", \"macruby\", \"rake\", \"rb\", \"rbx\"]},\r\n    {name: \"Rust\", mime: \"text/x-rustsrc\", mode: \"rust\", ext: [\"rs\"]},\r\n    {name: \"SAS\", mime: \"text/x-sas\", mode: \"sas\", ext: [\"sas\"]},\r\n    {name: \"Sass\", mime: \"text/x-sass\", mode: \"sass\", ext: [\"sass\"]},\r\n    {name: \"Scala\", mime: \"text/x-scala\", mode: \"clike\", ext: [\"scala\"]},\r\n    {name: \"Scheme\", mime: \"text/x-scheme\", mode: \"scheme\", ext: [\"scm\", \"ss\"]},\r\n    {name: \"SCSS\", mime: \"text/x-scss\", mode: \"css\", ext: [\"scss\"]},\r\n    {name: \"Shell\", mime: \"text/x-sh\", mode: \"shell\", ext: [\"sh\", \"ksh\", \"bash\"], alias: [\"bash\", \"sh\", \"zsh\"], file: /^PKGBUILD$/},\r\n    {name: \"Sieve\", mime: \"application/sieve\", mode: \"sieve\", ext: [\"siv\", \"sieve\"]},\r\n    {name: \"Slim\", mimes: [\"text/x-slim\", \"application/x-slim\"], mode: \"slim\", ext: [\"slim\"]},\r\n    {name: \"Smalltalk\", mime: \"text/x-stsrc\", mode: \"smalltalk\", ext: [\"st\"]},\r\n    {name: \"Smarty\", mime: \"text/x-smarty\", mode: \"smarty\", ext: [\"tpl\"]},\r\n    {name: \"Solr\", mime: \"text/x-solr\", mode: \"solr\"},\r\n    {name: \"Soy\", mime: \"text/x-soy\", mode: \"soy\", ext: [\"soy\"], alias: [\"closure template\"]},\r\n    {name: \"SPARQL\", mime: \"application/sparql-query\", mode: \"sparql\", ext: [\"rq\", \"sparql\"], alias: [\"sparul\"]},\r\n    {name: \"Spreadsheet\", mime: \"text/x-spreadsheet\", mode: \"spreadsheet\", alias: [\"excel\", \"formula\"]},\r\n    {name: \"SQL\", mime: \"text/x-sql\", mode: \"sql\", ext: [\"sql\"]},\r\n    {name: \"SQLite\", mime: \"text/x-sqlite\", mode: \"sql\"},\r\n    {name: \"Squirrel\", mime: \"text/x-squirrel\", mode: \"clike\", ext: [\"nut\"]},\r\n    {name: \"Stylus\", mime: \"text/x-styl\", mode: \"stylus\", ext: [\"styl\"]},\r\n    {name: \"Swift\", mime: \"text/x-swift\", mode: \"swift\", ext: [\"swift\"]},\r\n    {name: \"sTeX\", mime: \"text/x-stex\", mode: \"stex\"},\r\n    {name: \"LaTeX\", mime: \"text/x-latex\", mode: \"stex\", ext: [\"text\", \"ltx\"], alias: [\"tex\"]},\r\n    {name: \"SystemVerilog\", mime: \"text/x-systemverilog\", mode: \"verilog\", ext: [\"v\"]},\r\n    {name: \"Tcl\", mime: \"text/x-tcl\", mode: \"tcl\", ext: [\"tcl\"]},\r\n    {name: \"Textile\", mime: \"text/x-textile\", mode: \"textile\", ext: [\"textile\"]},\r\n    {name: \"TiddlyWiki \", mime: \"text/x-tiddlywiki\", mode: \"tiddlywiki\"},\r\n    {name: \"Tiki wiki\", mime: \"text/tiki\", mode: \"tiki\"},\r\n    {name: \"TOML\", mime: \"text/x-toml\", mode: \"toml\", ext: [\"toml\"]},\r\n    {name: \"Tornado\", mime: \"text/x-tornado\", mode: \"tornado\"},\r\n    {name: \"troff\", mime: \"text/troff\", mode: \"troff\", ext: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]},\r\n    {name: \"TTCN\", mime: \"text/x-ttcn\", mode: \"ttcn\", ext: [\"ttcn\", \"ttcn3\", \"ttcnpp\"]},\r\n    {name: \"TTCN_CFG\", mime: \"text/x-ttcn-cfg\", mode: \"ttcn-cfg\", ext: [\"cfg\"]},\r\n    {name: \"Turtle\", mime: \"text/turtle\", mode: \"turtle\", ext: [\"ttl\"]},\r\n    {name: \"TypeScript\", mime: \"application/typescript\", mode: \"javascript\", ext: [\"ts\"], alias: [\"ts\"]},\r\n    {name: \"TypeScript-JSX\", mime: \"text/typescript-jsx\", mode: \"jsx\", ext: [\"tsx\"], alias: [\"tsx\"]},\r\n    {name: \"Twig\", mime: \"text/x-twig\", mode: \"twig\"},\r\n    {name: \"Web IDL\", mime: \"text/x-webidl\", mode: \"webidl\", ext: [\"webidl\"]},\r\n    {name: \"VB.NET\", mime: \"text/x-vb\", mode: \"vb\", ext: [\"vb\"]},\r\n    {name: \"VBScript\", mime: \"text/vbscript\", mode: \"vbscript\", ext: [\"vbs\"]},\r\n    {name: \"Velocity\", mime: \"text/velocity\", mode: \"velocity\", ext: [\"vtl\"]},\r\n    {name: \"Verilog\", mime: \"text/x-verilog\", mode: \"verilog\", ext: [\"v\"]},\r\n    {name: \"VHDL\", mime: \"text/x-vhdl\", mode: \"vhdl\", ext: [\"vhd\", \"vhdl\"]},\r\n    {name: \"Vue.js Component\", mimes: [\"script/x-vue\", \"text/x-vue\"], mode: \"vue\", ext: [\"vue\"]},\r\n    {name: \"XML\", mimes: [\"application/xml\", \"text/xml\"], mode: \"xml\", ext: [\"xml\", \"xsl\", \"xsd\", \"svg\"], alias: [\"rss\", \"wsdl\", \"xsd\"]},\r\n    {name: \"XQuery\", mime: \"application/xquery\", mode: \"xquery\", ext: [\"xy\", \"xquery\"]},\r\n    {name: \"Yacas\", mime: \"text/x-yacas\", mode: \"yacas\", ext: [\"ys\"]},\r\n    {name: \"YAML\", mimes: [\"text/x-yaml\", \"text/yaml\"], mode: \"yaml\", ext: [\"yaml\", \"yml\"], alias: [\"yml\"]},\r\n    {name: \"Z80\", mime: \"text/x-z80\", mode: \"z80\", ext: [\"z80\"]},\r\n    {name: \"mscgen\", mime: \"text/x-mscgen\", mode: \"mscgen\", ext: [\"mscgen\", \"mscin\", \"msc\"]},\r\n    {name: \"xu\", mime: \"text/x-xu\", mode: \"mscgen\", ext: [\"xu\"]},\r\n    {name: \"msgenny\", mime: \"text/x-msgenny\", mode: \"mscgen\", ext: [\"msgenny\"]}\r\n  ];\r\n  // Ensure all modes have a mime property for backwards compatibility\r\n  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n    var info = CodeMirror.modeInfo[i];\r\n    if (info.mimes) info.mime = info.mimes[0];\r\n  }\r\n\r\n  CodeMirror.findModeByMIME = function(mime) {\r\n    mime = mime.toLowerCase();\r\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n      var info = CodeMirror.modeInfo[i];\r\n      if (info.mime == mime) return info;\r\n      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)\r\n        if (info.mimes[j] == mime) return info;\r\n    }\r\n    if (/\\+xml$/.test(mime)) return CodeMirror.findModeByMIME(\"application/xml\")\r\n    if (/\\+json$/.test(mime)) return CodeMirror.findModeByMIME(\"application/json\")\r\n  };\r\n\r\n  CodeMirror.findModeByExtension = function(ext) {\r\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n      var info = CodeMirror.modeInfo[i];\r\n      if (info.ext) for (var j = 0; j < info.ext.length; j++)\r\n        if (info.ext[j] == ext) return info;\r\n    }\r\n  };\r\n\r\n  CodeMirror.findModeByFileName = function(filename) {\r\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n      var info = CodeMirror.modeInfo[i];\r\n      if (info.file && info.file.test(filename)) return info;\r\n    }\r\n    var dot = filename.lastIndexOf(\".\");\r\n    var ext = dot > -1 && filename.substring(dot + 1, filename.length);\r\n    if (ext) return CodeMirror.findModeByExtension(ext);\r\n  };\r\n\r\n  CodeMirror.findModeByName = function(name) {\r\n    name = name.toLowerCase();\r\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n      var info = CodeMirror.modeInfo[i];\r\n      if (info.name.toLowerCase() == name) return info;\r\n      if (info.alias) for (var j = 0; j < info.alias.length; j++)\r\n        if (info.alias[j].toLowerCase() == name) return info;\r\n    }\r\n  };\r\n});\r\n\n\n/***/ }),\n\n/***/ 1084:\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(729)(true);\n// imports\n\n\n// module\nexports.push([module.i, \".CodeMirror{color:#000}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-ruler{border-left:1px solid #ccc;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-invalidchar,.cm-s-default .cm-error{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important;-webkit-user-select:none;-moz-user-select:none;user-select:none}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:none;font-variant-ligatures:none}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}.CodeMirror-focused div.CodeMirror-cursors,div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected,.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background:#ffa;background:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:\\\"\\\"}span.CodeMirror-selectedtext{background:0 0}.CodeMirror{height:auto;border:1px solid #ddd;border-bottom-left-radius:4px;border-bottom-right-radius:4px;padding:10px;font:inherit;z-index:1}.CodeMirror,.CodeMirror-scroll{min-height:300px}.CodeMirror-fullscreen{background:#fff;position:fixed!important;top:50px;left:0;right:0;bottom:0;height:auto;z-index:9}.CodeMirror-sided{width:50%!important}.editor-toolbar{position:relative;opacity:.6;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;padding:0 10px;border-top:1px solid #bbb;border-left:1px solid #bbb;border-right:1px solid #bbb;border-top-left-radius:4px;border-top-right-radius:4px}.editor-toolbar:after,.editor-toolbar:before{display:block;content:\\\" \\\";height:1px}.editor-toolbar:before{margin-bottom:8px}.editor-toolbar:after{margin-top:8px}.editor-toolbar:hover,.editor-wrapper input.title:focus,.editor-wrapper input.title:hover{opacity:.8}.editor-toolbar.fullscreen{width:100%;height:50px;overflow-x:auto;overflow-y:hidden;white-space:nowrap;padding-top:10px;padding-bottom:10px;box-sizing:border-box;background:#fff;border:0;position:fixed;top:0;left:0;opacity:1;z-index:9}.editor-toolbar.fullscreen:before{width:20px;height:50px;background:-moz-linear-gradient(left,#fff 0,hsla(0,0%,100%,0) 100%);background:-webkit-gradient(linear,left top,right top,color-stop(0,#fff),color-stop(100%,hsla(0,0%,100%,0)));background:-webkit-linear-gradient(left,#fff,hsla(0,0%,100%,0));background:-o-linear-gradient(left,#fff 0,hsla(0,0%,100%,0) 100%);background:-ms-linear-gradient(left,#fff 0,hsla(0,0%,100%,0) 100%);background:linear-gradient(90deg,#fff 0,hsla(0,0%,100%,0));position:fixed;top:0;left:0;margin:0;padding:0}.editor-toolbar.fullscreen:after{width:20px;height:50px;background:-moz-linear-gradient(left,hsla(0,0%,100%,0) 0,#fff 100%);background:-webkit-gradient(linear,left top,right top,color-stop(0,hsla(0,0%,100%,0)),color-stop(100%,#fff));background:-webkit-linear-gradient(left,hsla(0,0%,100%,0),#fff);background:-o-linear-gradient(left,hsla(0,0%,100%,0) 0,#fff 100%);background:-ms-linear-gradient(left,hsla(0,0%,100%,0) 0,#fff 100%);background:linear-gradient(90deg,hsla(0,0%,100%,0) 0,#fff);position:fixed;top:0;right:0;margin:0;padding:0}.editor-toolbar a{display:inline-block;text-align:center;text-decoration:none!important;color:#2c3e50!important;width:30px;height:30px;margin:0;border:1px solid transparent;border-radius:3px;cursor:pointer}.editor-toolbar a.active,.editor-toolbar a:hover{background:#fcfcfc;border-color:#95a5a6}.editor-toolbar a:before{line-height:30px}.editor-toolbar i.separator{display:inline-block;width:0;border-left:1px solid #d9d9d9;border-right:1px solid #fff;color:transparent;text-indent:-10px;margin:0 6px}.editor-toolbar a.fa-header-x:after{font-family:Arial,Helvetica Neue,Helvetica,sans-serif;font-size:65%;vertical-align:text-bottom;position:relative;top:2px}.editor-toolbar a.fa-header-1:after{content:\\\"1\\\"}.editor-toolbar a.fa-header-2:after{content:\\\"2\\\"}.editor-toolbar a.fa-header-3:after{content:\\\"3\\\"}.editor-toolbar a.fa-header-bigger:after{content:\\\"\\\\25B2\\\"}.editor-toolbar a.fa-header-smaller:after{content:\\\"\\\\25BC\\\"}.editor-toolbar.disabled-for-preview a:not(.no-disable){pointer-events:none;background:#fff;border-color:transparent;text-shadow:inherit}@media only screen and (max-width:700px){.editor-toolbar a.no-mobile{display:none}}.editor-statusbar{padding:8px 10px;font-size:12px;color:#959694;text-align:right}.editor-statusbar span{display:inline-block;min-width:4em;margin-left:1em}.editor-preview,.editor-preview-side{padding:10px;background:#fafafa;overflow:auto;display:none;box-sizing:border-box}.editor-statusbar .lines:before{content:\\\"lines: \\\"}.editor-statusbar .words:before{content:\\\"words: \\\"}.editor-statusbar .characters:before{content:\\\"characters: \\\"}.editor-preview{position:absolute;width:100%;height:100%;top:0;left:0;z-index:7}.editor-preview-side{position:fixed;bottom:0;width:50%;top:50px;right:0;z-index:9;border:1px solid #ddd}.editor-preview-active,.editor-preview-active-side{display:block}.editor-preview-side>p,.editor-preview>p{margin-top:0}.editor-preview-side pre,.editor-preview pre{background:#eee;margin-bottom:10px}.editor-preview-side table td,.editor-preview-side table th,.editor-preview table td,.editor-preview table th{border:1px solid #ddd;padding:5px}.CodeMirror .CodeMirror-code .cm-tag{color:#63a35c}.CodeMirror .CodeMirror-code .cm-attribute{color:#795da3}.CodeMirror .CodeMirror-code .cm-string{color:#183691}.CodeMirror .CodeMirror-selected{background:#d9d9d9}.CodeMirror .CodeMirror-code .cm-header-1{font-size:200%;line-height:200%}.CodeMirror .CodeMirror-code .cm-header-2{font-size:160%;line-height:160%}.CodeMirror .CodeMirror-code .cm-header-3{font-size:125%;line-height:125%}.CodeMirror .CodeMirror-code .cm-header-4{font-size:110%;line-height:110%}.CodeMirror .CodeMirror-code .cm-comment{background:rgba(0,0,0,.05);border-radius:2px}.CodeMirror .CodeMirror-code .cm-link{color:#7f8c8d}.CodeMirror .CodeMirror-code .cm-url{color:#aab2b3}.CodeMirror .CodeMirror-code .cm-strikethrough{text-decoration:line-through}.CodeMirror .CodeMirror-placeholder{opacity:.5}.CodeMirror .cm-spell-error:not(.cm-url):not(.cm-comment):not(.cm-tag):not(.cm-word){background:rgba(255,0,0,.15)}\", \"\", {\"version\":3,\"sources\":[\"C:/Users/admin/feeling_admin2/node_modules/simplemde/dist/simplemde.min.css\"],\"names\":[],\"mappings\":\"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\",\"file\":\"simplemde.min.css\",\"sourcesContent\":[\"/**\\r\\n * simplemde v1.11.2\\r\\n * Copyright Next Step Webs, Inc.\\r\\n * @link https://github.com/NextStepWebs/simplemde-markdown-editor\\r\\n * @license MIT\\r\\n */\\r\\n.CodeMirror{color:#000}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-ruler{border-left:1px solid #ccc;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-invalidchar,.cm-s-default .cm-error{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important;-webkit-user-select:none;-moz-user-select:none;user-select:none}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:none;font-variant-ligatures:none}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}.CodeMirror-focused div.CodeMirror-cursors,div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected,.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background:#ffa;background:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}.CodeMirror{height:auto;min-height:300px;border:1px solid #ddd;border-bottom-left-radius:4px;border-bottom-right-radius:4px;padding:10px;font:inherit;z-index:1}.CodeMirror-scroll{min-height:300px}.CodeMirror-fullscreen{background:#fff;position:fixed!important;top:50px;left:0;right:0;bottom:0;height:auto;z-index:9}.CodeMirror-sided{width:50%!important}.editor-toolbar{position:relative;opacity:.6;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;padding:0 10px;border-top:1px solid #bbb;border-left:1px solid #bbb;border-right:1px solid #bbb;border-top-left-radius:4px;border-top-right-radius:4px}.editor-toolbar:after,.editor-toolbar:before{display:block;content:' ';height:1px}.editor-toolbar:before{margin-bottom:8px}.editor-toolbar:after{margin-top:8px}.editor-toolbar:hover,.editor-wrapper input.title:focus,.editor-wrapper input.title:hover{opacity:.8}.editor-toolbar.fullscreen{width:100%;height:50px;overflow-x:auto;overflow-y:hidden;white-space:nowrap;padding-top:10px;padding-bottom:10px;box-sizing:border-box;background:#fff;border:0;position:fixed;top:0;left:0;opacity:1;z-index:9}.editor-toolbar.fullscreen::before{width:20px;height:50px;background:-moz-linear-gradient(left,rgba(255,255,255,1) 0,rgba(255,255,255,0) 100%);background:-webkit-gradient(linear,left top,right top,color-stop(0,rgba(255,255,255,1)),color-stop(100%,rgba(255,255,255,0)));background:-webkit-linear-gradient(left,rgba(255,255,255,1) 0,rgba(255,255,255,0) 100%);background:-o-linear-gradient(left,rgba(255,255,255,1) 0,rgba(255,255,255,0) 100%);background:-ms-linear-gradient(left,rgba(255,255,255,1) 0,rgba(255,255,255,0) 100%);background:linear-gradient(to right,rgba(255,255,255,1) 0,rgba(255,255,255,0) 100%);position:fixed;top:0;left:0;margin:0;padding:0}.editor-toolbar.fullscreen::after{width:20px;height:50px;background:-moz-linear-gradient(left,rgba(255,255,255,0) 0,rgba(255,255,255,1) 100%);background:-webkit-gradient(linear,left top,right top,color-stop(0,rgba(255,255,255,0)),color-stop(100%,rgba(255,255,255,1)));background:-webkit-linear-gradient(left,rgba(255,255,255,0) 0,rgba(255,255,255,1) 100%);background:-o-linear-gradient(left,rgba(255,255,255,0) 0,rgba(255,255,255,1) 100%);background:-ms-linear-gradient(left,rgba(255,255,255,0) 0,rgba(255,255,255,1) 100%);background:linear-gradient(to right,rgba(255,255,255,0) 0,rgba(255,255,255,1) 100%);position:fixed;top:0;right:0;margin:0;padding:0}.editor-toolbar a{display:inline-block;text-align:center;text-decoration:none!important;color:#2c3e50!important;width:30px;height:30px;margin:0;border:1px solid transparent;border-radius:3px;cursor:pointer}.editor-toolbar a.active,.editor-toolbar a:hover{background:#fcfcfc;border-color:#95a5a6}.editor-toolbar a:before{line-height:30px}.editor-toolbar i.separator{display:inline-block;width:0;border-left:1px solid #d9d9d9;border-right:1px solid #fff;color:transparent;text-indent:-10px;margin:0 6px}.editor-toolbar a.fa-header-x:after{font-family:Arial,\\\"Helvetica Neue\\\",Helvetica,sans-serif;font-size:65%;vertical-align:text-bottom;position:relative;top:2px}.editor-toolbar a.fa-header-1:after{content:\\\"1\\\"}.editor-toolbar a.fa-header-2:after{content:\\\"2\\\"}.editor-toolbar a.fa-header-3:after{content:\\\"3\\\"}.editor-toolbar a.fa-header-bigger:after{content:\\\"▲\\\"}.editor-toolbar a.fa-header-smaller:after{content:\\\"▼\\\"}.editor-toolbar.disabled-for-preview a:not(.no-disable){pointer-events:none;background:#fff;border-color:transparent;text-shadow:inherit}@media only screen and (max-width:700px){.editor-toolbar a.no-mobile{display:none}}.editor-statusbar{padding:8px 10px;font-size:12px;color:#959694;text-align:right}.editor-statusbar span{display:inline-block;min-width:4em;margin-left:1em}.editor-preview,.editor-preview-side{padding:10px;background:#fafafa;overflow:auto;display:none;box-sizing:border-box}.editor-statusbar .lines:before{content:'lines: '}.editor-statusbar .words:before{content:'words: '}.editor-statusbar .characters:before{content:'characters: '}.editor-preview{position:absolute;width:100%;height:100%;top:0;left:0;z-index:7}.editor-preview-side{position:fixed;bottom:0;width:50%;top:50px;right:0;z-index:9;border:1px solid #ddd}.editor-preview-active,.editor-preview-active-side{display:block}.editor-preview-side>p,.editor-preview>p{margin-top:0}.editor-preview pre,.editor-preview-side pre{background:#eee;margin-bottom:10px}.editor-preview table td,.editor-preview table th,.editor-preview-side table td,.editor-preview-side table th{border:1px solid #ddd;padding:5px}.CodeMirror .CodeMirror-code .cm-tag{color:#63a35c}.CodeMirror .CodeMirror-code .cm-attribute{color:#795da3}.CodeMirror .CodeMirror-code .cm-string{color:#183691}.CodeMirror .CodeMirror-selected{background:#d9d9d9}.CodeMirror .CodeMirror-code .cm-header-1{font-size:200%;line-height:200%}.CodeMirror .CodeMirror-code .cm-header-2{font-size:160%;line-height:160%}.CodeMirror .CodeMirror-code .cm-header-3{font-size:125%;line-height:125%}.CodeMirror .CodeMirror-code .cm-header-4{font-size:110%;line-height:110%}.CodeMirror .CodeMirror-code .cm-comment{background:rgba(0,0,0,.05);border-radius:2px}.CodeMirror .CodeMirror-code .cm-link{color:#7f8c8d}.CodeMirror .CodeMirror-code .cm-url{color:#aab2b3}.CodeMirror .CodeMirror-code .cm-strikethrough{text-decoration:line-through}.CodeMirror .CodeMirror-placeholder{opacity:.5}.CodeMirror .cm-spell-error:not(.cm-url):not(.cm-comment):not(.cm-tag):not(.cm-word){background:rgba(255,0,0,.15)}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ 1123:\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(729)(true);\n// imports\n\n\n// module\nexports.push([module.i, \".simplemde-container .CodeMirror,.simplemde-container .CodeMirror-scroll{min-height:150px}.simplemde-container .CodeMirror-code{padding-bottom:40px}.simplemde-container .editor-statusbar{display:none}.simplemde-container .CodeMirror .CodeMirror-code .cm-link{color:#1482f0}.simplemde-container .CodeMirror .CodeMirror-code .cm-string.cm-url{color:#2d3b4d;font-weight:700}.simplemde-container .CodeMirror .CodeMirror-code .cm-formatting-link-string.cm-url{padding:0 2px;font-weight:700;color:#e61e1e}\", \"\", {\"version\":3,\"sources\":[\"C:/Users/admin/feeling_admin2/src/components/MdEditor/index.vue\"],\"names\":[],\"mappings\":\"AAKA,yEACE,gBAAkB,CACnB,AACD,sCACE,mBAAqB,CACtB,AACD,uCACE,YAAc,CACf,AACD,2DACE,aAAe,CAChB,AACD,oEACE,cAAe,AACf,eAAkB,CACnB,AACD,oFACE,cAAe,AACf,gBAAkB,AAClB,aAAe,CAChB\",\"file\":\"index.vue\",\"sourcesContent\":[\"\\n.simplemde-container .CodeMirror {\\r\\n  /*height: 150px;*/\\r\\n  min-height: 150px;\\n}\\n.simplemde-container .CodeMirror-scroll {\\r\\n  min-height: 150px;\\n}\\n.simplemde-container .CodeMirror-code {\\r\\n  padding-bottom: 40px;\\n}\\n.simplemde-container .editor-statusbar {\\r\\n  display: none;\\n}\\n.simplemde-container .CodeMirror .CodeMirror-code .cm-link {\\r\\n  color: #1482F0;\\n}\\n.simplemde-container .CodeMirror .CodeMirror-code .cm-string.cm-url {\\r\\n  color: #2d3b4d;\\r\\n  font-weight: bold;\\n}\\n.simplemde-container .CodeMirror .CodeMirror-code .cm-formatting-link-string.cm-url {\\r\\n  padding: 0 2px;\\r\\n  font-weight: bold;\\r\\n  color: #E61E1E;\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ 1180:\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(1084);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(730)(\"0cac9a3e\", content, true);\n\n/***/ }),\n\n/***/ 1219:\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(1123);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(730)(\"b04691d0\", content, true);\n\n/***/ }),\n\n/***/ 1271:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\r\n * marked - a markdown parser\r\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\r\n * https://github.com/chjj/marked\r\n */\r\n\r\n;(function() {\r\n\r\n/**\r\n * Block-Level Grammar\r\n */\r\n\r\nvar block = {\r\n  newline: /^\\n+/,\r\n  code: /^( {4}[^\\n]+\\n*)+/,\r\n  fences: noop,\r\n  hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\r\n  heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\r\n  nptable: noop,\r\n  lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\r\n  blockquote: /^( *>[^\\n]+(\\n(?!def)[^\\n]+)*\\n*)+/,\r\n  list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\r\n  html: /^ *(?:comment *(?:\\n|\\s*$)|closed *(?:\\n{2,}|\\s*$)|closing *(?:\\n{2,}|\\s*$))/,\r\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\r\n  table: noop,\r\n  paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\r\n  text: /^[^\\n]+/\r\n};\r\n\r\nblock.bullet = /(?:[*+-]|\\d+\\.)/;\r\nblock.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\r\nblock.item = replace(block.item, 'gm')\r\n  (/bull/g, block.bullet)\r\n  ();\r\n\r\nblock.list = replace(block.list)\r\n  (/bull/g, block.bullet)\r\n  ('hr', '\\\\n+(?=\\\\1?(?:[-*_] *){3,}(?:\\\\n+|$))')\r\n  ('def', '\\\\n+(?=' + block.def.source + ')')\r\n  ();\r\n\r\nblock.blockquote = replace(block.blockquote)\r\n  ('def', block.def)\r\n  ();\r\n\r\nblock._tag = '(?!(?:'\r\n  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'\r\n  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'\r\n  + '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|[^\\\\w\\\\s@]*@)\\\\b';\r\n\r\nblock.html = replace(block.html)\r\n  ('comment', /<!--[\\s\\S]*?-->/)\r\n  ('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\r\n  ('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\r\n  (/tag/g, block._tag)\r\n  ();\r\n\r\nblock.paragraph = replace(block.paragraph)\r\n  ('hr', block.hr)\r\n  ('heading', block.heading)\r\n  ('lheading', block.lheading)\r\n  ('blockquote', block.blockquote)\r\n  ('tag', '<' + block._tag)\r\n  ('def', block.def)\r\n  ();\r\n\r\n/**\r\n * Normal Block Grammar\r\n */\r\n\r\nblock.normal = merge({}, block);\r\n\r\n/**\r\n * GFM Block Grammar\r\n */\r\n\r\nblock.gfm = merge({}, block.normal, {\r\n  fences: /^ *(`{3,}|~{3,})[ \\.]*(\\S+)? *\\n([\\s\\S]*?)\\s*\\1 *(?:\\n+|$)/,\r\n  paragraph: /^/,\r\n  heading: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/\r\n});\r\n\r\nblock.gfm.paragraph = replace(block.paragraph)\r\n  ('(?!', '(?!'\r\n    + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|'\r\n    + block.list.source.replace('\\\\1', '\\\\3') + '|')\r\n  ();\r\n\r\n/**\r\n * GFM + Tables Block Grammar\r\n */\r\n\r\nblock.tables = merge({}, block.gfm, {\r\n  nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\r\n  table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/\r\n});\r\n\r\n/**\r\n * Block Lexer\r\n */\r\n\r\nfunction Lexer(options) {\r\n  this.tokens = [];\r\n  this.tokens.links = {};\r\n  this.options = options || marked.defaults;\r\n  this.rules = block.normal;\r\n\r\n  if (this.options.gfm) {\r\n    if (this.options.tables) {\r\n      this.rules = block.tables;\r\n    } else {\r\n      this.rules = block.gfm;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Expose Block Rules\r\n */\r\n\r\nLexer.rules = block;\r\n\r\n/**\r\n * Static Lex Method\r\n */\r\n\r\nLexer.lex = function(src, options) {\r\n  var lexer = new Lexer(options);\r\n  return lexer.lex(src);\r\n};\r\n\r\n/**\r\n * Preprocessing\r\n */\r\n\r\nLexer.prototype.lex = function(src) {\r\n  src = src\r\n    .replace(/\\r\\n|\\r/g, '\\n')\r\n    .replace(/\\t/g, '    ')\r\n    .replace(/\\u00a0/g, ' ')\r\n    .replace(/\\u2424/g, '\\n');\r\n\r\n  return this.token(src, true);\r\n};\r\n\r\n/**\r\n * Lexing\r\n */\r\n\r\nLexer.prototype.token = function(src, top, bq) {\r\n  var src = src.replace(/^ +$/gm, '')\r\n    , next\r\n    , loose\r\n    , cap\r\n    , bull\r\n    , b\r\n    , item\r\n    , space\r\n    , i\r\n    , l;\r\n\r\n  while (src) {\r\n    // newline\r\n    if (cap = this.rules.newline.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      if (cap[0].length > 1) {\r\n        this.tokens.push({\r\n          type: 'space'\r\n        });\r\n      }\r\n    }\r\n\r\n    // code\r\n    if (cap = this.rules.code.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      cap = cap[0].replace(/^ {4}/gm, '');\r\n      this.tokens.push({\r\n        type: 'code',\r\n        text: !this.options.pedantic\r\n          ? cap.replace(/\\n+$/, '')\r\n          : cap\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // fences (gfm)\r\n    if (cap = this.rules.fences.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'code',\r\n        lang: cap[2],\r\n        text: cap[3] || ''\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // heading\r\n    if (cap = this.rules.heading.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'heading',\r\n        depth: cap[1].length,\r\n        text: cap[2]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // table no leading pipe (gfm)\r\n    if (top && (cap = this.rules.nptable.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n\r\n      item = {\r\n        type: 'table',\r\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\r\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\r\n        cells: cap[3].replace(/\\n$/, '').split('\\n')\r\n      };\r\n\r\n      for (i = 0; i < item.align.length; i++) {\r\n        if (/^ *-+: *$/.test(item.align[i])) {\r\n          item.align[i] = 'right';\r\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\r\n          item.align[i] = 'center';\r\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\r\n          item.align[i] = 'left';\r\n        } else {\r\n          item.align[i] = null;\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < item.cells.length; i++) {\r\n        item.cells[i] = item.cells[i].split(/ *\\| */);\r\n      }\r\n\r\n      this.tokens.push(item);\r\n\r\n      continue;\r\n    }\r\n\r\n    // lheading\r\n    if (cap = this.rules.lheading.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'heading',\r\n        depth: cap[2] === '=' ? 1 : 2,\r\n        text: cap[1]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // hr\r\n    if (cap = this.rules.hr.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'hr'\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // blockquote\r\n    if (cap = this.rules.blockquote.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n\r\n      this.tokens.push({\r\n        type: 'blockquote_start'\r\n      });\r\n\r\n      cap = cap[0].replace(/^ *> ?/gm, '');\r\n\r\n      // Pass `top` to keep the current\r\n      // \"toplevel\" state. This is exactly\r\n      // how markdown.pl works.\r\n      this.token(cap, top, true);\r\n\r\n      this.tokens.push({\r\n        type: 'blockquote_end'\r\n      });\r\n\r\n      continue;\r\n    }\r\n\r\n    // list\r\n    if (cap = this.rules.list.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      bull = cap[2];\r\n\r\n      this.tokens.push({\r\n        type: 'list_start',\r\n        ordered: bull.length > 1\r\n      });\r\n\r\n      // Get each top-level item.\r\n      cap = cap[0].match(this.rules.item);\r\n\r\n      next = false;\r\n      l = cap.length;\r\n      i = 0;\r\n\r\n      for (; i < l; i++) {\r\n        item = cap[i];\r\n\r\n        // Remove the list item's bullet\r\n        // so it is seen as the next token.\r\n        space = item.length;\r\n        item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\r\n\r\n        // Outdent whatever the\r\n        // list item contains. Hacky.\r\n        if (~item.indexOf('\\n ')) {\r\n          space -= item.length;\r\n          item = !this.options.pedantic\r\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\r\n            : item.replace(/^ {1,4}/gm, '');\r\n        }\r\n\r\n        // Determine whether the next list item belongs here.\r\n        // Backpedal if it does not belong in this list.\r\n        if (this.options.smartLists && i !== l - 1) {\r\n          b = block.bullet.exec(cap[i + 1])[0];\r\n          if (bull !== b && !(bull.length > 1 && b.length > 1)) {\r\n            src = cap.slice(i + 1).join('\\n') + src;\r\n            i = l - 1;\r\n          }\r\n        }\r\n\r\n        // Determine whether item is loose or not.\r\n        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\r\n        // for discount behavior.\r\n        loose = next || /\\n\\n(?!\\s*$)/.test(item);\r\n        if (i !== l - 1) {\r\n          next = item.charAt(item.length - 1) === '\\n';\r\n          if (!loose) loose = next;\r\n        }\r\n\r\n        this.tokens.push({\r\n          type: loose\r\n            ? 'loose_item_start'\r\n            : 'list_item_start'\r\n        });\r\n\r\n        // Recurse.\r\n        this.token(item, false, bq);\r\n\r\n        this.tokens.push({\r\n          type: 'list_item_end'\r\n        });\r\n      }\r\n\r\n      this.tokens.push({\r\n        type: 'list_end'\r\n      });\r\n\r\n      continue;\r\n    }\r\n\r\n    // html\r\n    if (cap = this.rules.html.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: this.options.sanitize\r\n          ? 'paragraph'\r\n          : 'html',\r\n        pre: !this.options.sanitizer\r\n          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\r\n        text: cap[0]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // def\r\n    if ((!bq && top) && (cap = this.rules.def.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.links[cap[1].toLowerCase()] = {\r\n        href: cap[2],\r\n        title: cap[3]\r\n      };\r\n      continue;\r\n    }\r\n\r\n    // table (gfm)\r\n    if (top && (cap = this.rules.table.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n\r\n      item = {\r\n        type: 'table',\r\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\r\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\r\n        cells: cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n')\r\n      };\r\n\r\n      for (i = 0; i < item.align.length; i++) {\r\n        if (/^ *-+: *$/.test(item.align[i])) {\r\n          item.align[i] = 'right';\r\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\r\n          item.align[i] = 'center';\r\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\r\n          item.align[i] = 'left';\r\n        } else {\r\n          item.align[i] = null;\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < item.cells.length; i++) {\r\n        item.cells[i] = item.cells[i]\r\n          .replace(/^ *\\| *| *\\| *$/g, '')\r\n          .split(/ *\\| */);\r\n      }\r\n\r\n      this.tokens.push(item);\r\n\r\n      continue;\r\n    }\r\n\r\n    // top-level paragraph\r\n    if (top && (cap = this.rules.paragraph.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'paragraph',\r\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\r\n          ? cap[1].slice(0, -1)\r\n          : cap[1]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // text\r\n    if (cap = this.rules.text.exec(src)) {\r\n      // Top-level should never reach here.\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'text',\r\n        text: cap[0]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    if (src) {\r\n      throw new\r\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\r\n    }\r\n  }\r\n\r\n  return this.tokens;\r\n};\r\n\r\n/**\r\n * Inline-Level Grammar\r\n */\r\n\r\nvar inline = {\r\n  escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\r\n  autolink: /^<([^ >]+(@|:\\/)[^ >]+)>/,\r\n  url: noop,\r\n  tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/,\r\n  link: /^!?\\[(inside)\\]\\(href\\)/,\r\n  reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\r\n  nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\r\n  strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\r\n  em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\r\n  code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\r\n  br: /^ {2,}\\n(?!\\s*$)/,\r\n  del: noop,\r\n  text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/\r\n};\r\n\r\ninline._inside = /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/;\r\ninline._href = /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/;\r\n\r\ninline.link = replace(inline.link)\r\n  ('inside', inline._inside)\r\n  ('href', inline._href)\r\n  ();\r\n\r\ninline.reflink = replace(inline.reflink)\r\n  ('inside', inline._inside)\r\n  ();\r\n\r\n/**\r\n * Normal Inline Grammar\r\n */\r\n\r\ninline.normal = merge({}, inline);\r\n\r\n/**\r\n * Pedantic Inline Grammar\r\n */\r\n\r\ninline.pedantic = merge({}, inline.normal, {\r\n  strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\r\n  em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/\r\n});\r\n\r\n/**\r\n * GFM Inline Grammar\r\n */\r\n\r\ninline.gfm = merge({}, inline.normal, {\r\n  escape: replace(inline.escape)('])', '~|])')(),\r\n  url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\r\n  del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\r\n  text: replace(inline.text)\r\n    (']|', '~]|')\r\n    ('|', '|https?://|')\r\n    ()\r\n});\r\n\r\n/**\r\n * GFM + Line Breaks Inline Grammar\r\n */\r\n\r\ninline.breaks = merge({}, inline.gfm, {\r\n  br: replace(inline.br)('{2,}', '*')(),\r\n  text: replace(inline.gfm.text)('{2,}', '*')()\r\n});\r\n\r\n/**\r\n * Inline Lexer & Compiler\r\n */\r\n\r\nfunction InlineLexer(links, options) {\r\n  this.options = options || marked.defaults;\r\n  this.links = links;\r\n  this.rules = inline.normal;\r\n  this.renderer = this.options.renderer || new Renderer;\r\n  this.renderer.options = this.options;\r\n\r\n  if (!this.links) {\r\n    throw new\r\n      Error('Tokens array requires a `links` property.');\r\n  }\r\n\r\n  if (this.options.gfm) {\r\n    if (this.options.breaks) {\r\n      this.rules = inline.breaks;\r\n    } else {\r\n      this.rules = inline.gfm;\r\n    }\r\n  } else if (this.options.pedantic) {\r\n    this.rules = inline.pedantic;\r\n  }\r\n}\r\n\r\n/**\r\n * Expose Inline Rules\r\n */\r\n\r\nInlineLexer.rules = inline;\r\n\r\n/**\r\n * Static Lexing/Compiling Method\r\n */\r\n\r\nInlineLexer.output = function(src, links, options) {\r\n  var inline = new InlineLexer(links, options);\r\n  return inline.output(src);\r\n};\r\n\r\n/**\r\n * Lexing/Compiling\r\n */\r\n\r\nInlineLexer.prototype.output = function(src) {\r\n  var out = ''\r\n    , link\r\n    , text\r\n    , href\r\n    , cap;\r\n\r\n  while (src) {\r\n    // escape\r\n    if (cap = this.rules.escape.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += cap[1];\r\n      continue;\r\n    }\r\n\r\n    // autolink\r\n    if (cap = this.rules.autolink.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      if (cap[2] === '@') {\r\n        text = cap[1].charAt(6) === ':'\r\n          ? this.mangle(cap[1].substring(7))\r\n          : this.mangle(cap[1]);\r\n        href = this.mangle('mailto:') + text;\r\n      } else {\r\n        text = escape(cap[1]);\r\n        href = text;\r\n      }\r\n      out += this.renderer.link(href, null, text);\r\n      continue;\r\n    }\r\n\r\n    // url (gfm)\r\n    if (!this.inLink && (cap = this.rules.url.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n      text = escape(cap[1]);\r\n      href = text;\r\n      out += this.renderer.link(href, null, text);\r\n      continue;\r\n    }\r\n\r\n    // tag\r\n    if (cap = this.rules.tag.exec(src)) {\r\n      if (!this.inLink && /^<a /i.test(cap[0])) {\r\n        this.inLink = true;\r\n      } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\r\n        this.inLink = false;\r\n      }\r\n      src = src.substring(cap[0].length);\r\n      out += this.options.sanitize\r\n        ? this.options.sanitizer\r\n          ? this.options.sanitizer(cap[0])\r\n          : escape(cap[0])\r\n        : cap[0]\r\n      continue;\r\n    }\r\n\r\n    // link\r\n    if (cap = this.rules.link.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.inLink = true;\r\n      out += this.outputLink(cap, {\r\n        href: cap[2],\r\n        title: cap[3]\r\n      });\r\n      this.inLink = false;\r\n      continue;\r\n    }\r\n\r\n    // reflink, nolink\r\n    if ((cap = this.rules.reflink.exec(src))\r\n        || (cap = this.rules.nolink.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n      link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\r\n      link = this.links[link.toLowerCase()];\r\n      if (!link || !link.href) {\r\n        out += cap[0].charAt(0);\r\n        src = cap[0].substring(1) + src;\r\n        continue;\r\n      }\r\n      this.inLink = true;\r\n      out += this.outputLink(cap, link);\r\n      this.inLink = false;\r\n      continue;\r\n    }\r\n\r\n    // strong\r\n    if (cap = this.rules.strong.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.strong(this.output(cap[2] || cap[1]));\r\n      continue;\r\n    }\r\n\r\n    // em\r\n    if (cap = this.rules.em.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.em(this.output(cap[2] || cap[1]));\r\n      continue;\r\n    }\r\n\r\n    // code\r\n    if (cap = this.rules.code.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.codespan(escape(cap[2], true));\r\n      continue;\r\n    }\r\n\r\n    // br\r\n    if (cap = this.rules.br.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.br();\r\n      continue;\r\n    }\r\n\r\n    // del (gfm)\r\n    if (cap = this.rules.del.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.del(this.output(cap[1]));\r\n      continue;\r\n    }\r\n\r\n    // text\r\n    if (cap = this.rules.text.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.text(escape(this.smartypants(cap[0])));\r\n      continue;\r\n    }\r\n\r\n    if (src) {\r\n      throw new\r\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\r\n    }\r\n  }\r\n\r\n  return out;\r\n};\r\n\r\n/**\r\n * Compile Link\r\n */\r\n\r\nInlineLexer.prototype.outputLink = function(cap, link) {\r\n  var href = escape(link.href)\r\n    , title = link.title ? escape(link.title) : null;\r\n\r\n  return cap[0].charAt(0) !== '!'\r\n    ? this.renderer.link(href, title, this.output(cap[1]))\r\n    : this.renderer.image(href, title, escape(cap[1]));\r\n};\r\n\r\n/**\r\n * Smartypants Transformations\r\n */\r\n\r\nInlineLexer.prototype.smartypants = function(text) {\r\n  if (!this.options.smartypants) return text;\r\n  return text\r\n    // em-dashes\r\n    .replace(/---/g, '\\u2014')\r\n    // en-dashes\r\n    .replace(/--/g, '\\u2013')\r\n    // opening singles\r\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\r\n    // closing singles & apostrophes\r\n    .replace(/'/g, '\\u2019')\r\n    // opening doubles\r\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\r\n    // closing doubles\r\n    .replace(/\"/g, '\\u201d')\r\n    // ellipses\r\n    .replace(/\\.{3}/g, '\\u2026');\r\n};\r\n\r\n/**\r\n * Mangle Links\r\n */\r\n\r\nInlineLexer.prototype.mangle = function(text) {\r\n  if (!this.options.mangle) return text;\r\n  var out = ''\r\n    , l = text.length\r\n    , i = 0\r\n    , ch;\r\n\r\n  for (; i < l; i++) {\r\n    ch = text.charCodeAt(i);\r\n    if (Math.random() > 0.5) {\r\n      ch = 'x' + ch.toString(16);\r\n    }\r\n    out += '&#' + ch + ';';\r\n  }\r\n\r\n  return out;\r\n};\r\n\r\n/**\r\n * Renderer\r\n */\r\n\r\nfunction Renderer(options) {\r\n  this.options = options || {};\r\n}\r\n\r\nRenderer.prototype.code = function(code, lang, escaped) {\r\n  if (this.options.highlight) {\r\n    var out = this.options.highlight(code, lang);\r\n    if (out != null && out !== code) {\r\n      escaped = true;\r\n      code = out;\r\n    }\r\n  }\r\n\r\n  if (!lang) {\r\n    return '<pre><code>'\r\n      + (escaped ? code : escape(code, true))\r\n      + '\\n</code></pre>';\r\n  }\r\n\r\n  return '<pre><code class=\"'\r\n    + this.options.langPrefix\r\n    + escape(lang, true)\r\n    + '\">'\r\n    + (escaped ? code : escape(code, true))\r\n    + '\\n</code></pre>\\n';\r\n};\r\n\r\nRenderer.prototype.blockquote = function(quote) {\r\n  return '<blockquote>\\n' + quote + '</blockquote>\\n';\r\n};\r\n\r\nRenderer.prototype.html = function(html) {\r\n  return html;\r\n};\r\n\r\nRenderer.prototype.heading = function(text, level, raw) {\r\n  return '<h'\r\n    + level\r\n    + ' id=\"'\r\n    + this.options.headerPrefix\r\n    + raw.toLowerCase().replace(/[^\\w]+/g, '-')\r\n    + '\">'\r\n    + text\r\n    + '</h'\r\n    + level\r\n    + '>\\n';\r\n};\r\n\r\nRenderer.prototype.hr = function() {\r\n  return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\r\n};\r\n\r\nRenderer.prototype.list = function(body, ordered) {\r\n  var type = ordered ? 'ol' : 'ul';\r\n  return '<' + type + '>\\n' + body + '</' + type + '>\\n';\r\n};\r\n\r\nRenderer.prototype.listitem = function(text) {\r\n  return '<li>' + text + '</li>\\n';\r\n};\r\n\r\nRenderer.prototype.paragraph = function(text) {\r\n  return '<p>' + text + '</p>\\n';\r\n};\r\n\r\nRenderer.prototype.table = function(header, body) {\r\n  return '<table>\\n'\r\n    + '<thead>\\n'\r\n    + header\r\n    + '</thead>\\n'\r\n    + '<tbody>\\n'\r\n    + body\r\n    + '</tbody>\\n'\r\n    + '</table>\\n';\r\n};\r\n\r\nRenderer.prototype.tablerow = function(content) {\r\n  return '<tr>\\n' + content + '</tr>\\n';\r\n};\r\n\r\nRenderer.prototype.tablecell = function(content, flags) {\r\n  var type = flags.header ? 'th' : 'td';\r\n  var tag = flags.align\r\n    ? '<' + type + ' style=\"text-align:' + flags.align + '\">'\r\n    : '<' + type + '>';\r\n  return tag + content + '</' + type + '>\\n';\r\n};\r\n\r\n// span level renderer\r\nRenderer.prototype.strong = function(text) {\r\n  return '<strong>' + text + '</strong>';\r\n};\r\n\r\nRenderer.prototype.em = function(text) {\r\n  return '<em>' + text + '</em>';\r\n};\r\n\r\nRenderer.prototype.codespan = function(text) {\r\n  return '<code>' + text + '</code>';\r\n};\r\n\r\nRenderer.prototype.br = function() {\r\n  return this.options.xhtml ? '<br/>' : '<br>';\r\n};\r\n\r\nRenderer.prototype.del = function(text) {\r\n  return '<del>' + text + '</del>';\r\n};\r\n\r\nRenderer.prototype.link = function(href, title, text) {\r\n  if (this.options.sanitize) {\r\n    try {\r\n      var prot = decodeURIComponent(unescape(href))\r\n        .replace(/[^\\w:]/g, '')\r\n        .toLowerCase();\r\n    } catch (e) {\r\n      return '';\r\n    }\r\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {\r\n      return '';\r\n    }\r\n  }\r\n  var out = '<a href=\"' + href + '\"';\r\n  if (title) {\r\n    out += ' title=\"' + title + '\"';\r\n  }\r\n  out += '>' + text + '</a>';\r\n  return out;\r\n};\r\n\r\nRenderer.prototype.image = function(href, title, text) {\r\n  var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\r\n  if (title) {\r\n    out += ' title=\"' + title + '\"';\r\n  }\r\n  out += this.options.xhtml ? '/>' : '>';\r\n  return out;\r\n};\r\n\r\nRenderer.prototype.text = function(text) {\r\n  return text;\r\n};\r\n\r\n/**\r\n * Parsing & Compiling\r\n */\r\n\r\nfunction Parser(options) {\r\n  this.tokens = [];\r\n  this.token = null;\r\n  this.options = options || marked.defaults;\r\n  this.options.renderer = this.options.renderer || new Renderer;\r\n  this.renderer = this.options.renderer;\r\n  this.renderer.options = this.options;\r\n}\r\n\r\n/**\r\n * Static Parse Method\r\n */\r\n\r\nParser.parse = function(src, options, renderer) {\r\n  var parser = new Parser(options, renderer);\r\n  return parser.parse(src);\r\n};\r\n\r\n/**\r\n * Parse Loop\r\n */\r\n\r\nParser.prototype.parse = function(src) {\r\n  this.inline = new InlineLexer(src.links, this.options, this.renderer);\r\n  this.tokens = src.reverse();\r\n\r\n  var out = '';\r\n  while (this.next()) {\r\n    out += this.tok();\r\n  }\r\n\r\n  return out;\r\n};\r\n\r\n/**\r\n * Next Token\r\n */\r\n\r\nParser.prototype.next = function() {\r\n  return this.token = this.tokens.pop();\r\n};\r\n\r\n/**\r\n * Preview Next Token\r\n */\r\n\r\nParser.prototype.peek = function() {\r\n  return this.tokens[this.tokens.length - 1] || 0;\r\n};\r\n\r\n/**\r\n * Parse Text Tokens\r\n */\r\n\r\nParser.prototype.parseText = function() {\r\n  var body = this.token.text;\r\n\r\n  while (this.peek().type === 'text') {\r\n    body += '\\n' + this.next().text;\r\n  }\r\n\r\n  return this.inline.output(body);\r\n};\r\n\r\n/**\r\n * Parse Current Token\r\n */\r\n\r\nParser.prototype.tok = function() {\r\n  switch (this.token.type) {\r\n    case 'space': {\r\n      return '';\r\n    }\r\n    case 'hr': {\r\n      return this.renderer.hr();\r\n    }\r\n    case 'heading': {\r\n      return this.renderer.heading(\r\n        this.inline.output(this.token.text),\r\n        this.token.depth,\r\n        this.token.text);\r\n    }\r\n    case 'code': {\r\n      return this.renderer.code(this.token.text,\r\n        this.token.lang,\r\n        this.token.escaped);\r\n    }\r\n    case 'table': {\r\n      var header = ''\r\n        , body = ''\r\n        , i\r\n        , row\r\n        , cell\r\n        , flags\r\n        , j;\r\n\r\n      // header\r\n      cell = '';\r\n      for (i = 0; i < this.token.header.length; i++) {\r\n        flags = { header: true, align: this.token.align[i] };\r\n        cell += this.renderer.tablecell(\r\n          this.inline.output(this.token.header[i]),\r\n          { header: true, align: this.token.align[i] }\r\n        );\r\n      }\r\n      header += this.renderer.tablerow(cell);\r\n\r\n      for (i = 0; i < this.token.cells.length; i++) {\r\n        row = this.token.cells[i];\r\n\r\n        cell = '';\r\n        for (j = 0; j < row.length; j++) {\r\n          cell += this.renderer.tablecell(\r\n            this.inline.output(row[j]),\r\n            { header: false, align: this.token.align[j] }\r\n          );\r\n        }\r\n\r\n        body += this.renderer.tablerow(cell);\r\n      }\r\n      return this.renderer.table(header, body);\r\n    }\r\n    case 'blockquote_start': {\r\n      var body = '';\r\n\r\n      while (this.next().type !== 'blockquote_end') {\r\n        body += this.tok();\r\n      }\r\n\r\n      return this.renderer.blockquote(body);\r\n    }\r\n    case 'list_start': {\r\n      var body = ''\r\n        , ordered = this.token.ordered;\r\n\r\n      while (this.next().type !== 'list_end') {\r\n        body += this.tok();\r\n      }\r\n\r\n      return this.renderer.list(body, ordered);\r\n    }\r\n    case 'list_item_start': {\r\n      var body = '';\r\n\r\n      while (this.next().type !== 'list_item_end') {\r\n        body += this.token.type === 'text'\r\n          ? this.parseText()\r\n          : this.tok();\r\n      }\r\n\r\n      return this.renderer.listitem(body);\r\n    }\r\n    case 'loose_item_start': {\r\n      var body = '';\r\n\r\n      while (this.next().type !== 'list_item_end') {\r\n        body += this.tok();\r\n      }\r\n\r\n      return this.renderer.listitem(body);\r\n    }\r\n    case 'html': {\r\n      var html = !this.token.pre && !this.options.pedantic\r\n        ? this.inline.output(this.token.text)\r\n        : this.token.text;\r\n      return this.renderer.html(html);\r\n    }\r\n    case 'paragraph': {\r\n      return this.renderer.paragraph(this.inline.output(this.token.text));\r\n    }\r\n    case 'text': {\r\n      return this.renderer.paragraph(this.parseText());\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Helpers\r\n */\r\n\r\nfunction escape(html, encode) {\r\n  return html\r\n    .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\"/g, '&quot;')\r\n    .replace(/'/g, '&#39;');\r\n}\r\n\r\nfunction unescape(html) {\r\n\t// explicitly match decimal, hex, and named HTML entities \r\n  return html.replace(/&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/g, function(_, n) {\r\n    n = n.toLowerCase();\r\n    if (n === 'colon') return ':';\r\n    if (n.charAt(0) === '#') {\r\n      return n.charAt(1) === 'x'\r\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\r\n        : String.fromCharCode(+n.substring(1));\r\n    }\r\n    return '';\r\n  });\r\n}\r\n\r\nfunction replace(regex, opt) {\r\n  regex = regex.source;\r\n  opt = opt || '';\r\n  return function self(name, val) {\r\n    if (!name) return new RegExp(regex, opt);\r\n    val = val.source || val;\r\n    val = val.replace(/(^|[^\\[])\\^/g, '$1');\r\n    regex = regex.replace(name, val);\r\n    return self;\r\n  };\r\n}\r\n\r\nfunction noop() {}\r\nnoop.exec = noop;\r\n\r\nfunction merge(obj) {\r\n  var i = 1\r\n    , target\r\n    , key;\r\n\r\n  for (; i < arguments.length; i++) {\r\n    target = arguments[i];\r\n    for (key in target) {\r\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\r\n        obj[key] = target[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\n\r\n/**\r\n * Marked\r\n */\r\n\r\nfunction marked(src, opt, callback) {\r\n  if (callback || typeof opt === 'function') {\r\n    if (!callback) {\r\n      callback = opt;\r\n      opt = null;\r\n    }\r\n\r\n    opt = merge({}, marked.defaults, opt || {});\r\n\r\n    var highlight = opt.highlight\r\n      , tokens\r\n      , pending\r\n      , i = 0;\r\n\r\n    try {\r\n      tokens = Lexer.lex(src, opt)\r\n    } catch (e) {\r\n      return callback(e);\r\n    }\r\n\r\n    pending = tokens.length;\r\n\r\n    var done = function(err) {\r\n      if (err) {\r\n        opt.highlight = highlight;\r\n        return callback(err);\r\n      }\r\n\r\n      var out;\r\n\r\n      try {\r\n        out = Parser.parse(tokens, opt);\r\n      } catch (e) {\r\n        err = e;\r\n      }\r\n\r\n      opt.highlight = highlight;\r\n\r\n      return err\r\n        ? callback(err)\r\n        : callback(null, out);\r\n    };\r\n\r\n    if (!highlight || highlight.length < 3) {\r\n      return done();\r\n    }\r\n\r\n    delete opt.highlight;\r\n\r\n    if (!pending) return done();\r\n\r\n    for (; i < tokens.length; i++) {\r\n      (function(token) {\r\n        if (token.type !== 'code') {\r\n          return --pending || done();\r\n        }\r\n        return highlight(token.text, token.lang, function(err, code) {\r\n          if (err) return done(err);\r\n          if (code == null || code === token.text) {\r\n            return --pending || done();\r\n          }\r\n          token.text = code;\r\n          token.escaped = true;\r\n          --pending || done();\r\n        });\r\n      })(tokens[i]);\r\n    }\r\n\r\n    return;\r\n  }\r\n  try {\r\n    if (opt) opt = merge({}, marked.defaults, opt);\r\n    return Parser.parse(Lexer.lex(src, opt), opt);\r\n  } catch (e) {\r\n    e.message += '\\nPlease report this to https://github.com/chjj/marked.';\r\n    if ((opt || marked.defaults).silent) {\r\n      return '<p>An error occured:</p><pre>'\r\n        + escape(e.message + '', true)\r\n        + '</pre>';\r\n    }\r\n    throw e;\r\n  }\r\n}\r\n\r\n/**\r\n * Options\r\n */\r\n\r\nmarked.options =\r\nmarked.setOptions = function(opt) {\r\n  merge(marked.defaults, opt);\r\n  return marked;\r\n};\r\n\r\nmarked.defaults = {\r\n  gfm: true,\r\n  tables: true,\r\n  breaks: false,\r\n  pedantic: false,\r\n  sanitize: false,\r\n  sanitizer: null,\r\n  mangle: true,\r\n  smartLists: false,\r\n  silent: false,\r\n  highlight: null,\r\n  langPrefix: 'lang-',\r\n  smartypants: false,\r\n  headerPrefix: '',\r\n  renderer: new Renderer,\r\n  xhtml: false\r\n};\r\n\r\n/**\r\n * Expose\r\n */\r\n\r\nmarked.Parser = Parser;\r\nmarked.parser = Parser.parse;\r\n\r\nmarked.Renderer = Renderer;\r\n\r\nmarked.Lexer = Lexer;\r\nmarked.lexer = Lexer.lex;\r\n\r\nmarked.InlineLexer = InlineLexer;\r\nmarked.inlineLexer = InlineLexer.output;\r\n\r\nmarked.parse = marked;\r\n\r\nif (true) {\r\n  module.exports = marked;\r\n} else if (typeof define === 'function' && define.amd) {\r\n  define(function() { return marked; });\r\n} else {\r\n  this.marked = marked;\r\n}\r\n\r\n}).call(function() {\r\n  return this || (typeof window !== 'undefined' ? window : global);\r\n}());\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(79)))\n\n/***/ }),\n\n/***/ 1281:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\nvar CodeMirror = __webpack_require__(877);\r\n\r\nCodeMirror.commands.tabAndIndentMarkdownList = function (cm) {\r\n\tvar ranges = cm.listSelections();\r\n\tvar pos = ranges[0].head;\r\n\tvar eolState = cm.getStateAfter(pos.line);\r\n\tvar inList = eolState.list !== false;\r\n\r\n\tif (inList) {\r\n\t\tcm.execCommand(\"indentMore\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (cm.options.indentWithTabs) {\r\n\t\tcm.execCommand(\"insertTab\");\r\n\t}\r\n\telse {\r\n\t\tvar spaces = Array(cm.options.tabSize + 1).join(\" \");\r\n\t\tcm.replaceSelection(spaces);\r\n\t}\r\n};\r\n\r\nCodeMirror.commands.shiftTabAndUnindentMarkdownList = function (cm) {\r\n\tvar ranges = cm.listSelections();\r\n\tvar pos = ranges[0].head;\r\n\tvar eolState = cm.getStateAfter(pos.line);\r\n\tvar inList = eolState.list !== false;\r\n\r\n\tif (inList) {\r\n\t\tcm.execCommand(\"indentLess\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (cm.options.indentWithTabs) {\r\n\t\tcm.execCommand(\"insertTab\");\r\n\t}\r\n\telse {\r\n\t\tvar spaces = Array(cm.options.tabSize + 1).join(\" \");\r\n\t\tcm.replaceSelection(spaces);\r\n\t}\r\n};\r\n\n\n/***/ }),\n\n/***/ 1282:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*global require,module*/\r\n\r\nvar CodeMirror = __webpack_require__(877);\r\n__webpack_require__(1073);\r\n__webpack_require__(1281);\r\n__webpack_require__(1071);\r\n__webpack_require__(960);\r\n__webpack_require__(959);\r\n__webpack_require__(1072);\r\n__webpack_require__(1076);\r\n__webpack_require__(1077);\r\n__webpack_require__(961);\r\nvar CodeMirrorSpellChecker = __webpack_require__(1070);\r\nvar marked = __webpack_require__(1271);\r\n\r\n\r\n// Some variables\r\nvar isMac = /Mac/.test(navigator.platform);\r\n\r\n// Mapping of actions that can be bound to keyboard shortcuts or toolbar buttons\r\nvar bindings = {\r\n\t\"toggleBold\": toggleBold,\r\n\t\"toggleItalic\": toggleItalic,\r\n\t\"drawLink\": drawLink,\r\n\t\"toggleHeadingSmaller\": toggleHeadingSmaller,\r\n\t\"toggleHeadingBigger\": toggleHeadingBigger,\r\n\t\"drawImage\": drawImage,\r\n\t\"toggleBlockquote\": toggleBlockquote,\r\n\t\"toggleOrderedList\": toggleOrderedList,\r\n\t\"toggleUnorderedList\": toggleUnorderedList,\r\n\t\"toggleCodeBlock\": toggleCodeBlock,\r\n\t\"togglePreview\": togglePreview,\r\n\t\"toggleStrikethrough\": toggleStrikethrough,\r\n\t\"toggleHeading1\": toggleHeading1,\r\n\t\"toggleHeading2\": toggleHeading2,\r\n\t\"toggleHeading3\": toggleHeading3,\r\n\t\"cleanBlock\": cleanBlock,\r\n\t\"drawTable\": drawTable,\r\n\t\"drawHorizontalRule\": drawHorizontalRule,\r\n\t\"undo\": undo,\r\n\t\"redo\": redo,\r\n\t\"toggleSideBySide\": toggleSideBySide,\r\n\t\"toggleFullScreen\": toggleFullScreen\r\n};\r\n\r\nvar shortcuts = {\r\n\t\"toggleBold\": \"Cmd-B\",\r\n\t\"toggleItalic\": \"Cmd-I\",\r\n\t\"drawLink\": \"Cmd-K\",\r\n\t\"toggleHeadingSmaller\": \"Cmd-H\",\r\n\t\"toggleHeadingBigger\": \"Shift-Cmd-H\",\r\n\t\"cleanBlock\": \"Cmd-E\",\r\n\t\"drawImage\": \"Cmd-Alt-I\",\r\n\t\"toggleBlockquote\": \"Cmd-'\",\r\n\t\"toggleOrderedList\": \"Cmd-Alt-L\",\r\n\t\"toggleUnorderedList\": \"Cmd-L\",\r\n\t\"toggleCodeBlock\": \"Cmd-Alt-C\",\r\n\t\"togglePreview\": \"Cmd-P\",\r\n\t\"toggleSideBySide\": \"F9\",\r\n\t\"toggleFullScreen\": \"F11\"\r\n};\r\n\r\nvar getBindingName = function(f) {\r\n\tfor(var key in bindings) {\r\n\t\tif(bindings[key] === f) {\r\n\t\t\treturn key;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nvar isMobile = function() {\r\n\tvar check = false;\r\n\t(function(a) {\r\n\t\tif(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4))) check = true;\r\n\t})(navigator.userAgent || navigator.vendor || window.opera);\r\n\treturn check;\r\n};\r\n\r\n\r\n/**\r\n * Fix shortcut. Mac use Command, others use Ctrl.\r\n */\r\nfunction fixShortcut(name) {\r\n\tif(isMac) {\r\n\t\tname = name.replace(\"Ctrl\", \"Cmd\");\r\n\t} else {\r\n\t\tname = name.replace(\"Cmd\", \"Ctrl\");\r\n\t}\r\n\treturn name;\r\n}\r\n\r\n\r\n/**\r\n * Create icon element for toolbar.\r\n */\r\nfunction createIcon(options, enableTooltips, shortcuts) {\r\n\toptions = options || {};\r\n\tvar el = document.createElement(\"a\");\r\n\tenableTooltips = (enableTooltips == undefined) ? true : enableTooltips;\r\n\r\n\tif(options.title && enableTooltips) {\r\n\t\tel.title = createTootlip(options.title, options.action, shortcuts);\r\n\r\n\t\tif(isMac) {\r\n\t\t\tel.title = el.title.replace(\"Ctrl\", \"⌘\");\r\n\t\t\tel.title = el.title.replace(\"Alt\", \"⌥\");\r\n\t\t}\r\n\t}\r\n\r\n\tel.tabIndex = -1;\r\n\tel.className = options.className;\r\n\treturn el;\r\n}\r\n\r\nfunction createSep() {\r\n\tvar el = document.createElement(\"i\");\r\n\tel.className = \"separator\";\r\n\tel.innerHTML = \"|\";\r\n\treturn el;\r\n}\r\n\r\nfunction createTootlip(title, action, shortcuts) {\r\n\tvar actionName;\r\n\tvar tooltip = title;\r\n\r\n\tif(action) {\r\n\t\tactionName = getBindingName(action);\r\n\t\tif(shortcuts[actionName]) {\r\n\t\t\ttooltip += \" (\" + fixShortcut(shortcuts[actionName]) + \")\";\r\n\t\t}\r\n\t}\r\n\r\n\treturn tooltip;\r\n}\r\n\r\n/**\r\n * The state of CodeMirror at the given position.\r\n */\r\nfunction getState(cm, pos) {\r\n\tpos = pos || cm.getCursor(\"start\");\r\n\tvar stat = cm.getTokenAt(pos);\r\n\tif(!stat.type) return {};\r\n\r\n\tvar types = stat.type.split(\" \");\r\n\r\n\tvar ret = {},\r\n\t\tdata, text;\r\n\tfor(var i = 0; i < types.length; i++) {\r\n\t\tdata = types[i];\r\n\t\tif(data === \"strong\") {\r\n\t\t\tret.bold = true;\r\n\t\t} else if(data === \"variable-2\") {\r\n\t\t\ttext = cm.getLine(pos.line);\r\n\t\t\tif(/^\\s*\\d+\\.\\s/.test(text)) {\r\n\t\t\t\tret[\"ordered-list\"] = true;\r\n\t\t\t} else {\r\n\t\t\t\tret[\"unordered-list\"] = true;\r\n\t\t\t}\r\n\t\t} else if(data === \"atom\") {\r\n\t\t\tret.quote = true;\r\n\t\t} else if(data === \"em\") {\r\n\t\t\tret.italic = true;\r\n\t\t} else if(data === \"quote\") {\r\n\t\t\tret.quote = true;\r\n\t\t} else if(data === \"strikethrough\") {\r\n\t\t\tret.strikethrough = true;\r\n\t\t} else if(data === \"comment\") {\r\n\t\t\tret.code = true;\r\n\t\t} else if(data === \"link\") {\r\n\t\t\tret.link = true;\r\n\t\t} else if(data === \"tag\") {\r\n\t\t\tret.image = true;\r\n\t\t} else if(data.match(/^header(\\-[1-6])?$/)) {\r\n\t\t\tret[data.replace(\"header\", \"heading\")] = true;\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n\r\n// Saved overflow setting\r\nvar saved_overflow = \"\";\r\n\r\n/**\r\n * Toggle full screen of the editor.\r\n */\r\nfunction toggleFullScreen(editor) {\r\n\t// Set fullscreen\r\n\tvar cm = editor.codemirror;\r\n\tcm.setOption(\"fullScreen\", !cm.getOption(\"fullScreen\"));\r\n\r\n\r\n\t// Prevent scrolling on body during fullscreen active\r\n\tif(cm.getOption(\"fullScreen\")) {\r\n\t\tsaved_overflow = document.body.style.overflow;\r\n\t\tdocument.body.style.overflow = \"hidden\";\r\n\t} else {\r\n\t\tdocument.body.style.overflow = saved_overflow;\r\n\t}\r\n\r\n\r\n\t// Update toolbar class\r\n\tvar wrap = cm.getWrapperElement();\r\n\r\n\tif(!/fullscreen/.test(wrap.previousSibling.className)) {\r\n\t\twrap.previousSibling.className += \" fullscreen\";\r\n\t} else {\r\n\t\twrap.previousSibling.className = wrap.previousSibling.className.replace(/\\s*fullscreen\\b/, \"\");\r\n\t}\r\n\r\n\r\n\t// Update toolbar button\r\n\tvar toolbarButton = editor.toolbarElements.fullscreen;\r\n\r\n\tif(!/active/.test(toolbarButton.className)) {\r\n\t\ttoolbarButton.className += \" active\";\r\n\t} else {\r\n\t\ttoolbarButton.className = toolbarButton.className.replace(/\\s*active\\s*/g, \"\");\r\n\t}\r\n\r\n\r\n\t// Hide side by side if needed\r\n\tvar sidebyside = cm.getWrapperElement().nextSibling;\r\n\tif(/editor-preview-active-side/.test(sidebyside.className))\r\n\t\ttoggleSideBySide(editor);\r\n}\r\n\r\n\r\n/**\r\n * Action for toggling bold.\r\n */\r\nfunction toggleBold(editor) {\r\n\t_toggleBlock(editor, \"bold\", editor.options.blockStyles.bold);\r\n}\r\n\r\n\r\n/**\r\n * Action for toggling italic.\r\n */\r\nfunction toggleItalic(editor) {\r\n\t_toggleBlock(editor, \"italic\", editor.options.blockStyles.italic);\r\n}\r\n\r\n\r\n/**\r\n * Action for toggling strikethrough.\r\n */\r\nfunction toggleStrikethrough(editor) {\r\n\t_toggleBlock(editor, \"strikethrough\", \"~~\");\r\n}\r\n\r\n/**\r\n * Action for toggling code block.\r\n */\r\nfunction toggleCodeBlock(editor) {\r\n\tvar fenceCharsToInsert = editor.options.blockStyles.code;\r\n\r\n\tfunction fencing_line(line) {\r\n\t\t/* return true, if this is a ``` or ~~~ line */\r\n\t\tif(typeof line !== \"object\") {\r\n\t\t\tthrow \"fencing_line() takes a 'line' object (not a line number, or line text).  Got: \" + typeof line + \": \" + line;\r\n\t\t}\r\n\t\treturn line.styles && line.styles[2] && line.styles[2].indexOf(\"formatting-code-block\") !== -1;\r\n\t}\r\n\r\n\tfunction token_state(token) {\r\n\t\t// base goes an extra level deep when mode backdrops are used, e.g. spellchecker on\r\n\t\treturn token.state.base.base || token.state.base;\r\n\t}\r\n\r\n\tfunction code_type(cm, line_num, line, firstTok, lastTok) {\r\n\t\t/*\r\n\t\t * Return \"single\", \"indented\", \"fenced\" or false\r\n\t\t *\r\n\t\t * cm and line_num are required.  Others are optional for efficiency\r\n\t\t *   To check in the middle of a line, pass in firstTok yourself.\r\n\t\t */\r\n\t\tline = line || cm.getLineHandle(line_num);\r\n\t\tfirstTok = firstTok || cm.getTokenAt({\r\n\t\t\tline: line_num,\r\n\t\t\tch: 1\r\n\t\t});\r\n\t\tlastTok = lastTok || (!!line.text && cm.getTokenAt({\r\n\t\t\tline: line_num,\r\n\t\t\tch: line.text.length - 1\r\n\t\t}));\r\n\t\tvar types = firstTok.type ? firstTok.type.split(\" \") : [];\r\n\t\tif(lastTok && token_state(lastTok).indentedCode) {\r\n\t\t\t// have to check last char, since first chars of first line aren\"t marked as indented\r\n\t\t\treturn \"indented\";\r\n\t\t} else if(types.indexOf(\"comment\") === -1) {\r\n\t\t\t// has to be after \"indented\" check, since first chars of first indented line aren\"t marked as such\r\n\t\t\treturn false;\r\n\t\t} else if(token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line)) {\r\n\t\t\treturn \"fenced\";\r\n\t\t} else {\r\n\t\t\treturn \"single\";\r\n\t\t}\r\n\t}\r\n\r\n\tfunction insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert) {\r\n\t\tvar start_line_sel = cur_start.line + 1,\r\n\t\t\tend_line_sel = cur_end.line + 1,\r\n\t\t\tsel_multi = cur_start.line !== cur_end.line,\r\n\t\t\trepl_start = fenceCharsToInsert + \"\\n\",\r\n\t\t\trepl_end = \"\\n\" + fenceCharsToInsert;\r\n\t\tif(sel_multi) {\r\n\t\t\tend_line_sel++;\r\n\t\t}\r\n\t\t// handle last char including \\n or not\r\n\t\tif(sel_multi && cur_end.ch === 0) {\r\n\t\t\trepl_end = fenceCharsToInsert + \"\\n\";\r\n\t\t\tend_line_sel--;\r\n\t\t}\r\n\t\t_replaceSelection(cm, false, [repl_start, repl_end]);\r\n\t\tcm.setSelection({\r\n\t\t\tline: start_line_sel,\r\n\t\t\tch: 0\r\n\t\t}, {\r\n\t\t\tline: end_line_sel,\r\n\t\t\tch: 0\r\n\t\t});\r\n\t}\r\n\r\n\tvar cm = editor.codemirror,\r\n\t\tcur_start = cm.getCursor(\"start\"),\r\n\t\tcur_end = cm.getCursor(\"end\"),\r\n\t\ttok = cm.getTokenAt({\r\n\t\t\tline: cur_start.line,\r\n\t\t\tch: cur_start.ch || 1\r\n\t\t}), // avoid ch 0 which is a cursor pos but not token\r\n\t\tline = cm.getLineHandle(cur_start.line),\r\n\t\tis_code = code_type(cm, cur_start.line, line, tok);\r\n\tvar block_start, block_end, lineCount;\r\n\r\n\tif(is_code === \"single\") {\r\n\t\t// similar to some SimpleMDE _toggleBlock logic\r\n\t\tvar start = line.text.slice(0, cur_start.ch).replace(\"`\", \"\"),\r\n\t\t\tend = line.text.slice(cur_start.ch).replace(\"`\", \"\");\r\n\t\tcm.replaceRange(start + end, {\r\n\t\t\tline: cur_start.line,\r\n\t\t\tch: 0\r\n\t\t}, {\r\n\t\t\tline: cur_start.line,\r\n\t\t\tch: 99999999999999\r\n\t\t});\r\n\t\tcur_start.ch--;\r\n\t\tif(cur_start !== cur_end) {\r\n\t\t\tcur_end.ch--;\r\n\t\t}\r\n\t\tcm.setSelection(cur_start, cur_end);\r\n\t\tcm.focus();\r\n\t} else if(is_code === \"fenced\") {\r\n\t\tif(cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {\r\n\t\t\t// use selection\r\n\r\n\t\t\t// find the fenced line so we know what type it is (tilde, backticks, number of them)\r\n\t\t\tfor(block_start = cur_start.line; block_start >= 0; block_start--) {\r\n\t\t\t\tline = cm.getLineHandle(block_start);\r\n\t\t\t\tif(fencing_line(line)) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar fencedTok = cm.getTokenAt({\r\n\t\t\t\tline: block_start,\r\n\t\t\t\tch: 1\r\n\t\t\t});\r\n\t\t\tvar fence_chars = token_state(fencedTok).fencedChars;\r\n\t\t\tvar start_text, start_line;\r\n\t\t\tvar end_text, end_line;\r\n\t\t\t// check for selection going up against fenced lines, in which case we don't want to add more fencing\r\n\t\t\tif(fencing_line(cm.getLineHandle(cur_start.line))) {\r\n\t\t\t\tstart_text = \"\";\r\n\t\t\t\tstart_line = cur_start.line;\r\n\t\t\t} else if(fencing_line(cm.getLineHandle(cur_start.line - 1))) {\r\n\t\t\t\tstart_text = \"\";\r\n\t\t\t\tstart_line = cur_start.line - 1;\r\n\t\t\t} else {\r\n\t\t\t\tstart_text = fence_chars + \"\\n\";\r\n\t\t\t\tstart_line = cur_start.line;\r\n\t\t\t}\r\n\t\t\tif(fencing_line(cm.getLineHandle(cur_end.line))) {\r\n\t\t\t\tend_text = \"\";\r\n\t\t\t\tend_line = cur_end.line;\r\n\t\t\t\tif(cur_end.ch === 0) {\r\n\t\t\t\t\tend_line += 1;\r\n\t\t\t\t}\r\n\t\t\t} else if(cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {\r\n\t\t\t\tend_text = \"\";\r\n\t\t\t\tend_line = cur_end.line + 1;\r\n\t\t\t} else {\r\n\t\t\t\tend_text = fence_chars + \"\\n\";\r\n\t\t\t\tend_line = cur_end.line + 1;\r\n\t\t\t}\r\n\t\t\tif(cur_end.ch === 0) {\r\n\t\t\t\t// full last line selected, putting cursor at beginning of next\r\n\t\t\t\tend_line -= 1;\r\n\t\t\t}\r\n\t\t\tcm.operation(function() {\r\n\t\t\t\t// end line first, so that line numbers don't change\r\n\t\t\t\tcm.replaceRange(end_text, {\r\n\t\t\t\t\tline: end_line,\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t}, {\r\n\t\t\t\t\tline: end_line + (end_text ? 0 : 1),\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t});\r\n\t\t\t\tcm.replaceRange(start_text, {\r\n\t\t\t\t\tline: start_line,\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t}, {\r\n\t\t\t\t\tline: start_line + (start_text ? 0 : 1),\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t\tcm.setSelection({\r\n\t\t\t\tline: start_line + (start_text ? 1 : 0),\r\n\t\t\t\tch: 0\r\n\t\t\t}, {\r\n\t\t\t\tline: end_line + (start_text ? 1 : -1),\r\n\t\t\t\tch: 0\r\n\t\t\t});\r\n\t\t\tcm.focus();\r\n\t\t} else {\r\n\t\t\t// no selection, search for ends of this fenced block\r\n\t\t\tvar search_from = cur_start.line;\r\n\t\t\tif(fencing_line(cm.getLineHandle(cur_start.line))) { // gets a little tricky if cursor is right on a fenced line\r\n\t\t\t\tif(code_type(cm, cur_start.line + 1) === \"fenced\") {\r\n\t\t\t\t\tblock_start = cur_start.line;\r\n\t\t\t\t\tsearch_from = cur_start.line + 1; // for searching for \"end\"\r\n\t\t\t\t} else {\r\n\t\t\t\t\tblock_end = cur_start.line;\r\n\t\t\t\t\tsearch_from = cur_start.line - 1; // for searching for \"start\"\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(block_start === undefined) {\r\n\t\t\t\tfor(block_start = search_from; block_start >= 0; block_start--) {\r\n\t\t\t\t\tline = cm.getLineHandle(block_start);\r\n\t\t\t\t\tif(fencing_line(line)) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(block_end === undefined) {\r\n\t\t\t\tlineCount = cm.lineCount();\r\n\t\t\t\tfor(block_end = search_from; block_end < lineCount; block_end++) {\r\n\t\t\t\t\tline = cm.getLineHandle(block_end);\r\n\t\t\t\t\tif(fencing_line(line)) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcm.operation(function() {\r\n\t\t\t\tcm.replaceRange(\"\", {\r\n\t\t\t\t\tline: block_start,\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t}, {\r\n\t\t\t\t\tline: block_start + 1,\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t});\r\n\t\t\t\tcm.replaceRange(\"\", {\r\n\t\t\t\t\tline: block_end - 1,\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t}, {\r\n\t\t\t\t\tline: block_end,\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t\tcm.focus();\r\n\t\t}\r\n\t} else if(is_code === \"indented\") {\r\n\t\tif(cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {\r\n\t\t\t// use selection\r\n\t\t\tblock_start = cur_start.line;\r\n\t\t\tblock_end = cur_end.line;\r\n\t\t\tif(cur_end.ch === 0) {\r\n\t\t\t\tblock_end--;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// no selection, search for ends of this indented block\r\n\t\t\tfor(block_start = cur_start.line; block_start >= 0; block_start--) {\r\n\t\t\t\tline = cm.getLineHandle(block_start);\r\n\t\t\t\tif(line.text.match(/^\\s*$/)) {\r\n\t\t\t\t\t// empty or all whitespace - keep going\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif(code_type(cm, block_start, line) !== \"indented\") {\r\n\t\t\t\t\t\tblock_start += 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlineCount = cm.lineCount();\r\n\t\t\tfor(block_end = cur_start.line; block_end < lineCount; block_end++) {\r\n\t\t\t\tline = cm.getLineHandle(block_end);\r\n\t\t\t\tif(line.text.match(/^\\s*$/)) {\r\n\t\t\t\t\t// empty or all whitespace - keep going\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif(code_type(cm, block_end, line) !== \"indented\") {\r\n\t\t\t\t\t\tblock_end -= 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// if we are going to un-indent based on a selected set of lines, and the next line is indented too, we need to\r\n\t\t// insert a blank line so that the next line(s) continue to be indented code\r\n\t\tvar next_line = cm.getLineHandle(block_end + 1),\r\n\t\t\tnext_line_last_tok = next_line && cm.getTokenAt({\r\n\t\t\t\tline: block_end + 1,\r\n\t\t\t\tch: next_line.text.length - 1\r\n\t\t\t}),\r\n\t\t\tnext_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;\r\n\t\tif(next_line_indented) {\r\n\t\t\tcm.replaceRange(\"\\n\", {\r\n\t\t\t\tline: block_end + 1,\r\n\t\t\t\tch: 0\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfor(var i = block_start; i <= block_end; i++) {\r\n\t\t\tcm.indentLine(i, \"subtract\"); // TODO: this doesn't get tracked in the history, so can't be undone :(\r\n\t\t}\r\n\t\tcm.focus();\r\n\t} else {\r\n\t\t// insert code formatting\r\n\t\tvar no_sel_and_starting_of_line = (cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0);\r\n\t\tvar sel_multi = cur_start.line !== cur_end.line;\r\n\t\tif(no_sel_and_starting_of_line || sel_multi) {\r\n\t\t\tinsertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);\r\n\t\t} else {\r\n\t\t\t_replaceSelection(cm, false, [\"`\", \"`\"]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Action for toggling blockquote.\r\n */\r\nfunction toggleBlockquote(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleLine(cm, \"quote\");\r\n}\r\n\r\n/**\r\n * Action for toggling heading size: normal -> h1 -> h2 -> h3 -> h4 -> h5 -> h6 -> normal\r\n */\r\nfunction toggleHeadingSmaller(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleHeading(cm, \"smaller\");\r\n}\r\n\r\n/**\r\n * Action for toggling heading size: normal -> h6 -> h5 -> h4 -> h3 -> h2 -> h1 -> normal\r\n */\r\nfunction toggleHeadingBigger(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleHeading(cm, \"bigger\");\r\n}\r\n\r\n/**\r\n * Action for toggling heading size 1\r\n */\r\nfunction toggleHeading1(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleHeading(cm, undefined, 1);\r\n}\r\n\r\n/**\r\n * Action for toggling heading size 2\r\n */\r\nfunction toggleHeading2(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleHeading(cm, undefined, 2);\r\n}\r\n\r\n/**\r\n * Action for toggling heading size 3\r\n */\r\nfunction toggleHeading3(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleHeading(cm, undefined, 3);\r\n}\r\n\r\n\r\n/**\r\n * Action for toggling ul.\r\n */\r\nfunction toggleUnorderedList(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleLine(cm, \"unordered-list\");\r\n}\r\n\r\n\r\n/**\r\n * Action for toggling ol.\r\n */\r\nfunction toggleOrderedList(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleLine(cm, \"ordered-list\");\r\n}\r\n\r\n/**\r\n * Action for clean block (remove headline, list, blockquote code, markers)\r\n */\r\nfunction cleanBlock(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_cleanBlock(cm);\r\n}\r\n\r\n/**\r\n * Action for drawing a link.\r\n */\r\nfunction drawLink(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tvar stat = getState(cm);\r\n\tvar options = editor.options;\r\n\tvar url = \"http://\";\r\n\tif(options.promptURLs) {\r\n\t\turl = prompt(options.promptTexts.link);\r\n\t\tif(!url) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t_replaceSelection(cm, stat.link, options.insertTexts.link, url);\r\n}\r\n\r\n/**\r\n * Action for drawing an img.\r\n */\r\nfunction drawImage(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tvar stat = getState(cm);\r\n\tvar options = editor.options;\r\n\tvar url = \"http://\";\r\n\tif(options.promptURLs) {\r\n\t\turl = prompt(options.promptTexts.image);\r\n\t\tif(!url) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t_replaceSelection(cm, stat.image, options.insertTexts.image, url);\r\n}\r\n\r\n/**\r\n * Action for drawing a table.\r\n */\r\nfunction drawTable(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tvar stat = getState(cm);\r\n\tvar options = editor.options;\r\n\t_replaceSelection(cm, stat.table, options.insertTexts.table);\r\n}\r\n\r\n/**\r\n * Action for drawing a horizontal rule.\r\n */\r\nfunction drawHorizontalRule(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tvar stat = getState(cm);\r\n\tvar options = editor.options;\r\n\t_replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);\r\n}\r\n\r\n\r\n/**\r\n * Undo action.\r\n */\r\nfunction undo(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tcm.undo();\r\n\tcm.focus();\r\n}\r\n\r\n\r\n/**\r\n * Redo action.\r\n */\r\nfunction redo(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tcm.redo();\r\n\tcm.focus();\r\n}\r\n\r\n\r\n/**\r\n * Toggle side by side preview\r\n */\r\nfunction toggleSideBySide(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tvar wrapper = cm.getWrapperElement();\r\n\tvar preview = wrapper.nextSibling;\r\n\tvar toolbarButton = editor.toolbarElements[\"side-by-side\"];\r\n\tvar useSideBySideListener = false;\r\n\tif(/editor-preview-active-side/.test(preview.className)) {\r\n\t\tpreview.className = preview.className.replace(\r\n\t\t\t/\\s*editor-preview-active-side\\s*/g, \"\"\r\n\t\t);\r\n\t\ttoolbarButton.className = toolbarButton.className.replace(/\\s*active\\s*/g, \"\");\r\n\t\twrapper.className = wrapper.className.replace(/\\s*CodeMirror-sided\\s*/g, \" \");\r\n\t} else {\r\n\t\t// When the preview button is clicked for the first time,\r\n\t\t// give some time for the transition from editor.css to fire and the view to slide from right to left,\r\n\t\t// instead of just appearing.\r\n\t\tsetTimeout(function() {\r\n\t\t\tif(!cm.getOption(\"fullScreen\"))\r\n\t\t\t\ttoggleFullScreen(editor);\r\n\t\t\tpreview.className += \" editor-preview-active-side\";\r\n\t\t}, 1);\r\n\t\ttoolbarButton.className += \" active\";\r\n\t\twrapper.className += \" CodeMirror-sided\";\r\n\t\tuseSideBySideListener = true;\r\n\t}\r\n\r\n\t// Hide normal preview if active\r\n\tvar previewNormal = wrapper.lastChild;\r\n\tif(/editor-preview-active/.test(previewNormal.className)) {\r\n\t\tpreviewNormal.className = previewNormal.className.replace(\r\n\t\t\t/\\s*editor-preview-active\\s*/g, \"\"\r\n\t\t);\r\n\t\tvar toolbar = editor.toolbarElements.preview;\r\n\t\tvar toolbar_div = wrapper.previousSibling;\r\n\t\ttoolbar.className = toolbar.className.replace(/\\s*active\\s*/g, \"\");\r\n\t\ttoolbar_div.className = toolbar_div.className.replace(/\\s*disabled-for-preview*/g, \"\");\r\n\t}\r\n\r\n\tvar sideBySideRenderingFunction = function() {\r\n\t\tpreview.innerHTML = editor.options.previewRender(editor.value(), preview);\r\n\t};\r\n\r\n\tif(!cm.sideBySideRenderingFunction) {\r\n\t\tcm.sideBySideRenderingFunction = sideBySideRenderingFunction;\r\n\t}\r\n\r\n\tif(useSideBySideListener) {\r\n\t\tpreview.innerHTML = editor.options.previewRender(editor.value(), preview);\r\n\t\tcm.on(\"update\", cm.sideBySideRenderingFunction);\r\n\t} else {\r\n\t\tcm.off(\"update\", cm.sideBySideRenderingFunction);\r\n\t}\r\n\r\n\t// Refresh to fix selection being off (#309)\r\n\tcm.refresh();\r\n}\r\n\r\n\r\n/**\r\n * Preview action.\r\n */\r\nfunction togglePreview(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tvar wrapper = cm.getWrapperElement();\r\n\tvar toolbar_div = wrapper.previousSibling;\r\n\tvar toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;\r\n\tvar preview = wrapper.lastChild;\r\n\tif(!preview || !/editor-preview/.test(preview.className)) {\r\n\t\tpreview = document.createElement(\"div\");\r\n\t\tpreview.className = \"editor-preview\";\r\n\t\twrapper.appendChild(preview);\r\n\t}\r\n\tif(/editor-preview-active/.test(preview.className)) {\r\n\t\tpreview.className = preview.className.replace(\r\n\t\t\t/\\s*editor-preview-active\\s*/g, \"\"\r\n\t\t);\r\n\t\tif(toolbar) {\r\n\t\t\ttoolbar.className = toolbar.className.replace(/\\s*active\\s*/g, \"\");\r\n\t\t\ttoolbar_div.className = toolbar_div.className.replace(/\\s*disabled-for-preview*/g, \"\");\r\n\t\t}\r\n\t} else {\r\n\t\t// When the preview button is clicked for the first time,\r\n\t\t// give some time for the transition from editor.css to fire and the view to slide from right to left,\r\n\t\t// instead of just appearing.\r\n\t\tsetTimeout(function() {\r\n\t\t\tpreview.className += \" editor-preview-active\";\r\n\t\t}, 1);\r\n\t\tif(toolbar) {\r\n\t\t\ttoolbar.className += \" active\";\r\n\t\t\ttoolbar_div.className += \" disabled-for-preview\";\r\n\t\t}\r\n\t}\r\n\tpreview.innerHTML = editor.options.previewRender(editor.value(), preview);\r\n\r\n\t// Turn off side by side if needed\r\n\tvar sidebyside = cm.getWrapperElement().nextSibling;\r\n\tif(/editor-preview-active-side/.test(sidebyside.className))\r\n\t\ttoggleSideBySide(editor);\r\n}\r\n\r\nfunction _replaceSelection(cm, active, startEnd, url) {\r\n\tif(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))\r\n\t\treturn;\r\n\r\n\tvar text;\r\n\tvar start = startEnd[0];\r\n\tvar end = startEnd[1];\r\n\tvar startPoint = cm.getCursor(\"start\");\r\n\tvar endPoint = cm.getCursor(\"end\");\r\n\tif(url) {\r\n\t\tend = end.replace(\"#url#\", url);\r\n\t}\r\n\tif(active) {\r\n\t\ttext = cm.getLine(startPoint.line);\r\n\t\tstart = text.slice(0, startPoint.ch);\r\n\t\tend = text.slice(startPoint.ch);\r\n\t\tcm.replaceRange(start + end, {\r\n\t\t\tline: startPoint.line,\r\n\t\t\tch: 0\r\n\t\t});\r\n\t} else {\r\n\t\ttext = cm.getSelection();\r\n\t\tcm.replaceSelection(start + text + end);\r\n\r\n\t\tstartPoint.ch += start.length;\r\n\t\tif(startPoint !== endPoint) {\r\n\t\t\tendPoint.ch += start.length;\r\n\t\t}\r\n\t}\r\n\tcm.setSelection(startPoint, endPoint);\r\n\tcm.focus();\r\n}\r\n\r\n\r\nfunction _toggleHeading(cm, direction, size) {\r\n\tif(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))\r\n\t\treturn;\r\n\r\n\tvar startPoint = cm.getCursor(\"start\");\r\n\tvar endPoint = cm.getCursor(\"end\");\r\n\tfor(var i = startPoint.line; i <= endPoint.line; i++) {\r\n\t\t(function(i) {\r\n\t\t\tvar text = cm.getLine(i);\r\n\t\t\tvar currHeadingLevel = text.search(/[^#]/);\r\n\r\n\t\t\tif(direction !== undefined) {\r\n\t\t\t\tif(currHeadingLevel <= 0) {\r\n\t\t\t\t\tif(direction == \"bigger\") {\r\n\t\t\t\t\t\ttext = \"###### \" + text;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttext = \"# \" + text;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(currHeadingLevel == 6 && direction == \"smaller\") {\r\n\t\t\t\t\ttext = text.substr(7);\r\n\t\t\t\t} else if(currHeadingLevel == 1 && direction == \"bigger\") {\r\n\t\t\t\t\ttext = text.substr(2);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif(direction == \"bigger\") {\r\n\t\t\t\t\t\ttext = text.substr(1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttext = \"#\" + text;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif(size == 1) {\r\n\t\t\t\t\tif(currHeadingLevel <= 0) {\r\n\t\t\t\t\t\ttext = \"# \" + text;\r\n\t\t\t\t\t} else if(currHeadingLevel == size) {\r\n\t\t\t\t\t\ttext = text.substr(currHeadingLevel + 1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttext = \"# \" + text.substr(currHeadingLevel + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(size == 2) {\r\n\t\t\t\t\tif(currHeadingLevel <= 0) {\r\n\t\t\t\t\t\ttext = \"## \" + text;\r\n\t\t\t\t\t} else if(currHeadingLevel == size) {\r\n\t\t\t\t\t\ttext = text.substr(currHeadingLevel + 1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttext = \"## \" + text.substr(currHeadingLevel + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif(currHeadingLevel <= 0) {\r\n\t\t\t\t\t\ttext = \"### \" + text;\r\n\t\t\t\t\t} else if(currHeadingLevel == size) {\r\n\t\t\t\t\t\ttext = text.substr(currHeadingLevel + 1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttext = \"### \" + text.substr(currHeadingLevel + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tcm.replaceRange(text, {\r\n\t\t\t\tline: i,\r\n\t\t\t\tch: 0\r\n\t\t\t}, {\r\n\t\t\t\tline: i,\r\n\t\t\t\tch: 99999999999999\r\n\t\t\t});\r\n\t\t})(i);\r\n\t}\r\n\tcm.focus();\r\n}\r\n\r\n\r\nfunction _toggleLine(cm, name) {\r\n\tif(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))\r\n\t\treturn;\r\n\r\n\tvar stat = getState(cm);\r\n\tvar startPoint = cm.getCursor(\"start\");\r\n\tvar endPoint = cm.getCursor(\"end\");\r\n\tvar repl = {\r\n\t\t\"quote\": /^(\\s*)\\>\\s+/,\r\n\t\t\"unordered-list\": /^(\\s*)(\\*|\\-|\\+)\\s+/,\r\n\t\t\"ordered-list\": /^(\\s*)\\d+\\.\\s+/\r\n\t};\r\n\tvar map = {\r\n\t\t\"quote\": \"> \",\r\n\t\t\"unordered-list\": \"* \",\r\n\t\t\"ordered-list\": \"1. \"\r\n\t};\r\n\tfor(var i = startPoint.line; i <= endPoint.line; i++) {\r\n\t\t(function(i) {\r\n\t\t\tvar text = cm.getLine(i);\r\n\t\t\tif(stat[name]) {\r\n\t\t\t\ttext = text.replace(repl[name], \"$1\");\r\n\t\t\t} else {\r\n\t\t\t\ttext = map[name] + text;\r\n\t\t\t}\r\n\t\t\tcm.replaceRange(text, {\r\n\t\t\t\tline: i,\r\n\t\t\t\tch: 0\r\n\t\t\t}, {\r\n\t\t\t\tline: i,\r\n\t\t\t\tch: 99999999999999\r\n\t\t\t});\r\n\t\t})(i);\r\n\t}\r\n\tcm.focus();\r\n}\r\n\r\nfunction _toggleBlock(editor, type, start_chars, end_chars) {\r\n\tif(/editor-preview-active/.test(editor.codemirror.getWrapperElement().lastChild.className))\r\n\t\treturn;\r\n\r\n\tend_chars = (typeof end_chars === \"undefined\") ? start_chars : end_chars;\r\n\tvar cm = editor.codemirror;\r\n\tvar stat = getState(cm);\r\n\r\n\tvar text;\r\n\tvar start = start_chars;\r\n\tvar end = end_chars;\r\n\r\n\tvar startPoint = cm.getCursor(\"start\");\r\n\tvar endPoint = cm.getCursor(\"end\");\r\n\r\n\tif(stat[type]) {\r\n\t\ttext = cm.getLine(startPoint.line);\r\n\t\tstart = text.slice(0, startPoint.ch);\r\n\t\tend = text.slice(startPoint.ch);\r\n\t\tif(type == \"bold\") {\r\n\t\t\tstart = start.replace(/(\\*\\*|__)(?![\\s\\S]*(\\*\\*|__))/, \"\");\r\n\t\t\tend = end.replace(/(\\*\\*|__)/, \"\");\r\n\t\t} else if(type == \"italic\") {\r\n\t\t\tstart = start.replace(/(\\*|_)(?![\\s\\S]*(\\*|_))/, \"\");\r\n\t\t\tend = end.replace(/(\\*|_)/, \"\");\r\n\t\t} else if(type == \"strikethrough\") {\r\n\t\t\tstart = start.replace(/(\\*\\*|~~)(?![\\s\\S]*(\\*\\*|~~))/, \"\");\r\n\t\t\tend = end.replace(/(\\*\\*|~~)/, \"\");\r\n\t\t}\r\n\t\tcm.replaceRange(start + end, {\r\n\t\t\tline: startPoint.line,\r\n\t\t\tch: 0\r\n\t\t}, {\r\n\t\t\tline: startPoint.line,\r\n\t\t\tch: 99999999999999\r\n\t\t});\r\n\r\n\t\tif(type == \"bold\" || type == \"strikethrough\") {\r\n\t\t\tstartPoint.ch -= 2;\r\n\t\t\tif(startPoint !== endPoint) {\r\n\t\t\t\tendPoint.ch -= 2;\r\n\t\t\t}\r\n\t\t} else if(type == \"italic\") {\r\n\t\t\tstartPoint.ch -= 1;\r\n\t\t\tif(startPoint !== endPoint) {\r\n\t\t\t\tendPoint.ch -= 1;\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\ttext = cm.getSelection();\r\n\t\tif(type == \"bold\") {\r\n\t\t\ttext = text.split(\"**\").join(\"\");\r\n\t\t\ttext = text.split(\"__\").join(\"\");\r\n\t\t} else if(type == \"italic\") {\r\n\t\t\ttext = text.split(\"*\").join(\"\");\r\n\t\t\ttext = text.split(\"_\").join(\"\");\r\n\t\t} else if(type == \"strikethrough\") {\r\n\t\t\ttext = text.split(\"~~\").join(\"\");\r\n\t\t}\r\n\t\tcm.replaceSelection(start + text + end);\r\n\r\n\t\tstartPoint.ch += start_chars.length;\r\n\t\tendPoint.ch = startPoint.ch + text.length;\r\n\t}\r\n\r\n\tcm.setSelection(startPoint, endPoint);\r\n\tcm.focus();\r\n}\r\n\r\nfunction _cleanBlock(cm) {\r\n\tif(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))\r\n\t\treturn;\r\n\r\n\tvar startPoint = cm.getCursor(\"start\");\r\n\tvar endPoint = cm.getCursor(\"end\");\r\n\tvar text;\r\n\r\n\tfor(var line = startPoint.line; line <= endPoint.line; line++) {\r\n\t\ttext = cm.getLine(line);\r\n\t\ttext = text.replace(/^[ ]*([# ]+|\\*|\\-|[> ]+|[0-9]+(.|\\)))[ ]*/, \"\");\r\n\r\n\t\tcm.replaceRange(text, {\r\n\t\t\tline: line,\r\n\t\t\tch: 0\r\n\t\t}, {\r\n\t\t\tline: line,\r\n\t\t\tch: 99999999999999\r\n\t\t});\r\n\t}\r\n}\r\n\r\n// Merge the properties of one object into another.\r\nfunction _mergeProperties(target, source) {\r\n\tfor(var property in source) {\r\n\t\tif(source.hasOwnProperty(property)) {\r\n\t\t\tif(source[property] instanceof Array) {\r\n\t\t\t\ttarget[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);\r\n\t\t\t} else if(\r\n\t\t\t\tsource[property] !== null &&\r\n\t\t\t\ttypeof source[property] === \"object\" &&\r\n\t\t\t\tsource[property].constructor === Object\r\n\t\t\t) {\r\n\t\t\t\ttarget[property] = _mergeProperties(target[property] || {}, source[property]);\r\n\t\t\t} else {\r\n\t\t\t\ttarget[property] = source[property];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn target;\r\n}\r\n\r\n// Merge an arbitrary number of objects into one.\r\nfunction extend(target) {\r\n\tfor(var i = 1; i < arguments.length; i++) {\r\n\t\ttarget = _mergeProperties(target, arguments[i]);\r\n\t}\r\n\r\n\treturn target;\r\n}\r\n\r\n/* The right word count in respect for CJK. */\r\nfunction wordCount(data) {\r\n\tvar pattern = /[a-zA-Z0-9_\\u0392-\\u03c9\\u0410-\\u04F9]+|[\\u4E00-\\u9FFF\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af]+/g;\r\n\tvar m = data.match(pattern);\r\n\tvar count = 0;\r\n\tif(m === null) return count;\r\n\tfor(var i = 0; i < m.length; i++) {\r\n\t\tif(m[i].charCodeAt(0) >= 0x4E00) {\r\n\t\t\tcount += m[i].length;\r\n\t\t} else {\r\n\t\t\tcount += 1;\r\n\t\t}\r\n\t}\r\n\treturn count;\r\n}\r\n\r\nvar toolbarBuiltInButtons = {\r\n\t\"bold\": {\r\n\t\tname: \"bold\",\r\n\t\taction: toggleBold,\r\n\t\tclassName: \"fa fa-bold\",\r\n\t\ttitle: \"Bold\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"italic\": {\r\n\t\tname: \"italic\",\r\n\t\taction: toggleItalic,\r\n\t\tclassName: \"fa fa-italic\",\r\n\t\ttitle: \"Italic\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"strikethrough\": {\r\n\t\tname: \"strikethrough\",\r\n\t\taction: toggleStrikethrough,\r\n\t\tclassName: \"fa fa-strikethrough\",\r\n\t\ttitle: \"Strikethrough\"\r\n\t},\r\n\t\"heading\": {\r\n\t\tname: \"heading\",\r\n\t\taction: toggleHeadingSmaller,\r\n\t\tclassName: \"fa fa-header\",\r\n\t\ttitle: \"Heading\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"heading-smaller\": {\r\n\t\tname: \"heading-smaller\",\r\n\t\taction: toggleHeadingSmaller,\r\n\t\tclassName: \"fa fa-header fa-header-x fa-header-smaller\",\r\n\t\ttitle: \"Smaller Heading\"\r\n\t},\r\n\t\"heading-bigger\": {\r\n\t\tname: \"heading-bigger\",\r\n\t\taction: toggleHeadingBigger,\r\n\t\tclassName: \"fa fa-header fa-header-x fa-header-bigger\",\r\n\t\ttitle: \"Bigger Heading\"\r\n\t},\r\n\t\"heading-1\": {\r\n\t\tname: \"heading-1\",\r\n\t\taction: toggleHeading1,\r\n\t\tclassName: \"fa fa-header fa-header-x fa-header-1\",\r\n\t\ttitle: \"Big Heading\"\r\n\t},\r\n\t\"heading-2\": {\r\n\t\tname: \"heading-2\",\r\n\t\taction: toggleHeading2,\r\n\t\tclassName: \"fa fa-header fa-header-x fa-header-2\",\r\n\t\ttitle: \"Medium Heading\"\r\n\t},\r\n\t\"heading-3\": {\r\n\t\tname: \"heading-3\",\r\n\t\taction: toggleHeading3,\r\n\t\tclassName: \"fa fa-header fa-header-x fa-header-3\",\r\n\t\ttitle: \"Small Heading\"\r\n\t},\r\n\t\"separator-1\": {\r\n\t\tname: \"separator-1\"\r\n\t},\r\n\t\"code\": {\r\n\t\tname: \"code\",\r\n\t\taction: toggleCodeBlock,\r\n\t\tclassName: \"fa fa-code\",\r\n\t\ttitle: \"Code\"\r\n\t},\r\n\t\"quote\": {\r\n\t\tname: \"quote\",\r\n\t\taction: toggleBlockquote,\r\n\t\tclassName: \"fa fa-quote-left\",\r\n\t\ttitle: \"Quote\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"unordered-list\": {\r\n\t\tname: \"unordered-list\",\r\n\t\taction: toggleUnorderedList,\r\n\t\tclassName: \"fa fa-list-ul\",\r\n\t\ttitle: \"Generic List\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"ordered-list\": {\r\n\t\tname: \"ordered-list\",\r\n\t\taction: toggleOrderedList,\r\n\t\tclassName: \"fa fa-list-ol\",\r\n\t\ttitle: \"Numbered List\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"clean-block\": {\r\n\t\tname: \"clean-block\",\r\n\t\taction: cleanBlock,\r\n\t\tclassName: \"fa fa-eraser fa-clean-block\",\r\n\t\ttitle: \"Clean block\"\r\n\t},\r\n\t\"separator-2\": {\r\n\t\tname: \"separator-2\"\r\n\t},\r\n\t\"link\": {\r\n\t\tname: \"link\",\r\n\t\taction: drawLink,\r\n\t\tclassName: \"fa fa-link\",\r\n\t\ttitle: \"Create Link\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"image\": {\r\n\t\tname: \"image\",\r\n\t\taction: drawImage,\r\n\t\tclassName: \"fa fa-picture-o\",\r\n\t\ttitle: \"Insert Image\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"table\": {\r\n\t\tname: \"table\",\r\n\t\taction: drawTable,\r\n\t\tclassName: \"fa fa-table\",\r\n\t\ttitle: \"Insert Table\"\r\n\t},\r\n\t\"horizontal-rule\": {\r\n\t\tname: \"horizontal-rule\",\r\n\t\taction: drawHorizontalRule,\r\n\t\tclassName: \"fa fa-minus\",\r\n\t\ttitle: \"Insert Horizontal Line\"\r\n\t},\r\n\t\"separator-3\": {\r\n\t\tname: \"separator-3\"\r\n\t},\r\n\t\"preview\": {\r\n\t\tname: \"preview\",\r\n\t\taction: togglePreview,\r\n\t\tclassName: \"fa fa-eye no-disable\",\r\n\t\ttitle: \"Toggle Preview\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"side-by-side\": {\r\n\t\tname: \"side-by-side\",\r\n\t\taction: toggleSideBySide,\r\n\t\tclassName: \"fa fa-columns no-disable no-mobile\",\r\n\t\ttitle: \"Toggle Side by Side\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"fullscreen\": {\r\n\t\tname: \"fullscreen\",\r\n\t\taction: toggleFullScreen,\r\n\t\tclassName: \"fa fa-arrows-alt no-disable no-mobile\",\r\n\t\ttitle: \"Toggle Fullscreen\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"separator-4\": {\r\n\t\tname: \"separator-4\"\r\n\t},\r\n\t\"guide\": {\r\n\t\tname: \"guide\",\r\n\t\taction: \"https://simplemde.com/markdown-guide\",\r\n\t\tclassName: \"fa fa-question-circle\",\r\n\t\ttitle: \"Markdown Guide\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"separator-5\": {\r\n\t\tname: \"separator-5\"\r\n\t},\r\n\t\"undo\": {\r\n\t\tname: \"undo\",\r\n\t\taction: undo,\r\n\t\tclassName: \"fa fa-undo no-disable\",\r\n\t\ttitle: \"Undo\"\r\n\t},\r\n\t\"redo\": {\r\n\t\tname: \"redo\",\r\n\t\taction: redo,\r\n\t\tclassName: \"fa fa-repeat no-disable\",\r\n\t\ttitle: \"Redo\"\r\n\t}\r\n};\r\n\r\nvar insertTexts = {\r\n\tlink: [\"[\", \"](#url#)\"],\r\n\timage: [\"![](\", \"#url#)\"],\r\n\ttable: [\"\", \"\\n\\n| Column 1 | Column 2 | Column 3 |\\n| -------- | -------- | -------- |\\n| Text     | Text     | Text     |\\n\\n\"],\r\n\thorizontalRule: [\"\", \"\\n\\n-----\\n\\n\"]\r\n};\r\n\r\nvar promptTexts = {\r\n\tlink: \"URL for the link:\",\r\n\timage: \"URL of the image:\"\r\n};\r\n\r\nvar blockStyles = {\r\n\t\"bold\": \"**\",\r\n\t\"code\": \"```\",\r\n\t\"italic\": \"*\"\r\n};\r\n\r\n/**\r\n * Interface of SimpleMDE.\r\n */\r\nfunction SimpleMDE(options) {\r\n\t// Handle options parameter\r\n\toptions = options || {};\r\n\r\n\r\n\t// Used later to refer to it\"s parent\r\n\toptions.parent = this;\r\n\r\n\r\n\t// Check if Font Awesome needs to be auto downloaded\r\n\tvar autoDownloadFA = true;\r\n\r\n\tif(options.autoDownloadFontAwesome === false) {\r\n\t\tautoDownloadFA = false;\r\n\t}\r\n\r\n\tif(options.autoDownloadFontAwesome !== true) {\r\n\t\tvar styleSheets = document.styleSheets;\r\n\t\tfor(var i = 0; i < styleSheets.length; i++) {\r\n\t\t\tif(!styleSheets[i].href)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tif(styleSheets[i].href.indexOf(\"//maxcdn.bootstrapcdn.com/font-awesome/\") > -1) {\r\n\t\t\t\tautoDownloadFA = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif(autoDownloadFA) {\r\n\t\tvar link = document.createElement(\"link\");\r\n\t\tlink.rel = \"stylesheet\";\r\n\t\tlink.href = \"https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css\";\r\n\t\tdocument.getElementsByTagName(\"head\")[0].appendChild(link);\r\n\t}\r\n\r\n\r\n\t// Find the textarea to use\r\n\tif(options.element) {\r\n\t\tthis.element = options.element;\r\n\t} else if(options.element === null) {\r\n\t\t// This means that the element option was specified, but no element was found\r\n\t\tconsole.log(\"SimpleMDE: Error. No element was found.\");\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\t// Handle toolbar\r\n\tif(options.toolbar === undefined) {\r\n\t\t// Initialize\r\n\t\toptions.toolbar = [];\r\n\r\n\r\n\t\t// Loop over the built in buttons, to get the preferred order\r\n\t\tfor(var key in toolbarBuiltInButtons) {\r\n\t\t\tif(toolbarBuiltInButtons.hasOwnProperty(key)) {\r\n\t\t\t\tif(key.indexOf(\"separator-\") != -1) {\r\n\t\t\t\t\toptions.toolbar.push(\"|\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(toolbarBuiltInButtons[key].default === true || (options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1)) {\r\n\t\t\t\t\toptions.toolbar.push(key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Handle status bar\r\n\tif(!options.hasOwnProperty(\"status\")) {\r\n\t\toptions.status = [\"autosave\", \"lines\", \"words\", \"cursor\"];\r\n\t}\r\n\r\n\r\n\t// Add default preview rendering function\r\n\tif(!options.previewRender) {\r\n\t\toptions.previewRender = function(plainText) {\r\n\t\t\t// Note: \"this\" refers to the options object\r\n\t\t\treturn this.parent.markdown(plainText);\r\n\t\t};\r\n\t}\r\n\r\n\r\n\t// Set default options for parsing config\r\n\toptions.parsingConfig = extend({\r\n\t\thighlightFormatting: true // needed for toggleCodeBlock to detect types of code\r\n\t}, options.parsingConfig || {});\r\n\r\n\r\n\t// Merging the insertTexts, with the given options\r\n\toptions.insertTexts = extend({}, insertTexts, options.insertTexts || {});\r\n\r\n\r\n\t// Merging the promptTexts, with the given options\r\n\toptions.promptTexts = promptTexts;\r\n\r\n\r\n\t// Merging the blockStyles, with the given options\r\n\toptions.blockStyles = extend({}, blockStyles, options.blockStyles || {});\r\n\r\n\r\n\t// Merging the shortcuts, with the given options\r\n\toptions.shortcuts = extend({}, shortcuts, options.shortcuts || {});\r\n\r\n\r\n\t// Change unique_id to uniqueId for backwards compatibility\r\n\tif(options.autosave != undefined && options.autosave.unique_id != undefined && options.autosave.unique_id != \"\")\r\n\t\toptions.autosave.uniqueId = options.autosave.unique_id;\r\n\r\n\r\n\t// Update this options\r\n\tthis.options = options;\r\n\r\n\r\n\t// Auto render\r\n\tthis.render();\r\n\r\n\r\n\t// The codemirror component is only available after rendering\r\n\t// so, the setter for the initialValue can only run after\r\n\t// the element has been rendered\r\n\tif(options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {\r\n\t\tthis.value(options.initialValue);\r\n\t}\r\n}\r\n\r\n/**\r\n * Default markdown render.\r\n */\r\nSimpleMDE.prototype.markdown = function(text) {\r\n\tif(marked) {\r\n\t\t// Initialize\r\n\t\tvar markedOptions = {};\r\n\r\n\r\n\t\t// Update options\r\n\t\tif(this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {\r\n\t\t\tmarkedOptions.breaks = false;\r\n\t\t} else {\r\n\t\t\tmarkedOptions.breaks = true;\r\n\t\t}\r\n\r\n\t\tif(this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true && window.hljs) {\r\n\t\t\tmarkedOptions.highlight = function(code) {\r\n\t\t\t\treturn window.hljs.highlightAuto(code).value;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\r\n\t\t// Set options\r\n\t\tmarked.setOptions(markedOptions);\r\n\r\n\r\n\t\t// Return\r\n\t\treturn marked(text);\r\n\t}\r\n};\r\n\r\n/**\r\n * Render editor to the given element.\r\n */\r\nSimpleMDE.prototype.render = function(el) {\r\n\tif(!el) {\r\n\t\tel = this.element || document.getElementsByTagName(\"textarea\")[0];\r\n\t}\r\n\r\n\tif(this._rendered && this._rendered === el) {\r\n\t\t// Already rendered.\r\n\t\treturn;\r\n\t}\r\n\r\n\tthis.element = el;\r\n\tvar options = this.options;\r\n\r\n\tvar self = this;\r\n\tvar keyMaps = {};\r\n\r\n\tfor(var key in options.shortcuts) {\r\n\t\t// null stands for \"do not bind this command\"\r\n\t\tif(options.shortcuts[key] !== null && bindings[key] !== null) {\r\n\t\t\t(function(key) {\r\n\t\t\t\tkeyMaps[fixShortcut(options.shortcuts[key])] = function() {\r\n\t\t\t\t\tbindings[key](self);\r\n\t\t\t\t};\r\n\t\t\t})(key);\r\n\t\t}\r\n\t}\r\n\r\n\tkeyMaps[\"Enter\"] = \"newlineAndIndentContinueMarkdownList\";\r\n\tkeyMaps[\"Tab\"] = \"tabAndIndentMarkdownList\";\r\n\tkeyMaps[\"Shift-Tab\"] = \"shiftTabAndUnindentMarkdownList\";\r\n\tkeyMaps[\"Esc\"] = function(cm) {\r\n\t\tif(cm.getOption(\"fullScreen\")) toggleFullScreen(self);\r\n\t};\r\n\r\n\tdocument.addEventListener(\"keydown\", function(e) {\r\n\t\te = e || window.event;\r\n\r\n\t\tif(e.keyCode == 27) {\r\n\t\t\tif(self.codemirror.getOption(\"fullScreen\")) toggleFullScreen(self);\r\n\t\t}\r\n\t}, false);\r\n\r\n\tvar mode, backdrop;\r\n\tif(options.spellChecker !== false) {\r\n\t\tmode = \"spell-checker\";\r\n\t\tbackdrop = options.parsingConfig;\r\n\t\tbackdrop.name = \"gfm\";\r\n\t\tbackdrop.gitHubSpice = false;\r\n\r\n\t\tCodeMirrorSpellChecker({\r\n\t\t\tcodeMirrorInstance: CodeMirror\r\n\t\t});\r\n\t} else {\r\n\t\tmode = options.parsingConfig;\r\n\t\tmode.name = \"gfm\";\r\n\t\tmode.gitHubSpice = false;\r\n\t}\r\n\r\n\tthis.codemirror = CodeMirror.fromTextArea(el, {\r\n\t\tmode: mode,\r\n\t\tbackdrop: backdrop,\r\n\t\ttheme: \"paper\",\r\n\t\ttabSize: (options.tabSize != undefined) ? options.tabSize : 2,\r\n\t\tindentUnit: (options.tabSize != undefined) ? options.tabSize : 2,\r\n\t\tindentWithTabs: (options.indentWithTabs === false) ? false : true,\r\n\t\tlineNumbers: false,\r\n\t\tautofocus: (options.autofocus === true) ? true : false,\r\n\t\textraKeys: keyMaps,\r\n\t\tlineWrapping: (options.lineWrapping === false) ? false : true,\r\n\t\tallowDropFileTypes: [\"text/plain\"],\r\n\t\tplaceholder: options.placeholder || el.getAttribute(\"placeholder\") || \"\",\r\n\t\tstyleSelectedText: (options.styleSelectedText != undefined) ? options.styleSelectedText : true\r\n\t});\r\n\r\n\tif(options.forceSync === true) {\r\n\t\tvar cm = this.codemirror;\r\n\t\tcm.on(\"change\", function() {\r\n\t\t\tcm.save();\r\n\t\t});\r\n\t}\r\n\r\n\tthis.gui = {};\r\n\r\n\tif(options.toolbar !== false) {\r\n\t\tthis.gui.toolbar = this.createToolbar();\r\n\t}\r\n\tif(options.status !== false) {\r\n\t\tthis.gui.statusbar = this.createStatusbar();\r\n\t}\r\n\tif(options.autosave != undefined && options.autosave.enabled === true) {\r\n\t\tthis.autosave();\r\n\t}\r\n\r\n\tthis.gui.sideBySide = this.createSideBySide();\r\n\r\n\tthis._rendered = this.element;\r\n\r\n\r\n\t// Fixes CodeMirror bug (#344)\r\n\tvar temp_cm = this.codemirror;\r\n\tsetTimeout(function() {\r\n\t\ttemp_cm.refresh();\r\n\t}.bind(temp_cm), 0);\r\n};\r\n\r\n// Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem throw QuotaExceededError. We're going to detect this and set a variable accordingly.\r\nfunction isLocalStorageAvailable() {\r\n\tif(typeof localStorage === \"object\") {\r\n\t\ttry {\r\n\t\t\tlocalStorage.setItem(\"smde_localStorage\", 1);\r\n\t\t\tlocalStorage.removeItem(\"smde_localStorage\");\r\n\t\t} catch(e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t} else {\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nSimpleMDE.prototype.autosave = function() {\r\n\tif(isLocalStorageAvailable()) {\r\n\t\tvar simplemde = this;\r\n\r\n\t\tif(this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == \"\") {\r\n\t\t\tconsole.log(\"SimpleMDE: You must set a uniqueId to use the autosave feature\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif(simplemde.element.form != null && simplemde.element.form != undefined) {\r\n\t\t\tsimplemde.element.form.addEventListener(\"submit\", function() {\r\n\t\t\t\tlocalStorage.removeItem(\"smde_\" + simplemde.options.autosave.uniqueId);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif(this.options.autosave.loaded !== true) {\r\n\t\t\tif(typeof localStorage.getItem(\"smde_\" + this.options.autosave.uniqueId) == \"string\" && localStorage.getItem(\"smde_\" + this.options.autosave.uniqueId) != \"\") {\r\n\t\t\t\tthis.codemirror.setValue(localStorage.getItem(\"smde_\" + this.options.autosave.uniqueId));\r\n\t\t\t\tthis.options.autosave.foundSavedValue = true;\r\n\t\t\t}\r\n\r\n\t\t\tthis.options.autosave.loaded = true;\r\n\t\t}\r\n\r\n\t\tlocalStorage.setItem(\"smde_\" + this.options.autosave.uniqueId, simplemde.value());\r\n\r\n\t\tvar el = document.getElementById(\"autosaved\");\r\n\t\tif(el != null && el != undefined && el != \"\") {\r\n\t\t\tvar d = new Date();\r\n\t\t\tvar hh = d.getHours();\r\n\t\t\tvar m = d.getMinutes();\r\n\t\t\tvar dd = \"am\";\r\n\t\t\tvar h = hh;\r\n\t\t\tif(h >= 12) {\r\n\t\t\t\th = hh - 12;\r\n\t\t\t\tdd = \"pm\";\r\n\t\t\t}\r\n\t\t\tif(h == 0) {\r\n\t\t\t\th = 12;\r\n\t\t\t}\r\n\t\t\tm = m < 10 ? \"0\" + m : m;\r\n\r\n\t\t\tel.innerHTML = \"Autosaved: \" + h + \":\" + m + \" \" + dd;\r\n\t\t}\r\n\r\n\t\tthis.autosaveTimeoutId = setTimeout(function() {\r\n\t\t\tsimplemde.autosave();\r\n\t\t}, this.options.autosave.delay || 10000);\r\n\t} else {\r\n\t\tconsole.log(\"SimpleMDE: localStorage not available, cannot autosave\");\r\n\t}\r\n};\r\n\r\nSimpleMDE.prototype.clearAutosavedValue = function() {\r\n\tif(isLocalStorageAvailable()) {\r\n\t\tif(this.options.autosave == undefined || this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == \"\") {\r\n\t\t\tconsole.log(\"SimpleMDE: You must set a uniqueId to clear the autosave value\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlocalStorage.removeItem(\"smde_\" + this.options.autosave.uniqueId);\r\n\t} else {\r\n\t\tconsole.log(\"SimpleMDE: localStorage not available, cannot autosave\");\r\n\t}\r\n};\r\n\r\nSimpleMDE.prototype.createSideBySide = function() {\r\n\tvar cm = this.codemirror;\r\n\tvar wrapper = cm.getWrapperElement();\r\n\tvar preview = wrapper.nextSibling;\r\n\r\n\tif(!preview || !/editor-preview-side/.test(preview.className)) {\r\n\t\tpreview = document.createElement(\"div\");\r\n\t\tpreview.className = \"editor-preview-side\";\r\n\t\twrapper.parentNode.insertBefore(preview, wrapper.nextSibling);\r\n\t}\r\n\r\n\t// Syncs scroll  editor -> preview\r\n\tvar cScroll = false;\r\n\tvar pScroll = false;\r\n\tcm.on(\"scroll\", function(v) {\r\n\t\tif(cScroll) {\r\n\t\t\tcScroll = false;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tpScroll = true;\r\n\t\tvar height = v.getScrollInfo().height - v.getScrollInfo().clientHeight;\r\n\t\tvar ratio = parseFloat(v.getScrollInfo().top) / height;\r\n\t\tvar move = (preview.scrollHeight - preview.clientHeight) * ratio;\r\n\t\tpreview.scrollTop = move;\r\n\t});\r\n\r\n\t// Syncs scroll  preview -> editor\r\n\tpreview.onscroll = function() {\r\n\t\tif(pScroll) {\r\n\t\t\tpScroll = false;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcScroll = true;\r\n\t\tvar height = preview.scrollHeight - preview.clientHeight;\r\n\t\tvar ratio = parseFloat(preview.scrollTop) / height;\r\n\t\tvar move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;\r\n\t\tcm.scrollTo(0, move);\r\n\t};\r\n\treturn preview;\r\n};\r\n\r\nSimpleMDE.prototype.createToolbar = function(items) {\r\n\titems = items || this.options.toolbar;\r\n\r\n\tif(!items || items.length === 0) {\r\n\t\treturn;\r\n\t}\r\n\tvar i;\r\n\tfor(i = 0; i < items.length; i++) {\r\n\t\tif(toolbarBuiltInButtons[items[i]] != undefined) {\r\n\t\t\titems[i] = toolbarBuiltInButtons[items[i]];\r\n\t\t}\r\n\t}\r\n\r\n\tvar bar = document.createElement(\"div\");\r\n\tbar.className = \"editor-toolbar\";\r\n\r\n\tvar self = this;\r\n\r\n\tvar toolbarData = {};\r\n\tself.toolbar = items;\r\n\r\n\tfor(i = 0; i < items.length; i++) {\r\n\t\tif(items[i].name == \"guide\" && self.options.toolbarGuideIcon === false)\r\n\t\t\tcontinue;\r\n\r\n\t\tif(self.options.hideIcons && self.options.hideIcons.indexOf(items[i].name) != -1)\r\n\t\t\tcontinue;\r\n\r\n\t\t// Fullscreen does not work well on mobile devices (even tablets)\r\n\t\t// In the future, hopefully this can be resolved\r\n\t\tif((items[i].name == \"fullscreen\" || items[i].name == \"side-by-side\") && isMobile())\r\n\t\t\tcontinue;\r\n\r\n\r\n\t\t// Don't include trailing separators\r\n\t\tif(items[i] === \"|\") {\r\n\t\t\tvar nonSeparatorIconsFollow = false;\r\n\r\n\t\t\tfor(var x = (i + 1); x < items.length; x++) {\r\n\t\t\t\tif(items[x] !== \"|\" && (!self.options.hideIcons || self.options.hideIcons.indexOf(items[x].name) == -1)) {\r\n\t\t\t\t\tnonSeparatorIconsFollow = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(!nonSeparatorIconsFollow)\r\n\t\t\t\tcontinue;\r\n\t\t}\r\n\r\n\r\n\t\t// Create the icon and append to the toolbar\r\n\t\t(function(item) {\r\n\t\t\tvar el;\r\n\t\t\tif(item === \"|\") {\r\n\t\t\t\tel = createSep();\r\n\t\t\t} else {\r\n\t\t\t\tel = createIcon(item, self.options.toolbarTips, self.options.shortcuts);\r\n\t\t\t}\r\n\r\n\t\t\t// bind events, special for info\r\n\t\t\tif(item.action) {\r\n\t\t\t\tif(typeof item.action === \"function\") {\r\n\t\t\t\t\tel.onclick = function(e) {\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t\titem.action(self);\r\n\t\t\t\t\t};\r\n\t\t\t\t} else if(typeof item.action === \"string\") {\r\n\t\t\t\t\tel.href = item.action;\r\n\t\t\t\t\tel.target = \"_blank\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttoolbarData[item.name || item] = el;\r\n\t\t\tbar.appendChild(el);\r\n\t\t})(items[i]);\r\n\t}\r\n\r\n\tself.toolbarElements = toolbarData;\r\n\r\n\tvar cm = this.codemirror;\r\n\tcm.on(\"cursorActivity\", function() {\r\n\t\tvar stat = getState(cm);\r\n\r\n\t\tfor(var key in toolbarData) {\r\n\t\t\t(function(key) {\r\n\t\t\t\tvar el = toolbarData[key];\r\n\t\t\t\tif(stat[key]) {\r\n\t\t\t\t\tel.className += \" active\";\r\n\t\t\t\t} else if(key != \"fullscreen\" && key != \"side-by-side\") {\r\n\t\t\t\t\tel.className = el.className.replace(/\\s*active\\s*/g, \"\");\r\n\t\t\t\t}\r\n\t\t\t})(key);\r\n\t\t}\r\n\t});\r\n\r\n\tvar cmWrapper = cm.getWrapperElement();\r\n\tcmWrapper.parentNode.insertBefore(bar, cmWrapper);\r\n\treturn bar;\r\n};\r\n\r\nSimpleMDE.prototype.createStatusbar = function(status) {\r\n\t// Initialize\r\n\tstatus = status || this.options.status;\r\n\tvar options = this.options;\r\n\tvar cm = this.codemirror;\r\n\r\n\r\n\t// Make sure the status variable is valid\r\n\tif(!status || status.length === 0)\r\n\t\treturn;\r\n\r\n\r\n\t// Set up the built-in items\r\n\tvar items = [];\r\n\tvar i, onUpdate, defaultValue;\r\n\r\n\tfor(i = 0; i < status.length; i++) {\r\n\t\t// Reset some values\r\n\t\tonUpdate = undefined;\r\n\t\tdefaultValue = undefined;\r\n\r\n\r\n\t\t// Handle if custom or not\r\n\t\tif(typeof status[i] === \"object\") {\r\n\t\t\titems.push({\r\n\t\t\t\tclassName: status[i].className,\r\n\t\t\t\tdefaultValue: status[i].defaultValue,\r\n\t\t\t\tonUpdate: status[i].onUpdate\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tvar name = status[i];\r\n\r\n\t\t\tif(name === \"words\") {\r\n\t\t\t\tdefaultValue = function(el) {\r\n\t\t\t\t\tel.innerHTML = wordCount(cm.getValue());\r\n\t\t\t\t};\r\n\t\t\t\tonUpdate = function(el) {\r\n\t\t\t\t\tel.innerHTML = wordCount(cm.getValue());\r\n\t\t\t\t};\r\n\t\t\t} else if(name === \"lines\") {\r\n\t\t\t\tdefaultValue = function(el) {\r\n\t\t\t\t\tel.innerHTML = cm.lineCount();\r\n\t\t\t\t};\r\n\t\t\t\tonUpdate = function(el) {\r\n\t\t\t\t\tel.innerHTML = cm.lineCount();\r\n\t\t\t\t};\r\n\t\t\t} else if(name === \"cursor\") {\r\n\t\t\t\tdefaultValue = function(el) {\r\n\t\t\t\t\tel.innerHTML = \"0:0\";\r\n\t\t\t\t};\r\n\t\t\t\tonUpdate = function(el) {\r\n\t\t\t\t\tvar pos = cm.getCursor();\r\n\t\t\t\t\tel.innerHTML = pos.line + \":\" + pos.ch;\r\n\t\t\t\t};\r\n\t\t\t} else if(name === \"autosave\") {\r\n\t\t\t\tdefaultValue = function(el) {\r\n\t\t\t\t\tif(options.autosave != undefined && options.autosave.enabled === true) {\r\n\t\t\t\t\t\tel.setAttribute(\"id\", \"autosaved\");\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\titems.push({\r\n\t\t\t\tclassName: name,\r\n\t\t\t\tdefaultValue: defaultValue,\r\n\t\t\t\tonUpdate: onUpdate\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Create element for the status bar\r\n\tvar bar = document.createElement(\"div\");\r\n\tbar.className = \"editor-statusbar\";\r\n\r\n\r\n\t// Create a new span for each item\r\n\tfor(i = 0; i < items.length; i++) {\r\n\t\t// Store in temporary variable\r\n\t\tvar item = items[i];\r\n\r\n\r\n\t\t// Create span element\r\n\t\tvar el = document.createElement(\"span\");\r\n\t\tel.className = item.className;\r\n\r\n\r\n\t\t// Ensure the defaultValue is a function\r\n\t\tif(typeof item.defaultValue === \"function\") {\r\n\t\t\titem.defaultValue(el);\r\n\t\t}\r\n\r\n\r\n\t\t// Ensure the onUpdate is a function\r\n\t\tif(typeof item.onUpdate === \"function\") {\r\n\t\t\t// Create a closure around the span of the current action, then execute the onUpdate handler\r\n\t\t\tthis.codemirror.on(\"update\", (function(el, item) {\r\n\t\t\t\treturn function() {\r\n\t\t\t\t\titem.onUpdate(el);\r\n\t\t\t\t};\r\n\t\t\t}(el, item)));\r\n\t\t}\r\n\r\n\r\n\t\t// Append the item to the status bar\r\n\t\tbar.appendChild(el);\r\n\t}\r\n\r\n\r\n\t// Insert the status bar into the DOM\r\n\tvar cmWrapper = this.codemirror.getWrapperElement();\r\n\tcmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);\r\n\treturn bar;\r\n};\r\n\r\n/**\r\n * Get or set the text content.\r\n */\r\nSimpleMDE.prototype.value = function(val) {\r\n\tif(val === undefined) {\r\n\t\treturn this.codemirror.getValue();\r\n\t} else {\r\n\t\tthis.codemirror.getDoc().setValue(val);\r\n\t\treturn this;\r\n\t}\r\n};\r\n\r\n\r\n/**\r\n * Bind static methods for exports.\r\n */\r\nSimpleMDE.toggleBold = toggleBold;\r\nSimpleMDE.toggleItalic = toggleItalic;\r\nSimpleMDE.toggleStrikethrough = toggleStrikethrough;\r\nSimpleMDE.toggleBlockquote = toggleBlockquote;\r\nSimpleMDE.toggleHeadingSmaller = toggleHeadingSmaller;\r\nSimpleMDE.toggleHeadingBigger = toggleHeadingBigger;\r\nSimpleMDE.toggleHeading1 = toggleHeading1;\r\nSimpleMDE.toggleHeading2 = toggleHeading2;\r\nSimpleMDE.toggleHeading3 = toggleHeading3;\r\nSimpleMDE.toggleCodeBlock = toggleCodeBlock;\r\nSimpleMDE.toggleUnorderedList = toggleUnorderedList;\r\nSimpleMDE.toggleOrderedList = toggleOrderedList;\r\nSimpleMDE.cleanBlock = cleanBlock;\r\nSimpleMDE.drawLink = drawLink;\r\nSimpleMDE.drawImage = drawImage;\r\nSimpleMDE.drawTable = drawTable;\r\nSimpleMDE.drawHorizontalRule = drawHorizontalRule;\r\nSimpleMDE.undo = undo;\r\nSimpleMDE.redo = redo;\r\nSimpleMDE.togglePreview = togglePreview;\r\nSimpleMDE.toggleSideBySide = toggleSideBySide;\r\nSimpleMDE.toggleFullScreen = toggleFullScreen;\r\n\r\n/**\r\n * Bind instance methods for exports.\r\n */\r\nSimpleMDE.prototype.toggleBold = function() {\r\n\ttoggleBold(this);\r\n};\r\nSimpleMDE.prototype.toggleItalic = function() {\r\n\ttoggleItalic(this);\r\n};\r\nSimpleMDE.prototype.toggleStrikethrough = function() {\r\n\ttoggleStrikethrough(this);\r\n};\r\nSimpleMDE.prototype.toggleBlockquote = function() {\r\n\ttoggleBlockquote(this);\r\n};\r\nSimpleMDE.prototype.toggleHeadingSmaller = function() {\r\n\ttoggleHeadingSmaller(this);\r\n};\r\nSimpleMDE.prototype.toggleHeadingBigger = function() {\r\n\ttoggleHeadingBigger(this);\r\n};\r\nSimpleMDE.prototype.toggleHeading1 = function() {\r\n\ttoggleHeading1(this);\r\n};\r\nSimpleMDE.prototype.toggleHeading2 = function() {\r\n\ttoggleHeading2(this);\r\n};\r\nSimpleMDE.prototype.toggleHeading3 = function() {\r\n\ttoggleHeading3(this);\r\n};\r\nSimpleMDE.prototype.toggleCodeBlock = function() {\r\n\ttoggleCodeBlock(this);\r\n};\r\nSimpleMDE.prototype.toggleUnorderedList = function() {\r\n\ttoggleUnorderedList(this);\r\n};\r\nSimpleMDE.prototype.toggleOrderedList = function() {\r\n\ttoggleOrderedList(this);\r\n};\r\nSimpleMDE.prototype.cleanBlock = function() {\r\n\tcleanBlock(this);\r\n};\r\nSimpleMDE.prototype.drawLink = function() {\r\n\tdrawLink(this);\r\n};\r\nSimpleMDE.prototype.drawImage = function() {\r\n\tdrawImage(this);\r\n};\r\nSimpleMDE.prototype.drawTable = function() {\r\n\tdrawTable(this);\r\n};\r\nSimpleMDE.prototype.drawHorizontalRule = function() {\r\n\tdrawHorizontalRule(this);\r\n};\r\nSimpleMDE.prototype.undo = function() {\r\n\tundo(this);\r\n};\r\nSimpleMDE.prototype.redo = function() {\r\n\tredo(this);\r\n};\r\nSimpleMDE.prototype.togglePreview = function() {\r\n\ttogglePreview(this);\r\n};\r\nSimpleMDE.prototype.toggleSideBySide = function() {\r\n\ttoggleSideBySide(this);\r\n};\r\nSimpleMDE.prototype.toggleFullScreen = function() {\r\n\ttoggleFullScreen(this);\r\n};\r\n\r\nSimpleMDE.prototype.isPreviewActive = function() {\r\n\tvar cm = this.codemirror;\r\n\tvar wrapper = cm.getWrapperElement();\r\n\tvar preview = wrapper.lastChild;\r\n\r\n\treturn /editor-preview-active/.test(preview.className);\r\n};\r\n\r\nSimpleMDE.prototype.isSideBySideActive = function() {\r\n\tvar cm = this.codemirror;\r\n\tvar wrapper = cm.getWrapperElement();\r\n\tvar preview = wrapper.nextSibling;\r\n\r\n\treturn /editor-preview-active-side/.test(preview.className);\r\n};\r\n\r\nSimpleMDE.prototype.isFullscreenActive = function() {\r\n\tvar cm = this.codemirror;\r\n\r\n\treturn cm.getOption(\"fullScreen\");\r\n};\r\n\r\nSimpleMDE.prototype.getState = function() {\r\n\tvar cm = this.codemirror;\r\n\r\n\treturn getState(cm);\r\n};\r\n\r\nSimpleMDE.prototype.toTextArea = function() {\r\n\tvar cm = this.codemirror;\r\n\tvar wrapper = cm.getWrapperElement();\r\n\r\n\tif(wrapper.parentNode) {\r\n\t\tif(this.gui.toolbar) {\r\n\t\t\twrapper.parentNode.removeChild(this.gui.toolbar);\r\n\t\t}\r\n\t\tif(this.gui.statusbar) {\r\n\t\t\twrapper.parentNode.removeChild(this.gui.statusbar);\r\n\t\t}\r\n\t\tif(this.gui.sideBySide) {\r\n\t\t\twrapper.parentNode.removeChild(this.gui.sideBySide);\r\n\t\t}\r\n\t}\r\n\r\n\tcm.toTextArea();\r\n\r\n\tif(this.autosaveTimeoutId) {\r\n\t\tclearTimeout(this.autosaveTimeoutId);\r\n\t\tthis.autosaveTimeoutId = undefined;\r\n\t\tthis.clearAutosavedValue();\r\n\t}\r\n};\r\n\r\nmodule.exports = SimpleMDE;\n\n/***/ }),\n\n/***/ 1284:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(__dirname, Buffer) {/* globals chrome: false */\r\n/* globals __dirname: false */\r\n/* globals require: false */\r\n/* globals Buffer: false */\r\n/* globals module: false */\r\n\r\n/**\r\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style \r\n * dictionaries.\r\n */\r\n\r\nvar Typo;\r\n\r\n(function () {\r\n\"use strict\";\r\n\r\n/**\r\n * Typo constructor.\r\n *\r\n * @param {String} [dictionary] The locale code of the dictionary being used. e.g.,\r\n *                              \"en_US\". This is only used to auto-load dictionaries.\r\n * @param {String} [affData]    The data from the dictionary's .aff file. If omitted\r\n *                              and Typo.js is being used in a Chrome extension, the .aff\r\n *                              file will be loaded automatically from\r\n *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff\r\n *                              In other environments, it will be loaded from\r\n *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff\r\n * @param {String} [wordsData]  The data from the dictionary's .dic file. If omitted\r\n *                              and Typo.js is being used in a Chrome extension, the .dic\r\n *                              file will be loaded automatically from\r\n *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic\r\n *                              In other environments, it will be loaded from\r\n *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic\r\n * @param {Object} [settings]   Constructor settings. Available properties are:\r\n *                              {String} [dictionaryPath]: path to load dictionary from in non-chrome\r\n *                              environment.\r\n *                              {Object} [flags]: flag information.\r\n *                              {Boolean} [asyncLoad]: If true, affData and wordsData will be loaded\r\n *                              asynchronously.\r\n *                              {Function} [loadedCallback]: Called when both affData and wordsData\r\n *                              have been loaded. Only used if asyncLoad is set to true. The parameter\r\n *                              is the instantiated Typo object.\r\n *\r\n * @returns {Typo} A Typo object.\r\n */\r\n\r\nTypo = function (dictionary, affData, wordsData, settings) {\r\n\tsettings = settings || {};\r\n\r\n\tthis.dictionary = null;\r\n\t\r\n\tthis.rules = {};\r\n\tthis.dictionaryTable = {};\r\n\t\r\n\tthis.compoundRules = [];\r\n\tthis.compoundRuleCodes = {};\r\n\t\r\n\tthis.replacementTable = [];\r\n\t\r\n\tthis.flags = settings.flags || {}; \r\n\t\r\n\tthis.memoized = {};\r\n\r\n\tthis.loaded = false;\r\n\t\r\n\tvar self = this;\r\n\t\r\n\tvar path;\r\n\t\r\n\t// Loop-control variables.\r\n\tvar i, j, _len, _jlen;\r\n\t\r\n\tif (dictionary) {\r\n\t\tself.dictionary = dictionary;\r\n\t\t\r\n\t\t// If the data is preloaded, just setup the Typo object.\r\n\t\tif (affData && wordsData) {\r\n\t\t\tsetup();\r\n\t\t}\r\n\t\t// Loading data for Chrome extentions.\r\n\t\telse if (typeof window !== 'undefined' && 'chrome' in window && 'extension' in window.chrome && 'getURL' in window.chrome.extension) {\r\n\t\t\tif (settings.dictionaryPath) {\r\n\t\t\t\tpath = settings.dictionaryPath;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tpath = \"typo/dictionaries\";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!affData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\"), setAffData);\r\n\t\t\tif (!wordsData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\"), setWordsData);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (settings.dictionaryPath) {\r\n\t\t\t\tpath = settings.dictionaryPath;\r\n\t\t\t}\r\n\t\t\telse if (true) {\r\n\t\t\t\tpath = __dirname + '/dictionaries';\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tpath = './dictionaries';\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!affData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\", setAffData);\r\n\t\t\tif (!wordsData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\", setWordsData);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction readDataFile(url, setFunc) {\r\n\t\tvar response = self._readFile(url, null, settings.asyncLoad);\r\n\t\t\r\n\t\tif (settings.asyncLoad) {\r\n\t\t\tresponse.then(function(data) {\r\n\t\t\t\tsetFunc(data);\r\n\t\t\t});\r\n\t\t}\r\n\t\telse {\r\n\t\t\tsetFunc(response);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setAffData(data) {\r\n\t\taffData = data;\r\n\r\n\t\tif (wordsData) {\r\n\t\t\tsetup();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setWordsData(data) {\r\n\t\twordsData = data;\r\n\r\n\t\tif (affData) {\r\n\t\t\tsetup();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setup() {\r\n\t\tself.rules = self._parseAFF(affData);\r\n\t\t\r\n\t\t// Save the rule codes that are used in compound rules.\r\n\t\tself.compoundRuleCodes = {};\r\n\t\t\r\n\t\tfor (i = 0, _len = self.compoundRules.length; i < _len; i++) {\r\n\t\t\tvar rule = self.compoundRules[i];\r\n\t\t\t\r\n\t\t\tfor (j = 0, _jlen = rule.length; j < _jlen; j++) {\r\n\t\t\t\tself.compoundRuleCodes[rule[j]] = [];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\r\n\t\t// will do the work of saving the list of words that are compound-only.\r\n\t\tif (\"ONLYINCOMPOUND\" in self.flags) {\r\n\t\t\tself.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];\r\n\t\t}\r\n\t\t\r\n\t\tself.dictionaryTable = self._parseDIC(wordsData);\r\n\t\t\r\n\t\t// Get rid of any codes from the compound rule codes that are never used \r\n\t\t// (or that were special regex characters).  Not especially necessary... \r\n\t\tfor (i in self.compoundRuleCodes) {\r\n\t\t\tif (self.compoundRuleCodes[i].length === 0) {\r\n\t\t\t\tdelete self.compoundRuleCodes[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Build the full regular expressions for each compound rule.\r\n\t\t// I have a feeling (but no confirmation yet) that this method of \r\n\t\t// testing for compound words is probably slow.\r\n\t\tfor (i = 0, _len = self.compoundRules.length; i < _len; i++) {\r\n\t\t\tvar ruleText = self.compoundRules[i];\r\n\t\t\t\r\n\t\t\tvar expressionText = \"\";\r\n\t\t\t\r\n\t\t\tfor (j = 0, _jlen = ruleText.length; j < _jlen; j++) {\r\n\t\t\t\tvar character = ruleText[j];\r\n\t\t\t\t\r\n\t\t\t\tif (character in self.compoundRuleCodes) {\r\n\t\t\t\t\texpressionText += \"(\" + self.compoundRuleCodes[character].join(\"|\") + \")\";\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\texpressionText += character;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tself.compoundRules[i] = new RegExp(expressionText, \"i\");\r\n\t\t}\r\n\t\t\r\n\t\tself.loaded = true;\r\n\t\t\r\n\t\tif (settings.asyncLoad && settings.loadedCallback) {\r\n\t\t\tsettings.loadedCallback(self);\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn this;\r\n};\r\n\r\nTypo.prototype = {\r\n\t/**\r\n\t * Loads a Typo instance from a hash of all of the Typo properties.\r\n\t *\r\n\t * @param object obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\r\n\t */\r\n\t\r\n\tload : function (obj) {\r\n\t\tfor (var i in obj) {\r\n\t\t\tif (obj.hasOwnProperty(i)) {\r\n\t\t\t\tthis[i] = obj[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn this;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Read the contents of a file.\r\n\t * \r\n\t * @param {String} path The path (relative) to the file.\r\n\t * @param {String} [charset=\"ISO8859-1\"] The expected charset of the file\r\n\t * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\r\n\t *        files are read synchronously.\r\n\t * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is\r\n\t *          always returned.\r\n\t */\r\n\t\r\n\t_readFile : function (path, charset, async) {\r\n\t\tcharset = charset || \"utf8\";\r\n\t\t\r\n\t\tif (typeof XMLHttpRequest !== 'undefined') {\r\n\t\t\tvar promise;\r\n\t\t\tvar req = new XMLHttpRequest();\r\n\t\t\treq.open(\"GET\", path, async);\r\n\t\t\t\r\n\t\t\tif (async) {\r\n\t\t\t\tpromise = new Promise(function(resolve, reject) {\r\n\t\t\t\t\treq.onload = function() {\r\n\t\t\t\t\t\tif (req.status === 200) {\r\n\t\t\t\t\t\t\tresolve(req.responseText);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\treject(req.statusText);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\treq.onerror = function() {\r\n\t\t\t\t\t\treject(req.statusText);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\r\n\t\t\tif (req.overrideMimeType)\r\n\t\t\t\treq.overrideMimeType(\"text/plain; charset=\" + charset);\r\n\t\t\r\n\t\t\treq.send(null);\r\n\t\t\t\r\n\t\t\treturn async ? promise : req.responseText;\r\n\t\t}\r\n\t\telse if (true) {\r\n\t\t\t// Node.js\r\n\t\t\tvar fs = __webpack_require__(1421);\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tif (fs.existsSync(path)) {\r\n\t\t\t\t\tvar stats = fs.statSync(path);\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar fileDescriptor = fs.openSync(path, 'r');\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar buffer = new Buffer(stats.size);\r\n\t\t\t\t\t\r\n\t\t\t\t\tfs.readSync(fileDescriptor, buffer, 0, buffer.length, null);\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn buffer.toString(charset, 0, buffer.length);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconsole.log(\"Path \" + path + \" does not exist.\");\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\tconsole.log(e);\r\n\t\t\t\treturn '';\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t\r\n\t/**\r\n\t * Parse the rules out from a .aff file.\r\n\t *\r\n\t * @param {String} data The contents of the affix file.\r\n\t * @returns object The rules from the file.\r\n\t */\r\n\t\r\n\t_parseAFF : function (data) {\r\n\t\tvar rules = {};\r\n\t\t\r\n\t\tvar line, subline, numEntries, lineParts;\r\n\t\tvar i, j, _len, _jlen;\r\n\t\t\r\n\t\t// Remove comment lines\r\n\t\tdata = this._removeAffixComments(data);\r\n\t\t\r\n\t\tvar lines = data.split(\"\\n\");\r\n\t\t\r\n\t\tfor (i = 0, _len = lines.length; i < _len; i++) {\r\n\t\t\tline = lines[i];\r\n\t\t\t\r\n\t\t\tvar definitionParts = line.split(/\\s+/);\r\n\t\t\t\r\n\t\t\tvar ruleType = definitionParts[0];\r\n\t\t\t\r\n\t\t\tif (ruleType == \"PFX\" || ruleType == \"SFX\") {\r\n\t\t\t\tvar ruleCode = definitionParts[1];\r\n\t\t\t\tvar combineable = definitionParts[2];\r\n\t\t\t\tnumEntries = parseInt(definitionParts[3], 10);\r\n\t\t\t\t\r\n\t\t\t\tvar entries = [];\r\n\t\t\t\t\r\n\t\t\t\tfor (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\r\n\t\t\t\t\tsubline = lines[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\tlineParts = subline.split(/\\s+/);\r\n\t\t\t\t\tvar charactersToRemove = lineParts[2];\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar additionParts = lineParts[3].split(\"/\");\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar charactersToAdd = additionParts[0];\r\n\t\t\t\t\tif (charactersToAdd === \"0\") charactersToAdd = \"\";\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar continuationClasses = this.parseRuleCodes(additionParts[1]);\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar regexToMatch = lineParts[4];\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar entry = {};\r\n\t\t\t\t\tentry.add = charactersToAdd;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (continuationClasses.length > 0) entry.continuationClasses = continuationClasses;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (regexToMatch !== \".\") {\r\n\t\t\t\t\t\tif (ruleType === \"SFX\") {\r\n\t\t\t\t\t\t\tentry.match = new RegExp(regexToMatch + \"$\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tentry.match = new RegExp(\"^\" + regexToMatch);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (charactersToRemove != \"0\") {\r\n\t\t\t\t\t\tif (ruleType === \"SFX\") {\r\n\t\t\t\t\t\t\tentry.remove = new RegExp(charactersToRemove  + \"$\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tentry.remove = charactersToRemove;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tentries.push(entry);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\trules[ruleCode] = { \"type\" : ruleType, \"combineable\" : (combineable == \"Y\"), \"entries\" : entries };\r\n\t\t\t\t\r\n\t\t\t\ti += numEntries;\r\n\t\t\t}\r\n\t\t\telse if (ruleType === \"COMPOUNDRULE\") {\r\n\t\t\t\tnumEntries = parseInt(definitionParts[1], 10);\r\n\t\t\t\t\r\n\t\t\t\tfor (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\r\n\t\t\t\t\tline = lines[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\tlineParts = line.split(/\\s+/);\r\n\t\t\t\t\tthis.compoundRules.push(lineParts[1]);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ti += numEntries;\r\n\t\t\t}\r\n\t\t\telse if (ruleType === \"REP\") {\r\n\t\t\t\tlineParts = line.split(/\\s+/);\r\n\t\t\t\t\r\n\t\t\t\tif (lineParts.length === 3) {\r\n\t\t\t\t\tthis.replacementTable.push([ lineParts[1], lineParts[2] ]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// ONLYINCOMPOUND\r\n\t\t\t\t// COMPOUNDMIN\r\n\t\t\t\t// FLAG\r\n\t\t\t\t// KEEPCASE\r\n\t\t\t\t// NEEDAFFIX\r\n\t\t\t\t\r\n\t\t\t\tthis.flags[ruleType] = definitionParts[1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn rules;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Removes comment lines and then cleans up blank lines and trailing whitespace.\r\n\t *\r\n\t * @param {String} data The data from an affix file.\r\n\t * @return {String} The cleaned-up data.\r\n\t */\r\n\t\r\n\t_removeAffixComments : function (data) {\r\n\t\t// Remove comments\r\n\t\t// This used to remove any string starting with '#' up to the end of the line,\r\n\t\t// but some COMPOUNDRULE definitions include '#' as part of the rule.\r\n\t\t// I haven't seen any affix files that use comments on the same line as real data,\r\n\t\t// so I don't think this will break anything.\r\n\t\tdata = data.replace(/^\\s*#.*$/mg, \"\");\r\n\t\t\r\n\t\t// Trim each line\r\n\t\tdata = data.replace(/^\\s\\s*/m, '').replace(/\\s\\s*$/m, '');\r\n\t\t\r\n\t\t// Remove blank lines.\r\n\t\tdata = data.replace(/\\n{2,}/g, \"\\n\");\r\n\t\t\r\n\t\t// Trim the entire string\r\n\t\tdata = data.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\r\n\t\t\r\n\t\treturn data;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Parses the words out from the .dic file.\r\n\t *\r\n\t * @param {String} data The data from the dictionary file.\r\n\t * @returns object The lookup table containing all of the words and\r\n\t *                 word forms from the dictionary.\r\n\t */\r\n\t\r\n\t_parseDIC : function (data) {\r\n\t\tdata = this._removeDicComments(data);\r\n\t\t\r\n\t\tvar lines = data.split(\"\\n\");\r\n\t\tvar dictionaryTable = {};\r\n\t\t\r\n\t\tfunction addWord(word, rules) {\r\n\t\t\t// Some dictionaries will list the same word multiple times with different rule sets.\r\n\t\t\tif (!dictionaryTable.hasOwnProperty(word)) {\r\n\t\t\t\tdictionaryTable[word] = null;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (rules.length > 0) {\r\n\t\t\t\tif (dictionaryTable[word] === null) {\r\n\t\t\t\t\tdictionaryTable[word] = [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdictionaryTable[word].push(rules);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// The first line is the number of words in the dictionary.\r\n\t\tfor (var i = 1, _len = lines.length; i < _len; i++) {\r\n\t\t\tvar line = lines[i];\r\n\t\t\t\r\n\t\t\tvar parts = line.split(\"/\", 2);\r\n\t\t\t\r\n\t\t\tvar word = parts[0];\r\n\r\n\t\t\t// Now for each affix rule, generate that form of the word.\r\n\t\t\tif (parts.length > 1) {\r\n\t\t\t\tvar ruleCodesArray = this.parseRuleCodes(parts[1]);\r\n\t\t\t\t\r\n\t\t\t\t// Save the ruleCodes for compound word situations.\r\n\t\t\t\tif (!(\"NEEDAFFIX\" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {\r\n\t\t\t\t\taddWord(word, ruleCodesArray);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfor (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {\r\n\t\t\t\t\tvar code = ruleCodesArray[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar rule = this.rules[code];\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (rule) {\r\n\t\t\t\t\t\tvar newWords = this._applyRule(word, rule);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfor (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {\r\n\t\t\t\t\t\t\tvar newWord = newWords[ii];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\taddWord(newWord, []);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (rule.combineable) {\r\n\t\t\t\t\t\t\t\tfor (var k = j + 1; k < _jlen; k++) {\r\n\t\t\t\t\t\t\t\t\tvar combineCode = ruleCodesArray[k];\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tvar combineRule = this.rules[combineCode];\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif (combineRule) {\r\n\t\t\t\t\t\t\t\t\t\tif (combineRule.combineable && (rule.type != combineRule.type)) {\r\n\t\t\t\t\t\t\t\t\t\t\tvar otherNewWords = this._applyRule(newWord, combineRule);\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\tfor (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvar otherNewWord = otherNewWords[iii];\r\n\t\t\t\t\t\t\t\t\t\t\t\taddWord(otherNewWord, []);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (code in this.compoundRuleCodes) {\r\n\t\t\t\t\t\tthis.compoundRuleCodes[code].push(word);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\taddWord(word.trim(), []);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn dictionaryTable;\r\n\t},\r\n\t\r\n\t\r\n\t/**\r\n\t * Removes comment lines and then cleans up blank lines and trailing whitespace.\r\n\t *\r\n\t * @param {String} data The data from a .dic file.\r\n\t * @return {String} The cleaned-up data.\r\n\t */\r\n\t\r\n\t_removeDicComments : function (data) {\r\n\t\t// I can't find any official documentation on it, but at least the de_DE\r\n\t\t// dictionary uses tab-indented lines as comments.\r\n\t\t\r\n\t\t// Remove comments\r\n\t\tdata = data.replace(/^\\t.*$/mg, \"\");\r\n\t\t\r\n\t\treturn data;\r\n\t},\r\n\t\r\n\tparseRuleCodes : function (textCodes) {\r\n\t\tif (!textCodes) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\t\telse if (!(\"FLAG\" in this.flags)) {\r\n\t\t\treturn textCodes.split(\"\");\r\n\t\t}\r\n\t\telse if (this.flags.FLAG === \"long\") {\r\n\t\t\tvar flags = [];\r\n\t\t\t\r\n\t\t\tfor (var i = 0, _len = textCodes.length; i < _len; i += 2) {\r\n\t\t\t\tflags.push(textCodes.substr(i, 2));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn flags;\r\n\t\t}\r\n\t\telse if (this.flags.FLAG === \"num\") {\r\n\t\t\treturn textCodes.split(\",\");\r\n\t\t}\r\n\t},\r\n\t\r\n\t/**\r\n\t * Applies an affix rule to a word.\r\n\t *\r\n\t * @param {String} word The base word.\r\n\t * @param {Object} rule The affix rule.\r\n\t * @returns {String[]} The new words generated by the rule.\r\n\t */\r\n\t\r\n\t_applyRule : function (word, rule) {\r\n\t\tvar entries = rule.entries;\r\n\t\tvar newWords = [];\r\n\t\t\r\n\t\tfor (var i = 0, _len = entries.length; i < _len; i++) {\r\n\t\t\tvar entry = entries[i];\r\n\t\t\t\r\n\t\t\tif (!entry.match || word.match(entry.match)) {\r\n\t\t\t\tvar newWord = word;\r\n\t\t\t\t\r\n\t\t\t\tif (entry.remove) {\r\n\t\t\t\t\tnewWord = newWord.replace(entry.remove, \"\");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (rule.type === \"SFX\") {\r\n\t\t\t\t\tnewWord = newWord + entry.add;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tnewWord = entry.add + newWord;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tnewWords.push(newWord);\r\n\t\t\t\t\r\n\t\t\t\tif (\"continuationClasses\" in entry) {\r\n\t\t\t\t\tfor (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {\r\n\t\t\t\t\t\tvar continuationRule = this.rules[entry.continuationClasses[j]];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (continuationRule) {\r\n\t\t\t\t\t\t\tnewWords = newWords.concat(this._applyRule(newWord, continuationRule));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// This shouldn't happen, but it does, at least in the de_DE dictionary.\r\n\t\t\t\t\t\t\t// I think the author mistakenly supplied lower-case rule codes instead \r\n\t\t\t\t\t\t\t// of upper-case.\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t*/\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn newWords;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Checks whether a word or a capitalization variant exists in the current dictionary.\r\n\t * The word is trimmed and several variations of capitalizations are checked.\r\n\t * If you want to check a word without any changes made to it, call checkExact()\r\n\t *\r\n\t * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\r\n\t *\r\n\t * @param {String} aWord The word to check.\r\n\t * @returns {Boolean}\r\n\t */\r\n\t\r\n\tcheck : function (aWord) {\r\n\t\tif (!this.loaded) {\r\n\t\t\tthrow \"Dictionary not loaded.\";\r\n\t\t}\r\n\t\t\r\n\t\t// Remove leading and trailing whitespace\r\n\t\tvar trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\r\n\t\t\r\n\t\tif (this.checkExact(trimmedWord)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t// The exact word is not in the dictionary.\r\n\t\tif (trimmedWord.toUpperCase() === trimmedWord) {\r\n\t\t\t// The word was supplied in all uppercase.\r\n\t\t\t// Check for a capitalized form of the word.\r\n\t\t\tvar capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\r\n\t\t\t\r\n\t\t\tif (this.hasFlag(capitalizedWord, \"KEEPCASE\")) {\r\n\t\t\t\t// Capitalization variants are not allowed for this word.\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (this.checkExact(capitalizedWord)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar lowercaseWord = trimmedWord.toLowerCase();\r\n\t\t\r\n\t\tif (lowercaseWord !== trimmedWord) {\r\n\t\t\tif (this.hasFlag(lowercaseWord, \"KEEPCASE\")) {\r\n\t\t\t\t// Capitalization variants are not allowed for this word.\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Check for a lowercase form\r\n\t\t\tif (this.checkExact(lowercaseWord)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Checks whether a word exists in the current dictionary.\r\n\t *\r\n\t * @param {String} word The word to check.\r\n\t * @returns {Boolean}\r\n\t */\r\n\t\r\n\tcheckExact : function (word) {\r\n\t\tif (!this.loaded) {\r\n\t\t\tthrow \"Dictionary not loaded.\";\r\n\t\t}\r\n\r\n\t\tvar ruleCodes = this.dictionaryTable[word];\r\n\t\t\r\n\t\tvar i, _len;\r\n\t\t\r\n\t\tif (typeof ruleCodes === 'undefined') {\r\n\t\t\t// Check if this might be a compound word.\r\n\t\t\tif (\"COMPOUNDMIN\" in this.flags && word.length >= this.flags.COMPOUNDMIN) {\r\n\t\t\t\tfor (i = 0, _len = this.compoundRules.length; i < _len; i++) {\r\n\t\t\t\t\tif (word.match(this.compoundRules[i])) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (ruleCodes === null) {\r\n\t\t\t// a null (but not undefined) value for an entry in the dictionary table\r\n\t\t\t// means that the word is in the dictionary but has no flags.\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.\r\n\t\t\tfor (i = 0, _len = ruleCodes.length; i < _len; i++) {\r\n\t\t\t\tif (!this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCodes[i])) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Looks up whether a given word is flagged with a given flag.\r\n\t *\r\n\t * @param {String} word The word in question.\r\n\t * @param {String} flag The flag in question.\r\n\t * @return {Boolean}\r\n\t */\r\n\t \r\n\thasFlag : function (word, flag, wordFlags) {\r\n\t\tif (!this.loaded) {\r\n\t\t\tthrow \"Dictionary not loaded.\";\r\n\t\t}\r\n\r\n\t\tif (flag in this.flags) {\r\n\t\t\tif (typeof wordFlags === 'undefined') {\r\n\t\t\t\twordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Returns a list of suggestions for a misspelled word.\r\n\t *\r\n\t * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\r\n\t * This suggestor is primitive, but it works.\r\n\t *\r\n\t * @param {String} word The misspelling.\r\n\t * @param {Number} [limit=5] The maximum number of suggestions to return.\r\n\t * @returns {String[]} The array of suggestions.\r\n\t */\r\n\t\r\n\talphabet : \"\",\r\n\t\r\n\tsuggest : function (word, limit) {\r\n\t\tif (!this.loaded) {\r\n\t\t\tthrow \"Dictionary not loaded.\";\r\n\t\t}\r\n\r\n\t\tlimit = limit || 5;\r\n\r\n\t\tif (this.memoized.hasOwnProperty(word)) {\r\n\t\t\tvar memoizedLimit = this.memoized[word]['limit'];\r\n\r\n\t\t\t// Only return the cached list if it's big enough or if there weren't enough suggestions\r\n\t\t\t// to fill a smaller limit.\r\n\t\t\tif (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\r\n\t\t\t\treturn this.memoized[word]['suggestions'].slice(0, limit);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (this.check(word)) return [];\r\n\t\t\r\n\t\t// Check the replacement table.\r\n\t\tfor (var i = 0, _len = this.replacementTable.length; i < _len; i++) {\r\n\t\t\tvar replacementEntry = this.replacementTable[i];\r\n\t\t\t\r\n\t\t\tif (word.indexOf(replacementEntry[0]) !== -1) {\r\n\t\t\t\tvar correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\r\n\t\t\t\t\r\n\t\t\t\tif (this.check(correctedWord)) {\r\n\t\t\t\t\treturn [ correctedWord ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar self = this;\r\n\t\tself.alphabet = \"abcdefghijklmnopqrstuvwxyz\";\r\n\t\t\r\n\t\t/*\r\n\t\tif (!self.alphabet) {\r\n\t\t\t// Use the alphabet as implicitly defined by the words in the dictionary.\r\n\t\t\tvar alphaHash = {};\r\n\t\t\t\r\n\t\t\tfor (var i in self.dictionaryTable) {\r\n\t\t\t\tfor (var j = 0, _len = i.length; j < _len; j++) {\r\n\t\t\t\t\talphaHash[i[j]] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (var i in alphaHash) {\r\n\t\t\t\tself.alphabet += i;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar alphaArray = self.alphabet.split(\"\");\r\n\t\t\talphaArray.sort();\r\n\t\t\tself.alphabet = alphaArray.join(\"\");\r\n\t\t}\r\n\t\t*/\r\n\t\t\r\n\t\tfunction edits1(words) {\r\n\t\t\tvar rv = [];\r\n\t\t\t\r\n\t\t\tvar ii, i, j, _iilen, _len, _jlen;\r\n\t\t\t\r\n\t\t\tfor (ii = 0, _iilen = words.length; ii < _iilen; ii++) {\r\n\t\t\t\tvar word = words[ii];\r\n\t\t\t\t\r\n\t\t\t\tfor (i = 0, _len = word.length + 1; i < _len; i++) {\r\n\t\t\t\t\tvar s = [ word.substring(0, i), word.substring(i) ];\r\n\t\t\t\t\r\n\t\t\t\t\tif (s[1]) {\r\n\t\t\t\t\t\trv.push(s[0] + s[1].substring(1));\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Eliminate transpositions of identical letters\r\n\t\t\t\t\tif (s[1].length > 1 && s[1][1] !== s[1][0]) {\r\n\t\t\t\t\t\trv.push(s[0] + s[1][1] + s[1][0] + s[1].substring(2));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (s[1]) {\r\n\t\t\t\t\t\tfor (j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {\r\n\t\t\t\t\t\t\t// Eliminate replacement of a letter by itself\r\n\t\t\t\t\t\t\tif (self.alphabet[j] != s[1].substring(0,1)){\r\n\t\t\t\t\t\t\t\trv.push(s[0] + self.alphabet[j] + s[1].substring(1));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (s[1]) {\r\n\t\t\t\t\t\tfor (j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {\r\n\t\t\t\t\t\t\trv.push(s[0] + self.alphabet[j] + s[1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn rv;\r\n\t\t}\r\n\t\t\r\n\t\tfunction known(words) {\r\n\t\t\tvar rv = [];\r\n\t\t\t\r\n\t\t\tfor (var i = 0, _len = words.length; i < _len; i++) {\r\n\t\t\t\tif (self.check(words[i])) {\r\n\t\t\t\t\trv.push(words[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn rv;\r\n\t\t}\r\n\t\t\r\n\t\tfunction correct(word) {\r\n\t\t\t// Get the edit-distance-1 and edit-distance-2 forms of this word.\r\n\t\t\tvar ed1 = edits1([word]);\r\n\t\t\tvar ed2 = edits1(ed1);\r\n\t\t\t\r\n\t\t\tvar corrections = known(ed1.concat(ed2));\r\n\t\t\t\r\n\t\t\tvar i, _len;\r\n\t\t\t\r\n\t\t\t// Sort the edits based on how many different ways they were created.\r\n\t\t\tvar weighted_corrections = {};\r\n\t\t\t\r\n\t\t\tfor (i = 0, _len = corrections.length; i < _len; i++) {\r\n\t\t\t\tif (!(corrections[i] in weighted_corrections)) {\r\n\t\t\t\t\tweighted_corrections[corrections[i]] = 1;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tweighted_corrections[corrections[i]] += 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar sorted_corrections = [];\r\n\t\t\t\r\n\t\t\tfor (i in weighted_corrections) {\r\n\t\t\t\tif (weighted_corrections.hasOwnProperty(i)) {\r\n\t\t\t\t\tsorted_corrections.push([ i, weighted_corrections[i] ]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfunction sorter(a, b) {\r\n\t\t\t\tif (a[1] < b[1]) {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsorted_corrections.sort(sorter).reverse();\r\n\t\t\t\r\n\t\t\tvar rv = [];\r\n\r\n\t\t\tvar capitalization_scheme = \"lowercase\";\r\n\t\t\t\r\n\t\t\tif (word.toUpperCase() === word) {\r\n\t\t\t\tcapitalization_scheme = \"uppercase\";\r\n\t\t\t}\r\n\t\t\telse if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {\r\n\t\t\t\tcapitalization_scheme = \"capitalized\";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (i = 0, _len = Math.min(limit, sorted_corrections.length); i < _len; i++) {\r\n\t\t\t\tif (\"uppercase\" === capitalization_scheme) {\r\n\t\t\t\t\tsorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();\r\n\t\t\t\t}\r\n\t\t\t\telse if (\"capitalized\" === capitalization_scheme) {\r\n\t\t\t\t\tsorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (!self.hasFlag(sorted_corrections[i][0], \"NOSUGGEST\")) {\r\n\t\t\t\t\trv.push(sorted_corrections[i][0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn rv;\r\n\t\t}\r\n\t\t\r\n\t\tthis.memoized[word] = {\r\n\t\t\t'suggestions': correct(word),\r\n\t\t\t'limit': limit\r\n\t\t};\r\n\r\n\t\treturn this.memoized[word]['suggestions'];\r\n\t}\r\n};\r\n})();\r\n\r\n// Support for use as a node.js module.\r\nif (true) {\r\n\tmodule.exports = Typo;\r\n}\n/* WEBPACK VAR INJECTION */}.call(exports, \"/\", __webpack_require__(933).Buffer))\n\n/***/ }),\n\n/***/ 1295:\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction injectStyle (ssrContext) {\n  __webpack_require__(1219)\n}\nvar Component = __webpack_require__(19)(\n  /* script */\n  __webpack_require__(968),\n  /* template */\n  __webpack_require__(1358),\n  /* styles */\n  injectStyle,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 1358:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"simplemde-container\",\n    style: ({\n      height: _vm.height + 'px',\n      zIndex: _vm.zIndex\n    })\n  }, [_c('textarea', {\n    attrs: {\n      \"id\": _vm.id\n    }\n  })])\n},staticRenderFns: []}\n\n/***/ }),\n\n/***/ 1398:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"components-container\"\n  }, [_vm._m(0), _vm._v(\" \"), _c('div', {\n    staticClass: \"editor-container\"\n  }, [_c('md-editor', {\n    ref: \"contentEditor\",\n    attrs: {\n      \"id\": \"contentEditor\",\n      \"height\": 300,\n      \"zIndex\": 20\n    },\n    model: {\n      value: (_vm.content),\n      callback: function($$v) {\n        _vm.content = $$v\n      },\n      expression: \"content\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-button', {\n    staticStyle: {\n      \"margin-top\": \"80px\"\n    },\n    attrs: {\n      \"type\": \"primary\"\n    },\n    on: {\n      \"click\": _vm.markdown2Html\n    }\n  }, [_vm._v(\"转为HTML\"), _c('i', {\n    staticClass: \"el-icon-document el-icon--right\"\n  })]), _vm._v(\" \"), _c('div', {\n    domProps: {\n      \"innerHTML\": _vm._s(_vm.html)\n    }\n  })], 1)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('code', [_vm._v(\"Markdown 我们这里选用了 \"), _c('a', {\n    attrs: {\n      \"href\": \"https://github.com/sparksuite/simplemde-markdown-editor\",\n      \"target\": \"_blank\"\n    }\n  }, [_vm._v(\"simplemde-markdown-editor\")]), _vm._v(\" ，简单的用vue封装了一下\"), _c('a', {\n    attrs: {\n      \"target\": \"_blank\",\n      \"href\": \"https://segmentfault.com/a/1190000009762198#articleHeader14\"\n    }\n  }, [_vm._v(\" 相关文章 \")])])\n}]}\n\n/***/ }),\n\n/***/ 1421:\n/***/ (function(module, exports) {\n\n/* (ignored) */\n\n/***/ }),\n\n/***/ 761:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(19)(\n  /* script */\n  __webpack_require__(1000),\n  /* template */\n  __webpack_require__(1398),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 877:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// This is CodeMirror (http://codemirror.net), a code editor\r\n// implemented in JavaScript on top of the browser's DOM.\r\n//\r\n// You can find some technical background for some of the code below\r\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\r\n\r\n(function (global, factory) {\r\n\t true ? module.exports = factory() :\r\n\ttypeof define === 'function' && define.amd ? define(factory) :\r\n\t(global.CodeMirror = factory());\r\n}(this, (function () { 'use strict';\r\n\r\n// Kludges for bugs and behavior differences that can't be feature\r\n// detected are enabled based on userAgent etc sniffing.\r\nvar userAgent = navigator.userAgent;\r\nvar platform = navigator.platform;\r\n\r\nvar gecko = /gecko\\/\\d/i.test(userAgent);\r\nvar ie_upto10 = /MSIE \\d/.test(userAgent);\r\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\r\nvar edge = /Edge\\/(\\d+)/.exec(userAgent);\r\nvar ie = ie_upto10 || ie_11up || edge;\r\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\r\nvar webkit = !edge && /WebKit\\//.test(userAgent);\r\nvar qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\r\nvar chrome = !edge && /Chrome\\//.test(userAgent);\r\nvar presto = /Opera\\//.test(userAgent);\r\nvar safari = /Apple Computer/.test(navigator.vendor);\r\nvar mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\r\nvar phantom = /PhantomJS/.test(userAgent);\r\n\r\nvar ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\r\nvar android = /Android/.test(userAgent);\r\n// This is woefully incomplete. Suggestions for alternative methods welcome.\r\nvar mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\r\nvar mac = ios || /Mac/.test(platform);\r\nvar chromeOS = /\\bCrOS\\b/.test(userAgent);\r\nvar windows = /win/i.test(platform);\r\n\r\nvar presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\r\nif (presto_version) { presto_version = Number(presto_version[1]); }\r\nif (presto_version && presto_version >= 15) { presto = false; webkit = true; }\r\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\r\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\r\nvar captureRightClick = gecko || (ie && ie_version >= 9);\r\n\r\nfunction classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\r\n\r\nvar rmClass = function(node, cls) {\r\n  var current = node.className;\r\n  var match = classTest(cls).exec(current);\r\n  if (match) {\r\n    var after = current.slice(match.index + match[0].length);\r\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\r\n  }\r\n};\r\n\r\nfunction removeChildren(e) {\r\n  for (var count = e.childNodes.length; count > 0; --count)\r\n    { e.removeChild(e.firstChild); }\r\n  return e\r\n}\r\n\r\nfunction removeChildrenAndAdd(parent, e) {\r\n  return removeChildren(parent).appendChild(e)\r\n}\r\n\r\nfunction elt(tag, content, className, style) {\r\n  var e = document.createElement(tag);\r\n  if (className) { e.className = className; }\r\n  if (style) { e.style.cssText = style; }\r\n  if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\r\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\r\n  return e\r\n}\r\n// wrapper for elt, which removes the elt from the accessibility tree\r\nfunction eltP(tag, content, className, style) {\r\n  var e = elt(tag, content, className, style);\r\n  e.setAttribute(\"role\", \"presentation\");\r\n  return e\r\n}\r\n\r\nvar range;\r\nif (document.createRange) { range = function(node, start, end, endNode) {\r\n  var r = document.createRange();\r\n  r.setEnd(endNode || node, end);\r\n  r.setStart(node, start);\r\n  return r\r\n}; }\r\nelse { range = function(node, start, end) {\r\n  var r = document.body.createTextRange();\r\n  try { r.moveToElementText(node.parentNode); }\r\n  catch(e) { return r }\r\n  r.collapse(true);\r\n  r.moveEnd(\"character\", end);\r\n  r.moveStart(\"character\", start);\r\n  return r\r\n}; }\r\n\r\nfunction contains(parent, child) {\r\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\r\n    { child = child.parentNode; }\r\n  if (parent.contains)\r\n    { return parent.contains(child) }\r\n  do {\r\n    if (child.nodeType == 11) { child = child.host; }\r\n    if (child == parent) { return true }\r\n  } while (child = child.parentNode)\r\n}\r\n\r\nfunction activeElt() {\r\n  // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\r\n  // IE < 10 will throw when accessed while the page is loading or in an iframe.\r\n  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\r\n  var activeElement;\r\n  try {\r\n    activeElement = document.activeElement;\r\n  } catch(e) {\r\n    activeElement = document.body || null;\r\n  }\r\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\r\n    { activeElement = activeElement.shadowRoot.activeElement; }\r\n  return activeElement\r\n}\r\n\r\nfunction addClass(node, cls) {\r\n  var current = node.className;\r\n  if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\r\n}\r\nfunction joinClasses(a, b) {\r\n  var as = a.split(\" \");\r\n  for (var i = 0; i < as.length; i++)\r\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\r\n  return b\r\n}\r\n\r\nvar selectInput = function(node) { node.select(); };\r\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\r\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\r\nelse if (ie) // Suppress mysterious IE10 errors\r\n  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\r\n\r\nfunction bind(f) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  return function(){return f.apply(null, args)}\r\n}\r\n\r\nfunction copyObj(obj, target, overwrite) {\r\n  if (!target) { target = {}; }\r\n  for (var prop in obj)\r\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\r\n      { target[prop] = obj[prop]; } }\r\n  return target\r\n}\r\n\r\n// Counts the column offset in a string, taking tabs into account.\r\n// Used mostly to find indentation.\r\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\r\n  if (end == null) {\r\n    end = string.search(/[^\\s\\u00a0]/);\r\n    if (end == -1) { end = string.length; }\r\n  }\r\n  for (var i = startIndex || 0, n = startValue || 0;;) {\r\n    var nextTab = string.indexOf(\"\\t\", i);\r\n    if (nextTab < 0 || nextTab >= end)\r\n      { return n + (end - i) }\r\n    n += nextTab - i;\r\n    n += tabSize - (n % tabSize);\r\n    i = nextTab + 1;\r\n  }\r\n}\r\n\r\nvar Delayed = function() {this.id = null;};\r\nDelayed.prototype.set = function (ms, f) {\r\n  clearTimeout(this.id);\r\n  this.id = setTimeout(f, ms);\r\n};\r\n\r\nfunction indexOf(array, elt) {\r\n  for (var i = 0; i < array.length; ++i)\r\n    { if (array[i] == elt) { return i } }\r\n  return -1\r\n}\r\n\r\n// Number of pixels added to scroller and sizer to hide scrollbar\r\nvar scrollerGap = 30;\r\n\r\n// Returned or thrown by various protocols to signal 'I'm not\r\n// handling this'.\r\nvar Pass = {toString: function(){return \"CodeMirror.Pass\"}};\r\n\r\n// Reused option objects for setSelection & friends\r\nvar sel_dontScroll = {scroll: false};\r\nvar sel_mouse = {origin: \"*mouse\"};\r\nvar sel_move = {origin: \"+move\"};\r\n\r\n// The inverse of countColumn -- find the offset that corresponds to\r\n// a particular column.\r\nfunction findColumn(string, goal, tabSize) {\r\n  for (var pos = 0, col = 0;;) {\r\n    var nextTab = string.indexOf(\"\\t\", pos);\r\n    if (nextTab == -1) { nextTab = string.length; }\r\n    var skipped = nextTab - pos;\r\n    if (nextTab == string.length || col + skipped >= goal)\r\n      { return pos + Math.min(skipped, goal - col) }\r\n    col += nextTab - pos;\r\n    col += tabSize - (col % tabSize);\r\n    pos = nextTab + 1;\r\n    if (col >= goal) { return pos }\r\n  }\r\n}\r\n\r\nvar spaceStrs = [\"\"];\r\nfunction spaceStr(n) {\r\n  while (spaceStrs.length <= n)\r\n    { spaceStrs.push(lst(spaceStrs) + \" \"); }\r\n  return spaceStrs[n]\r\n}\r\n\r\nfunction lst(arr) { return arr[arr.length-1] }\r\n\r\nfunction map(array, f) {\r\n  var out = [];\r\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\r\n  return out\r\n}\r\n\r\nfunction insertSorted(array, value, score) {\r\n  var pos = 0, priority = score(value);\r\n  while (pos < array.length && score(array[pos]) <= priority) { pos++; }\r\n  array.splice(pos, 0, value);\r\n}\r\n\r\nfunction nothing() {}\r\n\r\nfunction createObj(base, props) {\r\n  var inst;\r\n  if (Object.create) {\r\n    inst = Object.create(base);\r\n  } else {\r\n    nothing.prototype = base;\r\n    inst = new nothing();\r\n  }\r\n  if (props) { copyObj(props, inst); }\r\n  return inst\r\n}\r\n\r\nvar nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\r\nfunction isWordCharBasic(ch) {\r\n  return /\\w/.test(ch) || ch > \"\\x80\" &&\r\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\r\n}\r\nfunction isWordChar(ch, helper) {\r\n  if (!helper) { return isWordCharBasic(ch) }\r\n  if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\r\n  return helper.test(ch)\r\n}\r\n\r\nfunction isEmpty(obj) {\r\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\r\n  return true\r\n}\r\n\r\n// Extending unicode characters. A series of a non-extending char +\r\n// any number of extending chars is treated as a single unit as far\r\n// as editing and measuring is concerned. This is not fully correct,\r\n// since some scripts/fonts/browsers also treat other configurations\r\n// of code points as a group.\r\nvar extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\r\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\r\n\r\n// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\r\nfunction skipExtendingChars(str, pos, dir) {\r\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\r\n  return pos\r\n}\r\n\r\n// Returns the value from the range [`from`; `to`] that satisfies\r\n// `pred` and is closest to `from`. Assumes that at least `to` satisfies `pred`.\r\nfunction findFirst(pred, from, to) {\r\n  for (;;) {\r\n    if (Math.abs(from - to) <= 1) { return pred(from) ? from : to }\r\n    var mid = Math.floor((from + to) / 2);\r\n    if (pred(mid)) { to = mid; }\r\n    else { from = mid; }\r\n  }\r\n}\r\n\r\n// The display handles the DOM integration, both for input reading\r\n// and content drawing. It holds references to DOM nodes and\r\n// display-related state.\r\n\r\nfunction Display(place, doc, input) {\r\n  var d = this;\r\n  this.input = input;\r\n\r\n  // Covers bottom-right square when both scrollbars are present.\r\n  d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\r\n  d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\r\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\r\n  // and h scrollbar is present.\r\n  d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\r\n  d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\r\n  // Will contain the actual code, positioned to cover the viewport.\r\n  d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\r\n  // Elements are added to these to represent selection and cursors.\r\n  d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\r\n  d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\r\n  // A visibility: hidden element used to find the size of things.\r\n  d.measure = elt(\"div\", null, \"CodeMirror-measure\");\r\n  // When lines outside of the viewport are measured, they are drawn in this.\r\n  d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\r\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\r\n  d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\r\n                    null, \"position: relative; outline: none\");\r\n  var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\r\n  // Moved around its parent to cover visible view.\r\n  d.mover = elt(\"div\", [lines], null, \"position: relative\");\r\n  // Set to the height of the document, allowing scrolling.\r\n  d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\r\n  d.sizerWidth = null;\r\n  // Behavior of elts with overflow: auto and padding is\r\n  // inconsistent across browsers. This is used to ensure the\r\n  // scrollable area is big enough.\r\n  d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\r\n  // Will contain the gutters, if any.\r\n  d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\r\n  d.lineGutter = null;\r\n  // Actual scrollable element.\r\n  d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\r\n  d.scroller.setAttribute(\"tabIndex\", \"-1\");\r\n  // The element in which the editor lives.\r\n  d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\r\n\r\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\r\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\r\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\r\n\r\n  if (place) {\r\n    if (place.appendChild) { place.appendChild(d.wrapper); }\r\n    else { place(d.wrapper); }\r\n  }\r\n\r\n  // Current rendered range (may be bigger than the view window).\r\n  d.viewFrom = d.viewTo = doc.first;\r\n  d.reportedViewFrom = d.reportedViewTo = doc.first;\r\n  // Information about the rendered lines.\r\n  d.view = [];\r\n  d.renderedView = null;\r\n  // Holds info about a single rendered line when it was rendered\r\n  // for measurement, while not in view.\r\n  d.externalMeasured = null;\r\n  // Empty space (in pixels) above the view\r\n  d.viewOffset = 0;\r\n  d.lastWrapHeight = d.lastWrapWidth = 0;\r\n  d.updateLineNumbers = null;\r\n\r\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0;\r\n  d.scrollbarsClipped = false;\r\n\r\n  // Used to only resize the line number gutter when necessary (when\r\n  // the amount of lines crosses a boundary that makes its width change)\r\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\r\n  // Set to true when a non-horizontal-scrolling line widget is\r\n  // added. As an optimization, line widget aligning is skipped when\r\n  // this is false.\r\n  d.alignWidgets = false;\r\n\r\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\r\n\r\n  // Tracks the maximum line length so that the horizontal scrollbar\r\n  // can be kept static when scrolling.\r\n  d.maxLine = null;\r\n  d.maxLineLength = 0;\r\n  d.maxLineChanged = false;\r\n\r\n  // Used for measuring wheel scrolling granularity\r\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\r\n\r\n  // True when shift is held down.\r\n  d.shift = false;\r\n\r\n  // Used to track whether anything happened since the context menu\r\n  // was opened.\r\n  d.selForContextMenu = null;\r\n\r\n  d.activeTouch = null;\r\n\r\n  input.init(d);\r\n}\r\n\r\n// Find the line object corresponding to the given line number.\r\nfunction getLine(doc, n) {\r\n  n -= doc.first;\r\n  if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\r\n  var chunk = doc;\r\n  while (!chunk.lines) {\r\n    for (var i = 0;; ++i) {\r\n      var child = chunk.children[i], sz = child.chunkSize();\r\n      if (n < sz) { chunk = child; break }\r\n      n -= sz;\r\n    }\r\n  }\r\n  return chunk.lines[n]\r\n}\r\n\r\n// Get the part of a document between two positions, as an array of\r\n// strings.\r\nfunction getBetween(doc, start, end) {\r\n  var out = [], n = start.line;\r\n  doc.iter(start.line, end.line + 1, function (line) {\r\n    var text = line.text;\r\n    if (n == end.line) { text = text.slice(0, end.ch); }\r\n    if (n == start.line) { text = text.slice(start.ch); }\r\n    out.push(text);\r\n    ++n;\r\n  });\r\n  return out\r\n}\r\n// Get the lines between from and to, as array of strings.\r\nfunction getLines(doc, from, to) {\r\n  var out = [];\r\n  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\r\n  return out\r\n}\r\n\r\n// Update the height of a line, propagating the height change\r\n// upwards to parent nodes.\r\nfunction updateLineHeight(line, height) {\r\n  var diff = height - line.height;\r\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\r\n}\r\n\r\n// Given a line object, find its line number by walking up through\r\n// its parent links.\r\nfunction lineNo(line) {\r\n  if (line.parent == null) { return null }\r\n  var cur = line.parent, no = indexOf(cur.lines, line);\r\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\r\n    for (var i = 0;; ++i) {\r\n      if (chunk.children[i] == cur) { break }\r\n      no += chunk.children[i].chunkSize();\r\n    }\r\n  }\r\n  return no + cur.first\r\n}\r\n\r\n// Find the line at the given vertical position, using the height\r\n// information in the document tree.\r\nfunction lineAtHeight(chunk, h) {\r\n  var n = chunk.first;\r\n  outer: do {\r\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\r\n      var child = chunk.children[i$1], ch = child.height;\r\n      if (h < ch) { chunk = child; continue outer }\r\n      h -= ch;\r\n      n += child.chunkSize();\r\n    }\r\n    return n\r\n  } while (!chunk.lines)\r\n  var i = 0;\r\n  for (; i < chunk.lines.length; ++i) {\r\n    var line = chunk.lines[i], lh = line.height;\r\n    if (h < lh) { break }\r\n    h -= lh;\r\n  }\r\n  return n + i\r\n}\r\n\r\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\r\n\r\nfunction lineNumberFor(options, i) {\r\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\r\n}\r\n\r\n// A Pos instance represents a position within the text.\r\nfunction Pos(line, ch, sticky) {\r\n  if ( sticky === void 0 ) sticky = null;\r\n\r\n  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\r\n  this.line = line;\r\n  this.ch = ch;\r\n  this.sticky = sticky;\r\n}\r\n\r\n// Compare two positions, return 0 if they are the same, a negative\r\n// number when a is less, and a positive number otherwise.\r\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\r\n\r\nfunction equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\r\n\r\nfunction copyPos(x) {return Pos(x.line, x.ch)}\r\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\r\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\r\n\r\n// Most of the external API clips given positions to make sure they\r\n// actually exist within the document.\r\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\r\nfunction clipPos(doc, pos) {\r\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\r\n  var last = doc.first + doc.size - 1;\r\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\r\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\r\n}\r\nfunction clipToLen(pos, linelen) {\r\n  var ch = pos.ch;\r\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\r\n  else if (ch < 0) { return Pos(pos.line, 0) }\r\n  else { return pos }\r\n}\r\nfunction clipPosArray(doc, array) {\r\n  var out = [];\r\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\r\n  return out\r\n}\r\n\r\n// Optimize some code when these features are not used.\r\nvar sawReadOnlySpans = false;\r\nvar sawCollapsedSpans = false;\r\n\r\nfunction seeReadOnlySpans() {\r\n  sawReadOnlySpans = true;\r\n}\r\n\r\nfunction seeCollapsedSpans() {\r\n  sawCollapsedSpans = true;\r\n}\r\n\r\n// TEXTMARKER SPANS\r\n\r\nfunction MarkedSpan(marker, from, to) {\r\n  this.marker = marker;\r\n  this.from = from; this.to = to;\r\n}\r\n\r\n// Search an array of spans for a span matching the given marker.\r\nfunction getMarkedSpanFor(spans, marker) {\r\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\r\n    var span = spans[i];\r\n    if (span.marker == marker) { return span }\r\n  } }\r\n}\r\n// Remove a span from an array, returning undefined if no spans are\r\n// left (we don't store arrays for lines without spans).\r\nfunction removeMarkedSpan(spans, span) {\r\n  var r;\r\n  for (var i = 0; i < spans.length; ++i)\r\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\r\n  return r\r\n}\r\n// Add a span to a line.\r\nfunction addMarkedSpan(line, span) {\r\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\r\n  span.marker.attachLine(line);\r\n}\r\n\r\n// Used for the algorithm that adjusts markers for a change in the\r\n// document. These functions cut an array of spans at a given\r\n// character position, returning an array of remaining chunks (or\r\n// undefined if nothing remains).\r\nfunction markedSpansBefore(old, startCh, isInsert) {\r\n  var nw;\r\n  if (old) { for (var i = 0; i < old.length; ++i) {\r\n    var span = old[i], marker = span.marker;\r\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\r\n    if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\r\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\r\n    }\r\n  } }\r\n  return nw\r\n}\r\nfunction markedSpansAfter(old, endCh, isInsert) {\r\n  var nw;\r\n  if (old) { for (var i = 0; i < old.length; ++i) {\r\n    var span = old[i], marker = span.marker;\r\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\r\n    if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\r\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\r\n                                            span.to == null ? null : span.to - endCh));\r\n    }\r\n  } }\r\n  return nw\r\n}\r\n\r\n// Given a change object, compute the new set of marker spans that\r\n// cover the line in which the change took place. Removes spans\r\n// entirely within the change, reconnects spans belonging to the\r\n// same marker that appear on both sides of the change, and cuts off\r\n// spans partially within the change. Returns an array of span\r\n// arrays with one element for each line in (after) the change.\r\nfunction stretchSpansOverChange(doc, change) {\r\n  if (change.full) { return null }\r\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\r\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\r\n  if (!oldFirst && !oldLast) { return null }\r\n\r\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\r\n  // Get the spans that 'stick out' on both sides\r\n  var first = markedSpansBefore(oldFirst, startCh, isInsert);\r\n  var last = markedSpansAfter(oldLast, endCh, isInsert);\r\n\r\n  // Next, merge those two ends\r\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\r\n  if (first) {\r\n    // Fix up .to properties of first\r\n    for (var i = 0; i < first.length; ++i) {\r\n      var span = first[i];\r\n      if (span.to == null) {\r\n        var found = getMarkedSpanFor(last, span.marker);\r\n        if (!found) { span.to = startCh; }\r\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\r\n      }\r\n    }\r\n  }\r\n  if (last) {\r\n    // Fix up .from in last (or move them into first in case of sameLine)\r\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\r\n      var span$1 = last[i$1];\r\n      if (span$1.to != null) { span$1.to += offset; }\r\n      if (span$1.from == null) {\r\n        var found$1 = getMarkedSpanFor(first, span$1.marker);\r\n        if (!found$1) {\r\n          span$1.from = offset;\r\n          if (sameLine) { (first || (first = [])).push(span$1); }\r\n        }\r\n      } else {\r\n        span$1.from += offset;\r\n        if (sameLine) { (first || (first = [])).push(span$1); }\r\n      }\r\n    }\r\n  }\r\n  // Make sure we didn't create any zero-length spans\r\n  if (first) { first = clearEmptySpans(first); }\r\n  if (last && last != first) { last = clearEmptySpans(last); }\r\n\r\n  var newMarkers = [first];\r\n  if (!sameLine) {\r\n    // Fill gap with whole-line-spans\r\n    var gap = change.text.length - 2, gapMarkers;\r\n    if (gap > 0 && first)\r\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\r\n        { if (first[i$2].to == null)\r\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\r\n    for (var i$3 = 0; i$3 < gap; ++i$3)\r\n      { newMarkers.push(gapMarkers); }\r\n    newMarkers.push(last);\r\n  }\r\n  return newMarkers\r\n}\r\n\r\n// Remove spans that are empty and don't have a clearWhenEmpty\r\n// option of false.\r\nfunction clearEmptySpans(spans) {\r\n  for (var i = 0; i < spans.length; ++i) {\r\n    var span = spans[i];\r\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\r\n      { spans.splice(i--, 1); }\r\n  }\r\n  if (!spans.length) { return null }\r\n  return spans\r\n}\r\n\r\n// Used to 'clip' out readOnly ranges when making a change.\r\nfunction removeReadOnlyRanges(doc, from, to) {\r\n  var markers = null;\r\n  doc.iter(from.line, to.line + 1, function (line) {\r\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\r\n      var mark = line.markedSpans[i].marker;\r\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\r\n        { (markers || (markers = [])).push(mark); }\r\n    } }\r\n  });\r\n  if (!markers) { return null }\r\n  var parts = [{from: from, to: to}];\r\n  for (var i = 0; i < markers.length; ++i) {\r\n    var mk = markers[i], m = mk.find(0);\r\n    for (var j = 0; j < parts.length; ++j) {\r\n      var p = parts[j];\r\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\r\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\r\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\r\n        { newParts.push({from: p.from, to: m.from}); }\r\n      if (dto > 0 || !mk.inclusiveRight && !dto)\r\n        { newParts.push({from: m.to, to: p.to}); }\r\n      parts.splice.apply(parts, newParts);\r\n      j += newParts.length - 3;\r\n    }\r\n  }\r\n  return parts\r\n}\r\n\r\n// Connect or disconnect spans from a line.\r\nfunction detachMarkedSpans(line) {\r\n  var spans = line.markedSpans;\r\n  if (!spans) { return }\r\n  for (var i = 0; i < spans.length; ++i)\r\n    { spans[i].marker.detachLine(line); }\r\n  line.markedSpans = null;\r\n}\r\nfunction attachMarkedSpans(line, spans) {\r\n  if (!spans) { return }\r\n  for (var i = 0; i < spans.length; ++i)\r\n    { spans[i].marker.attachLine(line); }\r\n  line.markedSpans = spans;\r\n}\r\n\r\n// Helpers used when computing which overlapping collapsed span\r\n// counts as the larger one.\r\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\r\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\r\n\r\n// Returns a number indicating which of two overlapping collapsed\r\n// spans is larger (and thus includes the other). Falls back to\r\n// comparing ids when the spans cover exactly the same range.\r\nfunction compareCollapsedMarkers(a, b) {\r\n  var lenDiff = a.lines.length - b.lines.length;\r\n  if (lenDiff != 0) { return lenDiff }\r\n  var aPos = a.find(), bPos = b.find();\r\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\r\n  if (fromCmp) { return -fromCmp }\r\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\r\n  if (toCmp) { return toCmp }\r\n  return b.id - a.id\r\n}\r\n\r\n// Find out whether a line ends or starts in a collapsed span. If\r\n// so, return the marker for that span.\r\nfunction collapsedSpanAtSide(line, start) {\r\n  var sps = sawCollapsedSpans && line.markedSpans, found;\r\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\r\n    sp = sps[i];\r\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\r\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\r\n      { found = sp.marker; }\r\n  } }\r\n  return found\r\n}\r\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\r\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\r\n\r\n// Test whether there exists a collapsed span that partially\r\n// overlaps (covers the start or end, but not both) of a new span.\r\n// Such overlap is not allowed.\r\nfunction conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\r\n  var line = getLine(doc, lineNo$$1);\r\n  var sps = sawCollapsedSpans && line.markedSpans;\r\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\r\n    var sp = sps[i];\r\n    if (!sp.marker.collapsed) { continue }\r\n    var found = sp.marker.find(0);\r\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\r\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\r\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\r\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\r\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\r\n      { return true }\r\n  } }\r\n}\r\n\r\n// A visual line is a line as drawn on the screen. Folding, for\r\n// example, can cause multiple logical lines to appear on the same\r\n// visual line. This finds the start of the visual line that the\r\n// given line is part of (usually that is the line itself).\r\nfunction visualLine(line) {\r\n  var merged;\r\n  while (merged = collapsedSpanAtStart(line))\r\n    { line = merged.find(-1, true).line; }\r\n  return line\r\n}\r\n\r\nfunction visualLineEnd(line) {\r\n  var merged;\r\n  while (merged = collapsedSpanAtEnd(line))\r\n    { line = merged.find(1, true).line; }\r\n  return line\r\n}\r\n\r\n// Returns an array of logical lines that continue the visual line\r\n// started by the argument, or undefined if there are no such lines.\r\nfunction visualLineContinued(line) {\r\n  var merged, lines;\r\n  while (merged = collapsedSpanAtEnd(line)) {\r\n    line = merged.find(1, true).line\r\n    ;(lines || (lines = [])).push(line);\r\n  }\r\n  return lines\r\n}\r\n\r\n// Get the line number of the start of the visual line that the\r\n// given line number is part of.\r\nfunction visualLineNo(doc, lineN) {\r\n  var line = getLine(doc, lineN), vis = visualLine(line);\r\n  if (line == vis) { return lineN }\r\n  return lineNo(vis)\r\n}\r\n\r\n// Get the line number of the start of the next visual line after\r\n// the given line.\r\nfunction visualLineEndNo(doc, lineN) {\r\n  if (lineN > doc.lastLine()) { return lineN }\r\n  var line = getLine(doc, lineN), merged;\r\n  if (!lineIsHidden(doc, line)) { return lineN }\r\n  while (merged = collapsedSpanAtEnd(line))\r\n    { line = merged.find(1, true).line; }\r\n  return lineNo(line) + 1\r\n}\r\n\r\n// Compute whether a line is hidden. Lines count as hidden when they\r\n// are part of a visual line that starts with another line, or when\r\n// they are entirely covered by collapsed, non-widget span.\r\nfunction lineIsHidden(doc, line) {\r\n  var sps = sawCollapsedSpans && line.markedSpans;\r\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\r\n    sp = sps[i];\r\n    if (!sp.marker.collapsed) { continue }\r\n    if (sp.from == null) { return true }\r\n    if (sp.marker.widgetNode) { continue }\r\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\r\n      { return true }\r\n  } }\r\n}\r\nfunction lineIsHiddenInner(doc, line, span) {\r\n  if (span.to == null) {\r\n    var end = span.marker.find(1, true);\r\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\r\n  }\r\n  if (span.marker.inclusiveRight && span.to == line.text.length)\r\n    { return true }\r\n  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\r\n    sp = line.markedSpans[i];\r\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\r\n        (sp.to == null || sp.to != span.from) &&\r\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\r\n        lineIsHiddenInner(doc, line, sp)) { return true }\r\n  }\r\n}\r\n\r\n// Find the height above the given line.\r\nfunction heightAtLine(lineObj) {\r\n  lineObj = visualLine(lineObj);\r\n\r\n  var h = 0, chunk = lineObj.parent;\r\n  for (var i = 0; i < chunk.lines.length; ++i) {\r\n    var line = chunk.lines[i];\r\n    if (line == lineObj) { break }\r\n    else { h += line.height; }\r\n  }\r\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\r\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\r\n      var cur = p.children[i$1];\r\n      if (cur == chunk) { break }\r\n      else { h += cur.height; }\r\n    }\r\n  }\r\n  return h\r\n}\r\n\r\n// Compute the character length of a line, taking into account\r\n// collapsed ranges (see markText) that might hide parts, and join\r\n// other lines onto it.\r\nfunction lineLength(line) {\r\n  if (line.height == 0) { return 0 }\r\n  var len = line.text.length, merged, cur = line;\r\n  while (merged = collapsedSpanAtStart(cur)) {\r\n    var found = merged.find(0, true);\r\n    cur = found.from.line;\r\n    len += found.from.ch - found.to.ch;\r\n  }\r\n  cur = line;\r\n  while (merged = collapsedSpanAtEnd(cur)) {\r\n    var found$1 = merged.find(0, true);\r\n    len -= cur.text.length - found$1.from.ch;\r\n    cur = found$1.to.line;\r\n    len += cur.text.length - found$1.to.ch;\r\n  }\r\n  return len\r\n}\r\n\r\n// Find the longest line in the document.\r\nfunction findMaxLine(cm) {\r\n  var d = cm.display, doc = cm.doc;\r\n  d.maxLine = getLine(doc, doc.first);\r\n  d.maxLineLength = lineLength(d.maxLine);\r\n  d.maxLineChanged = true;\r\n  doc.iter(function (line) {\r\n    var len = lineLength(line);\r\n    if (len > d.maxLineLength) {\r\n      d.maxLineLength = len;\r\n      d.maxLine = line;\r\n    }\r\n  });\r\n}\r\n\r\n// BIDI HELPERS\r\n\r\nfunction iterateBidiSections(order, from, to, f) {\r\n  if (!order) { return f(from, to, \"ltr\") }\r\n  var found = false;\r\n  for (var i = 0; i < order.length; ++i) {\r\n    var part = order[i];\r\n    if (part.from < to && part.to > from || from == to && part.to == from) {\r\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\r\n      found = true;\r\n    }\r\n  }\r\n  if (!found) { f(from, to, \"ltr\"); }\r\n}\r\n\r\nvar bidiOther = null;\r\nfunction getBidiPartAt(order, ch, sticky) {\r\n  var found;\r\n  bidiOther = null;\r\n  for (var i = 0; i < order.length; ++i) {\r\n    var cur = order[i];\r\n    if (cur.from < ch && cur.to > ch) { return i }\r\n    if (cur.to == ch) {\r\n      if (cur.from != cur.to && sticky == \"before\") { found = i; }\r\n      else { bidiOther = i; }\r\n    }\r\n    if (cur.from == ch) {\r\n      if (cur.from != cur.to && sticky != \"before\") { found = i; }\r\n      else { bidiOther = i; }\r\n    }\r\n  }\r\n  return found != null ? found : bidiOther\r\n}\r\n\r\n// Bidirectional ordering algorithm\r\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\r\n// that this (partially) implements.\r\n\r\n// One-char codes used for character types:\r\n// L (L):   Left-to-Right\r\n// R (R):   Right-to-Left\r\n// r (AL):  Right-to-Left Arabic\r\n// 1 (EN):  European Number\r\n// + (ES):  European Number Separator\r\n// % (ET):  European Number Terminator\r\n// n (AN):  Arabic Number\r\n// , (CS):  Common Number Separator\r\n// m (NSM): Non-Spacing Mark\r\n// b (BN):  Boundary Neutral\r\n// s (B):   Paragraph Separator\r\n// t (S):   Segment Separator\r\n// w (WS):  Whitespace\r\n// N (ON):  Other Neutrals\r\n\r\n// Returns null if characters are ordered as they appear\r\n// (left-to-right), or an array of sections ({from, to, level}\r\n// objects) in the order in which they occur visually.\r\nvar bidiOrdering = (function() {\r\n  // Character types for codepoints 0 to 0xff\r\n  var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\r\n  // Character types for codepoints 0x600 to 0x6f9\r\n  var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\r\n  function charType(code) {\r\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\r\n    else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\r\n    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\r\n    else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\r\n    else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\r\n    else if (code == 0x200c) { return \"b\" }\r\n    else { return \"L\" }\r\n  }\r\n\r\n  var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\r\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\r\n\r\n  function BidiSpan(level, from, to) {\r\n    this.level = level;\r\n    this.from = from; this.to = to;\r\n  }\r\n\r\n  return function(str, direction) {\r\n    var outerType = direction == \"ltr\" ? \"L\" : \"R\";\r\n\r\n    if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\r\n    var len = str.length, types = [];\r\n    for (var i = 0; i < len; ++i)\r\n      { types.push(charType(str.charCodeAt(i))); }\r\n\r\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\r\n    // change the type of the NSM to the type of the previous\r\n    // character. If the NSM is at the start of the level run, it will\r\n    // get the type of sor.\r\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\r\n      var type = types[i$1];\r\n      if (type == \"m\") { types[i$1] = prev; }\r\n      else { prev = type; }\r\n    }\r\n\r\n    // W2. Search backwards from each instance of a European number\r\n    // until the first strong type (R, L, AL, or sor) is found. If an\r\n    // AL is found, change the type of the European number to Arabic\r\n    // number.\r\n    // W3. Change all ALs to R.\r\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\r\n      var type$1 = types[i$2];\r\n      if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\r\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\r\n    }\r\n\r\n    // W4. A single European separator between two European numbers\r\n    // changes to a European number. A single common separator between\r\n    // two numbers of the same type changes to that type.\r\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\r\n      var type$2 = types[i$3];\r\n      if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\r\n      else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\r\n               (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\r\n      prev$1 = type$2;\r\n    }\r\n\r\n    // W5. A sequence of European terminators adjacent to European\r\n    // numbers changes to all European numbers.\r\n    // W6. Otherwise, separators and terminators change to Other\r\n    // Neutral.\r\n    for (var i$4 = 0; i$4 < len; ++i$4) {\r\n      var type$3 = types[i$4];\r\n      if (type$3 == \",\") { types[i$4] = \"N\"; }\r\n      else if (type$3 == \"%\") {\r\n        var end = (void 0);\r\n        for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\r\n        var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\r\n        for (var j = i$4; j < end; ++j) { types[j] = replace; }\r\n        i$4 = end - 1;\r\n      }\r\n    }\r\n\r\n    // W7. Search backwards from each instance of a European number\r\n    // until the first strong type (R, L, or sor) is found. If an L is\r\n    // found, then change the type of the European number to L.\r\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\r\n      var type$4 = types[i$5];\r\n      if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\r\n      else if (isStrong.test(type$4)) { cur$1 = type$4; }\r\n    }\r\n\r\n    // N1. A sequence of neutrals takes the direction of the\r\n    // surrounding strong text if the text on both sides has the same\r\n    // direction. European and Arabic numbers act as if they were R in\r\n    // terms of their influence on neutrals. Start-of-level-run (sor)\r\n    // and end-of-level-run (eor) are used at level run boundaries.\r\n    // N2. Any remaining neutrals take the embedding direction.\r\n    for (var i$6 = 0; i$6 < len; ++i$6) {\r\n      if (isNeutral.test(types[i$6])) {\r\n        var end$1 = (void 0);\r\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\r\n        var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\r\n        var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\r\n        var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\r\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\r\n        i$6 = end$1 - 1;\r\n      }\r\n    }\r\n\r\n    // Here we depart from the documented algorithm, in order to avoid\r\n    // building up an actual levels array. Since there are only three\r\n    // levels (0, 1, 2) in an implementation that doesn't take\r\n    // explicit embedding into account, we can build up the order on\r\n    // the fly, without following the level-based algorithm.\r\n    var order = [], m;\r\n    for (var i$7 = 0; i$7 < len;) {\r\n      if (countsAsLeft.test(types[i$7])) {\r\n        var start = i$7;\r\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\r\n        order.push(new BidiSpan(0, start, i$7));\r\n      } else {\r\n        var pos = i$7, at = order.length;\r\n        for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\r\n        for (var j$2 = pos; j$2 < i$7;) {\r\n          if (countsAsNum.test(types[j$2])) {\r\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\r\n            var nstart = j$2;\r\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\r\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\r\n            pos = j$2;\r\n          } else { ++j$2; }\r\n        }\r\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\r\n      }\r\n    }\r\n    if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\r\n      order[0].from = m[0].length;\r\n      order.unshift(new BidiSpan(0, 0, m[0].length));\r\n    }\r\n    if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\r\n      lst(order).to -= m[0].length;\r\n      order.push(new BidiSpan(0, len - m[0].length, len));\r\n    }\r\n\r\n    return direction == \"rtl\" ? order.reverse() : order\r\n  }\r\n})();\r\n\r\n// Get the bidi ordering for the given line (and cache it). Returns\r\n// false for lines that are fully left-to-right, and an array of\r\n// BidiSpan objects otherwise.\r\nfunction getOrder(line, direction) {\r\n  var order = line.order;\r\n  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\r\n  return order\r\n}\r\n\r\nfunction moveCharLogically(line, ch, dir) {\r\n  var target = skipExtendingChars(line.text, ch + dir, dir);\r\n  return target < 0 || target > line.text.length ? null : target\r\n}\r\n\r\nfunction moveLogically(line, start, dir) {\r\n  var ch = moveCharLogically(line, start.ch, dir);\r\n  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\r\n}\r\n\r\nfunction endOfLine(visually, cm, lineObj, lineNo, dir) {\r\n  if (visually) {\r\n    var order = getOrder(lineObj, cm.doc.direction);\r\n    if (order) {\r\n      var part = dir < 0 ? lst(order) : order[0];\r\n      var moveInStorageOrder = (dir < 0) == (part.level == 1);\r\n      var sticky = moveInStorageOrder ? \"after\" : \"before\";\r\n      var ch;\r\n      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\r\n      // it could be that the last bidi part is not on the last visual line,\r\n      // since visual lines contain content order-consecutive chunks.\r\n      // Thus, in rtl, we are looking for the first (content-order) character\r\n      // in the rtl chunk that is on the last line (that is, the same line\r\n      // as the last (content-order) character).\r\n      if (part.level > 0) {\r\n        var prep = prepareMeasureForLine(cm, lineObj);\r\n        ch = dir < 0 ? lineObj.text.length - 1 : 0;\r\n        var targetTop = measureCharPrepared(cm, prep, ch).top;\r\n        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\r\n        if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\r\n      } else { ch = dir < 0 ? part.to : part.from; }\r\n      return new Pos(lineNo, ch, sticky)\r\n    }\r\n  }\r\n  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\r\n}\r\n\r\nfunction moveVisually(cm, line, start, dir) {\r\n  var bidi = getOrder(line, cm.doc.direction);\r\n  if (!bidi) { return moveLogically(line, start, dir) }\r\n  if (start.ch >= line.text.length) {\r\n    start.ch = line.text.length;\r\n    start.sticky = \"before\";\r\n  } else if (start.ch <= 0) {\r\n    start.ch = 0;\r\n    start.sticky = \"after\";\r\n  }\r\n  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\r\n  if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\r\n    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\r\n    // nothing interesting happens.\r\n    return moveLogically(line, start, dir)\r\n  }\r\n\r\n  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\r\n  var prep;\r\n  var getWrappedLineExtent = function (ch) {\r\n    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\r\n    prep = prep || prepareMeasureForLine(cm, line);\r\n    return wrappedLineExtentChar(cm, line, prep, ch)\r\n  };\r\n  var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\r\n\r\n  if (cm.doc.direction == \"rtl\" || part.level == 1) {\r\n    var moveInStorageOrder = (part.level == 1) == (dir < 0);\r\n    var ch = mv(start, moveInStorageOrder ? 1 : -1);\r\n    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\r\n      // Case 2: We move within an rtl part or in an rtl editor on the same visual line\r\n      var sticky = moveInStorageOrder ? \"before\" : \"after\";\r\n      return new Pos(start.line, ch, sticky)\r\n    }\r\n  }\r\n\r\n  // Case 3: Could not move within this bidi part in this visual line, so leave\r\n  // the current bidi part\r\n\r\n  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\r\n    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\r\n      ? new Pos(start.line, mv(ch, 1), \"before\")\r\n      : new Pos(start.line, ch, \"after\"); };\r\n\r\n    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\r\n      var part = bidi[partPos];\r\n      var moveInStorageOrder = (dir > 0) == (part.level != 1);\r\n      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\r\n      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\r\n      ch = moveInStorageOrder ? part.from : mv(part.to, -1);\r\n      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\r\n    }\r\n  };\r\n\r\n  // Case 3a: Look for other bidi parts on the same visual line\r\n  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\r\n  if (res) { return res }\r\n\r\n  // Case 3b: Look for other bidi parts on the next visual line\r\n  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\r\n  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\r\n    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\r\n    if (res) { return res }\r\n  }\r\n\r\n  // Case 4: Nowhere to move\r\n  return null\r\n}\r\n\r\n// EVENT HANDLING\r\n\r\n// Lightweight event framework. on/off also work on DOM nodes,\r\n// registering native DOM handlers.\r\n\r\nvar noHandlers = [];\r\n\r\nvar on = function(emitter, type, f) {\r\n  if (emitter.addEventListener) {\r\n    emitter.addEventListener(type, f, false);\r\n  } else if (emitter.attachEvent) {\r\n    emitter.attachEvent(\"on\" + type, f);\r\n  } else {\r\n    var map$$1 = emitter._handlers || (emitter._handlers = {});\r\n    map$$1[type] = (map$$1[type] || noHandlers).concat(f);\r\n  }\r\n};\r\n\r\nfunction getHandlers(emitter, type) {\r\n  return emitter._handlers && emitter._handlers[type] || noHandlers\r\n}\r\n\r\nfunction off(emitter, type, f) {\r\n  if (emitter.removeEventListener) {\r\n    emitter.removeEventListener(type, f, false);\r\n  } else if (emitter.detachEvent) {\r\n    emitter.detachEvent(\"on\" + type, f);\r\n  } else {\r\n    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\r\n    if (arr) {\r\n      var index = indexOf(arr, f);\r\n      if (index > -1)\r\n        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\r\n    }\r\n  }\r\n}\r\n\r\nfunction signal(emitter, type /*, values...*/) {\r\n  var handlers = getHandlers(emitter, type);\r\n  if (!handlers.length) { return }\r\n  var args = Array.prototype.slice.call(arguments, 2);\r\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\r\n}\r\n\r\n// The DOM events that CodeMirror handles can be overridden by\r\n// registering a (non-DOM) handler on the editor for the event name,\r\n// and preventDefault-ing the event in that handler.\r\nfunction signalDOMEvent(cm, e, override) {\r\n  if (typeof e == \"string\")\r\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\r\n  signal(cm, override || e.type, cm, e);\r\n  return e_defaultPrevented(e) || e.codemirrorIgnore\r\n}\r\n\r\nfunction signalCursorActivity(cm) {\r\n  var arr = cm._handlers && cm._handlers.cursorActivity;\r\n  if (!arr) { return }\r\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\r\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\r\n    { set.push(arr[i]); } }\r\n}\r\n\r\nfunction hasHandler(emitter, type) {\r\n  return getHandlers(emitter, type).length > 0\r\n}\r\n\r\n// Add on and off methods to a constructor's prototype, to make\r\n// registering events on such objects more convenient.\r\nfunction eventMixin(ctor) {\r\n  ctor.prototype.on = function(type, f) {on(this, type, f);};\r\n  ctor.prototype.off = function(type, f) {off(this, type, f);};\r\n}\r\n\r\n// Due to the fact that we still support jurassic IE versions, some\r\n// compatibility wrappers are needed.\r\n\r\nfunction e_preventDefault(e) {\r\n  if (e.preventDefault) { e.preventDefault(); }\r\n  else { e.returnValue = false; }\r\n}\r\nfunction e_stopPropagation(e) {\r\n  if (e.stopPropagation) { e.stopPropagation(); }\r\n  else { e.cancelBubble = true; }\r\n}\r\nfunction e_defaultPrevented(e) {\r\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\r\n}\r\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\r\n\r\nfunction e_target(e) {return e.target || e.srcElement}\r\nfunction e_button(e) {\r\n  var b = e.which;\r\n  if (b == null) {\r\n    if (e.button & 1) { b = 1; }\r\n    else if (e.button & 2) { b = 3; }\r\n    else if (e.button & 4) { b = 2; }\r\n  }\r\n  if (mac && e.ctrlKey && b == 1) { b = 3; }\r\n  return b\r\n}\r\n\r\n// Detect drag-and-drop\r\nvar dragAndDrop = function() {\r\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\r\n  // couldn't get it to work yet.\r\n  if (ie && ie_version < 9) { return false }\r\n  var div = elt('div');\r\n  return \"draggable\" in div || \"dragDrop\" in div\r\n}();\r\n\r\nvar zwspSupported;\r\nfunction zeroWidthElement(measure) {\r\n  if (zwspSupported == null) {\r\n    var test = elt(\"span\", \"\\u200b\");\r\n    removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\r\n    if (measure.firstChild.offsetHeight != 0)\r\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\r\n  }\r\n  var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\r\n    elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\r\n  node.setAttribute(\"cm-text\", \"\");\r\n  return node\r\n}\r\n\r\n// Feature-detect IE's crummy client rect reporting for bidi text\r\nvar badBidiRects;\r\nfunction hasBadBidiRects(measure) {\r\n  if (badBidiRects != null) { return badBidiRects }\r\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\r\n  var r0 = range(txt, 0, 1).getBoundingClientRect();\r\n  var r1 = range(txt, 1, 2).getBoundingClientRect();\r\n  removeChildren(measure);\r\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\r\n  return badBidiRects = (r1.right - r0.right < 3)\r\n}\r\n\r\n// See if \"\".split is the broken IE version, if so, provide an\r\n// alternative way to split lines.\r\nvar splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\r\n  var pos = 0, result = [], l = string.length;\r\n  while (pos <= l) {\r\n    var nl = string.indexOf(\"\\n\", pos);\r\n    if (nl == -1) { nl = string.length; }\r\n    var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\r\n    var rt = line.indexOf(\"\\r\");\r\n    if (rt != -1) {\r\n      result.push(line.slice(0, rt));\r\n      pos += rt + 1;\r\n    } else {\r\n      result.push(line);\r\n      pos = nl + 1;\r\n    }\r\n  }\r\n  return result\r\n} : function (string) { return string.split(/\\r\\n?|\\n/); };\r\n\r\nvar hasSelection = window.getSelection ? function (te) {\r\n  try { return te.selectionStart != te.selectionEnd }\r\n  catch(e) { return false }\r\n} : function (te) {\r\n  var range$$1;\r\n  try {range$$1 = te.ownerDocument.selection.createRange();}\r\n  catch(e) {}\r\n  if (!range$$1 || range$$1.parentElement() != te) { return false }\r\n  return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\r\n};\r\n\r\nvar hasCopyEvent = (function () {\r\n  var e = elt(\"div\");\r\n  if (\"oncopy\" in e) { return true }\r\n  e.setAttribute(\"oncopy\", \"return;\");\r\n  return typeof e.oncopy == \"function\"\r\n})();\r\n\r\nvar badZoomedRects = null;\r\nfunction hasBadZoomedRects(measure) {\r\n  if (badZoomedRects != null) { return badZoomedRects }\r\n  var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\r\n  var normal = node.getBoundingClientRect();\r\n  var fromRange = range(node, 0, 1).getBoundingClientRect();\r\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\r\n}\r\n\r\n// Known modes, by name and by MIME\r\nvar modes = {};\r\nvar mimeModes = {};\r\n\r\n// Extra arguments are stored as the mode's dependencies, which is\r\n// used by (legacy) mechanisms like loadmode.js to automatically\r\n// load a mode. (Preferred mechanism is the require/define calls.)\r\nfunction defineMode(name, mode) {\r\n  if (arguments.length > 2)\r\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\r\n  modes[name] = mode;\r\n}\r\n\r\nfunction defineMIME(mime, spec) {\r\n  mimeModes[mime] = spec;\r\n}\r\n\r\n// Given a MIME type, a {name, ...options} config object, or a name\r\n// string, return a mode config object.\r\nfunction resolveMode(spec) {\r\n  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\r\n    spec = mimeModes[spec];\r\n  } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\r\n    var found = mimeModes[spec.name];\r\n    if (typeof found == \"string\") { found = {name: found}; }\r\n    spec = createObj(found, spec);\r\n    spec.name = found.name;\r\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\r\n    return resolveMode(\"application/xml\")\r\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\r\n    return resolveMode(\"application/json\")\r\n  }\r\n  if (typeof spec == \"string\") { return {name: spec} }\r\n  else { return spec || {name: \"null\"} }\r\n}\r\n\r\n// Given a mode spec (anything that resolveMode accepts), find and\r\n// initialize an actual mode object.\r\nfunction getMode(options, spec) {\r\n  spec = resolveMode(spec);\r\n  var mfactory = modes[spec.name];\r\n  if (!mfactory) { return getMode(options, \"text/plain\") }\r\n  var modeObj = mfactory(options, spec);\r\n  if (modeExtensions.hasOwnProperty(spec.name)) {\r\n    var exts = modeExtensions[spec.name];\r\n    for (var prop in exts) {\r\n      if (!exts.hasOwnProperty(prop)) { continue }\r\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\r\n      modeObj[prop] = exts[prop];\r\n    }\r\n  }\r\n  modeObj.name = spec.name;\r\n  if (spec.helperType) { modeObj.helperType = spec.helperType; }\r\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\r\n    { modeObj[prop$1] = spec.modeProps[prop$1]; } }\r\n\r\n  return modeObj\r\n}\r\n\r\n// This can be used to attach properties to mode objects from\r\n// outside the actual mode definition.\r\nvar modeExtensions = {};\r\nfunction extendMode(mode, properties) {\r\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\r\n  copyObj(properties, exts);\r\n}\r\n\r\nfunction copyState(mode, state) {\r\n  if (state === true) { return state }\r\n  if (mode.copyState) { return mode.copyState(state) }\r\n  var nstate = {};\r\n  for (var n in state) {\r\n    var val = state[n];\r\n    if (val instanceof Array) { val = val.concat([]); }\r\n    nstate[n] = val;\r\n  }\r\n  return nstate\r\n}\r\n\r\n// Given a mode and a state (for that mode), find the inner mode and\r\n// state at the position that the state refers to.\r\nfunction innerMode(mode, state) {\r\n  var info;\r\n  while (mode.innerMode) {\r\n    info = mode.innerMode(state);\r\n    if (!info || info.mode == mode) { break }\r\n    state = info.state;\r\n    mode = info.mode;\r\n  }\r\n  return info || {mode: mode, state: state}\r\n}\r\n\r\nfunction startState(mode, a1, a2) {\r\n  return mode.startState ? mode.startState(a1, a2) : true\r\n}\r\n\r\n// STRING STREAM\r\n\r\n// Fed to the mode parsers, provides helper functions to make\r\n// parsers more succinct.\r\n\r\nvar StringStream = function(string, tabSize) {\r\n  this.pos = this.start = 0;\r\n  this.string = string;\r\n  this.tabSize = tabSize || 8;\r\n  this.lastColumnPos = this.lastColumnValue = 0;\r\n  this.lineStart = 0;\r\n};\r\n\r\nStringStream.prototype.eol = function () {return this.pos >= this.string.length};\r\nStringStream.prototype.sol = function () {return this.pos == this.lineStart};\r\nStringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\r\nStringStream.prototype.next = function () {\r\n  if (this.pos < this.string.length)\r\n    { return this.string.charAt(this.pos++) }\r\n};\r\nStringStream.prototype.eat = function (match) {\r\n  var ch = this.string.charAt(this.pos);\r\n  var ok;\r\n  if (typeof match == \"string\") { ok = ch == match; }\r\n  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\r\n  if (ok) {++this.pos; return ch}\r\n};\r\nStringStream.prototype.eatWhile = function (match) {\r\n  var start = this.pos;\r\n  while (this.eat(match)){}\r\n  return this.pos > start\r\n};\r\nStringStream.prototype.eatSpace = function () {\r\n    var this$1 = this;\r\n\r\n  var start = this.pos;\r\n  while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\r\n  return this.pos > start\r\n};\r\nStringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\r\nStringStream.prototype.skipTo = function (ch) {\r\n  var found = this.string.indexOf(ch, this.pos);\r\n  if (found > -1) {this.pos = found; return true}\r\n};\r\nStringStream.prototype.backUp = function (n) {this.pos -= n;};\r\nStringStream.prototype.column = function () {\r\n  if (this.lastColumnPos < this.start) {\r\n    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\r\n    this.lastColumnPos = this.start;\r\n  }\r\n  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\r\n};\r\nStringStream.prototype.indentation = function () {\r\n  return countColumn(this.string, null, this.tabSize) -\r\n    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\r\n};\r\nStringStream.prototype.match = function (pattern, consume, caseInsensitive) {\r\n  if (typeof pattern == \"string\") {\r\n    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\r\n    var substr = this.string.substr(this.pos, pattern.length);\r\n    if (cased(substr) == cased(pattern)) {\r\n      if (consume !== false) { this.pos += pattern.length; }\r\n      return true\r\n    }\r\n  } else {\r\n    var match = this.string.slice(this.pos).match(pattern);\r\n    if (match && match.index > 0) { return null }\r\n    if (match && consume !== false) { this.pos += match[0].length; }\r\n    return match\r\n  }\r\n};\r\nStringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\r\nStringStream.prototype.hideFirstChars = function (n, inner) {\r\n  this.lineStart += n;\r\n  try { return inner() }\r\n  finally { this.lineStart -= n; }\r\n};\r\n\r\n// Compute a style array (an array starting with a mode generation\r\n// -- for invalidation -- followed by pairs of end positions and\r\n// style strings), which is used to highlight the tokens on the\r\n// line.\r\nfunction highlightLine(cm, line, state, forceToEnd) {\r\n  // A styles array always starts with a number identifying the\r\n  // mode/overlays that it is based on (for easy invalidation).\r\n  var st = [cm.state.modeGen], lineClasses = {};\r\n  // Compute the base array of styles\r\n  runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },\r\n    lineClasses, forceToEnd);\r\n\r\n  // Run overlays, adjust style array.\r\n  var loop = function ( o ) {\r\n    var overlay = cm.state.overlays[o], i = 1, at = 0;\r\n    runMode(cm, line.text, overlay.mode, true, function (end, style) {\r\n      var start = i;\r\n      // Ensure there's a token end at the current position, and that i points at it\r\n      while (at < end) {\r\n        var i_end = st[i];\r\n        if (i_end > end)\r\n          { st.splice(i, 1, end, st[i+1], i_end); }\r\n        i += 2;\r\n        at = Math.min(end, i_end);\r\n      }\r\n      if (!style) { return }\r\n      if (overlay.opaque) {\r\n        st.splice(start, i - start, end, \"overlay \" + style);\r\n        i = start + 2;\r\n      } else {\r\n        for (; start < i; start += 2) {\r\n          var cur = st[start+1];\r\n          st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\r\n        }\r\n      }\r\n    }, lineClasses);\r\n  };\r\n\r\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\r\n\r\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\r\n}\r\n\r\nfunction getLineStyles(cm, line, updateFrontier) {\r\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\r\n    var state = getStateBefore(cm, lineNo(line));\r\n    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\r\n    line.stateAfter = state;\r\n    line.styles = result.styles;\r\n    if (result.classes) { line.styleClasses = result.classes; }\r\n    else if (line.styleClasses) { line.styleClasses = null; }\r\n    if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++; }\r\n  }\r\n  return line.styles\r\n}\r\n\r\nfunction getStateBefore(cm, n, precise) {\r\n  var doc = cm.doc, display = cm.display;\r\n  if (!doc.mode.startState) { return true }\r\n  var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\r\n  if (!state) { state = startState(doc.mode); }\r\n  else { state = copyState(doc.mode, state); }\r\n  doc.iter(pos, n, function (line) {\r\n    processLine(cm, line.text, state);\r\n    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\r\n    line.stateAfter = save ? copyState(doc.mode, state) : null;\r\n    ++pos;\r\n  });\r\n  if (precise) { doc.frontier = pos; }\r\n  return state\r\n}\r\n\r\n// Lightweight form of highlight -- proceed over this line and\r\n// update state, but don't save a style array. Used for lines that\r\n// aren't currently visible.\r\nfunction processLine(cm, text, state, startAt) {\r\n  var mode = cm.doc.mode;\r\n  var stream = new StringStream(text, cm.options.tabSize);\r\n  stream.start = stream.pos = startAt || 0;\r\n  if (text == \"\") { callBlankLine(mode, state); }\r\n  while (!stream.eol()) {\r\n    readToken(mode, stream, state);\r\n    stream.start = stream.pos;\r\n  }\r\n}\r\n\r\nfunction callBlankLine(mode, state) {\r\n  if (mode.blankLine) { return mode.blankLine(state) }\r\n  if (!mode.innerMode) { return }\r\n  var inner = innerMode(mode, state);\r\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\r\n}\r\n\r\nfunction readToken(mode, stream, state, inner) {\r\n  for (var i = 0; i < 10; i++) {\r\n    if (inner) { inner[0] = innerMode(mode, state).mode; }\r\n    var style = mode.token(stream, state);\r\n    if (stream.pos > stream.start) { return style }\r\n  }\r\n  throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\r\n}\r\n\r\n// Utility for getTokenAt and getLineTokens\r\nfunction takeToken(cm, pos, precise, asArray) {\r\n  var getObj = function (copy) { return ({\r\n    start: stream.start, end: stream.pos,\r\n    string: stream.current(),\r\n    type: style || null,\r\n    state: copy ? copyState(doc.mode, state) : state\r\n  }); };\r\n\r\n  var doc = cm.doc, mode = doc.mode, style;\r\n  pos = clipPos(doc, pos);\r\n  var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\r\n  var stream = new StringStream(line.text, cm.options.tabSize), tokens;\r\n  if (asArray) { tokens = []; }\r\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\r\n    stream.start = stream.pos;\r\n    style = readToken(mode, stream, state);\r\n    if (asArray) { tokens.push(getObj(true)); }\r\n  }\r\n  return asArray ? tokens : getObj()\r\n}\r\n\r\nfunction extractLineClasses(type, output) {\r\n  if (type) { for (;;) {\r\n    var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\r\n    if (!lineClass) { break }\r\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\r\n    var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\r\n    if (output[prop] == null)\r\n      { output[prop] = lineClass[2]; }\r\n    else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\r\n      { output[prop] += \" \" + lineClass[2]; }\r\n  } }\r\n  return type\r\n}\r\n\r\n// Run the given mode's parser over a line, calling f for each token.\r\nfunction runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\r\n  var flattenSpans = mode.flattenSpans;\r\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\r\n  var curStart = 0, curStyle = null;\r\n  var stream = new StringStream(text, cm.options.tabSize), style;\r\n  var inner = cm.options.addModeClass && [null];\r\n  if (text == \"\") { extractLineClasses(callBlankLine(mode, state), lineClasses); }\r\n  while (!stream.eol()) {\r\n    if (stream.pos > cm.options.maxHighlightLength) {\r\n      flattenSpans = false;\r\n      if (forceToEnd) { processLine(cm, text, state, stream.pos); }\r\n      stream.pos = text.length;\r\n      style = null;\r\n    } else {\r\n      style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\r\n    }\r\n    if (inner) {\r\n      var mName = inner[0].name;\r\n      if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\r\n    }\r\n    if (!flattenSpans || curStyle != style) {\r\n      while (curStart < stream.start) {\r\n        curStart = Math.min(stream.start, curStart + 5000);\r\n        f(curStart, curStyle);\r\n      }\r\n      curStyle = style;\r\n    }\r\n    stream.start = stream.pos;\r\n  }\r\n  while (curStart < stream.pos) {\r\n    // Webkit seems to refuse to render text nodes longer than 57444\r\n    // characters, and returns inaccurate measurements in nodes\r\n    // starting around 5000 chars.\r\n    var pos = Math.min(stream.pos, curStart + 5000);\r\n    f(pos, curStyle);\r\n    curStart = pos;\r\n  }\r\n}\r\n\r\n// Finds the line to start with when starting a parse. Tries to\r\n// find a line with a stateAfter, so that it can start with a\r\n// valid state. If that fails, it returns the line with the\r\n// smallest indentation, which tends to need the least context to\r\n// parse correctly.\r\nfunction findStartLine(cm, n, precise) {\r\n  var minindent, minline, doc = cm.doc;\r\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\r\n  for (var search = n; search > lim; --search) {\r\n    if (search <= doc.first) { return doc.first }\r\n    var line = getLine(doc, search - 1);\r\n    if (line.stateAfter && (!precise || search <= doc.frontier)) { return search }\r\n    var indented = countColumn(line.text, null, cm.options.tabSize);\r\n    if (minline == null || minindent > indented) {\r\n      minline = search - 1;\r\n      minindent = indented;\r\n    }\r\n  }\r\n  return minline\r\n}\r\n\r\n// LINE DATA STRUCTURE\r\n\r\n// Line objects. These hold state related to a line, including\r\n// highlighting info (the styles array).\r\nvar Line = function(text, markedSpans, estimateHeight) {\r\n  this.text = text;\r\n  attachMarkedSpans(this, markedSpans);\r\n  this.height = estimateHeight ? estimateHeight(this) : 1;\r\n};\r\n\r\nLine.prototype.lineNo = function () { return lineNo(this) };\r\neventMixin(Line);\r\n\r\n// Change the content (text, markers) of a line. Automatically\r\n// invalidates cached information and tries to re-estimate the\r\n// line's height.\r\nfunction updateLine(line, text, markedSpans, estimateHeight) {\r\n  line.text = text;\r\n  if (line.stateAfter) { line.stateAfter = null; }\r\n  if (line.styles) { line.styles = null; }\r\n  if (line.order != null) { line.order = null; }\r\n  detachMarkedSpans(line);\r\n  attachMarkedSpans(line, markedSpans);\r\n  var estHeight = estimateHeight ? estimateHeight(line) : 1;\r\n  if (estHeight != line.height) { updateLineHeight(line, estHeight); }\r\n}\r\n\r\n// Detach a line from the document tree and its markers.\r\nfunction cleanUpLine(line) {\r\n  line.parent = null;\r\n  detachMarkedSpans(line);\r\n}\r\n\r\n// Convert a style as returned by a mode (either null, or a string\r\n// containing one or more styles) to a CSS style. This is cached,\r\n// and also looks for line-wide styles.\r\nvar styleToClassCache = {};\r\nvar styleToClassCacheWithMode = {};\r\nfunction interpretTokenStyle(style, options) {\r\n  if (!style || /^\\s*$/.test(style)) { return null }\r\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\r\n  return cache[style] ||\r\n    (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\r\n}\r\n\r\n// Render the DOM representation of the text of a line. Also builds\r\n// up a 'line map', which points at the DOM nodes that represent\r\n// specific stretches of text, and is used by the measuring code.\r\n// The returned object contains the DOM node, this map, and\r\n// information about line-wide styles that were set by the mode.\r\nfunction buildLineContent(cm, lineView) {\r\n  // The padding-right forces the element to have a 'border', which\r\n  // is needed on Webkit to be able to get line-level bounding\r\n  // rectangles for it (in measureChar).\r\n  var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\r\n  var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\r\n                 col: 0, pos: 0, cm: cm,\r\n                 trailingSpace: false,\r\n                 splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\r\n  lineView.measure = {};\r\n\r\n  // Iterate over the logical lines that make up this visual line.\r\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\r\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\r\n    builder.pos = 0;\r\n    builder.addToken = buildToken;\r\n    // Optionally wire in some hacks into the token-rendering\r\n    // algorithm, to deal with browser quirks.\r\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\r\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\r\n    builder.map = [];\r\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\r\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\r\n    if (line.styleClasses) {\r\n      if (line.styleClasses.bgClass)\r\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\r\n      if (line.styleClasses.textClass)\r\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\r\n    }\r\n\r\n    // Ensure at least a single node is present, for measuring.\r\n    if (builder.map.length == 0)\r\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\r\n\r\n    // Store the map and a cache object for the current logical line\r\n    if (i == 0) {\r\n      lineView.measure.map = builder.map;\r\n      lineView.measure.cache = {};\r\n    } else {\r\n      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\r\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\r\n    }\r\n  }\r\n\r\n  // See issue #2901\r\n  if (webkit) {\r\n    var last = builder.content.lastChild;\r\n    if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\r\n      { builder.content.className = \"cm-tab-wrap-hack\"; }\r\n  }\r\n\r\n  signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\r\n  if (builder.pre.className)\r\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\r\n\r\n  return builder\r\n}\r\n\r\nfunction defaultSpecialCharPlaceholder(ch) {\r\n  var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\r\n  token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\r\n  token.setAttribute(\"aria-label\", token.title);\r\n  return token\r\n}\r\n\r\n// Build up the DOM representation for a single token, and add it to\r\n// the line map. Takes care to render special characters separately.\r\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\r\n  if (!text) { return }\r\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\r\n  var special = builder.cm.state.specialChars, mustWrap = false;\r\n  var content;\r\n  if (!special.test(text)) {\r\n    builder.col += text.length;\r\n    content = document.createTextNode(displayText);\r\n    builder.map.push(builder.pos, builder.pos + text.length, content);\r\n    if (ie && ie_version < 9) { mustWrap = true; }\r\n    builder.pos += text.length;\r\n  } else {\r\n    content = document.createDocumentFragment();\r\n    var pos = 0;\r\n    while (true) {\r\n      special.lastIndex = pos;\r\n      var m = special.exec(text);\r\n      var skipped = m ? m.index - pos : text.length - pos;\r\n      if (skipped) {\r\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\r\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\r\n        else { content.appendChild(txt); }\r\n        builder.map.push(builder.pos, builder.pos + skipped, txt);\r\n        builder.col += skipped;\r\n        builder.pos += skipped;\r\n      }\r\n      if (!m) { break }\r\n      pos += skipped + 1;\r\n      var txt$1 = (void 0);\r\n      if (m[0] == \"\\t\") {\r\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\r\n        txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\r\n        txt$1.setAttribute(\"role\", \"presentation\");\r\n        txt$1.setAttribute(\"cm-text\", \"\\t\");\r\n        builder.col += tabWidth;\r\n      } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\r\n        txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\r\n        txt$1.setAttribute(\"cm-text\", m[0]);\r\n        builder.col += 1;\r\n      } else {\r\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\r\n        txt$1.setAttribute(\"cm-text\", m[0]);\r\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\r\n        else { content.appendChild(txt$1); }\r\n        builder.col += 1;\r\n      }\r\n      builder.map.push(builder.pos, builder.pos + 1, txt$1);\r\n      builder.pos++;\r\n    }\r\n  }\r\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\r\n  if (style || startStyle || endStyle || mustWrap || css) {\r\n    var fullStyle = style || \"\";\r\n    if (startStyle) { fullStyle += startStyle; }\r\n    if (endStyle) { fullStyle += endStyle; }\r\n    var token = elt(\"span\", [content], fullStyle, css);\r\n    if (title) { token.title = title; }\r\n    return builder.content.appendChild(token)\r\n  }\r\n  builder.content.appendChild(content);\r\n}\r\n\r\nfunction splitSpaces(text, trailingBefore) {\r\n  if (text.length > 1 && !/  /.test(text)) { return text }\r\n  var spaceBefore = trailingBefore, result = \"\";\r\n  for (var i = 0; i < text.length; i++) {\r\n    var ch = text.charAt(i);\r\n    if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\r\n      { ch = \"\\u00a0\"; }\r\n    result += ch;\r\n    spaceBefore = ch == \" \";\r\n  }\r\n  return result\r\n}\r\n\r\n// Work around nonsense dimensions being reported for stretches of\r\n// right-to-left text.\r\nfunction buildTokenBadBidi(inner, order) {\r\n  return function (builder, text, style, startStyle, endStyle, title, css) {\r\n    style = style ? style + \" cm-force-border\" : \"cm-force-border\";\r\n    var start = builder.pos, end = start + text.length;\r\n    for (;;) {\r\n      // Find the part that overlaps with the start of this text\r\n      var part = (void 0);\r\n      for (var i = 0; i < order.length; i++) {\r\n        part = order[i];\r\n        if (part.to > start && part.from <= start) { break }\r\n      }\r\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\r\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\r\n      startStyle = null;\r\n      text = text.slice(part.to - start);\r\n      start = part.to;\r\n    }\r\n  }\r\n}\r\n\r\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\r\n  var widget = !ignoreWidget && marker.widgetNode;\r\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\r\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\r\n    if (!widget)\r\n      { widget = builder.content.appendChild(document.createElement(\"span\")); }\r\n    widget.setAttribute(\"cm-marker\", marker.id);\r\n  }\r\n  if (widget) {\r\n    builder.cm.display.input.setUneditable(widget);\r\n    builder.content.appendChild(widget);\r\n  }\r\n  builder.pos += size;\r\n  builder.trailingSpace = false;\r\n}\r\n\r\n// Outputs a number of spans to make up a line, taking highlighting\r\n// and marked text into account.\r\nfunction insertLineContent(line, builder, styles) {\r\n  var spans = line.markedSpans, allText = line.text, at = 0;\r\n  if (!spans) {\r\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\r\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\r\n    return\r\n  }\r\n\r\n  var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\r\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\r\n  for (;;) {\r\n    if (nextChange == pos) { // Update current marker set\r\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\r\n      collapsed = null; nextChange = Infinity;\r\n      var foundBookmarks = [], endStyles = (void 0);\r\n      for (var j = 0; j < spans.length; ++j) {\r\n        var sp = spans[j], m = sp.marker;\r\n        if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\r\n          foundBookmarks.push(m);\r\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\r\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\r\n            nextChange = sp.to;\r\n            spanEndStyle = \"\";\r\n          }\r\n          if (m.className) { spanStyle += \" \" + m.className; }\r\n          if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\r\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\r\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\r\n          if (m.title && !title) { title = m.title; }\r\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\r\n            { collapsed = sp; }\r\n        } else if (sp.from > pos && nextChange > sp.from) {\r\n          nextChange = sp.from;\r\n        }\r\n      }\r\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\r\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\r\n\r\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\r\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\r\n      if (collapsed && (collapsed.from || 0) == pos) {\r\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\r\n                           collapsed.marker, collapsed.from == null);\r\n        if (collapsed.to == null) { return }\r\n        if (collapsed.to == pos) { collapsed = false; }\r\n      }\r\n    }\r\n    if (pos >= len) { break }\r\n\r\n    var upto = Math.min(len, nextChange);\r\n    while (true) {\r\n      if (text) {\r\n        var end = pos + text.length;\r\n        if (!collapsed) {\r\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text;\r\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\r\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\r\n        }\r\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\r\n        pos = end;\r\n        spanStartStyle = \"\";\r\n      }\r\n      text = allText.slice(at, at = styles[i++]);\r\n      style = interpretTokenStyle(styles[i++], builder.cm.options);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n// These objects are used to represent the visible (currently drawn)\r\n// part of the document. A LineView may correspond to multiple\r\n// logical lines, if those are connected by collapsed ranges.\r\nfunction LineView(doc, line, lineN) {\r\n  // The starting line\r\n  this.line = line;\r\n  // Continuing lines, if any\r\n  this.rest = visualLineContinued(line);\r\n  // Number of logical lines in this visual line\r\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\r\n  this.node = this.text = null;\r\n  this.hidden = lineIsHidden(doc, line);\r\n}\r\n\r\n// Create a range of LineView objects for the given lines.\r\nfunction buildViewArray(cm, from, to) {\r\n  var array = [], nextPos;\r\n  for (var pos = from; pos < to; pos = nextPos) {\r\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\r\n    nextPos = pos + view.size;\r\n    array.push(view);\r\n  }\r\n  return array\r\n}\r\n\r\nvar operationGroup = null;\r\n\r\nfunction pushOperation(op) {\r\n  if (operationGroup) {\r\n    operationGroup.ops.push(op);\r\n  } else {\r\n    op.ownsGroup = operationGroup = {\r\n      ops: [op],\r\n      delayedCallbacks: []\r\n    };\r\n  }\r\n}\r\n\r\nfunction fireCallbacksForOps(group) {\r\n  // Calls delayed callbacks and cursorActivity handlers until no\r\n  // new ones appear\r\n  var callbacks = group.delayedCallbacks, i = 0;\r\n  do {\r\n    for (; i < callbacks.length; i++)\r\n      { callbacks[i].call(null); }\r\n    for (var j = 0; j < group.ops.length; j++) {\r\n      var op = group.ops[j];\r\n      if (op.cursorActivityHandlers)\r\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\r\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\r\n    }\r\n  } while (i < callbacks.length)\r\n}\r\n\r\nfunction finishOperation(op, endCb) {\r\n  var group = op.ownsGroup;\r\n  if (!group) { return }\r\n\r\n  try { fireCallbacksForOps(group); }\r\n  finally {\r\n    operationGroup = null;\r\n    endCb(group);\r\n  }\r\n}\r\n\r\nvar orphanDelayedCallbacks = null;\r\n\r\n// Often, we want to signal events at a point where we are in the\r\n// middle of some work, but don't want the handler to start calling\r\n// other methods on the editor, which might be in an inconsistent\r\n// state or simply not expect any other events to happen.\r\n// signalLater looks whether there are any handlers, and schedules\r\n// them to be executed when the last operation ends, or, if no\r\n// operation is active, when a timeout fires.\r\nfunction signalLater(emitter, type /*, values...*/) {\r\n  var arr = getHandlers(emitter, type);\r\n  if (!arr.length) { return }\r\n  var args = Array.prototype.slice.call(arguments, 2), list;\r\n  if (operationGroup) {\r\n    list = operationGroup.delayedCallbacks;\r\n  } else if (orphanDelayedCallbacks) {\r\n    list = orphanDelayedCallbacks;\r\n  } else {\r\n    list = orphanDelayedCallbacks = [];\r\n    setTimeout(fireOrphanDelayed, 0);\r\n  }\r\n  var loop = function ( i ) {\r\n    list.push(function () { return arr[i].apply(null, args); });\r\n  };\r\n\r\n  for (var i = 0; i < arr.length; ++i)\r\n    loop( i );\r\n}\r\n\r\nfunction fireOrphanDelayed() {\r\n  var delayed = orphanDelayedCallbacks;\r\n  orphanDelayedCallbacks = null;\r\n  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\r\n}\r\n\r\n// When an aspect of a line changes, a string is added to\r\n// lineView.changes. This updates the relevant part of the line's\r\n// DOM structure.\r\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\r\n  for (var j = 0; j < lineView.changes.length; j++) {\r\n    var type = lineView.changes[j];\r\n    if (type == \"text\") { updateLineText(cm, lineView); }\r\n    else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\r\n    else if (type == \"class\") { updateLineClasses(cm, lineView); }\r\n    else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\r\n  }\r\n  lineView.changes = null;\r\n}\r\n\r\n// Lines with gutter elements, widgets or a background class need to\r\n// be wrapped, and have the extra elements added to the wrapper div\r\nfunction ensureLineWrapped(lineView) {\r\n  if (lineView.node == lineView.text) {\r\n    lineView.node = elt(\"div\", null, null, \"position: relative\");\r\n    if (lineView.text.parentNode)\r\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\r\n    lineView.node.appendChild(lineView.text);\r\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\r\n  }\r\n  return lineView.node\r\n}\r\n\r\nfunction updateLineBackground(cm, lineView) {\r\n  var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\r\n  if (cls) { cls += \" CodeMirror-linebackground\"; }\r\n  if (lineView.background) {\r\n    if (cls) { lineView.background.className = cls; }\r\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\r\n  } else if (cls) {\r\n    var wrap = ensureLineWrapped(lineView);\r\n    lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\r\n    cm.display.input.setUneditable(lineView.background);\r\n  }\r\n}\r\n\r\n// Wrapper around buildLineContent which will reuse the structure\r\n// in display.externalMeasured when possible.\r\nfunction getLineContent(cm, lineView) {\r\n  var ext = cm.display.externalMeasured;\r\n  if (ext && ext.line == lineView.line) {\r\n    cm.display.externalMeasured = null;\r\n    lineView.measure = ext.measure;\r\n    return ext.built\r\n  }\r\n  return buildLineContent(cm, lineView)\r\n}\r\n\r\n// Redraw the line's text. Interacts with the background and text\r\n// classes because the mode may output tokens that influence these\r\n// classes.\r\nfunction updateLineText(cm, lineView) {\r\n  var cls = lineView.text.className;\r\n  var built = getLineContent(cm, lineView);\r\n  if (lineView.text == lineView.node) { lineView.node = built.pre; }\r\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text);\r\n  lineView.text = built.pre;\r\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\r\n    lineView.bgClass = built.bgClass;\r\n    lineView.textClass = built.textClass;\r\n    updateLineClasses(cm, lineView);\r\n  } else if (cls) {\r\n    lineView.text.className = cls;\r\n  }\r\n}\r\n\r\nfunction updateLineClasses(cm, lineView) {\r\n  updateLineBackground(cm, lineView);\r\n  if (lineView.line.wrapClass)\r\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\r\n  else if (lineView.node != lineView.text)\r\n    { lineView.node.className = \"\"; }\r\n  var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\r\n  lineView.text.className = textClass || \"\";\r\n}\r\n\r\nfunction updateLineGutter(cm, lineView, lineN, dims) {\r\n  if (lineView.gutter) {\r\n    lineView.node.removeChild(lineView.gutter);\r\n    lineView.gutter = null;\r\n  }\r\n  if (lineView.gutterBackground) {\r\n    lineView.node.removeChild(lineView.gutterBackground);\r\n    lineView.gutterBackground = null;\r\n  }\r\n  if (lineView.line.gutterClass) {\r\n    var wrap = ensureLineWrapped(lineView);\r\n    lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\r\n                                    (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\r\n    cm.display.input.setUneditable(lineView.gutterBackground);\r\n    wrap.insertBefore(lineView.gutterBackground, lineView.text);\r\n  }\r\n  var markers = lineView.line.gutterMarkers;\r\n  if (cm.options.lineNumbers || markers) {\r\n    var wrap$1 = ensureLineWrapped(lineView);\r\n    var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\r\n    cm.display.input.setUneditable(gutterWrap);\r\n    wrap$1.insertBefore(gutterWrap, lineView.text);\r\n    if (lineView.line.gutterClass)\r\n      { gutterWrap.className += \" \" + lineView.line.gutterClass; }\r\n    if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\r\n      { lineView.lineNumber = gutterWrap.appendChild(\r\n        elt(\"div\", lineNumberFor(cm.options, lineN),\r\n            \"CodeMirror-linenumber CodeMirror-gutter-elt\",\r\n            (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\r\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\r\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\r\n      if (found)\r\n        { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\r\n                                   (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\r\n    } }\r\n  }\r\n}\r\n\r\nfunction updateLineWidgets(cm, lineView, dims) {\r\n  if (lineView.alignable) { lineView.alignable = null; }\r\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\r\n    next = node.nextSibling;\r\n    if (node.className == \"CodeMirror-linewidget\")\r\n      { lineView.node.removeChild(node); }\r\n  }\r\n  insertLineWidgets(cm, lineView, dims);\r\n}\r\n\r\n// Build a line's DOM representation from scratch\r\nfunction buildLineElement(cm, lineView, lineN, dims) {\r\n  var built = getLineContent(cm, lineView);\r\n  lineView.text = lineView.node = built.pre;\r\n  if (built.bgClass) { lineView.bgClass = built.bgClass; }\r\n  if (built.textClass) { lineView.textClass = built.textClass; }\r\n\r\n  updateLineClasses(cm, lineView);\r\n  updateLineGutter(cm, lineView, lineN, dims);\r\n  insertLineWidgets(cm, lineView, dims);\r\n  return lineView.node\r\n}\r\n\r\n// A lineView may contain multiple logical lines (when merged by\r\n// collapsed spans). The widgets for all of them need to be drawn.\r\nfunction insertLineWidgets(cm, lineView, dims) {\r\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\r\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\r\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\r\n}\r\n\r\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\r\n  if (!line.widgets) { return }\r\n  var wrap = ensureLineWrapped(lineView);\r\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\r\n    var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\r\n    if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\r\n    positionLineWidget(widget, node, lineView, dims);\r\n    cm.display.input.setUneditable(node);\r\n    if (allowAbove && widget.above)\r\n      { wrap.insertBefore(node, lineView.gutter || lineView.text); }\r\n    else\r\n      { wrap.appendChild(node); }\r\n    signalLater(widget, \"redraw\");\r\n  }\r\n}\r\n\r\nfunction positionLineWidget(widget, node, lineView, dims) {\r\n  if (widget.noHScroll) {\r\n    (lineView.alignable || (lineView.alignable = [])).push(node);\r\n    var width = dims.wrapperWidth;\r\n    node.style.left = dims.fixedPos + \"px\";\r\n    if (!widget.coverGutter) {\r\n      width -= dims.gutterTotalWidth;\r\n      node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\r\n    }\r\n    node.style.width = width + \"px\";\r\n  }\r\n  if (widget.coverGutter) {\r\n    node.style.zIndex = 5;\r\n    node.style.position = \"relative\";\r\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\r\n  }\r\n}\r\n\r\nfunction widgetHeight(widget) {\r\n  if (widget.height != null) { return widget.height }\r\n  var cm = widget.doc.cm;\r\n  if (!cm) { return 0 }\r\n  if (!contains(document.body, widget.node)) {\r\n    var parentStyle = \"position: relative;\";\r\n    if (widget.coverGutter)\r\n      { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\r\n    if (widget.noHScroll)\r\n      { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\r\n    removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\r\n  }\r\n  return widget.height = widget.node.parentNode.offsetHeight\r\n}\r\n\r\n// Return true when the given mouse event happened in a widget\r\nfunction eventInWidget(display, e) {\r\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\r\n    if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\r\n        (n.parentNode == display.sizer && n != display.mover))\r\n      { return true }\r\n  }\r\n}\r\n\r\n// POSITION MEASUREMENT\r\n\r\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\r\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\r\nfunction paddingH(display) {\r\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\r\n  var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\r\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\r\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\r\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\r\n  return data\r\n}\r\n\r\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\r\nfunction displayWidth(cm) {\r\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\r\n}\r\nfunction displayHeight(cm) {\r\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\r\n}\r\n\r\n// Ensure the lineView.wrapping.heights array is populated. This is\r\n// an array of bottom offsets for the lines that make up a drawn\r\n// line. When lineWrapping is on, there might be more than one\r\n// height.\r\nfunction ensureLineHeights(cm, lineView, rect) {\r\n  var wrapping = cm.options.lineWrapping;\r\n  var curWidth = wrapping && displayWidth(cm);\r\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\r\n    var heights = lineView.measure.heights = [];\r\n    if (wrapping) {\r\n      lineView.measure.width = curWidth;\r\n      var rects = lineView.text.firstChild.getClientRects();\r\n      for (var i = 0; i < rects.length - 1; i++) {\r\n        var cur = rects[i], next = rects[i + 1];\r\n        if (Math.abs(cur.bottom - next.bottom) > 2)\r\n          { heights.push((cur.bottom + next.top) / 2 - rect.top); }\r\n      }\r\n    }\r\n    heights.push(rect.bottom - rect.top);\r\n  }\r\n}\r\n\r\n// Find a line map (mapping character offsets to text nodes) and a\r\n// measurement cache for the given line number. (A line view might\r\n// contain multiple lines when collapsed ranges are present.)\r\nfunction mapFromLineView(lineView, line, lineN) {\r\n  if (lineView.line == line)\r\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\r\n  for (var i = 0; i < lineView.rest.length; i++)\r\n    { if (lineView.rest[i] == line)\r\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\r\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\r\n    { if (lineNo(lineView.rest[i$1]) > lineN)\r\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\r\n}\r\n\r\n// Render a line into the hidden node display.externalMeasured. Used\r\n// when measurement is needed for a line that's not in the viewport.\r\nfunction updateExternalMeasurement(cm, line) {\r\n  line = visualLine(line);\r\n  var lineN = lineNo(line);\r\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\r\n  view.lineN = lineN;\r\n  var built = view.built = buildLineContent(cm, view);\r\n  view.text = built.pre;\r\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\r\n  return view\r\n}\r\n\r\n// Get a {top, bottom, left, right} box (in line-local coordinates)\r\n// for a given character.\r\nfunction measureChar(cm, line, ch, bias) {\r\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\r\n}\r\n\r\n// Find a line view that corresponds to the given line number.\r\nfunction findViewForLine(cm, lineN) {\r\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\r\n    { return cm.display.view[findViewIndex(cm, lineN)] }\r\n  var ext = cm.display.externalMeasured;\r\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\r\n    { return ext }\r\n}\r\n\r\n// Measurement can be split in two steps, the set-up work that\r\n// applies to the whole line, and the measurement of the actual\r\n// character. Functions like coordsChar, that need to do a lot of\r\n// measurements in a row, can thus ensure that the set-up work is\r\n// only done once.\r\nfunction prepareMeasureForLine(cm, line) {\r\n  var lineN = lineNo(line);\r\n  var view = findViewForLine(cm, lineN);\r\n  if (view && !view.text) {\r\n    view = null;\r\n  } else if (view && view.changes) {\r\n    updateLineForChanges(cm, view, lineN, getDimensions(cm));\r\n    cm.curOp.forceUpdate = true;\r\n  }\r\n  if (!view)\r\n    { view = updateExternalMeasurement(cm, line); }\r\n\r\n  var info = mapFromLineView(view, line, lineN);\r\n  return {\r\n    line: line, view: view, rect: null,\r\n    map: info.map, cache: info.cache, before: info.before,\r\n    hasHeights: false\r\n  }\r\n}\r\n\r\n// Given a prepared measurement object, measures the position of an\r\n// actual character (or fetches it from the cache).\r\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\r\n  if (prepared.before) { ch = -1; }\r\n  var key = ch + (bias || \"\"), found;\r\n  if (prepared.cache.hasOwnProperty(key)) {\r\n    found = prepared.cache[key];\r\n  } else {\r\n    if (!prepared.rect)\r\n      { prepared.rect = prepared.view.text.getBoundingClientRect(); }\r\n    if (!prepared.hasHeights) {\r\n      ensureLineHeights(cm, prepared.view, prepared.rect);\r\n      prepared.hasHeights = true;\r\n    }\r\n    found = measureCharInner(cm, prepared, ch, bias);\r\n    if (!found.bogus) { prepared.cache[key] = found; }\r\n  }\r\n  return {left: found.left, right: found.right,\r\n          top: varHeight ? found.rtop : found.top,\r\n          bottom: varHeight ? found.rbottom : found.bottom}\r\n}\r\n\r\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0};\r\n\r\nfunction nodeAndOffsetInLineMap(map$$1, ch, bias) {\r\n  var node, start, end, collapse, mStart, mEnd;\r\n  // First, search the line map for the text node corresponding to,\r\n  // or closest to, the target character.\r\n  for (var i = 0; i < map$$1.length; i += 3) {\r\n    mStart = map$$1[i];\r\n    mEnd = map$$1[i + 1];\r\n    if (ch < mStart) {\r\n      start = 0; end = 1;\r\n      collapse = \"left\";\r\n    } else if (ch < mEnd) {\r\n      start = ch - mStart;\r\n      end = start + 1;\r\n    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\r\n      end = mEnd - mStart;\r\n      start = end - 1;\r\n      if (ch >= mEnd) { collapse = \"right\"; }\r\n    }\r\n    if (start != null) {\r\n      node = map$$1[i + 2];\r\n      if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\r\n        { collapse = bias; }\r\n      if (bias == \"left\" && start == 0)\r\n        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\r\n          node = map$$1[(i -= 3) + 2];\r\n          collapse = \"left\";\r\n        } }\r\n      if (bias == \"right\" && start == mEnd - mStart)\r\n        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\r\n          node = map$$1[(i += 3) + 2];\r\n          collapse = \"right\";\r\n        } }\r\n      break\r\n    }\r\n  }\r\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\r\n}\r\n\r\nfunction getUsefulRect(rects, bias) {\r\n  var rect = nullRect;\r\n  if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\r\n    if ((rect = rects[i]).left != rect.right) { break }\r\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\r\n    if ((rect = rects[i$1]).left != rect.right) { break }\r\n  } }\r\n  return rect\r\n}\r\n\r\nfunction measureCharInner(cm, prepared, ch, bias) {\r\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\r\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\r\n\r\n  var rect;\r\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\r\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\r\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\r\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\r\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\r\n        { rect = node.parentNode.getBoundingClientRect(); }\r\n      else\r\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\r\n      if (rect.left || rect.right || start == 0) { break }\r\n      end = start;\r\n      start = start - 1;\r\n      collapse = \"right\";\r\n    }\r\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\r\n  } else { // If it is a widget, simply get the box for the whole widget.\r\n    if (start > 0) { collapse = bias = \"right\"; }\r\n    var rects;\r\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\r\n      { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\r\n    else\r\n      { rect = node.getBoundingClientRect(); }\r\n  }\r\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\r\n    var rSpan = node.parentNode.getClientRects()[0];\r\n    if (rSpan)\r\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\r\n    else\r\n      { rect = nullRect; }\r\n  }\r\n\r\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\r\n  var mid = (rtop + rbot) / 2;\r\n  var heights = prepared.view.measure.heights;\r\n  var i = 0;\r\n  for (; i < heights.length - 1; i++)\r\n    { if (mid < heights[i]) { break } }\r\n  var top = i ? heights[i - 1] : 0, bot = heights[i];\r\n  var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\r\n                right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\r\n                top: top, bottom: bot};\r\n  if (!rect.left && !rect.right) { result.bogus = true; }\r\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\r\n\r\n  return result\r\n}\r\n\r\n// Work around problem with bounding client rects on ranges being\r\n// returned incorrectly when zoomed on IE10 and below.\r\nfunction maybeUpdateRectForZooming(measure, rect) {\r\n  if (!window.screen || screen.logicalXDPI == null ||\r\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\r\n    { return rect }\r\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI;\r\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI;\r\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\r\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\r\n}\r\n\r\nfunction clearLineMeasurementCacheFor(lineView) {\r\n  if (lineView.measure) {\r\n    lineView.measure.cache = {};\r\n    lineView.measure.heights = null;\r\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\r\n      { lineView.measure.caches[i] = {}; } }\r\n  }\r\n}\r\n\r\nfunction clearLineMeasurementCache(cm) {\r\n  cm.display.externalMeasure = null;\r\n  removeChildren(cm.display.lineMeasure);\r\n  for (var i = 0; i < cm.display.view.length; i++)\r\n    { clearLineMeasurementCacheFor(cm.display.view[i]); }\r\n}\r\n\r\nfunction clearCaches(cm) {\r\n  clearLineMeasurementCache(cm);\r\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\r\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\r\n  cm.display.lineNumChars = null;\r\n}\r\n\r\nfunction pageScrollX() {\r\n  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\r\n  // which causes page_Offset and bounding client rects to use\r\n  // different reference viewports and invalidate our calculations.\r\n  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\r\n  return window.pageXOffset || (document.documentElement || document.body).scrollLeft\r\n}\r\nfunction pageScrollY() {\r\n  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\r\n  return window.pageYOffset || (document.documentElement || document.body).scrollTop\r\n}\r\n\r\n// Converts a {top, bottom, left, right} box from line-local\r\n// coordinates into another coordinate system. Context may be one of\r\n// \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\r\n// or \"page\".\r\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\r\n  if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {\r\n    var size = widgetHeight(lineObj.widgets[i]);\r\n    rect.top += size; rect.bottom += size;\r\n  } } }\r\n  if (context == \"line\") { return rect }\r\n  if (!context) { context = \"local\"; }\r\n  var yOff = heightAtLine(lineObj);\r\n  if (context == \"local\") { yOff += paddingTop(cm.display); }\r\n  else { yOff -= cm.display.viewOffset; }\r\n  if (context == \"page\" || context == \"window\") {\r\n    var lOff = cm.display.lineSpace.getBoundingClientRect();\r\n    yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\r\n    var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\r\n    rect.left += xOff; rect.right += xOff;\r\n  }\r\n  rect.top += yOff; rect.bottom += yOff;\r\n  return rect\r\n}\r\n\r\n// Coverts a box from \"div\" coords to another coordinate system.\r\n// Context may be \"window\", \"page\", \"div\", or \"local\"./null.\r\nfunction fromCoordSystem(cm, coords, context) {\r\n  if (context == \"div\") { return coords }\r\n  var left = coords.left, top = coords.top;\r\n  // First move into \"page\" coordinate system\r\n  if (context == \"page\") {\r\n    left -= pageScrollX();\r\n    top -= pageScrollY();\r\n  } else if (context == \"local\" || !context) {\r\n    var localBox = cm.display.sizer.getBoundingClientRect();\r\n    left += localBox.left;\r\n    top += localBox.top;\r\n  }\r\n\r\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\r\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\r\n}\r\n\r\nfunction charCoords(cm, pos, context, lineObj, bias) {\r\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\r\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\r\n}\r\n\r\n// Returns a box for a given cursor position, which may have an\r\n// 'other' property containing the position of the secondary cursor\r\n// on a bidi boundary.\r\n// A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\r\n// and after `char - 1` in writing order of `char - 1`\r\n// A cursor Pos(line, char, \"after\") is on the same visual line as `char`\r\n// and before `char` in writing order of `char`\r\n// Examples (upper-case letters are RTL, lower-case are LTR):\r\n//     Pos(0, 1, ...)\r\n//     before   after\r\n// ab     a|b     a|b\r\n// aB     a|B     aB|\r\n// Ab     |Ab     A|b\r\n// AB     B|A     B|A\r\n// Every position after the last character on a line is considered to stick\r\n// to the last character on the line.\r\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\r\n  lineObj = lineObj || getLine(cm.doc, pos.line);\r\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\r\n  function get(ch, right) {\r\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\r\n    if (right) { m.left = m.right; } else { m.right = m.left; }\r\n    return intoCoordSystem(cm, lineObj, m, context)\r\n  }\r\n  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\r\n  if (ch >= lineObj.text.length) {\r\n    ch = lineObj.text.length;\r\n    sticky = \"before\";\r\n  } else if (ch <= 0) {\r\n    ch = 0;\r\n    sticky = \"after\";\r\n  }\r\n  if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\r\n\r\n  function getBidi(ch, partPos, invert) {\r\n    var part = order[partPos], right = (part.level % 2) != 0;\r\n    return get(invert ? ch - 1 : ch, right != invert)\r\n  }\r\n  var partPos = getBidiPartAt(order, ch, sticky);\r\n  var other = bidiOther;\r\n  var val = getBidi(ch, partPos, sticky == \"before\");\r\n  if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\r\n  return val\r\n}\r\n\r\n// Used to cheaply estimate the coordinates for a position. Used for\r\n// intermediate scroll updates.\r\nfunction estimateCoords(cm, pos) {\r\n  var left = 0;\r\n  pos = clipPos(cm.doc, pos);\r\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\r\n  var lineObj = getLine(cm.doc, pos.line);\r\n  var top = heightAtLine(lineObj) + paddingTop(cm.display);\r\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\r\n}\r\n\r\n// Positions returned by coordsChar contain some extra information.\r\n// xRel is the relative x position of the input coordinates compared\r\n// to the found position (so xRel > 0 means the coordinates are to\r\n// the right of the character position, for example). When outside\r\n// is true, that means the coordinates lie outside the line's\r\n// vertical range.\r\nfunction PosWithInfo(line, ch, sticky, outside, xRel) {\r\n  var pos = Pos(line, ch, sticky);\r\n  pos.xRel = xRel;\r\n  if (outside) { pos.outside = true; }\r\n  return pos\r\n}\r\n\r\n// Compute the character position closest to the given coordinates.\r\n// Input must be lineSpace-local (\"div\" coordinate system).\r\nfunction coordsChar(cm, x, y) {\r\n  var doc = cm.doc;\r\n  y += cm.display.viewOffset;\r\n  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\r\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\r\n  if (lineN > last)\r\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\r\n  if (x < 0) { x = 0; }\r\n\r\n  var lineObj = getLine(doc, lineN);\r\n  for (;;) {\r\n    var found = coordsCharInner(cm, lineObj, lineN, x, y);\r\n    var merged = collapsedSpanAtEnd(lineObj);\r\n    var mergedPos = merged && merged.find(0, true);\r\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\r\n      { lineN = lineNo(lineObj = mergedPos.to.line); }\r\n    else\r\n      { return found }\r\n  }\r\n}\r\n\r\nfunction wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\r\n  var measure = function (ch) { return intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \"line\"); };\r\n  var end = lineObj.text.length;\r\n  var begin = findFirst(function (ch) { return measure(ch - 1).bottom <= y; }, end, 0);\r\n  end = findFirst(function (ch) { return measure(ch).top > y; }, begin, end);\r\n  return {begin: begin, end: end}\r\n}\r\n\r\nfunction wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\r\n  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\r\n  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\r\n}\r\n\r\nfunction coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\r\n  y -= heightAtLine(lineObj);\r\n  var begin = 0, end = lineObj.text.length;\r\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj);\r\n  var pos;\r\n  var order = getOrder(lineObj, cm.doc.direction);\r\n  if (order) {\r\n    if (cm.options.lineWrapping) {\r\n      var assign;\r\n      ((assign = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = assign.begin, end = assign.end, assign));\r\n    }\r\n    pos = new Pos(lineNo$$1, begin);\r\n    var beginLeft = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure).left;\r\n    var dir = beginLeft < x ? 1 : -1;\r\n    var prevDiff, diff = beginLeft - x, prevPos;\r\n    do {\r\n      prevDiff = diff;\r\n      prevPos = pos;\r\n      pos = moveVisually(cm, lineObj, pos, dir);\r\n      if (pos == null || pos.ch < begin || end <= (pos.sticky == \"before\" ? pos.ch - 1 : pos.ch)) {\r\n        pos = prevPos;\r\n        break\r\n      }\r\n      diff = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure).left - x;\r\n    } while ((dir < 0) != (diff < 0) && (Math.abs(diff) <= Math.abs(prevDiff)))\r\n    if (Math.abs(diff) > Math.abs(prevDiff)) {\r\n      if ((diff < 0) == (prevDiff < 0)) { throw new Error(\"Broke out of infinite loop in coordsCharInner\") }\r\n      pos = prevPos;\r\n    }\r\n  } else {\r\n    var ch = findFirst(function (ch) {\r\n      var box = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \"line\");\r\n      if (box.top > y) {\r\n        // For the cursor stickiness\r\n        end = Math.min(ch, end);\r\n        return true\r\n      }\r\n      else if (box.bottom <= y) { return false }\r\n      else if (box.left > x) { return true }\r\n      else if (box.right < x) { return false }\r\n      else { return (x - box.left < box.right - x) }\r\n    }, begin, end);\r\n    ch = skipExtendingChars(lineObj.text, ch, 1);\r\n    pos = new Pos(lineNo$$1, ch, ch == end ? \"before\" : \"after\");\r\n  }\r\n  var coords = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure);\r\n  if (y < coords.top || coords.bottom < y) { pos.outside = true; }\r\n  pos.xRel = x < coords.left ? -1 : (x > coords.right ? 1 : 0);\r\n  return pos\r\n}\r\n\r\nvar measureText;\r\n// Compute the default text height.\r\nfunction textHeight(display) {\r\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\r\n  if (measureText == null) {\r\n    measureText = elt(\"pre\");\r\n    // Measure a bunch of lines, for browsers that compute\r\n    // fractional heights.\r\n    for (var i = 0; i < 49; ++i) {\r\n      measureText.appendChild(document.createTextNode(\"x\"));\r\n      measureText.appendChild(elt(\"br\"));\r\n    }\r\n    measureText.appendChild(document.createTextNode(\"x\"));\r\n  }\r\n  removeChildrenAndAdd(display.measure, measureText);\r\n  var height = measureText.offsetHeight / 50;\r\n  if (height > 3) { display.cachedTextHeight = height; }\r\n  removeChildren(display.measure);\r\n  return height || 1\r\n}\r\n\r\n// Compute the default character width.\r\nfunction charWidth(display) {\r\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\r\n  var anchor = elt(\"span\", \"xxxxxxxxxx\");\r\n  var pre = elt(\"pre\", [anchor]);\r\n  removeChildrenAndAdd(display.measure, pre);\r\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\r\n  if (width > 2) { display.cachedCharWidth = width; }\r\n  return width || 10\r\n}\r\n\r\n// Do a bulk-read of the DOM positions and sizes needed to draw the\r\n// view, so that we don't interleave reading and writing to the DOM.\r\nfunction getDimensions(cm) {\r\n  var d = cm.display, left = {}, width = {};\r\n  var gutterLeft = d.gutters.clientLeft;\r\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\r\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\r\n    width[cm.options.gutters[i]] = n.clientWidth;\r\n  }\r\n  return {fixedPos: compensateForHScroll(d),\r\n          gutterTotalWidth: d.gutters.offsetWidth,\r\n          gutterLeft: left,\r\n          gutterWidth: width,\r\n          wrapperWidth: d.wrapper.clientWidth}\r\n}\r\n\r\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\r\n// but using getBoundingClientRect to get a sub-pixel-accurate\r\n// result.\r\nfunction compensateForHScroll(display) {\r\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\r\n}\r\n\r\n// Returns a function that estimates the height of a line, to use as\r\n// first approximation until the line becomes visible (and is thus\r\n// properly measurable).\r\nfunction estimateHeight(cm) {\r\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\r\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\r\n  return function (line) {\r\n    if (lineIsHidden(cm.doc, line)) { return 0 }\r\n\r\n    var widgetsHeight = 0;\r\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\r\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\r\n    } }\r\n\r\n    if (wrapping)\r\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\r\n    else\r\n      { return widgetsHeight + th }\r\n  }\r\n}\r\n\r\nfunction estimateLineHeights(cm) {\r\n  var doc = cm.doc, est = estimateHeight(cm);\r\n  doc.iter(function (line) {\r\n    var estHeight = est(line);\r\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\r\n  });\r\n}\r\n\r\n// Given a mouse event, find the corresponding position. If liberal\r\n// is false, it checks whether a gutter or scrollbar was clicked,\r\n// and returns null if it was. forRect is used by rectangular\r\n// selections, and tries to estimate a character position even for\r\n// coordinates beyond the right of the text.\r\nfunction posFromMouse(cm, e, liberal, forRect) {\r\n  var display = cm.display;\r\n  if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\r\n\r\n  var x, y, space = display.lineSpace.getBoundingClientRect();\r\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\r\n  try { x = e.clientX - space.left; y = e.clientY - space.top; }\r\n  catch (e) { return null }\r\n  var coords = coordsChar(cm, x, y), line;\r\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\r\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\r\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\r\n  }\r\n  return coords\r\n}\r\n\r\n// Find the view element corresponding to a given line. Return null\r\n// when the line isn't visible.\r\nfunction findViewIndex(cm, n) {\r\n  if (n >= cm.display.viewTo) { return null }\r\n  n -= cm.display.viewFrom;\r\n  if (n < 0) { return null }\r\n  var view = cm.display.view;\r\n  for (var i = 0; i < view.length; i++) {\r\n    n -= view[i].size;\r\n    if (n < 0) { return i }\r\n  }\r\n}\r\n\r\nfunction updateSelection(cm) {\r\n  cm.display.input.showSelection(cm.display.input.prepareSelection());\r\n}\r\n\r\nfunction prepareSelection(cm, primary) {\r\n  var doc = cm.doc, result = {};\r\n  var curFragment = result.cursors = document.createDocumentFragment();\r\n  var selFragment = result.selection = document.createDocumentFragment();\r\n\r\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\r\n    if (primary === false && i == doc.sel.primIndex) { continue }\r\n    var range$$1 = doc.sel.ranges[i];\r\n    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\r\n    var collapsed = range$$1.empty();\r\n    if (collapsed || cm.options.showCursorWhenSelecting)\r\n      { drawSelectionCursor(cm, range$$1.head, curFragment); }\r\n    if (!collapsed)\r\n      { drawSelectionRange(cm, range$$1, selFragment); }\r\n  }\r\n  return result\r\n}\r\n\r\n// Draws a cursor for the given range\r\nfunction drawSelectionCursor(cm, head, output) {\r\n  var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\r\n\r\n  var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\r\n  cursor.style.left = pos.left + \"px\";\r\n  cursor.style.top = pos.top + \"px\";\r\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\r\n\r\n  if (pos.other) {\r\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\r\n    var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\r\n    otherCursor.style.display = \"\";\r\n    otherCursor.style.left = pos.other.left + \"px\";\r\n    otherCursor.style.top = pos.other.top + \"px\";\r\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\r\n  }\r\n}\r\n\r\n// Draws the given range as a highlighted selection\r\nfunction drawSelectionRange(cm, range$$1, output) {\r\n  var display = cm.display, doc = cm.doc;\r\n  var fragment = document.createDocumentFragment();\r\n  var padding = paddingH(cm.display), leftSide = padding.left;\r\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\r\n\r\n  function add(left, top, width, bottom) {\r\n    if (top < 0) { top = 0; }\r\n    top = Math.round(top);\r\n    bottom = Math.round(bottom);\r\n    fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\r\n  }\r\n\r\n  function drawForLine(line, fromArg, toArg) {\r\n    var lineObj = getLine(doc, line);\r\n    var lineLen = lineObj.text.length;\r\n    var start, end;\r\n    function coords(ch, bias) {\r\n      return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\r\n    }\r\n\r\n    iterateBidiSections(getOrder(lineObj, doc.direction), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {\r\n      var leftPos = coords(from, \"left\"), rightPos, left, right;\r\n      if (from == to) {\r\n        rightPos = leftPos;\r\n        left = right = leftPos.left;\r\n      } else {\r\n        rightPos = coords(to - 1, \"right\");\r\n        if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\r\n        left = leftPos.left;\r\n        right = rightPos.right;\r\n      }\r\n      if (fromArg == null && from == 0) { left = leftSide; }\r\n      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\r\n        add(left, leftPos.top, null, leftPos.bottom);\r\n        left = leftSide;\r\n        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top); }\r\n      }\r\n      if (toArg == null && to == lineLen) { right = rightSide; }\r\n      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\r\n        { start = leftPos; }\r\n      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\r\n        { end = rightPos; }\r\n      if (left < leftSide + 1) { left = leftSide; }\r\n      add(left, rightPos.top, right - left, rightPos.bottom);\r\n    });\r\n    return {start: start, end: end}\r\n  }\r\n\r\n  var sFrom = range$$1.from(), sTo = range$$1.to();\r\n  if (sFrom.line == sTo.line) {\r\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch);\r\n  } else {\r\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\r\n    var singleVLine = visualLine(fromLine) == visualLine(toLine);\r\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\r\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\r\n    if (singleVLine) {\r\n      if (leftEnd.top < rightStart.top - 2) {\r\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\r\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\r\n      } else {\r\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\r\n      }\r\n    }\r\n    if (leftEnd.bottom < rightStart.top)\r\n      { add(leftSide, leftEnd.bottom, null, rightStart.top); }\r\n  }\r\n\r\n  output.appendChild(fragment);\r\n}\r\n\r\n// Cursor-blinking\r\nfunction restartBlink(cm) {\r\n  if (!cm.state.focused) { return }\r\n  var display = cm.display;\r\n  clearInterval(display.blinker);\r\n  var on = true;\r\n  display.cursorDiv.style.visibility = \"\";\r\n  if (cm.options.cursorBlinkRate > 0)\r\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\r\n      cm.options.cursorBlinkRate); }\r\n  else if (cm.options.cursorBlinkRate < 0)\r\n    { display.cursorDiv.style.visibility = \"hidden\"; }\r\n}\r\n\r\nfunction ensureFocus(cm) {\r\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\r\n}\r\n\r\nfunction delayBlurEvent(cm) {\r\n  cm.state.delayingBlurEvent = true;\r\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\r\n    cm.state.delayingBlurEvent = false;\r\n    onBlur(cm);\r\n  } }, 100);\r\n}\r\n\r\nfunction onFocus(cm, e) {\r\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\r\n\r\n  if (cm.options.readOnly == \"nocursor\") { return }\r\n  if (!cm.state.focused) {\r\n    signal(cm, \"focus\", cm, e);\r\n    cm.state.focused = true;\r\n    addClass(cm.display.wrapper, \"CodeMirror-focused\");\r\n    // This test prevents this from firing when a context\r\n    // menu is closed (since the input reset would kill the\r\n    // select-all detection hack)\r\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\r\n      cm.display.input.reset();\r\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\r\n    }\r\n    cm.display.input.receivedFocus();\r\n  }\r\n  restartBlink(cm);\r\n}\r\nfunction onBlur(cm, e) {\r\n  if (cm.state.delayingBlurEvent) { return }\r\n\r\n  if (cm.state.focused) {\r\n    signal(cm, \"blur\", cm, e);\r\n    cm.state.focused = false;\r\n    rmClass(cm.display.wrapper, \"CodeMirror-focused\");\r\n  }\r\n  clearInterval(cm.display.blinker);\r\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\r\n}\r\n\r\n// Read the actual heights of the rendered lines, and update their\r\n// stored heights to match.\r\nfunction updateHeightsInViewport(cm) {\r\n  var display = cm.display;\r\n  var prevBottom = display.lineDiv.offsetTop;\r\n  for (var i = 0; i < display.view.length; i++) {\r\n    var cur = display.view[i], height = (void 0);\r\n    if (cur.hidden) { continue }\r\n    if (ie && ie_version < 8) {\r\n      var bot = cur.node.offsetTop + cur.node.offsetHeight;\r\n      height = bot - prevBottom;\r\n      prevBottom = bot;\r\n    } else {\r\n      var box = cur.node.getBoundingClientRect();\r\n      height = box.bottom - box.top;\r\n    }\r\n    var diff = cur.line.height - height;\r\n    if (height < 2) { height = textHeight(display); }\r\n    if (diff > .001 || diff < -.001) {\r\n      updateLineHeight(cur.line, height);\r\n      updateWidgetHeight(cur.line);\r\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\r\n        { updateWidgetHeight(cur.rest[j]); } }\r\n    }\r\n  }\r\n}\r\n\r\n// Read and store the height of line widgets associated with the\r\n// given line.\r\nfunction updateWidgetHeight(line) {\r\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)\r\n    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight; } }\r\n}\r\n\r\n// Compute the lines that are visible in a given viewport (defaults\r\n// the the current scroll position). viewport may contain top,\r\n// height, and ensure (see op.scrollToPos) properties.\r\nfunction visibleLines(display, doc, viewport) {\r\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\r\n  top = Math.floor(top - paddingTop(display));\r\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\r\n\r\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\r\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\r\n  // forces those lines into the viewport (if possible).\r\n  if (viewport && viewport.ensure) {\r\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\r\n    if (ensureFrom < from) {\r\n      from = ensureFrom;\r\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\r\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\r\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\r\n      to = ensureTo;\r\n    }\r\n  }\r\n  return {from: from, to: Math.max(to, from + 1)}\r\n}\r\n\r\n// Re-align line numbers and gutter marks to compensate for\r\n// horizontal scrolling.\r\nfunction alignHorizontally(cm) {\r\n  var display = cm.display, view = display.view;\r\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\r\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\r\n  var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\r\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\r\n    if (cm.options.fixedGutter) {\r\n      if (view[i].gutter)\r\n        { view[i].gutter.style.left = left; }\r\n      if (view[i].gutterBackground)\r\n        { view[i].gutterBackground.style.left = left; }\r\n    }\r\n    var align = view[i].alignable;\r\n    if (align) { for (var j = 0; j < align.length; j++)\r\n      { align[j].style.left = left; } }\r\n  } }\r\n  if (cm.options.fixedGutter)\r\n    { display.gutters.style.left = (comp + gutterW) + \"px\"; }\r\n}\r\n\r\n// Used to ensure that the line number gutter is still the right\r\n// size for the current document size. Returns true when an update\r\n// is needed.\r\nfunction maybeUpdateLineNumberWidth(cm) {\r\n  if (!cm.options.lineNumbers) { return false }\r\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\r\n  if (last.length != display.lineNumChars) {\r\n    var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\r\n                                               \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\r\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\r\n    display.lineGutter.style.width = \"\";\r\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\r\n    display.lineNumWidth = display.lineNumInnerWidth + padding;\r\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\r\n    display.lineGutter.style.width = display.lineNumWidth + \"px\";\r\n    updateGutterSpace(cm);\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\n// SCROLLING THINGS INTO VIEW\r\n\r\n// If an editor sits on the top or bottom of the window, partially\r\n// scrolled out of view, this ensures that the cursor is visible.\r\nfunction maybeScrollWindow(cm, rect) {\r\n  if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\r\n\r\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\r\n  if (rect.top + box.top < 0) { doScroll = true; }\r\n  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\r\n  if (doScroll != null && !phantom) {\r\n    var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\r\n    cm.display.lineSpace.appendChild(scrollNode);\r\n    scrollNode.scrollIntoView(doScroll);\r\n    cm.display.lineSpace.removeChild(scrollNode);\r\n  }\r\n}\r\n\r\n// Scroll a given position into view (immediately), verifying that\r\n// it actually became visible (as line heights are accurately\r\n// measured, the position of something may 'drift' during drawing).\r\nfunction scrollPosIntoView(cm, pos, end, margin) {\r\n  if (margin == null) { margin = 0; }\r\n  var rect;\r\n  for (var limit = 0; limit < 5; limit++) {\r\n    var changed = false;\r\n    var coords = cursorCoords(cm, pos);\r\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\r\n    rect = {left: Math.min(coords.left, endCoords.left),\r\n            top: Math.min(coords.top, endCoords.top) - margin,\r\n            right: Math.max(coords.left, endCoords.left),\r\n            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\r\n    var scrollPos = calculateScrollPos(cm, rect);\r\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\r\n    if (scrollPos.scrollTop != null) {\r\n      updateScrollTop(cm, scrollPos.scrollTop);\r\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\r\n    }\r\n    if (scrollPos.scrollLeft != null) {\r\n      setScrollLeft(cm, scrollPos.scrollLeft);\r\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\r\n    }\r\n    if (!changed) { break }\r\n  }\r\n  return rect\r\n}\r\n\r\n// Scroll a given set of coordinates into view (immediately).\r\nfunction scrollIntoView(cm, rect) {\r\n  var scrollPos = calculateScrollPos(cm, rect);\r\n  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\r\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\r\n}\r\n\r\n// Calculate a new scroll position needed to scroll the given\r\n// rectangle into view. Returns an object with scrollTop and\r\n// scrollLeft properties. When these are undefined, the\r\n// vertical/horizontal position does not need to be adjusted.\r\nfunction calculateScrollPos(cm, rect) {\r\n  var display = cm.display, snapMargin = textHeight(cm.display);\r\n  if (rect.top < 0) { rect.top = 0; }\r\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\r\n  var screen = displayHeight(cm), result = {};\r\n  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\r\n  var docBottom = cm.doc.height + paddingVert(display);\r\n  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\r\n  if (rect.top < screentop) {\r\n    result.scrollTop = atTop ? 0 : rect.top;\r\n  } else if (rect.bottom > screentop + screen) {\r\n    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\r\n    if (newTop != screentop) { result.scrollTop = newTop; }\r\n  }\r\n\r\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\r\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\r\n  var tooWide = rect.right - rect.left > screenw;\r\n  if (tooWide) { rect.right = rect.left + screenw; }\r\n  if (rect.left < 10)\r\n    { result.scrollLeft = 0; }\r\n  else if (rect.left < screenleft)\r\n    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\r\n  else if (rect.right > screenw + screenleft - 3)\r\n    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\r\n  return result\r\n}\r\n\r\n// Store a relative adjustment to the scroll position in the current\r\n// operation (to be applied when the operation finishes).\r\nfunction addToScrollTop(cm, top) {\r\n  if (top == null) { return }\r\n  resolveScrollToPos(cm);\r\n  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\r\n}\r\n\r\n// Make sure that at the end of the operation the current cursor is\r\n// shown.\r\nfunction ensureCursorVisible(cm) {\r\n  resolveScrollToPos(cm);\r\n  var cur = cm.getCursor(), from = cur, to = cur;\r\n  if (!cm.options.lineWrapping) {\r\n    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\r\n    to = Pos(cur.line, cur.ch + 1);\r\n  }\r\n  cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin};\r\n}\r\n\r\nfunction scrollToCoords(cm, x, y) {\r\n  if (x != null || y != null) { resolveScrollToPos(cm); }\r\n  if (x != null) { cm.curOp.scrollLeft = x; }\r\n  if (y != null) { cm.curOp.scrollTop = y; }\r\n}\r\n\r\nfunction scrollToRange(cm, range$$1) {\r\n  resolveScrollToPos(cm);\r\n  cm.curOp.scrollToPos = range$$1;\r\n}\r\n\r\n// When an operation has its scrollToPos property set, and another\r\n// scroll action is applied before the end of the operation, this\r\n// 'simulates' scrolling that position into view in a cheap way, so\r\n// that the effect of intermediate scroll commands is not ignored.\r\nfunction resolveScrollToPos(cm) {\r\n  var range$$1 = cm.curOp.scrollToPos;\r\n  if (range$$1) {\r\n    cm.curOp.scrollToPos = null;\r\n    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\r\n    scrollToCoordsRange(cm, from, to, range$$1.margin);\r\n  }\r\n}\r\n\r\nfunction scrollToCoordsRange(cm, from, to, margin) {\r\n  var sPos = calculateScrollPos(cm, {\r\n    left: Math.min(from.left, to.left),\r\n    top: Math.min(from.top, to.top) - margin,\r\n    right: Math.max(from.right, to.right),\r\n    bottom: Math.max(from.bottom, to.bottom) + margin\r\n  });\r\n  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\r\n}\r\n\r\n// Sync the scrollable area and scrollbars, ensure the viewport\r\n// covers the visible area.\r\nfunction updateScrollTop(cm, val) {\r\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\r\n  if (!gecko) { updateDisplaySimple(cm, {top: val}); }\r\n  setScrollTop(cm, val, true);\r\n  if (gecko) { updateDisplaySimple(cm); }\r\n  startWorker(cm, 100);\r\n}\r\n\r\nfunction setScrollTop(cm, val, forceScroll) {\r\n  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\r\n  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\r\n  cm.doc.scrollTop = val;\r\n  cm.display.scrollbars.setScrollTop(val);\r\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\r\n}\r\n\r\n// Sync scroller and scrollbar, ensure the gutter elements are\r\n// aligned.\r\nfunction setScrollLeft(cm, val, isScroller, forceScroll) {\r\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\r\n  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\r\n  cm.doc.scrollLeft = val;\r\n  alignHorizontally(cm);\r\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\r\n  cm.display.scrollbars.setScrollLeft(val);\r\n}\r\n\r\n// SCROLLBARS\r\n\r\n// Prepare DOM reads needed to update the scrollbars. Done in one\r\n// shot to minimize update/measure roundtrips.\r\nfunction measureForScrollbars(cm) {\r\n  var d = cm.display, gutterW = d.gutters.offsetWidth;\r\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display));\r\n  return {\r\n    clientHeight: d.scroller.clientHeight,\r\n    viewHeight: d.wrapper.clientHeight,\r\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\r\n    viewWidth: d.wrapper.clientWidth,\r\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\r\n    docHeight: docH,\r\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\r\n    nativeBarWidth: d.nativeBarWidth,\r\n    gutterWidth: gutterW\r\n  }\r\n}\r\n\r\nvar NativeScrollbars = function(place, scroll, cm) {\r\n  this.cm = cm;\r\n  var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\r\n  var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\r\n  place(vert); place(horiz);\r\n\r\n  on(vert, \"scroll\", function () {\r\n    if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\r\n  });\r\n  on(horiz, \"scroll\", function () {\r\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\r\n  });\r\n\r\n  this.checkedZeroWidth = false;\r\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\r\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\r\n};\r\n\r\nNativeScrollbars.prototype.update = function (measure) {\r\n  var needsH = measure.scrollWidth > measure.clientWidth + 1;\r\n  var needsV = measure.scrollHeight > measure.clientHeight + 1;\r\n  var sWidth = measure.nativeBarWidth;\r\n\r\n  if (needsV) {\r\n    this.vert.style.display = \"block\";\r\n    this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\r\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\r\n    // A bug in IE8 can cause this value to be negative, so guard it.\r\n    this.vert.firstChild.style.height =\r\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\r\n  } else {\r\n    this.vert.style.display = \"\";\r\n    this.vert.firstChild.style.height = \"0\";\r\n  }\r\n\r\n  if (needsH) {\r\n    this.horiz.style.display = \"block\";\r\n    this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\r\n    this.horiz.style.left = measure.barLeft + \"px\";\r\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\r\n    this.horiz.firstChild.style.width =\r\n      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\r\n  } else {\r\n    this.horiz.style.display = \"\";\r\n    this.horiz.firstChild.style.width = \"0\";\r\n  }\r\n\r\n  if (!this.checkedZeroWidth && measure.clientHeight > 0) {\r\n    if (sWidth == 0) { this.zeroWidthHack(); }\r\n    this.checkedZeroWidth = true;\r\n  }\r\n\r\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\r\n};\r\n\r\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\r\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\r\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\r\n};\r\n\r\nNativeScrollbars.prototype.setScrollTop = function (pos) {\r\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\r\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\r\n};\r\n\r\nNativeScrollbars.prototype.zeroWidthHack = function () {\r\n  var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\r\n  this.horiz.style.height = this.vert.style.width = w;\r\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\r\n  this.disableHoriz = new Delayed;\r\n  this.disableVert = new Delayed;\r\n};\r\n\r\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\r\n  bar.style.pointerEvents = \"auto\";\r\n  function maybeDisable() {\r\n    // To find out whether the scrollbar is still visible, we\r\n    // check whether the element under the pixel in the bottom\r\n    // right corner of the scrollbar box is the scrollbar box\r\n    // itself (when the bar is still visible) or its filler child\r\n    // (when the bar is hidden). If it is still visible, we keep\r\n    // it enabled, if it's hidden, we disable pointer events.\r\n    var box = bar.getBoundingClientRect();\r\n    var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\r\n        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\r\n    if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\r\n    else { delay.set(1000, maybeDisable); }\r\n  }\r\n  delay.set(1000, maybeDisable);\r\n};\r\n\r\nNativeScrollbars.prototype.clear = function () {\r\n  var parent = this.horiz.parentNode;\r\n  parent.removeChild(this.horiz);\r\n  parent.removeChild(this.vert);\r\n};\r\n\r\nvar NullScrollbars = function () {};\r\n\r\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\r\nNullScrollbars.prototype.setScrollLeft = function () {};\r\nNullScrollbars.prototype.setScrollTop = function () {};\r\nNullScrollbars.prototype.clear = function () {};\r\n\r\nfunction updateScrollbars(cm, measure) {\r\n  if (!measure) { measure = measureForScrollbars(cm); }\r\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\r\n  updateScrollbarsInner(cm, measure);\r\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\r\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\r\n      { updateHeightsInViewport(cm); }\r\n    updateScrollbarsInner(cm, measureForScrollbars(cm));\r\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\r\n  }\r\n}\r\n\r\n// Re-synchronize the fake scrollbars with the actual size of the\r\n// content.\r\nfunction updateScrollbarsInner(cm, measure) {\r\n  var d = cm.display;\r\n  var sizes = d.scrollbars.update(measure);\r\n\r\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\r\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\r\n  d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\r\n\r\n  if (sizes.right && sizes.bottom) {\r\n    d.scrollbarFiller.style.display = \"block\";\r\n    d.scrollbarFiller.style.height = sizes.bottom + \"px\";\r\n    d.scrollbarFiller.style.width = sizes.right + \"px\";\r\n  } else { d.scrollbarFiller.style.display = \"\"; }\r\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\r\n    d.gutterFiller.style.display = \"block\";\r\n    d.gutterFiller.style.height = sizes.bottom + \"px\";\r\n    d.gutterFiller.style.width = measure.gutterWidth + \"px\";\r\n  } else { d.gutterFiller.style.display = \"\"; }\r\n}\r\n\r\nvar scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\r\n\r\nfunction initScrollbars(cm) {\r\n  if (cm.display.scrollbars) {\r\n    cm.display.scrollbars.clear();\r\n    if (cm.display.scrollbars.addClass)\r\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\r\n  }\r\n\r\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\r\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\r\n    // Prevent clicks in the scrollbars from killing focus\r\n    on(node, \"mousedown\", function () {\r\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\r\n    });\r\n    node.setAttribute(\"cm-not-content\", \"true\");\r\n  }, function (pos, axis) {\r\n    if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\r\n    else { updateScrollTop(cm, pos); }\r\n  }, cm);\r\n  if (cm.display.scrollbars.addClass)\r\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\r\n}\r\n\r\n// Operations are used to wrap a series of changes to the editor\r\n// state in such a way that each change won't have to update the\r\n// cursor and display (which would be awkward, slow, and\r\n// error-prone). Instead, display updates are batched and then all\r\n// combined and executed at once.\r\n\r\nvar nextOpId = 0;\r\n// Start a new operation.\r\nfunction startOperation(cm) {\r\n  cm.curOp = {\r\n    cm: cm,\r\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\r\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\r\n    forceUpdate: false,      // Used to force a redraw\r\n    updateInput: null,       // Whether to reset the input textarea\r\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\r\n    changeObjs: null,        // Accumulated changes, for firing change events\r\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\r\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\r\n    selectionChanged: false, // Whether the selection needs to be redrawn\r\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\r\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\r\n    scrollToPos: null,       // Used to scroll to a specific position\r\n    focus: false,\r\n    id: ++nextOpId           // Unique ID\r\n  };\r\n  pushOperation(cm.curOp);\r\n}\r\n\r\n// Finish an operation, updating the display and signalling delayed events\r\nfunction endOperation(cm) {\r\n  var op = cm.curOp;\r\n  finishOperation(op, function (group) {\r\n    for (var i = 0; i < group.ops.length; i++)\r\n      { group.ops[i].cm.curOp = null; }\r\n    endOperations(group);\r\n  });\r\n}\r\n\r\n// The DOM updates done when an operation finishes are batched so\r\n// that the minimum number of relayouts are required.\r\nfunction endOperations(group) {\r\n  var ops = group.ops;\r\n  for (var i = 0; i < ops.length; i++) // Read DOM\r\n    { endOperation_R1(ops[i]); }\r\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\r\n    { endOperation_W1(ops[i$1]); }\r\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\r\n    { endOperation_R2(ops[i$2]); }\r\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\r\n    { endOperation_W2(ops[i$3]); }\r\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\r\n    { endOperation_finish(ops[i$4]); }\r\n}\r\n\r\nfunction endOperation_R1(op) {\r\n  var cm = op.cm, display = cm.display;\r\n  maybeClipScrollbars(cm);\r\n  if (op.updateMaxLine) { findMaxLine(cm); }\r\n\r\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\r\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\r\n                       op.scrollToPos.to.line >= display.viewTo) ||\r\n    display.maxLineChanged && cm.options.lineWrapping;\r\n  op.update = op.mustUpdate &&\r\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\r\n}\r\n\r\nfunction endOperation_W1(op) {\r\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\r\n}\r\n\r\nfunction endOperation_R2(op) {\r\n  var cm = op.cm, display = cm.display;\r\n  if (op.updatedDisplay) { updateHeightsInViewport(cm); }\r\n\r\n  op.barMeasure = measureForScrollbars(cm);\r\n\r\n  // If the max line changed since it was last measured, measure it,\r\n  // and ensure the document's width matches it.\r\n  // updateDisplay_W2 will use these properties to do the actual resizing\r\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\r\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\r\n    cm.display.sizerWidth = op.adjustWidthTo;\r\n    op.barMeasure.scrollWidth =\r\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\r\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\r\n  }\r\n\r\n  if (op.updatedDisplay || op.selectionChanged)\r\n    { op.preparedSelection = display.input.prepareSelection(op.focus); }\r\n}\r\n\r\nfunction endOperation_W2(op) {\r\n  var cm = op.cm;\r\n\r\n  if (op.adjustWidthTo != null) {\r\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\r\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\r\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\r\n    cm.display.maxLineChanged = false;\r\n  }\r\n\r\n  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus());\r\n  if (op.preparedSelection)\r\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\r\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\r\n    { updateScrollbars(cm, op.barMeasure); }\r\n  if (op.updatedDisplay)\r\n    { setDocumentHeight(cm, op.barMeasure); }\r\n\r\n  if (op.selectionChanged) { restartBlink(cm); }\r\n\r\n  if (cm.state.focused && op.updateInput)\r\n    { cm.display.input.reset(op.typing); }\r\n  if (takeFocus) { ensureFocus(op.cm); }\r\n}\r\n\r\nfunction endOperation_finish(op) {\r\n  var cm = op.cm, display = cm.display, doc = cm.doc;\r\n\r\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\r\n\r\n  // Abort mouse wheel delta measurement, when scrolling explicitly\r\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\r\n    { display.wheelStartX = display.wheelStartY = null; }\r\n\r\n  // Propagate the scroll position to the actual DOM scroller\r\n  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\r\n\r\n  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\r\n  // If we need to scroll a specific position into view, do so.\r\n  if (op.scrollToPos) {\r\n    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\r\n                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\r\n    maybeScrollWindow(cm, rect);\r\n  }\r\n\r\n  // Fire events for markers that are hidden/unidden by editing or\r\n  // undoing\r\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\r\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\r\n    { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\r\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\r\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\r\n\r\n  if (display.wrapper.offsetHeight)\r\n    { doc.scrollTop = cm.display.scroller.scrollTop; }\r\n\r\n  // Fire change events, and delayed event handlers\r\n  if (op.changeObjs)\r\n    { signal(cm, \"changes\", cm, op.changeObjs); }\r\n  if (op.update)\r\n    { op.update.finish(); }\r\n}\r\n\r\n// Run the given function in an operation\r\nfunction runInOp(cm, f) {\r\n  if (cm.curOp) { return f() }\r\n  startOperation(cm);\r\n  try { return f() }\r\n  finally { endOperation(cm); }\r\n}\r\n// Wraps a function in an operation. Returns the wrapped function.\r\nfunction operation(cm, f) {\r\n  return function() {\r\n    if (cm.curOp) { return f.apply(cm, arguments) }\r\n    startOperation(cm);\r\n    try { return f.apply(cm, arguments) }\r\n    finally { endOperation(cm); }\r\n  }\r\n}\r\n// Used to add methods to editor and doc instances, wrapping them in\r\n// operations.\r\nfunction methodOp(f) {\r\n  return function() {\r\n    if (this.curOp) { return f.apply(this, arguments) }\r\n    startOperation(this);\r\n    try { return f.apply(this, arguments) }\r\n    finally { endOperation(this); }\r\n  }\r\n}\r\nfunction docMethodOp(f) {\r\n  return function() {\r\n    var cm = this.cm;\r\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\r\n    startOperation(cm);\r\n    try { return f.apply(this, arguments) }\r\n    finally { endOperation(cm); }\r\n  }\r\n}\r\n\r\n// Updates the display.view data structure for a given change to the\r\n// document. From and to are in pre-change coordinates. Lendiff is\r\n// the amount of lines added or subtracted by the change. This is\r\n// used for changes that span multiple lines, or change the way\r\n// lines are divided into visual lines. regLineChange (below)\r\n// registers single-line changes.\r\nfunction regChange(cm, from, to, lendiff) {\r\n  if (from == null) { from = cm.doc.first; }\r\n  if (to == null) { to = cm.doc.first + cm.doc.size; }\r\n  if (!lendiff) { lendiff = 0; }\r\n\r\n  var display = cm.display;\r\n  if (lendiff && to < display.viewTo &&\r\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\r\n    { display.updateLineNumbers = from; }\r\n\r\n  cm.curOp.viewChanged = true;\r\n\r\n  if (from >= display.viewTo) { // Change after\r\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\r\n      { resetView(cm); }\r\n  } else if (to <= display.viewFrom) { // Change before\r\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\r\n      resetView(cm);\r\n    } else {\r\n      display.viewFrom += lendiff;\r\n      display.viewTo += lendiff;\r\n    }\r\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\r\n    resetView(cm);\r\n  } else if (from <= display.viewFrom) { // Top overlap\r\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\r\n    if (cut) {\r\n      display.view = display.view.slice(cut.index);\r\n      display.viewFrom = cut.lineN;\r\n      display.viewTo += lendiff;\r\n    } else {\r\n      resetView(cm);\r\n    }\r\n  } else if (to >= display.viewTo) { // Bottom overlap\r\n    var cut$1 = viewCuttingPoint(cm, from, from, -1);\r\n    if (cut$1) {\r\n      display.view = display.view.slice(0, cut$1.index);\r\n      display.viewTo = cut$1.lineN;\r\n    } else {\r\n      resetView(cm);\r\n    }\r\n  } else { // Gap in the middle\r\n    var cutTop = viewCuttingPoint(cm, from, from, -1);\r\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\r\n    if (cutTop && cutBot) {\r\n      display.view = display.view.slice(0, cutTop.index)\r\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\r\n        .concat(display.view.slice(cutBot.index));\r\n      display.viewTo += lendiff;\r\n    } else {\r\n      resetView(cm);\r\n    }\r\n  }\r\n\r\n  var ext = display.externalMeasured;\r\n  if (ext) {\r\n    if (to < ext.lineN)\r\n      { ext.lineN += lendiff; }\r\n    else if (from < ext.lineN + ext.size)\r\n      { display.externalMeasured = null; }\r\n  }\r\n}\r\n\r\n// Register a change to a single line. Type must be one of \"text\",\r\n// \"gutter\", \"class\", \"widget\"\r\nfunction regLineChange(cm, line, type) {\r\n  cm.curOp.viewChanged = true;\r\n  var display = cm.display, ext = cm.display.externalMeasured;\r\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\r\n    { display.externalMeasured = null; }\r\n\r\n  if (line < display.viewFrom || line >= display.viewTo) { return }\r\n  var lineView = display.view[findViewIndex(cm, line)];\r\n  if (lineView.node == null) { return }\r\n  var arr = lineView.changes || (lineView.changes = []);\r\n  if (indexOf(arr, type) == -1) { arr.push(type); }\r\n}\r\n\r\n// Clear the view.\r\nfunction resetView(cm) {\r\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\r\n  cm.display.view = [];\r\n  cm.display.viewOffset = 0;\r\n}\r\n\r\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\r\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\r\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\r\n    { return {index: index, lineN: newN} }\r\n  var n = cm.display.viewFrom;\r\n  for (var i = 0; i < index; i++)\r\n    { n += view[i].size; }\r\n  if (n != oldN) {\r\n    if (dir > 0) {\r\n      if (index == view.length - 1) { return null }\r\n      diff = (n + view[index].size) - oldN;\r\n      index++;\r\n    } else {\r\n      diff = n - oldN;\r\n    }\r\n    oldN += diff; newN += diff;\r\n  }\r\n  while (visualLineNo(cm.doc, newN) != newN) {\r\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\r\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\r\n    index += dir;\r\n  }\r\n  return {index: index, lineN: newN}\r\n}\r\n\r\n// Force the view to cover a given range, adding empty view element\r\n// or clipping off existing ones as needed.\r\nfunction adjustView(cm, from, to) {\r\n  var display = cm.display, view = display.view;\r\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\r\n    display.view = buildViewArray(cm, from, to);\r\n    display.viewFrom = from;\r\n  } else {\r\n    if (display.viewFrom > from)\r\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\r\n    else if (display.viewFrom < from)\r\n      { display.view = display.view.slice(findViewIndex(cm, from)); }\r\n    display.viewFrom = from;\r\n    if (display.viewTo < to)\r\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\r\n    else if (display.viewTo > to)\r\n      { display.view = display.view.slice(0, findViewIndex(cm, to)); }\r\n  }\r\n  display.viewTo = to;\r\n}\r\n\r\n// Count the number of lines in the view whose DOM representation is\r\n// out of date (or nonexistent).\r\nfunction countDirtyView(cm) {\r\n  var view = cm.display.view, dirty = 0;\r\n  for (var i = 0; i < view.length; i++) {\r\n    var lineView = view[i];\r\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\r\n  }\r\n  return dirty\r\n}\r\n\r\n// HIGHLIGHT WORKER\r\n\r\nfunction startWorker(cm, time) {\r\n  if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\r\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\r\n}\r\n\r\nfunction highlightWorker(cm) {\r\n  var doc = cm.doc;\r\n  if (doc.frontier < doc.first) { doc.frontier = doc.first; }\r\n  if (doc.frontier >= cm.display.viewTo) { return }\r\n  var end = +new Date + cm.options.workTime;\r\n  var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\r\n  var changedLines = [];\r\n\r\n  doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\r\n    if (doc.frontier >= cm.display.viewFrom) { // Visible\r\n      var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\r\n      var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\r\n      line.styles = highlighted.styles;\r\n      var oldCls = line.styleClasses, newCls = highlighted.classes;\r\n      if (newCls) { line.styleClasses = newCls; }\r\n      else if (oldCls) { line.styleClasses = null; }\r\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\r\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\r\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\r\n      if (ischange) { changedLines.push(doc.frontier); }\r\n      line.stateAfter = tooLong ? state : copyState(doc.mode, state);\r\n    } else {\r\n      if (line.text.length <= cm.options.maxHighlightLength)\r\n        { processLine(cm, line.text, state); }\r\n      line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\r\n    }\r\n    ++doc.frontier;\r\n    if (+new Date > end) {\r\n      startWorker(cm, cm.options.workDelay);\r\n      return true\r\n    }\r\n  });\r\n  if (changedLines.length) { runInOp(cm, function () {\r\n    for (var i = 0; i < changedLines.length; i++)\r\n      { regLineChange(cm, changedLines[i], \"text\"); }\r\n  }); }\r\n}\r\n\r\n// DISPLAY DRAWING\r\n\r\nvar DisplayUpdate = function(cm, viewport, force) {\r\n  var display = cm.display;\r\n\r\n  this.viewport = viewport;\r\n  // Store some values that we'll need later (but don't want to force a relayout for)\r\n  this.visible = visibleLines(display, cm.doc, viewport);\r\n  this.editorIsHidden = !display.wrapper.offsetWidth;\r\n  this.wrapperHeight = display.wrapper.clientHeight;\r\n  this.wrapperWidth = display.wrapper.clientWidth;\r\n  this.oldDisplayWidth = displayWidth(cm);\r\n  this.force = force;\r\n  this.dims = getDimensions(cm);\r\n  this.events = [];\r\n};\r\n\r\nDisplayUpdate.prototype.signal = function (emitter, type) {\r\n  if (hasHandler(emitter, type))\r\n    { this.events.push(arguments); }\r\n};\r\nDisplayUpdate.prototype.finish = function () {\r\n    var this$1 = this;\r\n\r\n  for (var i = 0; i < this.events.length; i++)\r\n    { signal.apply(null, this$1.events[i]); }\r\n};\r\n\r\nfunction maybeClipScrollbars(cm) {\r\n  var display = cm.display;\r\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\r\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\r\n    display.heightForcer.style.height = scrollGap(cm) + \"px\";\r\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\r\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\r\n    display.scrollbarsClipped = true;\r\n  }\r\n}\r\n\r\nfunction selectionSnapshot(cm) {\r\n  if (cm.hasFocus()) { return null }\r\n  var active = activeElt();\r\n  if (!active || !contains(cm.display.lineDiv, active)) { return null }\r\n  var result = {activeElt: active};\r\n  if (window.getSelection) {\r\n    var sel = window.getSelection();\r\n    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\r\n      result.anchorNode = sel.anchorNode;\r\n      result.anchorOffset = sel.anchorOffset;\r\n      result.focusNode = sel.focusNode;\r\n      result.focusOffset = sel.focusOffset;\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\nfunction restoreSelection(snapshot) {\r\n  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\r\n  snapshot.activeElt.focus();\r\n  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\r\n    var sel = window.getSelection(), range$$1 = document.createRange();\r\n    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\r\n    range$$1.collapse(false);\r\n    sel.removeAllRanges();\r\n    sel.addRange(range$$1);\r\n    sel.extend(snapshot.focusNode, snapshot.focusOffset);\r\n  }\r\n}\r\n\r\n// Does the actual updating of the line display. Bails out\r\n// (returning false) when there is nothing to be done and forced is\r\n// false.\r\nfunction updateDisplayIfNeeded(cm, update) {\r\n  var display = cm.display, doc = cm.doc;\r\n\r\n  if (update.editorIsHidden) {\r\n    resetView(cm);\r\n    return false\r\n  }\r\n\r\n  // Bail out if the visible area is already rendered and nothing changed.\r\n  if (!update.force &&\r\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\r\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\r\n      display.renderedView == display.view && countDirtyView(cm) == 0)\r\n    { return false }\r\n\r\n  if (maybeUpdateLineNumberWidth(cm)) {\r\n    resetView(cm);\r\n    update.dims = getDimensions(cm);\r\n  }\r\n\r\n  // Compute a suitable new viewport (from & to)\r\n  var end = doc.first + doc.size;\r\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\r\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\r\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\r\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\r\n  if (sawCollapsedSpans) {\r\n    from = visualLineNo(cm.doc, from);\r\n    to = visualLineEndNo(cm.doc, to);\r\n  }\r\n\r\n  var different = from != display.viewFrom || to != display.viewTo ||\r\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\r\n  adjustView(cm, from, to);\r\n\r\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\r\n  // Position the mover div to align with the current scroll position\r\n  cm.display.mover.style.top = display.viewOffset + \"px\";\r\n\r\n  var toUpdate = countDirtyView(cm);\r\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\r\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\r\n    { return false }\r\n\r\n  // For big changes, we hide the enclosing element during the\r\n  // update, since that speeds up the operations on most browsers.\r\n  var selSnapshot = selectionSnapshot(cm);\r\n  if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\r\n  patchDisplay(cm, display.updateLineNumbers, update.dims);\r\n  if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\r\n  display.renderedView = display.view;\r\n  // There might have been a widget with a focused element that got\r\n  // hidden or updated, if so re-focus it.\r\n  restoreSelection(selSnapshot);\r\n\r\n  // Prevent selection and cursors from interfering with the scroll\r\n  // width and height.\r\n  removeChildren(display.cursorDiv);\r\n  removeChildren(display.selectionDiv);\r\n  display.gutters.style.height = display.sizer.style.minHeight = 0;\r\n\r\n  if (different) {\r\n    display.lastWrapHeight = update.wrapperHeight;\r\n    display.lastWrapWidth = update.wrapperWidth;\r\n    startWorker(cm, 400);\r\n  }\r\n\r\n  display.updateLineNumbers = null;\r\n\r\n  return true\r\n}\r\n\r\nfunction postUpdateDisplay(cm, update) {\r\n  var viewport = update.viewport;\r\n\r\n  for (var first = true;; first = false) {\r\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\r\n      // Clip forced viewport to actual scrollable area.\r\n      if (viewport && viewport.top != null)\r\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\r\n      // Updated line heights might result in the drawn area not\r\n      // actually covering the viewport. Keep looping until it does.\r\n      update.visible = visibleLines(cm.display, cm.doc, viewport);\r\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\r\n        { break }\r\n    }\r\n    if (!updateDisplayIfNeeded(cm, update)) { break }\r\n    updateHeightsInViewport(cm);\r\n    var barMeasure = measureForScrollbars(cm);\r\n    updateSelection(cm);\r\n    updateScrollbars(cm, barMeasure);\r\n    setDocumentHeight(cm, barMeasure);\r\n  }\r\n\r\n  update.signal(cm, \"update\", cm);\r\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\r\n    update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\r\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\r\n  }\r\n}\r\n\r\nfunction updateDisplaySimple(cm, viewport) {\r\n  var update = new DisplayUpdate(cm, viewport);\r\n  if (updateDisplayIfNeeded(cm, update)) {\r\n    updateHeightsInViewport(cm);\r\n    postUpdateDisplay(cm, update);\r\n    var barMeasure = measureForScrollbars(cm);\r\n    updateSelection(cm);\r\n    updateScrollbars(cm, barMeasure);\r\n    setDocumentHeight(cm, barMeasure);\r\n    update.finish();\r\n  }\r\n}\r\n\r\n// Sync the actual display DOM structure with display.view, removing\r\n// nodes for lines that are no longer in view, and creating the ones\r\n// that are not there yet, and updating the ones that are out of\r\n// date.\r\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\r\n  var display = cm.display, lineNumbers = cm.options.lineNumbers;\r\n  var container = display.lineDiv, cur = container.firstChild;\r\n\r\n  function rm(node) {\r\n    var next = node.nextSibling;\r\n    // Works around a throw-scroll bug in OS X Webkit\r\n    if (webkit && mac && cm.display.currentWheelTarget == node)\r\n      { node.style.display = \"none\"; }\r\n    else\r\n      { node.parentNode.removeChild(node); }\r\n    return next\r\n  }\r\n\r\n  var view = display.view, lineN = display.viewFrom;\r\n  // Loop over the elements in the view, syncing cur (the DOM nodes\r\n  // in display.lineDiv) with the view as we go.\r\n  for (var i = 0; i < view.length; i++) {\r\n    var lineView = view[i];\r\n    if (lineView.hidden) {\r\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\r\n      var node = buildLineElement(cm, lineView, lineN, dims);\r\n      container.insertBefore(node, cur);\r\n    } else { // Already drawn\r\n      while (cur != lineView.node) { cur = rm(cur); }\r\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\r\n        updateNumbersFrom <= lineN && lineView.lineNumber;\r\n      if (lineView.changes) {\r\n        if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\r\n        updateLineForChanges(cm, lineView, lineN, dims);\r\n      }\r\n      if (updateNumber) {\r\n        removeChildren(lineView.lineNumber);\r\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\r\n      }\r\n      cur = lineView.node.nextSibling;\r\n    }\r\n    lineN += lineView.size;\r\n  }\r\n  while (cur) { cur = rm(cur); }\r\n}\r\n\r\nfunction updateGutterSpace(cm) {\r\n  var width = cm.display.gutters.offsetWidth;\r\n  cm.display.sizer.style.marginLeft = width + \"px\";\r\n}\r\n\r\nfunction setDocumentHeight(cm, measure) {\r\n  cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\r\n  cm.display.heightForcer.style.top = measure.docHeight + \"px\";\r\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\r\n}\r\n\r\n// Rebuild the gutter elements, ensure the margin to the left of the\r\n// code matches their width.\r\nfunction updateGutters(cm) {\r\n  var gutters = cm.display.gutters, specs = cm.options.gutters;\r\n  removeChildren(gutters);\r\n  var i = 0;\r\n  for (; i < specs.length; ++i) {\r\n    var gutterClass = specs[i];\r\n    var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\r\n    if (gutterClass == \"CodeMirror-linenumbers\") {\r\n      cm.display.lineGutter = gElt;\r\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\r\n    }\r\n  }\r\n  gutters.style.display = i ? \"\" : \"none\";\r\n  updateGutterSpace(cm);\r\n}\r\n\r\n// Make sure the gutters options contains the element\r\n// \"CodeMirror-linenumbers\" when the lineNumbers option is true.\r\nfunction setGuttersForLineNumbers(options) {\r\n  var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\r\n  if (found == -1 && options.lineNumbers) {\r\n    options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\r\n  } else if (found > -1 && !options.lineNumbers) {\r\n    options.gutters = options.gutters.slice(0);\r\n    options.gutters.splice(found, 1);\r\n  }\r\n}\r\n\r\n// Since the delta values reported on mouse wheel events are\r\n// unstandardized between browsers and even browser versions, and\r\n// generally horribly unpredictable, this code starts by measuring\r\n// the scroll effect that the first few mouse wheel events have,\r\n// and, from that, detects the way it can convert deltas to pixel\r\n// offsets afterwards.\r\n//\r\n// The reason we want to know the amount a wheel event will scroll\r\n// is that it gives us a chance to update the display before the\r\n// actual scrolling happens, reducing flickering.\r\n\r\nvar wheelSamples = 0;\r\nvar wheelPixelsPerUnit = null;\r\n// Fill in a browser-detected starting value on browsers where we\r\n// know one. These don't have to be accurate -- the result of them\r\n// being wrong would just be a slight flicker on the first wheel\r\n// scroll (if it is large enough).\r\nif (ie) { wheelPixelsPerUnit = -.53; }\r\nelse if (gecko) { wheelPixelsPerUnit = 15; }\r\nelse if (chrome) { wheelPixelsPerUnit = -.7; }\r\nelse if (safari) { wheelPixelsPerUnit = -1/3; }\r\n\r\nfunction wheelEventDelta(e) {\r\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\r\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\r\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\r\n  else if (dy == null) { dy = e.wheelDelta; }\r\n  return {x: dx, y: dy}\r\n}\r\nfunction wheelEventPixels(e) {\r\n  var delta = wheelEventDelta(e);\r\n  delta.x *= wheelPixelsPerUnit;\r\n  delta.y *= wheelPixelsPerUnit;\r\n  return delta\r\n}\r\n\r\nfunction onScrollWheel(cm, e) {\r\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\r\n\r\n  var display = cm.display, scroll = display.scroller;\r\n  // Quit if there's nothing to scroll here\r\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth;\r\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight;\r\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\r\n\r\n  // Webkit browsers on OS X abort momentum scrolls when the target\r\n  // of the scroll event is removed from the scrollable element.\r\n  // This hack (see related code in patchDisplay) makes sure the\r\n  // element is kept around.\r\n  if (dy && mac && webkit) {\r\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\r\n      for (var i = 0; i < view.length; i++) {\r\n        if (view[i].node == cur) {\r\n          cm.display.currentWheelTarget = cur;\r\n          break outer\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // On some browsers, horizontal scrolling will cause redraws to\r\n  // happen before the gutter has been realigned, causing it to\r\n  // wriggle around in a most unseemly way. When we have an\r\n  // estimated pixels/delta value, we just handle horizontal\r\n  // scrolling entirely here. It'll be slightly off from native, but\r\n  // better than glitching out.\r\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\r\n    if (dy && canScrollY)\r\n      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\r\n    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\r\n    // Only prevent default scrolling if vertical scrolling is\r\n    // actually possible. Otherwise, it causes vertical scroll\r\n    // jitter on OSX trackpads when deltaX is small and deltaY\r\n    // is large (issue #3579)\r\n    if (!dy || (dy && canScrollY))\r\n      { e_preventDefault(e); }\r\n    display.wheelStartX = null; // Abort measurement, if in progress\r\n    return\r\n  }\r\n\r\n  // 'Project' the visible viewport to cover the area that is being\r\n  // scrolled into view (if we know enough to estimate it).\r\n  if (dy && wheelPixelsPerUnit != null) {\r\n    var pixels = dy * wheelPixelsPerUnit;\r\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\r\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\r\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\r\n    updateDisplaySimple(cm, {top: top, bottom: bot});\r\n  }\r\n\r\n  if (wheelSamples < 20) {\r\n    if (display.wheelStartX == null) {\r\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\r\n      display.wheelDX = dx; display.wheelDY = dy;\r\n      setTimeout(function () {\r\n        if (display.wheelStartX == null) { return }\r\n        var movedX = scroll.scrollLeft - display.wheelStartX;\r\n        var movedY = scroll.scrollTop - display.wheelStartY;\r\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\r\n          (movedX && display.wheelDX && movedX / display.wheelDX);\r\n        display.wheelStartX = display.wheelStartY = null;\r\n        if (!sample) { return }\r\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\r\n        ++wheelSamples;\r\n      }, 200);\r\n    } else {\r\n      display.wheelDX += dx; display.wheelDY += dy;\r\n    }\r\n  }\r\n}\r\n\r\n// Selection objects are immutable. A new one is created every time\r\n// the selection changes. A selection is one or more non-overlapping\r\n// (and non-touching) ranges, sorted, and an integer that indicates\r\n// which one is the primary selection (the one that's scrolled into\r\n// view, that getCursor returns, etc).\r\nvar Selection = function(ranges, primIndex) {\r\n  this.ranges = ranges;\r\n  this.primIndex = primIndex;\r\n};\r\n\r\nSelection.prototype.primary = function () { return this.ranges[this.primIndex] };\r\n\r\nSelection.prototype.equals = function (other) {\r\n    var this$1 = this;\r\n\r\n  if (other == this) { return true }\r\n  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\r\n  for (var i = 0; i < this.ranges.length; i++) {\r\n    var here = this$1.ranges[i], there = other.ranges[i];\r\n    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\r\n  }\r\n  return true\r\n};\r\n\r\nSelection.prototype.deepCopy = function () {\r\n    var this$1 = this;\r\n\r\n  var out = [];\r\n  for (var i = 0; i < this.ranges.length; i++)\r\n    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\r\n  return new Selection(out, this.primIndex)\r\n};\r\n\r\nSelection.prototype.somethingSelected = function () {\r\n    var this$1 = this;\r\n\r\n  for (var i = 0; i < this.ranges.length; i++)\r\n    { if (!this$1.ranges[i].empty()) { return true } }\r\n  return false\r\n};\r\n\r\nSelection.prototype.contains = function (pos, end) {\r\n    var this$1 = this;\r\n\r\n  if (!end) { end = pos; }\r\n  for (var i = 0; i < this.ranges.length; i++) {\r\n    var range = this$1.ranges[i];\r\n    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\r\n      { return i }\r\n  }\r\n  return -1\r\n};\r\n\r\nvar Range = function(anchor, head) {\r\n  this.anchor = anchor; this.head = head;\r\n};\r\n\r\nRange.prototype.from = function () { return minPos(this.anchor, this.head) };\r\nRange.prototype.to = function () { return maxPos(this.anchor, this.head) };\r\nRange.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\r\n\r\n// Take an unsorted, potentially overlapping set of ranges, and\r\n// build a selection out of it. 'Consumes' ranges array (modifying\r\n// it).\r\nfunction normalizeSelection(ranges, primIndex) {\r\n  var prim = ranges[primIndex];\r\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\r\n  primIndex = indexOf(ranges, prim);\r\n  for (var i = 1; i < ranges.length; i++) {\r\n    var cur = ranges[i], prev = ranges[i - 1];\r\n    if (cmp(prev.to(), cur.from()) >= 0) {\r\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\r\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\r\n      if (i <= primIndex) { --primIndex; }\r\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\r\n    }\r\n  }\r\n  return new Selection(ranges, primIndex)\r\n}\r\n\r\nfunction simpleSelection(anchor, head) {\r\n  return new Selection([new Range(anchor, head || anchor)], 0)\r\n}\r\n\r\n// Compute the position of the end of a change (its 'to' property\r\n// refers to the pre-change end).\r\nfunction changeEnd(change) {\r\n  if (!change.text) { return change.to }\r\n  return Pos(change.from.line + change.text.length - 1,\r\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\r\n}\r\n\r\n// Adjust a position to refer to the post-change position of the\r\n// same text, or the end of the change if the change covers it.\r\nfunction adjustForChange(pos, change) {\r\n  if (cmp(pos, change.from) < 0) { return pos }\r\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\r\n\r\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\r\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\r\n  return Pos(line, ch)\r\n}\r\n\r\nfunction computeSelAfterChange(doc, change) {\r\n  var out = [];\r\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\r\n    var range = doc.sel.ranges[i];\r\n    out.push(new Range(adjustForChange(range.anchor, change),\r\n                       adjustForChange(range.head, change)));\r\n  }\r\n  return normalizeSelection(out, doc.sel.primIndex)\r\n}\r\n\r\nfunction offsetPos(pos, old, nw) {\r\n  if (pos.line == old.line)\r\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\r\n  else\r\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\r\n}\r\n\r\n// Used by replaceSelections to allow moving the selection to the\r\n// start or around the replaced test. Hint may be \"start\" or \"around\".\r\nfunction computeReplacedSel(doc, changes, hint) {\r\n  var out = [];\r\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\r\n  for (var i = 0; i < changes.length; i++) {\r\n    var change = changes[i];\r\n    var from = offsetPos(change.from, oldPrev, newPrev);\r\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev);\r\n    oldPrev = change.to;\r\n    newPrev = to;\r\n    if (hint == \"around\") {\r\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\r\n      out[i] = new Range(inv ? to : from, inv ? from : to);\r\n    } else {\r\n      out[i] = new Range(from, from);\r\n    }\r\n  }\r\n  return new Selection(out, doc.sel.primIndex)\r\n}\r\n\r\n// Used to get the editor into a consistent state again when options change.\r\n\r\nfunction loadMode(cm) {\r\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\r\n  resetModeState(cm);\r\n}\r\n\r\nfunction resetModeState(cm) {\r\n  cm.doc.iter(function (line) {\r\n    if (line.stateAfter) { line.stateAfter = null; }\r\n    if (line.styles) { line.styles = null; }\r\n  });\r\n  cm.doc.frontier = cm.doc.first;\r\n  startWorker(cm, 100);\r\n  cm.state.modeGen++;\r\n  if (cm.curOp) { regChange(cm); }\r\n}\r\n\r\n// DOCUMENT DATA STRUCTURE\r\n\r\n// By default, updates that start and end at the beginning of a line\r\n// are treated specially, in order to make the association of line\r\n// widgets and marker elements with the text behave more intuitive.\r\nfunction isWholeLineUpdate(doc, change) {\r\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\r\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\r\n}\r\n\r\n// Perform a change on the document data structure.\r\nfunction updateDoc(doc, change, markedSpans, estimateHeight$$1) {\r\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\r\n  function update(line, text, spans) {\r\n    updateLine(line, text, spans, estimateHeight$$1);\r\n    signalLater(line, \"change\", line, change);\r\n  }\r\n  function linesFor(start, end) {\r\n    var result = [];\r\n    for (var i = start; i < end; ++i)\r\n      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\r\n    return result\r\n  }\r\n\r\n  var from = change.from, to = change.to, text = change.text;\r\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\r\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\r\n\r\n  // Adjust the line structure\r\n  if (change.full) {\r\n    doc.insert(0, linesFor(0, text.length));\r\n    doc.remove(text.length, doc.size - text.length);\r\n  } else if (isWholeLineUpdate(doc, change)) {\r\n    // This is a whole-line replace. Treated specially to make\r\n    // sure line objects move the way they are supposed to.\r\n    var added = linesFor(0, text.length - 1);\r\n    update(lastLine, lastLine.text, lastSpans);\r\n    if (nlines) { doc.remove(from.line, nlines); }\r\n    if (added.length) { doc.insert(from.line, added); }\r\n  } else if (firstLine == lastLine) {\r\n    if (text.length == 1) {\r\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\r\n    } else {\r\n      var added$1 = linesFor(1, text.length - 1);\r\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\r\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\r\n      doc.insert(from.line + 1, added$1);\r\n    }\r\n  } else if (text.length == 1) {\r\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\r\n    doc.remove(from.line + 1, nlines);\r\n  } else {\r\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\r\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\r\n    var added$2 = linesFor(1, text.length - 1);\r\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\r\n    doc.insert(from.line + 1, added$2);\r\n  }\r\n\r\n  signalLater(doc, \"change\", doc, change);\r\n}\r\n\r\n// Call f for all linked documents.\r\nfunction linkedDocs(doc, f, sharedHistOnly) {\r\n  function propagate(doc, skip, sharedHist) {\r\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\r\n      var rel = doc.linked[i];\r\n      if (rel.doc == skip) { continue }\r\n      var shared = sharedHist && rel.sharedHist;\r\n      if (sharedHistOnly && !shared) { continue }\r\n      f(rel.doc, shared);\r\n      propagate(rel.doc, doc, shared);\r\n    } }\r\n  }\r\n  propagate(doc, null, true);\r\n}\r\n\r\n// Attach a document to an editor.\r\nfunction attachDoc(cm, doc) {\r\n  if (doc.cm) { throw new Error(\"This document is already in use.\") }\r\n  cm.doc = doc;\r\n  doc.cm = cm;\r\n  estimateLineHeights(cm);\r\n  loadMode(cm);\r\n  setDirectionClass(cm);\r\n  if (!cm.options.lineWrapping) { findMaxLine(cm); }\r\n  cm.options.mode = doc.modeOption;\r\n  regChange(cm);\r\n}\r\n\r\nfunction setDirectionClass(cm) {\r\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\r\n}\r\n\r\nfunction directionChanged(cm) {\r\n  runInOp(cm, function () {\r\n    setDirectionClass(cm);\r\n    regChange(cm);\r\n  });\r\n}\r\n\r\nfunction History(startGen) {\r\n  // Arrays of change events and selections. Doing something adds an\r\n  // event to done and clears undo. Undoing moves events from done\r\n  // to undone, redoing moves them in the other direction.\r\n  this.done = []; this.undone = [];\r\n  this.undoDepth = Infinity;\r\n  // Used to track when changes can be merged into a single undo\r\n  // event\r\n  this.lastModTime = this.lastSelTime = 0;\r\n  this.lastOp = this.lastSelOp = null;\r\n  this.lastOrigin = this.lastSelOrigin = null;\r\n  // Used by the isClean() method\r\n  this.generation = this.maxGeneration = startGen || 1;\r\n}\r\n\r\n// Create a history change event from an updateDoc-style change\r\n// object.\r\nfunction historyChangeFromChange(doc, change) {\r\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\r\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\r\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\r\n  return histChange\r\n}\r\n\r\n// Pop all selection events off the end of a history array. Stop at\r\n// a change event.\r\nfunction clearSelectionEvents(array) {\r\n  while (array.length) {\r\n    var last = lst(array);\r\n    if (last.ranges) { array.pop(); }\r\n    else { break }\r\n  }\r\n}\r\n\r\n// Find the top change event in the history. Pop off selection\r\n// events that are in the way.\r\nfunction lastChangeEvent(hist, force) {\r\n  if (force) {\r\n    clearSelectionEvents(hist.done);\r\n    return lst(hist.done)\r\n  } else if (hist.done.length && !lst(hist.done).ranges) {\r\n    return lst(hist.done)\r\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\r\n    hist.done.pop();\r\n    return lst(hist.done)\r\n  }\r\n}\r\n\r\n// Register a change in the history. Merges changes that are within\r\n// a single operation, or are close together with an origin that\r\n// allows merging (starting with \"+\") into a single event.\r\nfunction addChangeToHistory(doc, change, selAfter, opId) {\r\n  var hist = doc.history;\r\n  hist.undone.length = 0;\r\n  var time = +new Date, cur;\r\n  var last;\r\n\r\n  if ((hist.lastOp == opId ||\r\n       hist.lastOrigin == change.origin && change.origin &&\r\n       ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\r\n        change.origin.charAt(0) == \"*\")) &&\r\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\r\n    // Merge this change into the last event\r\n    last = lst(cur.changes);\r\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\r\n      // Optimized case for simple insertion -- don't want to add\r\n      // new changesets for every character typed\r\n      last.to = changeEnd(change);\r\n    } else {\r\n      // Add new sub-event\r\n      cur.changes.push(historyChangeFromChange(doc, change));\r\n    }\r\n  } else {\r\n    // Can not be merged, start a new event.\r\n    var before = lst(hist.done);\r\n    if (!before || !before.ranges)\r\n      { pushSelectionToHistory(doc.sel, hist.done); }\r\n    cur = {changes: [historyChangeFromChange(doc, change)],\r\n           generation: hist.generation};\r\n    hist.done.push(cur);\r\n    while (hist.done.length > hist.undoDepth) {\r\n      hist.done.shift();\r\n      if (!hist.done[0].ranges) { hist.done.shift(); }\r\n    }\r\n  }\r\n  hist.done.push(selAfter);\r\n  hist.generation = ++hist.maxGeneration;\r\n  hist.lastModTime = hist.lastSelTime = time;\r\n  hist.lastOp = hist.lastSelOp = opId;\r\n  hist.lastOrigin = hist.lastSelOrigin = change.origin;\r\n\r\n  if (!last) { signal(doc, \"historyAdded\"); }\r\n}\r\n\r\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\r\n  var ch = origin.charAt(0);\r\n  return ch == \"*\" ||\r\n    ch == \"+\" &&\r\n    prev.ranges.length == sel.ranges.length &&\r\n    prev.somethingSelected() == sel.somethingSelected() &&\r\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\r\n}\r\n\r\n// Called whenever the selection changes, sets the new selection as\r\n// the pending selection in the history, and pushes the old pending\r\n// selection into the 'done' array when it was significantly\r\n// different (in number of selected ranges, emptiness, or time).\r\nfunction addSelectionToHistory(doc, sel, opId, options) {\r\n  var hist = doc.history, origin = options && options.origin;\r\n\r\n  // A new event is started when the previous origin does not match\r\n  // the current, or the origins don't allow matching. Origins\r\n  // starting with * are always merged, those starting with + are\r\n  // merged when similar and close together in time.\r\n  if (opId == hist.lastSelOp ||\r\n      (origin && hist.lastSelOrigin == origin &&\r\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\r\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\r\n    { hist.done[hist.done.length - 1] = sel; }\r\n  else\r\n    { pushSelectionToHistory(sel, hist.done); }\r\n\r\n  hist.lastSelTime = +new Date;\r\n  hist.lastSelOrigin = origin;\r\n  hist.lastSelOp = opId;\r\n  if (options && options.clearRedo !== false)\r\n    { clearSelectionEvents(hist.undone); }\r\n}\r\n\r\nfunction pushSelectionToHistory(sel, dest) {\r\n  var top = lst(dest);\r\n  if (!(top && top.ranges && top.equals(sel)))\r\n    { dest.push(sel); }\r\n}\r\n\r\n// Used to store marked span information in the history.\r\nfunction attachLocalSpans(doc, change, from, to) {\r\n  var existing = change[\"spans_\" + doc.id], n = 0;\r\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\r\n    if (line.markedSpans)\r\n      { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\r\n    ++n;\r\n  });\r\n}\r\n\r\n// When un/re-doing restores text containing marked spans, those\r\n// that have been explicitly cleared should not be restored.\r\nfunction removeClearedSpans(spans) {\r\n  if (!spans) { return null }\r\n  var out;\r\n  for (var i = 0; i < spans.length; ++i) {\r\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\r\n    else if (out) { out.push(spans[i]); }\r\n  }\r\n  return !out ? spans : out.length ? out : null\r\n}\r\n\r\n// Retrieve and filter the old marked spans stored in a change event.\r\nfunction getOldSpans(doc, change) {\r\n  var found = change[\"spans_\" + doc.id];\r\n  if (!found) { return null }\r\n  var nw = [];\r\n  for (var i = 0; i < change.text.length; ++i)\r\n    { nw.push(removeClearedSpans(found[i])); }\r\n  return nw\r\n}\r\n\r\n// Used for un/re-doing changes from the history. Combines the\r\n// result of computing the existing spans with the set of spans that\r\n// existed in the history (so that deleting around a span and then\r\n// undoing brings back the span).\r\nfunction mergeOldSpans(doc, change) {\r\n  var old = getOldSpans(doc, change);\r\n  var stretched = stretchSpansOverChange(doc, change);\r\n  if (!old) { return stretched }\r\n  if (!stretched) { return old }\r\n\r\n  for (var i = 0; i < old.length; ++i) {\r\n    var oldCur = old[i], stretchCur = stretched[i];\r\n    if (oldCur && stretchCur) {\r\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\r\n        var span = stretchCur[j];\r\n        for (var k = 0; k < oldCur.length; ++k)\r\n          { if (oldCur[k].marker == span.marker) { continue spans } }\r\n        oldCur.push(span);\r\n      }\r\n    } else if (stretchCur) {\r\n      old[i] = stretchCur;\r\n    }\r\n  }\r\n  return old\r\n}\r\n\r\n// Used both to provide a JSON-safe object in .getHistory, and, when\r\n// detaching a document, to split the history in two\r\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\r\n  var copy = [];\r\n  for (var i = 0; i < events.length; ++i) {\r\n    var event = events[i];\r\n    if (event.ranges) {\r\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\r\n      continue\r\n    }\r\n    var changes = event.changes, newChanges = [];\r\n    copy.push({changes: newChanges});\r\n    for (var j = 0; j < changes.length; ++j) {\r\n      var change = changes[j], m = (void 0);\r\n      newChanges.push({from: change.from, to: change.to, text: change.text});\r\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\r\n        if (indexOf(newGroup, Number(m[1])) > -1) {\r\n          lst(newChanges)[prop] = change[prop];\r\n          delete change[prop];\r\n        }\r\n      } } }\r\n    }\r\n  }\r\n  return copy\r\n}\r\n\r\n// The 'scroll' parameter given to many of these indicated whether\r\n// the new cursor position should be scrolled into view after\r\n// modifying the selection.\r\n\r\n// If shift is held or the extend flag is set, extends a range to\r\n// include a given position (and optionally a second position).\r\n// Otherwise, simply returns the range between the given positions.\r\n// Used for cursor motion and such.\r\nfunction extendRange(doc, range, head, other) {\r\n  if (doc.cm && doc.cm.display.shift || doc.extend) {\r\n    var anchor = range.anchor;\r\n    if (other) {\r\n      var posBefore = cmp(head, anchor) < 0;\r\n      if (posBefore != (cmp(other, anchor) < 0)) {\r\n        anchor = head;\r\n        head = other;\r\n      } else if (posBefore != (cmp(head, other) < 0)) {\r\n        head = other;\r\n      }\r\n    }\r\n    return new Range(anchor, head)\r\n  } else {\r\n    return new Range(other || head, head)\r\n  }\r\n}\r\n\r\n// Extend the primary selection range, discard the rest.\r\nfunction extendSelection(doc, head, other, options) {\r\n  setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\r\n}\r\n\r\n// Extend all selections (pos is an array of selections with length\r\n// equal the number of selections)\r\nfunction extendSelections(doc, heads, options) {\r\n  var out = [];\r\n  for (var i = 0; i < doc.sel.ranges.length; i++)\r\n    { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null); }\r\n  var newSel = normalizeSelection(out, doc.sel.primIndex);\r\n  setSelection(doc, newSel, options);\r\n}\r\n\r\n// Updates a single range in the selection.\r\nfunction replaceOneSelection(doc, i, range, options) {\r\n  var ranges = doc.sel.ranges.slice(0);\r\n  ranges[i] = range;\r\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\r\n}\r\n\r\n// Reset the selection to a single range.\r\nfunction setSimpleSelection(doc, anchor, head, options) {\r\n  setSelection(doc, simpleSelection(anchor, head), options);\r\n}\r\n\r\n// Give beforeSelectionChange handlers a change to influence a\r\n// selection update.\r\nfunction filterSelectionChange(doc, sel, options) {\r\n  var obj = {\r\n    ranges: sel.ranges,\r\n    update: function(ranges) {\r\n      var this$1 = this;\r\n\r\n      this.ranges = [];\r\n      for (var i = 0; i < ranges.length; i++)\r\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\r\n                                   clipPos(doc, ranges[i].head)); }\r\n    },\r\n    origin: options && options.origin\r\n  };\r\n  signal(doc, \"beforeSelectionChange\", doc, obj);\r\n  if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\r\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\r\n  else { return sel }\r\n}\r\n\r\nfunction setSelectionReplaceHistory(doc, sel, options) {\r\n  var done = doc.history.done, last = lst(done);\r\n  if (last && last.ranges) {\r\n    done[done.length - 1] = sel;\r\n    setSelectionNoUndo(doc, sel, options);\r\n  } else {\r\n    setSelection(doc, sel, options);\r\n  }\r\n}\r\n\r\n// Set a new selection.\r\nfunction setSelection(doc, sel, options) {\r\n  setSelectionNoUndo(doc, sel, options);\r\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\r\n}\r\n\r\nfunction setSelectionNoUndo(doc, sel, options) {\r\n  if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\r\n    { sel = filterSelectionChange(doc, sel, options); }\r\n\r\n  var bias = options && options.bias ||\r\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\r\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\r\n\r\n  if (!(options && options.scroll === false) && doc.cm)\r\n    { ensureCursorVisible(doc.cm); }\r\n}\r\n\r\nfunction setSelectionInner(doc, sel) {\r\n  if (sel.equals(doc.sel)) { return }\r\n\r\n  doc.sel = sel;\r\n\r\n  if (doc.cm) {\r\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\r\n    signalCursorActivity(doc.cm);\r\n  }\r\n  signalLater(doc, \"cursorActivity\", doc);\r\n}\r\n\r\n// Verify that the selection does not partially select any atomic\r\n// marked ranges.\r\nfunction reCheckSelection(doc) {\r\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\r\n}\r\n\r\n// Return a selection that does not partially select any atomic\r\n// ranges.\r\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\r\n  var out;\r\n  for (var i = 0; i < sel.ranges.length; i++) {\r\n    var range = sel.ranges[i];\r\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\r\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\r\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\r\n    if (out || newAnchor != range.anchor || newHead != range.head) {\r\n      if (!out) { out = sel.ranges.slice(0, i); }\r\n      out[i] = new Range(newAnchor, newHead);\r\n    }\r\n  }\r\n  return out ? normalizeSelection(out, sel.primIndex) : sel\r\n}\r\n\r\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\r\n  var line = getLine(doc, pos.line);\r\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\r\n    var sp = line.markedSpans[i], m = sp.marker;\r\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\r\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\r\n      if (mayClear) {\r\n        signal(m, \"beforeCursorEnter\");\r\n        if (m.explicitlyCleared) {\r\n          if (!line.markedSpans) { break }\r\n          else {--i; continue}\r\n        }\r\n      }\r\n      if (!m.atomic) { continue }\r\n\r\n      if (oldPos) {\r\n        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\r\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\r\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\r\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\r\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\r\n      }\r\n\r\n      var far = m.find(dir < 0 ? -1 : 1);\r\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\r\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\r\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\r\n    }\r\n  } }\r\n  return pos\r\n}\r\n\r\n// Ensure a given position is not inside an atomic range.\r\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\r\n  var dir = bias || 1;\r\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\r\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\r\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\r\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\r\n  if (!found) {\r\n    doc.cantEdit = true;\r\n    return Pos(doc.first, 0)\r\n  }\r\n  return found\r\n}\r\n\r\nfunction movePos(doc, pos, dir, line) {\r\n  if (dir < 0 && pos.ch == 0) {\r\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\r\n    else { return null }\r\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\r\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\r\n    else { return null }\r\n  } else {\r\n    return new Pos(pos.line, pos.ch + dir)\r\n  }\r\n}\r\n\r\nfunction selectAll(cm) {\r\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\r\n}\r\n\r\n// UPDATING\r\n\r\n// Allow \"beforeChange\" event handlers to influence a change\r\nfunction filterChange(doc, change, update) {\r\n  var obj = {\r\n    canceled: false,\r\n    from: change.from,\r\n    to: change.to,\r\n    text: change.text,\r\n    origin: change.origin,\r\n    cancel: function () { return obj.canceled = true; }\r\n  };\r\n  if (update) { obj.update = function (from, to, text, origin) {\r\n    if (from) { obj.from = clipPos(doc, from); }\r\n    if (to) { obj.to = clipPos(doc, to); }\r\n    if (text) { obj.text = text; }\r\n    if (origin !== undefined) { obj.origin = origin; }\r\n  }; }\r\n  signal(doc, \"beforeChange\", doc, obj);\r\n  if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\r\n\r\n  if (obj.canceled) { return null }\r\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\r\n}\r\n\r\n// Apply a change to a document, and add it to the document's\r\n// history, and propagating it to all linked documents.\r\nfunction makeChange(doc, change, ignoreReadOnly) {\r\n  if (doc.cm) {\r\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\r\n    if (doc.cm.state.suppressEdits) { return }\r\n  }\r\n\r\n  if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\r\n    change = filterChange(doc, change, true);\r\n    if (!change) { return }\r\n  }\r\n\r\n  // Possibly split or suppress the update based on the presence\r\n  // of read-only spans in its range.\r\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\r\n  if (split) {\r\n    for (var i = split.length - 1; i >= 0; --i)\r\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text}); }\r\n  } else {\r\n    makeChangeInner(doc, change);\r\n  }\r\n}\r\n\r\nfunction makeChangeInner(doc, change) {\r\n  if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\r\n  var selAfter = computeSelAfterChange(doc, change);\r\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\r\n\r\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\r\n  var rebased = [];\r\n\r\n  linkedDocs(doc, function (doc, sharedHist) {\r\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\r\n      rebaseHist(doc.history, change);\r\n      rebased.push(doc.history);\r\n    }\r\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\r\n  });\r\n}\r\n\r\n// Revert a change stored in a document's history.\r\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\r\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\r\n\r\n  var hist = doc.history, event, selAfter = doc.sel;\r\n  var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\r\n\r\n  // Verify that there is a useable event (so that ctrl-z won't\r\n  // needlessly clear selection events)\r\n  var i = 0;\r\n  for (; i < source.length; i++) {\r\n    event = source[i];\r\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\r\n      { break }\r\n  }\r\n  if (i == source.length) { return }\r\n  hist.lastOrigin = hist.lastSelOrigin = null;\r\n\r\n  for (;;) {\r\n    event = source.pop();\r\n    if (event.ranges) {\r\n      pushSelectionToHistory(event, dest);\r\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\r\n        setSelection(doc, event, {clearRedo: false});\r\n        return\r\n      }\r\n      selAfter = event;\r\n    }\r\n    else { break }\r\n  }\r\n\r\n  // Build up a reverse change object to add to the opposite history\r\n  // stack (redo when undoing, and vice versa).\r\n  var antiChanges = [];\r\n  pushSelectionToHistory(selAfter, dest);\r\n  dest.push({changes: antiChanges, generation: hist.generation});\r\n  hist.generation = event.generation || ++hist.maxGeneration;\r\n\r\n  var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\r\n\r\n  var loop = function ( i ) {\r\n    var change = event.changes[i];\r\n    change.origin = type;\r\n    if (filter && !filterChange(doc, change, false)) {\r\n      source.length = 0;\r\n      return {}\r\n    }\r\n\r\n    antiChanges.push(historyChangeFromChange(doc, change));\r\n\r\n    var after = i ? computeSelAfterChange(doc, change) : lst(source);\r\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\r\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\r\n    var rebased = [];\r\n\r\n    // Propagate to the linked documents\r\n    linkedDocs(doc, function (doc, sharedHist) {\r\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\r\n        rebaseHist(doc.history, change);\r\n        rebased.push(doc.history);\r\n      }\r\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\r\n    });\r\n  };\r\n\r\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\r\n    var returned = loop( i$1 );\r\n\r\n    if ( returned ) return returned.v;\r\n  }\r\n}\r\n\r\n// Sub-views need their line numbers shifted when text is added\r\n// above or below them in the parent document.\r\nfunction shiftDoc(doc, distance) {\r\n  if (distance == 0) { return }\r\n  doc.first += distance;\r\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\r\n    Pos(range.anchor.line + distance, range.anchor.ch),\r\n    Pos(range.head.line + distance, range.head.ch)\r\n  ); }), doc.sel.primIndex);\r\n  if (doc.cm) {\r\n    regChange(doc.cm, doc.first, doc.first - distance, distance);\r\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\r\n      { regLineChange(doc.cm, l, \"gutter\"); }\r\n  }\r\n}\r\n\r\n// More lower-level change function, handling only a single document\r\n// (not linked ones).\r\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\r\n  if (doc.cm && !doc.cm.curOp)\r\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\r\n\r\n  if (change.to.line < doc.first) {\r\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\r\n    return\r\n  }\r\n  if (change.from.line > doc.lastLine()) { return }\r\n\r\n  // Clip the change to the size of this doc\r\n  if (change.from.line < doc.first) {\r\n    var shift = change.text.length - 1 - (doc.first - change.from.line);\r\n    shiftDoc(doc, shift);\r\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\r\n              text: [lst(change.text)], origin: change.origin};\r\n  }\r\n  var last = doc.lastLine();\r\n  if (change.to.line > last) {\r\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\r\n              text: [change.text[0]], origin: change.origin};\r\n  }\r\n\r\n  change.removed = getBetween(doc, change.from, change.to);\r\n\r\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\r\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\r\n  else { updateDoc(doc, change, spans); }\r\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll);\r\n}\r\n\r\n// Handle the interaction of a change to a document with the editor\r\n// that this document is part of.\r\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\r\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\r\n\r\n  var recomputeMaxLength = false, checkWidthStart = from.line;\r\n  if (!cm.options.lineWrapping) {\r\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\r\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\r\n      if (line == display.maxLine) {\r\n        recomputeMaxLength = true;\r\n        return true\r\n      }\r\n    });\r\n  }\r\n\r\n  if (doc.sel.contains(change.from, change.to) > -1)\r\n    { signalCursorActivity(cm); }\r\n\r\n  updateDoc(doc, change, spans, estimateHeight(cm));\r\n\r\n  if (!cm.options.lineWrapping) {\r\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\r\n      var len = lineLength(line);\r\n      if (len > display.maxLineLength) {\r\n        display.maxLine = line;\r\n        display.maxLineLength = len;\r\n        display.maxLineChanged = true;\r\n        recomputeMaxLength = false;\r\n      }\r\n    });\r\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\r\n  }\r\n\r\n  // Adjust frontier, schedule worker\r\n  doc.frontier = Math.min(doc.frontier, from.line);\r\n  startWorker(cm, 400);\r\n\r\n  var lendiff = change.text.length - (to.line - from.line) - 1;\r\n  // Remember that these lines changed, for updating the display\r\n  if (change.full)\r\n    { regChange(cm); }\r\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\r\n    { regLineChange(cm, from.line, \"text\"); }\r\n  else\r\n    { regChange(cm, from.line, to.line + 1, lendiff); }\r\n\r\n  var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\r\n  if (changeHandler || changesHandler) {\r\n    var obj = {\r\n      from: from, to: to,\r\n      text: change.text,\r\n      removed: change.removed,\r\n      origin: change.origin\r\n    };\r\n    if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\r\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\r\n  }\r\n  cm.display.selForContextMenu = null;\r\n}\r\n\r\nfunction replaceRange(doc, code, from, to, origin) {\r\n  if (!to) { to = from; }\r\n  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\r\n  if (typeof code == \"string\") { code = doc.splitLines(code); }\r\n  makeChange(doc, {from: from, to: to, text: code, origin: origin});\r\n}\r\n\r\n// Rebasing/resetting history to deal with externally-sourced changes\r\n\r\nfunction rebaseHistSelSingle(pos, from, to, diff) {\r\n  if (to < pos.line) {\r\n    pos.line += diff;\r\n  } else if (from < pos.line) {\r\n    pos.line = from;\r\n    pos.ch = 0;\r\n  }\r\n}\r\n\r\n// Tries to rebase an array of history events given a change in the\r\n// document. If the change touches the same lines as the event, the\r\n// event, and everything 'behind' it, is discarded. If the change is\r\n// before the event, the event's positions are updated. Uses a\r\n// copy-on-write scheme for the positions, to avoid having to\r\n// reallocate them all on every rebase, but also avoid problems with\r\n// shared position objects being unsafely updated.\r\nfunction rebaseHistArray(array, from, to, diff) {\r\n  for (var i = 0; i < array.length; ++i) {\r\n    var sub = array[i], ok = true;\r\n    if (sub.ranges) {\r\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\r\n      for (var j = 0; j < sub.ranges.length; j++) {\r\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\r\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\r\n      }\r\n      continue\r\n    }\r\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\r\n      var cur = sub.changes[j$1];\r\n      if (to < cur.from.line) {\r\n        cur.from = Pos(cur.from.line + diff, cur.from.ch);\r\n        cur.to = Pos(cur.to.line + diff, cur.to.ch);\r\n      } else if (from <= cur.to.line) {\r\n        ok = false;\r\n        break\r\n      }\r\n    }\r\n    if (!ok) {\r\n      array.splice(0, i + 1);\r\n      i = 0;\r\n    }\r\n  }\r\n}\r\n\r\nfunction rebaseHist(hist, change) {\r\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\r\n  rebaseHistArray(hist.done, from, to, diff);\r\n  rebaseHistArray(hist.undone, from, to, diff);\r\n}\r\n\r\n// Utility for applying a change to a line by handle or number,\r\n// returning the number and optionally registering the line as\r\n// changed.\r\nfunction changeLine(doc, handle, changeType, op) {\r\n  var no = handle, line = handle;\r\n  if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\r\n  else { no = lineNo(handle); }\r\n  if (no == null) { return null }\r\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\r\n  return line\r\n}\r\n\r\n// The document is represented as a BTree consisting of leaves, with\r\n// chunk of lines in them, and branches, with up to ten leaves or\r\n// other branch nodes below them. The top node is always a branch\r\n// node, and is the document object itself (meaning it has\r\n// additional methods and properties).\r\n//\r\n// All nodes have parent links. The tree is used both to go from\r\n// line numbers to line objects, and to go from objects to numbers.\r\n// It also indexes by height, and is used to convert between height\r\n// and line object, and to find the total height of the document.\r\n//\r\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\r\n\r\nvar LeafChunk = function(lines) {\r\n  var this$1 = this;\r\n\r\n  this.lines = lines;\r\n  this.parent = null;\r\n  var height = 0;\r\n  for (var i = 0; i < lines.length; ++i) {\r\n    lines[i].parent = this$1;\r\n    height += lines[i].height;\r\n  }\r\n  this.height = height;\r\n};\r\n\r\nLeafChunk.prototype.chunkSize = function () { return this.lines.length };\r\n\r\n// Remove the n lines at offset 'at'.\r\nLeafChunk.prototype.removeInner = function (at, n) {\r\n    var this$1 = this;\r\n\r\n  for (var i = at, e = at + n; i < e; ++i) {\r\n    var line = this$1.lines[i];\r\n    this$1.height -= line.height;\r\n    cleanUpLine(line);\r\n    signalLater(line, \"delete\");\r\n  }\r\n  this.lines.splice(at, n);\r\n};\r\n\r\n// Helper used to collapse a small branch into a single leaf.\r\nLeafChunk.prototype.collapse = function (lines) {\r\n  lines.push.apply(lines, this.lines);\r\n};\r\n\r\n// Insert the given array of lines at offset 'at', count them as\r\n// having the given height.\r\nLeafChunk.prototype.insertInner = function (at, lines, height) {\r\n    var this$1 = this;\r\n\r\n  this.height += height;\r\n  this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\r\n  for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\r\n};\r\n\r\n// Used to iterate over a part of the tree.\r\nLeafChunk.prototype.iterN = function (at, n, op) {\r\n    var this$1 = this;\r\n\r\n  for (var e = at + n; at < e; ++at)\r\n    { if (op(this$1.lines[at])) { return true } }\r\n};\r\n\r\nvar BranchChunk = function(children) {\r\n  var this$1 = this;\r\n\r\n  this.children = children;\r\n  var size = 0, height = 0;\r\n  for (var i = 0; i < children.length; ++i) {\r\n    var ch = children[i];\r\n    size += ch.chunkSize(); height += ch.height;\r\n    ch.parent = this$1;\r\n  }\r\n  this.size = size;\r\n  this.height = height;\r\n  this.parent = null;\r\n};\r\n\r\nBranchChunk.prototype.chunkSize = function () { return this.size };\r\n\r\nBranchChunk.prototype.removeInner = function (at, n) {\r\n    var this$1 = this;\r\n\r\n  this.size -= n;\r\n  for (var i = 0; i < this.children.length; ++i) {\r\n    var child = this$1.children[i], sz = child.chunkSize();\r\n    if (at < sz) {\r\n      var rm = Math.min(n, sz - at), oldHeight = child.height;\r\n      child.removeInner(at, rm);\r\n      this$1.height -= oldHeight - child.height;\r\n      if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\r\n      if ((n -= rm) == 0) { break }\r\n      at = 0;\r\n    } else { at -= sz; }\r\n  }\r\n  // If the result is smaller than 25 lines, ensure that it is a\r\n  // single leaf node.\r\n  if (this.size - n < 25 &&\r\n      (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\r\n    var lines = [];\r\n    this.collapse(lines);\r\n    this.children = [new LeafChunk(lines)];\r\n    this.children[0].parent = this;\r\n  }\r\n};\r\n\r\nBranchChunk.prototype.collapse = function (lines) {\r\n    var this$1 = this;\r\n\r\n  for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\r\n};\r\n\r\nBranchChunk.prototype.insertInner = function (at, lines, height) {\r\n    var this$1 = this;\r\n\r\n  this.size += lines.length;\r\n  this.height += height;\r\n  for (var i = 0; i < this.children.length; ++i) {\r\n    var child = this$1.children[i], sz = child.chunkSize();\r\n    if (at <= sz) {\r\n      child.insertInner(at, lines, height);\r\n      if (child.lines && child.lines.length > 50) {\r\n        // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\r\n        // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\r\n        var remaining = child.lines.length % 25 + 25;\r\n        for (var pos = remaining; pos < child.lines.length;) {\r\n          var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\r\n          child.height -= leaf.height;\r\n          this$1.children.splice(++i, 0, leaf);\r\n          leaf.parent = this$1;\r\n        }\r\n        child.lines = child.lines.slice(0, remaining);\r\n        this$1.maybeSpill();\r\n      }\r\n      break\r\n    }\r\n    at -= sz;\r\n  }\r\n};\r\n\r\n// When a node has grown, check whether it should be split.\r\nBranchChunk.prototype.maybeSpill = function () {\r\n  if (this.children.length <= 10) { return }\r\n  var me = this;\r\n  do {\r\n    var spilled = me.children.splice(me.children.length - 5, 5);\r\n    var sibling = new BranchChunk(spilled);\r\n    if (!me.parent) { // Become the parent node\r\n      var copy = new BranchChunk(me.children);\r\n      copy.parent = me;\r\n      me.children = [copy, sibling];\r\n      me = copy;\r\n   } else {\r\n      me.size -= sibling.size;\r\n      me.height -= sibling.height;\r\n      var myIndex = indexOf(me.parent.children, me);\r\n      me.parent.children.splice(myIndex + 1, 0, sibling);\r\n    }\r\n    sibling.parent = me.parent;\r\n  } while (me.children.length > 10)\r\n  me.parent.maybeSpill();\r\n};\r\n\r\nBranchChunk.prototype.iterN = function (at, n, op) {\r\n    var this$1 = this;\r\n\r\n  for (var i = 0; i < this.children.length; ++i) {\r\n    var child = this$1.children[i], sz = child.chunkSize();\r\n    if (at < sz) {\r\n      var used = Math.min(n, sz - at);\r\n      if (child.iterN(at, used, op)) { return true }\r\n      if ((n -= used) == 0) { break }\r\n      at = 0;\r\n    } else { at -= sz; }\r\n  }\r\n};\r\n\r\n// Line widgets are block elements displayed above or below a line.\r\n\r\nvar LineWidget = function(doc, node, options) {\r\n  var this$1 = this;\r\n\r\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\r\n    { this$1[opt] = options[opt]; } } }\r\n  this.doc = doc;\r\n  this.node = node;\r\n};\r\n\r\nLineWidget.prototype.clear = function () {\r\n    var this$1 = this;\r\n\r\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\r\n  if (no == null || !ws) { return }\r\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\r\n  if (!ws.length) { line.widgets = null; }\r\n  var height = widgetHeight(this);\r\n  updateLineHeight(line, Math.max(0, line.height - height));\r\n  if (cm) {\r\n    runInOp(cm, function () {\r\n      adjustScrollWhenAboveVisible(cm, line, -height);\r\n      regLineChange(cm, no, \"widget\");\r\n    });\r\n    signalLater(cm, \"lineWidgetCleared\", cm, this, no);\r\n  }\r\n};\r\n\r\nLineWidget.prototype.changed = function () {\r\n    var this$1 = this;\r\n\r\n  var oldH = this.height, cm = this.doc.cm, line = this.line;\r\n  this.height = null;\r\n  var diff = widgetHeight(this) - oldH;\r\n  if (!diff) { return }\r\n  updateLineHeight(line, line.height + diff);\r\n  if (cm) {\r\n    runInOp(cm, function () {\r\n      cm.curOp.forceUpdate = true;\r\n      adjustScrollWhenAboveVisible(cm, line, diff);\r\n      signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\r\n    });\r\n  }\r\n};\r\neventMixin(LineWidget);\r\n\r\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\r\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\r\n    { addToScrollTop(cm, diff); }\r\n}\r\n\r\nfunction addLineWidget(doc, handle, node, options) {\r\n  var widget = new LineWidget(doc, node, options);\r\n  var cm = doc.cm;\r\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\r\n  changeLine(doc, handle, \"widget\", function (line) {\r\n    var widgets = line.widgets || (line.widgets = []);\r\n    if (widget.insertAt == null) { widgets.push(widget); }\r\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\r\n    widget.line = line;\r\n    if (cm && !lineIsHidden(doc, line)) {\r\n      var aboveVisible = heightAtLine(line) < doc.scrollTop;\r\n      updateLineHeight(line, line.height + widgetHeight(widget));\r\n      if (aboveVisible) { addToScrollTop(cm, widget.height); }\r\n      cm.curOp.forceUpdate = true;\r\n    }\r\n    return true\r\n  });\r\n  signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\r\n  return widget\r\n}\r\n\r\n// TEXTMARKERS\r\n\r\n// Created with markText and setBookmark methods. A TextMarker is a\r\n// handle that can be used to clear or find a marked position in the\r\n// document. Line objects hold arrays (markedSpans) containing\r\n// {from, to, marker} object pointing to such marker objects, and\r\n// indicating that such a marker is present on that line. Multiple\r\n// lines may point to the same marker when it spans across lines.\r\n// The spans will have null for their from/to properties when the\r\n// marker continues beyond the start/end of the line. Markers have\r\n// links back to the lines they currently touch.\r\n\r\n// Collapsed markers have unique ids, in order to be able to order\r\n// them, which is needed for uniquely determining an outer marker\r\n// when they overlap (they may nest, but not partially overlap).\r\nvar nextMarkerId = 0;\r\n\r\nvar TextMarker = function(doc, type) {\r\n  this.lines = [];\r\n  this.type = type;\r\n  this.doc = doc;\r\n  this.id = ++nextMarkerId;\r\n};\r\n\r\n// Clear the marker.\r\nTextMarker.prototype.clear = function () {\r\n    var this$1 = this;\r\n\r\n  if (this.explicitlyCleared) { return }\r\n  var cm = this.doc.cm, withOp = cm && !cm.curOp;\r\n  if (withOp) { startOperation(cm); }\r\n  if (hasHandler(this, \"clear\")) {\r\n    var found = this.find();\r\n    if (found) { signalLater(this, \"clear\", found.from, found.to); }\r\n  }\r\n  var min = null, max = null;\r\n  for (var i = 0; i < this.lines.length; ++i) {\r\n    var line = this$1.lines[i];\r\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\r\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\r\n    else if (cm) {\r\n      if (span.to != null) { max = lineNo(line); }\r\n      if (span.from != null) { min = lineNo(line); }\r\n    }\r\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span);\r\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\r\n      { updateLineHeight(line, textHeight(cm.display)); }\r\n  }\r\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\r\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\r\n    if (len > cm.display.maxLineLength) {\r\n      cm.display.maxLine = visual;\r\n      cm.display.maxLineLength = len;\r\n      cm.display.maxLineChanged = true;\r\n    }\r\n  } }\r\n\r\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\r\n  this.lines.length = 0;\r\n  this.explicitlyCleared = true;\r\n  if (this.atomic && this.doc.cantEdit) {\r\n    this.doc.cantEdit = false;\r\n    if (cm) { reCheckSelection(cm.doc); }\r\n  }\r\n  if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\r\n  if (withOp) { endOperation(cm); }\r\n  if (this.parent) { this.parent.clear(); }\r\n};\r\n\r\n// Find the position of the marker in the document. Returns a {from,\r\n// to} object by default. Side can be passed to get a specific side\r\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\r\n// Pos objects returned contain a line object, rather than a line\r\n// number (used to prevent looking up the same line twice).\r\nTextMarker.prototype.find = function (side, lineObj) {\r\n    var this$1 = this;\r\n\r\n  if (side == null && this.type == \"bookmark\") { side = 1; }\r\n  var from, to;\r\n  for (var i = 0; i < this.lines.length; ++i) {\r\n    var line = this$1.lines[i];\r\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\r\n    if (span.from != null) {\r\n      from = Pos(lineObj ? line : lineNo(line), span.from);\r\n      if (side == -1) { return from }\r\n    }\r\n    if (span.to != null) {\r\n      to = Pos(lineObj ? line : lineNo(line), span.to);\r\n      if (side == 1) { return to }\r\n    }\r\n  }\r\n  return from && {from: from, to: to}\r\n};\r\n\r\n// Signals that the marker's widget changed, and surrounding layout\r\n// should be recomputed.\r\nTextMarker.prototype.changed = function () {\r\n    var this$1 = this;\r\n\r\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\r\n  if (!pos || !cm) { return }\r\n  runInOp(cm, function () {\r\n    var line = pos.line, lineN = lineNo(pos.line);\r\n    var view = findViewForLine(cm, lineN);\r\n    if (view) {\r\n      clearLineMeasurementCacheFor(view);\r\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\r\n    }\r\n    cm.curOp.updateMaxLine = true;\r\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\r\n      var oldHeight = widget.height;\r\n      widget.height = null;\r\n      var dHeight = widgetHeight(widget) - oldHeight;\r\n      if (dHeight)\r\n        { updateLineHeight(line, line.height + dHeight); }\r\n    }\r\n    signalLater(cm, \"markerChanged\", cm, this$1);\r\n  });\r\n};\r\n\r\nTextMarker.prototype.attachLine = function (line) {\r\n  if (!this.lines.length && this.doc.cm) {\r\n    var op = this.doc.cm.curOp;\r\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\r\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\r\n  }\r\n  this.lines.push(line);\r\n};\r\n\r\nTextMarker.prototype.detachLine = function (line) {\r\n  this.lines.splice(indexOf(this.lines, line), 1);\r\n  if (!this.lines.length && this.doc.cm) {\r\n    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\r\n  }\r\n};\r\neventMixin(TextMarker);\r\n\r\n// Create a marker, wire it up to the right lines, and\r\nfunction markText(doc, from, to, options, type) {\r\n  // Shared markers (across linked documents) are handled separately\r\n  // (markTextShared will call out to this again, once per\r\n  // document).\r\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\r\n  // Ensure we are in an operation.\r\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\r\n\r\n  var marker = new TextMarker(doc, type), diff = cmp(from, to);\r\n  if (options) { copyObj(options, marker, false); }\r\n  // Don't connect empty markers unless clearWhenEmpty is false\r\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\r\n    { return marker }\r\n  if (marker.replacedWith) {\r\n    // Showing up as a widget implies collapsed (widget replaces text)\r\n    marker.collapsed = true;\r\n    marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\r\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\r\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\r\n  }\r\n  if (marker.collapsed) {\r\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\r\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\r\n      { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\r\n    seeCollapsedSpans();\r\n  }\r\n\r\n  if (marker.addToHistory)\r\n    { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\r\n\r\n  var curLine = from.line, cm = doc.cm, updateMaxLine;\r\n  doc.iter(curLine, to.line + 1, function (line) {\r\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\r\n      { updateMaxLine = true; }\r\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\r\n    addMarkedSpan(line, new MarkedSpan(marker,\r\n                                       curLine == from.line ? from.ch : null,\r\n                                       curLine == to.line ? to.ch : null));\r\n    ++curLine;\r\n  });\r\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\r\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\r\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\r\n  }); }\r\n\r\n  if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\r\n\r\n  if (marker.readOnly) {\r\n    seeReadOnlySpans();\r\n    if (doc.history.done.length || doc.history.undone.length)\r\n      { doc.clearHistory(); }\r\n  }\r\n  if (marker.collapsed) {\r\n    marker.id = ++nextMarkerId;\r\n    marker.atomic = true;\r\n  }\r\n  if (cm) {\r\n    // Sync editor state\r\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\r\n    if (marker.collapsed)\r\n      { regChange(cm, from.line, to.line + 1); }\r\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\r\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\r\n    if (marker.atomic) { reCheckSelection(cm.doc); }\r\n    signalLater(cm, \"markerAdded\", cm, marker);\r\n  }\r\n  return marker\r\n}\r\n\r\n// SHARED TEXTMARKERS\r\n\r\n// A shared marker spans multiple linked documents. It is\r\n// implemented as a meta-marker-object controlling multiple normal\r\n// markers.\r\nvar SharedTextMarker = function(markers, primary) {\r\n  var this$1 = this;\r\n\r\n  this.markers = markers;\r\n  this.primary = primary;\r\n  for (var i = 0; i < markers.length; ++i)\r\n    { markers[i].parent = this$1; }\r\n};\r\n\r\nSharedTextMarker.prototype.clear = function () {\r\n    var this$1 = this;\r\n\r\n  if (this.explicitlyCleared) { return }\r\n  this.explicitlyCleared = true;\r\n  for (var i = 0; i < this.markers.length; ++i)\r\n    { this$1.markers[i].clear(); }\r\n  signalLater(this, \"clear\");\r\n};\r\n\r\nSharedTextMarker.prototype.find = function (side, lineObj) {\r\n  return this.primary.find(side, lineObj)\r\n};\r\neventMixin(SharedTextMarker);\r\n\r\nfunction markTextShared(doc, from, to, options, type) {\r\n  options = copyObj(options);\r\n  options.shared = false;\r\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0];\r\n  var widget = options.widgetNode;\r\n  linkedDocs(doc, function (doc) {\r\n    if (widget) { options.widgetNode = widget.cloneNode(true); }\r\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\r\n    for (var i = 0; i < doc.linked.length; ++i)\r\n      { if (doc.linked[i].isParent) { return } }\r\n    primary = lst(markers);\r\n  });\r\n  return new SharedTextMarker(markers, primary)\r\n}\r\n\r\nfunction findSharedMarkers(doc) {\r\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\r\n}\r\n\r\nfunction copySharedMarkers(doc, markers) {\r\n  for (var i = 0; i < markers.length; i++) {\r\n    var marker = markers[i], pos = marker.find();\r\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\r\n    if (cmp(mFrom, mTo)) {\r\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\r\n      marker.markers.push(subMark);\r\n      subMark.parent = marker;\r\n    }\r\n  }\r\n}\r\n\r\nfunction detachSharedMarkers(markers) {\r\n  var loop = function ( i ) {\r\n    var marker = markers[i], linked = [marker.primary.doc];\r\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\r\n    for (var j = 0; j < marker.markers.length; j++) {\r\n      var subMarker = marker.markers[j];\r\n      if (indexOf(linked, subMarker.doc) == -1) {\r\n        subMarker.parent = null;\r\n        marker.markers.splice(j--, 1);\r\n      }\r\n    }\r\n  };\r\n\r\n  for (var i = 0; i < markers.length; i++) loop( i );\r\n}\r\n\r\nvar nextDocId = 0;\r\nvar Doc = function(text, mode, firstLine, lineSep, direction) {\r\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\r\n  if (firstLine == null) { firstLine = 0; }\r\n\r\n  BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\r\n  this.first = firstLine;\r\n  this.scrollTop = this.scrollLeft = 0;\r\n  this.cantEdit = false;\r\n  this.cleanGeneration = 1;\r\n  this.frontier = firstLine;\r\n  var start = Pos(firstLine, 0);\r\n  this.sel = simpleSelection(start);\r\n  this.history = new History(null);\r\n  this.id = ++nextDocId;\r\n  this.modeOption = mode;\r\n  this.lineSep = lineSep;\r\n  this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\r\n  this.extend = false;\r\n\r\n  if (typeof text == \"string\") { text = this.splitLines(text); }\r\n  updateDoc(this, {from: start, to: start, text: text});\r\n  setSelection(this, simpleSelection(start), sel_dontScroll);\r\n};\r\n\r\nDoc.prototype = createObj(BranchChunk.prototype, {\r\n  constructor: Doc,\r\n  // Iterate over the document. Supports two forms -- with only one\r\n  // argument, it calls that for each line in the document. With\r\n  // three, it iterates over the range given by the first two (with\r\n  // the second being non-inclusive).\r\n  iter: function(from, to, op) {\r\n    if (op) { this.iterN(from - this.first, to - from, op); }\r\n    else { this.iterN(this.first, this.first + this.size, from); }\r\n  },\r\n\r\n  // Non-public interface for adding and removing lines.\r\n  insert: function(at, lines) {\r\n    var height = 0;\r\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\r\n    this.insertInner(at - this.first, lines, height);\r\n  },\r\n  remove: function(at, n) { this.removeInner(at - this.first, n); },\r\n\r\n  // From here, the methods are part of the public interface. Most\r\n  // are also available from CodeMirror (editor) instances.\r\n\r\n  getValue: function(lineSep) {\r\n    var lines = getLines(this, this.first, this.first + this.size);\r\n    if (lineSep === false) { return lines }\r\n    return lines.join(lineSep || this.lineSeparator())\r\n  },\r\n  setValue: docMethodOp(function(code) {\r\n    var top = Pos(this.first, 0), last = this.first + this.size - 1;\r\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\r\n                      text: this.splitLines(code), origin: \"setValue\", full: true}, true);\r\n    if (this.cm) { scrollToCoords(this.cm, 0, 0); }\r\n    setSelection(this, simpleSelection(top), sel_dontScroll);\r\n  }),\r\n  replaceRange: function(code, from, to, origin) {\r\n    from = clipPos(this, from);\r\n    to = to ? clipPos(this, to) : from;\r\n    replaceRange(this, code, from, to, origin);\r\n  },\r\n  getRange: function(from, to, lineSep) {\r\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\r\n    if (lineSep === false) { return lines }\r\n    return lines.join(lineSep || this.lineSeparator())\r\n  },\r\n\r\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\r\n\r\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\r\n  getLineNumber: function(line) {return lineNo(line)},\r\n\r\n  getLineHandleVisualStart: function(line) {\r\n    if (typeof line == \"number\") { line = getLine(this, line); }\r\n    return visualLine(line)\r\n  },\r\n\r\n  lineCount: function() {return this.size},\r\n  firstLine: function() {return this.first},\r\n  lastLine: function() {return this.first + this.size - 1},\r\n\r\n  clipPos: function(pos) {return clipPos(this, pos)},\r\n\r\n  getCursor: function(start) {\r\n    var range$$1 = this.sel.primary(), pos;\r\n    if (start == null || start == \"head\") { pos = range$$1.head; }\r\n    else if (start == \"anchor\") { pos = range$$1.anchor; }\r\n    else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\r\n    else { pos = range$$1.from(); }\r\n    return pos\r\n  },\r\n  listSelections: function() { return this.sel.ranges },\r\n  somethingSelected: function() {return this.sel.somethingSelected()},\r\n\r\n  setCursor: docMethodOp(function(line, ch, options) {\r\n    setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\r\n  }),\r\n  setSelection: docMethodOp(function(anchor, head, options) {\r\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\r\n  }),\r\n  extendSelection: docMethodOp(function(head, other, options) {\r\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\r\n  }),\r\n  extendSelections: docMethodOp(function(heads, options) {\r\n    extendSelections(this, clipPosArray(this, heads), options);\r\n  }),\r\n  extendSelectionsBy: docMethodOp(function(f, options) {\r\n    var heads = map(this.sel.ranges, f);\r\n    extendSelections(this, clipPosArray(this, heads), options);\r\n  }),\r\n  setSelections: docMethodOp(function(ranges, primary, options) {\r\n    var this$1 = this;\r\n\r\n    if (!ranges.length) { return }\r\n    var out = [];\r\n    for (var i = 0; i < ranges.length; i++)\r\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\r\n                         clipPos(this$1, ranges[i].head)); }\r\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\r\n    setSelection(this, normalizeSelection(out, primary), options);\r\n  }),\r\n  addSelection: docMethodOp(function(anchor, head, options) {\r\n    var ranges = this.sel.ranges.slice(0);\r\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\r\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\r\n  }),\r\n\r\n  getSelection: function(lineSep) {\r\n    var this$1 = this;\r\n\r\n    var ranges = this.sel.ranges, lines;\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\r\n      lines = lines ? lines.concat(sel) : sel;\r\n    }\r\n    if (lineSep === false) { return lines }\r\n    else { return lines.join(lineSep || this.lineSeparator()) }\r\n  },\r\n  getSelections: function(lineSep) {\r\n    var this$1 = this;\r\n\r\n    var parts = [], ranges = this.sel.ranges;\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\r\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\r\n      parts[i] = sel;\r\n    }\r\n    return parts\r\n  },\r\n  replaceSelection: function(code, collapse, origin) {\r\n    var dup = [];\r\n    for (var i = 0; i < this.sel.ranges.length; i++)\r\n      { dup[i] = code; }\r\n    this.replaceSelections(dup, collapse, origin || \"+input\");\r\n  },\r\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\r\n    var this$1 = this;\r\n\r\n    var changes = [], sel = this.sel;\r\n    for (var i = 0; i < sel.ranges.length; i++) {\r\n      var range$$1 = sel.ranges[i];\r\n      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\r\n    }\r\n    var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\r\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\r\n      { makeChange(this$1, changes[i$1]); }\r\n    if (newSel) { setSelectionReplaceHistory(this, newSel); }\r\n    else if (this.cm) { ensureCursorVisible(this.cm); }\r\n  }),\r\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\r\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\r\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\r\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\r\n\r\n  setExtending: function(val) {this.extend = val;},\r\n  getExtending: function() {return this.extend},\r\n\r\n  historySize: function() {\r\n    var hist = this.history, done = 0, undone = 0;\r\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\r\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\r\n    return {undo: done, redo: undone}\r\n  },\r\n  clearHistory: function() {this.history = new History(this.history.maxGeneration);},\r\n\r\n  markClean: function() {\r\n    this.cleanGeneration = this.changeGeneration(true);\r\n  },\r\n  changeGeneration: function(forceSplit) {\r\n    if (forceSplit)\r\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\r\n    return this.history.generation\r\n  },\r\n  isClean: function (gen) {\r\n    return this.history.generation == (gen || this.cleanGeneration)\r\n  },\r\n\r\n  getHistory: function() {\r\n    return {done: copyHistoryArray(this.history.done),\r\n            undone: copyHistoryArray(this.history.undone)}\r\n  },\r\n  setHistory: function(histData) {\r\n    var hist = this.history = new History(this.history.maxGeneration);\r\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true);\r\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\r\n  },\r\n\r\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\r\n    return changeLine(this, line, \"gutter\", function (line) {\r\n      var markers = line.gutterMarkers || (line.gutterMarkers = {});\r\n      markers[gutterID] = value;\r\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\r\n      return true\r\n    })\r\n  }),\r\n\r\n  clearGutter: docMethodOp(function(gutterID) {\r\n    var this$1 = this;\r\n\r\n    this.iter(function (line) {\r\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\r\n        changeLine(this$1, line, \"gutter\", function () {\r\n          line.gutterMarkers[gutterID] = null;\r\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\r\n          return true\r\n        });\r\n      }\r\n    });\r\n  }),\r\n\r\n  lineInfo: function(line) {\r\n    var n;\r\n    if (typeof line == \"number\") {\r\n      if (!isLine(this, line)) { return null }\r\n      n = line;\r\n      line = getLine(this, line);\r\n      if (!line) { return null }\r\n    } else {\r\n      n = lineNo(line);\r\n      if (n == null) { return null }\r\n    }\r\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\r\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\r\n            widgets: line.widgets}\r\n  },\r\n\r\n  addLineClass: docMethodOp(function(handle, where, cls) {\r\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\r\n      var prop = where == \"text\" ? \"textClass\"\r\n               : where == \"background\" ? \"bgClass\"\r\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\r\n      if (!line[prop]) { line[prop] = cls; }\r\n      else if (classTest(cls).test(line[prop])) { return false }\r\n      else { line[prop] += \" \" + cls; }\r\n      return true\r\n    })\r\n  }),\r\n  removeLineClass: docMethodOp(function(handle, where, cls) {\r\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\r\n      var prop = where == \"text\" ? \"textClass\"\r\n               : where == \"background\" ? \"bgClass\"\r\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\r\n      var cur = line[prop];\r\n      if (!cur) { return false }\r\n      else if (cls == null) { line[prop] = null; }\r\n      else {\r\n        var found = cur.match(classTest(cls));\r\n        if (!found) { return false }\r\n        var end = found.index + found[0].length;\r\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\r\n      }\r\n      return true\r\n    })\r\n  }),\r\n\r\n  addLineWidget: docMethodOp(function(handle, node, options) {\r\n    return addLineWidget(this, handle, node, options)\r\n  }),\r\n  removeLineWidget: function(widget) { widget.clear(); },\r\n\r\n  markText: function(from, to, options) {\r\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\r\n  },\r\n  setBookmark: function(pos, options) {\r\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\r\n                    insertLeft: options && options.insertLeft,\r\n                    clearWhenEmpty: false, shared: options && options.shared,\r\n                    handleMouseEvents: options && options.handleMouseEvents};\r\n    pos = clipPos(this, pos);\r\n    return markText(this, pos, pos, realOpts, \"bookmark\")\r\n  },\r\n  findMarksAt: function(pos) {\r\n    pos = clipPos(this, pos);\r\n    var markers = [], spans = getLine(this, pos.line).markedSpans;\r\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\r\n      var span = spans[i];\r\n      if ((span.from == null || span.from <= pos.ch) &&\r\n          (span.to == null || span.to >= pos.ch))\r\n        { markers.push(span.marker.parent || span.marker); }\r\n    } }\r\n    return markers\r\n  },\r\n  findMarks: function(from, to, filter) {\r\n    from = clipPos(this, from); to = clipPos(this, to);\r\n    var found = [], lineNo$$1 = from.line;\r\n    this.iter(from.line, to.line + 1, function (line) {\r\n      var spans = line.markedSpans;\r\n      if (spans) { for (var i = 0; i < spans.length; i++) {\r\n        var span = spans[i];\r\n        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\r\n              span.from == null && lineNo$$1 != from.line ||\r\n              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\r\n            (!filter || filter(span.marker)))\r\n          { found.push(span.marker.parent || span.marker); }\r\n      } }\r\n      ++lineNo$$1;\r\n    });\r\n    return found\r\n  },\r\n  getAllMarks: function() {\r\n    var markers = [];\r\n    this.iter(function (line) {\r\n      var sps = line.markedSpans;\r\n      if (sps) { for (var i = 0; i < sps.length; ++i)\r\n        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\r\n    });\r\n    return markers\r\n  },\r\n\r\n  posFromIndex: function(off) {\r\n    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\r\n    this.iter(function (line) {\r\n      var sz = line.text.length + sepSize;\r\n      if (sz > off) { ch = off; return true }\r\n      off -= sz;\r\n      ++lineNo$$1;\r\n    });\r\n    return clipPos(this, Pos(lineNo$$1, ch))\r\n  },\r\n  indexFromPos: function (coords) {\r\n    coords = clipPos(this, coords);\r\n    var index = coords.ch;\r\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\r\n    var sepSize = this.lineSeparator().length;\r\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\r\n      index += line.text.length + sepSize;\r\n    });\r\n    return index\r\n  },\r\n\r\n  copy: function(copyHistory) {\r\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\r\n                      this.modeOption, this.first, this.lineSep, this.direction);\r\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\r\n    doc.sel = this.sel;\r\n    doc.extend = false;\r\n    if (copyHistory) {\r\n      doc.history.undoDepth = this.history.undoDepth;\r\n      doc.setHistory(this.getHistory());\r\n    }\r\n    return doc\r\n  },\r\n\r\n  linkedDoc: function(options) {\r\n    if (!options) { options = {}; }\r\n    var from = this.first, to = this.first + this.size;\r\n    if (options.from != null && options.from > from) { from = options.from; }\r\n    if (options.to != null && options.to < to) { to = options.to; }\r\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\r\n    if (options.sharedHist) { copy.history = this.history\r\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\r\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\r\n    copySharedMarkers(copy, findSharedMarkers(this));\r\n    return copy\r\n  },\r\n  unlinkDoc: function(other) {\r\n    var this$1 = this;\r\n\r\n    if (other instanceof CodeMirror$1) { other = other.doc; }\r\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\r\n      var link = this$1.linked[i];\r\n      if (link.doc != other) { continue }\r\n      this$1.linked.splice(i, 1);\r\n      other.unlinkDoc(this$1);\r\n      detachSharedMarkers(findSharedMarkers(this$1));\r\n      break\r\n    } }\r\n    // If the histories were shared, split them again\r\n    if (other.history == this.history) {\r\n      var splitIds = [other.id];\r\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\r\n      other.history = new History(null);\r\n      other.history.done = copyHistoryArray(this.history.done, splitIds);\r\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds);\r\n    }\r\n  },\r\n  iterLinkedDocs: function(f) {linkedDocs(this, f);},\r\n\r\n  getMode: function() {return this.mode},\r\n  getEditor: function() {return this.cm},\r\n\r\n  splitLines: function(str) {\r\n    if (this.lineSep) { return str.split(this.lineSep) }\r\n    return splitLinesAuto(str)\r\n  },\r\n  lineSeparator: function() { return this.lineSep || \"\\n\" },\r\n\r\n  setDirection: docMethodOp(function (dir) {\r\n    if (dir != \"rtl\") { dir = \"ltr\"; }\r\n    if (dir == this.direction) { return }\r\n    this.direction = dir;\r\n    this.iter(function (line) { return line.order = null; });\r\n    if (this.cm) { directionChanged(this.cm); }\r\n  })\r\n});\r\n\r\n// Public alias.\r\nDoc.prototype.eachLine = Doc.prototype.iter;\r\n\r\n// Kludge to work around strange IE behavior where it'll sometimes\r\n// re-fire a series of drag-related events right after the drop (#1551)\r\nvar lastDrop = 0;\r\n\r\nfunction onDrop(e) {\r\n  var cm = this;\r\n  clearDragCursor(cm);\r\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\r\n    { return }\r\n  e_preventDefault(e);\r\n  if (ie) { lastDrop = +new Date; }\r\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\r\n  if (!pos || cm.isReadOnly()) { return }\r\n  // Might be a file drop, in which case we simply extract the text\r\n  // and insert it.\r\n  if (files && files.length && window.FileReader && window.File) {\r\n    var n = files.length, text = Array(n), read = 0;\r\n    var loadFile = function (file, i) {\r\n      if (cm.options.allowDropFileTypes &&\r\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\r\n        { return }\r\n\r\n      var reader = new FileReader;\r\n      reader.onload = operation(cm, function () {\r\n        var content = reader.result;\r\n        if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\r\n        text[i] = content;\r\n        if (++read == n) {\r\n          pos = clipPos(cm.doc, pos);\r\n          var change = {from: pos, to: pos,\r\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\r\n                        origin: \"paste\"};\r\n          makeChange(cm.doc, change);\r\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\r\n        }\r\n      });\r\n      reader.readAsText(file);\r\n    };\r\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\r\n  } else { // Normal drop\r\n    // Don't do a replace if the drop happened inside of the selected text.\r\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\r\n      cm.state.draggingText(e);\r\n      // Ensure the editor is re-focused\r\n      setTimeout(function () { return cm.display.input.focus(); }, 20);\r\n      return\r\n    }\r\n    try {\r\n      var text$1 = e.dataTransfer.getData(\"Text\");\r\n      if (text$1) {\r\n        var selected;\r\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\r\n          { selected = cm.listSelections(); }\r\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\r\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\r\n          { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\r\n        cm.replaceSelection(text$1, \"around\", \"paste\");\r\n        cm.display.input.focus();\r\n      }\r\n    }\r\n    catch(e){}\r\n  }\r\n}\r\n\r\nfunction onDragStart(cm, e) {\r\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\r\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\r\n\r\n  e.dataTransfer.setData(\"Text\", cm.getSelection());\r\n  e.dataTransfer.effectAllowed = \"copyMove\";\r\n\r\n  // Use dummy image instead of default browsers image.\r\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\r\n  if (e.dataTransfer.setDragImage && !safari) {\r\n    var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\r\n    img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\r\n    if (presto) {\r\n      img.width = img.height = 1;\r\n      cm.display.wrapper.appendChild(img);\r\n      // Force a relayout, or Opera won't use our image for some obscure reason\r\n      img._top = img.offsetTop;\r\n    }\r\n    e.dataTransfer.setDragImage(img, 0, 0);\r\n    if (presto) { img.parentNode.removeChild(img); }\r\n  }\r\n}\r\n\r\nfunction onDragOver(cm, e) {\r\n  var pos = posFromMouse(cm, e);\r\n  if (!pos) { return }\r\n  var frag = document.createDocumentFragment();\r\n  drawSelectionCursor(cm, pos, frag);\r\n  if (!cm.display.dragCursor) {\r\n    cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\r\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\r\n  }\r\n  removeChildrenAndAdd(cm.display.dragCursor, frag);\r\n}\r\n\r\nfunction clearDragCursor(cm) {\r\n  if (cm.display.dragCursor) {\r\n    cm.display.lineSpace.removeChild(cm.display.dragCursor);\r\n    cm.display.dragCursor = null;\r\n  }\r\n}\r\n\r\n// These must be handled carefully, because naively registering a\r\n// handler for each editor will cause the editors to never be\r\n// garbage collected.\r\n\r\nfunction forEachCodeMirror(f) {\r\n  if (!document.body.getElementsByClassName) { return }\r\n  var byClass = document.body.getElementsByClassName(\"CodeMirror\");\r\n  for (var i = 0; i < byClass.length; i++) {\r\n    var cm = byClass[i].CodeMirror;\r\n    if (cm) { f(cm); }\r\n  }\r\n}\r\n\r\nvar globalsRegistered = false;\r\nfunction ensureGlobalHandlers() {\r\n  if (globalsRegistered) { return }\r\n  registerGlobalHandlers();\r\n  globalsRegistered = true;\r\n}\r\nfunction registerGlobalHandlers() {\r\n  // When the window resizes, we need to refresh active editors.\r\n  var resizeTimer;\r\n  on(window, \"resize\", function () {\r\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\r\n      resizeTimer = null;\r\n      forEachCodeMirror(onResize);\r\n    }, 100); }\r\n  });\r\n  // When the window loses focus, we want to show the editor as blurred\r\n  on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\r\n}\r\n// Called when the window resizes\r\nfunction onResize(cm) {\r\n  var d = cm.display;\r\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\r\n    { return }\r\n  // Might be a text scaling operation, clear size caches.\r\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\r\n  d.scrollbarsClipped = false;\r\n  cm.setSize();\r\n}\r\n\r\nvar keyNames = {\r\n  3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\r\n  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\r\n  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\r\n  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\r\n  106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\r\n  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\r\n  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\r\n  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\r\n};\r\n\r\n// Number keys\r\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\r\n// Alphabetic keys\r\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\r\n// Function keys\r\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\r\n\r\nvar keyMap = {};\r\n\r\nkeyMap.basic = {\r\n  \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\r\n  \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\r\n  \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\r\n  \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\r\n  \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\r\n  \"Esc\": \"singleSelection\"\r\n};\r\n// Note that the save and find-related commands aren't defined by\r\n// default. User code or addons can define them. Unknown commands\r\n// are simply ignored.\r\nkeyMap.pcDefault = {\r\n  \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\r\n  \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\r\n  \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\r\n  \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\r\n  \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\r\n  \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\r\n  \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\r\n  fallthrough: \"basic\"\r\n};\r\n// Very basic readline/emacs-style bindings, which are standard on Mac.\r\nkeyMap.emacsy = {\r\n  \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\r\n  \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\r\n  \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\r\n  \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\r\n  \"Ctrl-O\": \"openLine\"\r\n};\r\nkeyMap.macDefault = {\r\n  \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\r\n  \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\r\n  \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\r\n  \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\r\n  \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\r\n  \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\r\n  \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\r\n  fallthrough: [\"basic\", \"emacsy\"]\r\n};\r\nkeyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\r\n\r\n// KEYMAP DISPATCH\r\n\r\nfunction normalizeKeyName(name) {\r\n  var parts = name.split(/-(?!$)/);\r\n  name = parts[parts.length - 1];\r\n  var alt, ctrl, shift, cmd;\r\n  for (var i = 0; i < parts.length - 1; i++) {\r\n    var mod = parts[i];\r\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\r\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\r\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\r\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\r\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\r\n  }\r\n  if (alt) { name = \"Alt-\" + name; }\r\n  if (ctrl) { name = \"Ctrl-\" + name; }\r\n  if (cmd) { name = \"Cmd-\" + name; }\r\n  if (shift) { name = \"Shift-\" + name; }\r\n  return name\r\n}\r\n\r\n// This is a kludge to keep keymaps mostly working as raw objects\r\n// (backwards compatibility) while at the same time support features\r\n// like normalization and multi-stroke key bindings. It compiles a\r\n// new normalized keymap, and then updates the old object to reflect\r\n// this.\r\nfunction normalizeKeyMap(keymap) {\r\n  var copy = {};\r\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\r\n    var value = keymap[keyname];\r\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\r\n    if (value == \"...\") { delete keymap[keyname]; continue }\r\n\r\n    var keys = map(keyname.split(\" \"), normalizeKeyName);\r\n    for (var i = 0; i < keys.length; i++) {\r\n      var val = (void 0), name = (void 0);\r\n      if (i == keys.length - 1) {\r\n        name = keys.join(\" \");\r\n        val = value;\r\n      } else {\r\n        name = keys.slice(0, i + 1).join(\" \");\r\n        val = \"...\";\r\n      }\r\n      var prev = copy[name];\r\n      if (!prev) { copy[name] = val; }\r\n      else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\r\n    }\r\n    delete keymap[keyname];\r\n  } }\r\n  for (var prop in copy) { keymap[prop] = copy[prop]; }\r\n  return keymap\r\n}\r\n\r\nfunction lookupKey(key, map$$1, handle, context) {\r\n  map$$1 = getKeyMap(map$$1);\r\n  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\r\n  if (found === false) { return \"nothing\" }\r\n  if (found === \"...\") { return \"multi\" }\r\n  if (found != null && handle(found)) { return \"handled\" }\r\n\r\n  if (map$$1.fallthrough) {\r\n    if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\r\n      { return lookupKey(key, map$$1.fallthrough, handle, context) }\r\n    for (var i = 0; i < map$$1.fallthrough.length; i++) {\r\n      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\r\n      if (result) { return result }\r\n    }\r\n  }\r\n}\r\n\r\n// Modifier key presses don't count as 'real' key presses for the\r\n// purpose of keymap fallthrough.\r\nfunction isModifierKey(value) {\r\n  var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\r\n  return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\r\n}\r\n\r\n// Look up the name of a key as indicated by an event object.\r\nfunction keyName(event, noShift) {\r\n  if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\r\n  var base = keyNames[event.keyCode], name = base;\r\n  if (name == null || event.altGraphKey) { return false }\r\n  if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\r\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\r\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\r\n  if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\r\n  return name\r\n}\r\n\r\nfunction getKeyMap(val) {\r\n  return typeof val == \"string\" ? keyMap[val] : val\r\n}\r\n\r\n// Helper for deleting text near the selection(s), used to implement\r\n// backspace, delete, and similar functionality.\r\nfunction deleteNearSelection(cm, compute) {\r\n  var ranges = cm.doc.sel.ranges, kill = [];\r\n  // Build up a set of ranges to kill first, merging overlapping\r\n  // ranges.\r\n  for (var i = 0; i < ranges.length; i++) {\r\n    var toKill = compute(ranges[i]);\r\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\r\n      var replaced = kill.pop();\r\n      if (cmp(replaced.from, toKill.from) < 0) {\r\n        toKill.from = replaced.from;\r\n        break\r\n      }\r\n    }\r\n    kill.push(toKill);\r\n  }\r\n  // Next, remove those actual ranges.\r\n  runInOp(cm, function () {\r\n    for (var i = kill.length - 1; i >= 0; i--)\r\n      { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\r\n    ensureCursorVisible(cm);\r\n  });\r\n}\r\n\r\n// Commands are parameter-less actions that can be performed on an\r\n// editor, mostly used for keybindings.\r\nvar commands = {\r\n  selectAll: selectAll,\r\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\r\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\r\n    if (range.empty()) {\r\n      var len = getLine(cm.doc, range.head.line).text.length;\r\n      if (range.head.ch == len && range.head.line < cm.lastLine())\r\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\r\n      else\r\n        { return {from: range.head, to: Pos(range.head.line, len)} }\r\n    } else {\r\n      return {from: range.from(), to: range.to()}\r\n    }\r\n  }); },\r\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\r\n    from: Pos(range.from().line, 0),\r\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\r\n  }); }); },\r\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\r\n    from: Pos(range.from().line, 0), to: range.from()\r\n  }); }); },\r\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\r\n    var top = cm.charCoords(range.head, \"div\").top + 5;\r\n    var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\r\n    return {from: leftPos, to: range.from()}\r\n  }); },\r\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\r\n    var top = cm.charCoords(range.head, \"div\").top + 5;\r\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\r\n    return {from: range.from(), to: rightPos }\r\n  }); },\r\n  undo: function (cm) { return cm.undo(); },\r\n  redo: function (cm) { return cm.redo(); },\r\n  undoSelection: function (cm) { return cm.undoSelection(); },\r\n  redoSelection: function (cm) { return cm.redoSelection(); },\r\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\r\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\r\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\r\n    {origin: \"+move\", bias: 1}\r\n  ); },\r\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\r\n    {origin: \"+move\", bias: 1}\r\n  ); },\r\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\r\n    {origin: \"+move\", bias: -1}\r\n  ); },\r\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\r\n    var top = cm.charCoords(range.head, \"div\").top + 5;\r\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\r\n  }, sel_move); },\r\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\r\n    var top = cm.charCoords(range.head, \"div\").top + 5;\r\n    return cm.coordsChar({left: 0, top: top}, \"div\")\r\n  }, sel_move); },\r\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\r\n    var top = cm.charCoords(range.head, \"div\").top + 5;\r\n    var pos = cm.coordsChar({left: 0, top: top}, \"div\");\r\n    if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\r\n    return pos\r\n  }, sel_move); },\r\n  goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\r\n  goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\r\n  goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\r\n  goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\r\n  goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\r\n  goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\r\n  goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\r\n  goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\r\n  goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\r\n  goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\r\n  goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\r\n  goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\r\n  delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\r\n  delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\r\n  delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\r\n  delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\r\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\r\n  delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\r\n  indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\r\n  indentMore: function (cm) { return cm.indentSelection(\"add\"); },\r\n  indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\r\n  insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\r\n  insertSoftTab: function (cm) {\r\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var pos = ranges[i].from();\r\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\r\n      spaces.push(spaceStr(tabSize - col % tabSize));\r\n    }\r\n    cm.replaceSelections(spaces);\r\n  },\r\n  defaultTab: function (cm) {\r\n    if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\r\n    else { cm.execCommand(\"insertTab\"); }\r\n  },\r\n  // Swap the two chars left and right of each selection's head.\r\n  // Move cursor behind the two swapped characters afterwards.\r\n  //\r\n  // Doesn't consider line feeds a character.\r\n  // Doesn't scan more than one line above to find a character.\r\n  // Doesn't do anything on an empty line.\r\n  // Doesn't do anything with non-empty selections.\r\n  transposeChars: function (cm) { return runInOp(cm, function () {\r\n    var ranges = cm.listSelections(), newSel = [];\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      if (!ranges[i].empty()) { continue }\r\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\r\n      if (line) {\r\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\r\n        if (cur.ch > 0) {\r\n          cur = new Pos(cur.line, cur.ch + 1);\r\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\r\n                          Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\r\n        } else if (cur.line > cm.doc.first) {\r\n          var prev = getLine(cm.doc, cur.line - 1).text;\r\n          if (prev) {\r\n            cur = new Pos(cur.line, 1);\r\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\r\n                            prev.charAt(prev.length - 1),\r\n                            Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\r\n          }\r\n        }\r\n      }\r\n      newSel.push(new Range(cur, cur));\r\n    }\r\n    cm.setSelections(newSel);\r\n  }); },\r\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\r\n    var sels = cm.listSelections();\r\n    for (var i = sels.length - 1; i >= 0; i--)\r\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\r\n    sels = cm.listSelections();\r\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\r\n      { cm.indentLine(sels[i$1].from().line, null, true); }\r\n    ensureCursorVisible(cm);\r\n  }); },\r\n  openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\r\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\r\n};\r\n\r\n\r\nfunction lineStart(cm, lineN) {\r\n  var line = getLine(cm.doc, lineN);\r\n  var visual = visualLine(line);\r\n  if (visual != line) { lineN = lineNo(visual); }\r\n  return endOfLine(true, cm, visual, lineN, 1)\r\n}\r\nfunction lineEnd(cm, lineN) {\r\n  var line = getLine(cm.doc, lineN);\r\n  var visual = visualLineEnd(line);\r\n  if (visual != line) { lineN = lineNo(visual); }\r\n  return endOfLine(true, cm, line, lineN, -1)\r\n}\r\nfunction lineStartSmart(cm, pos) {\r\n  var start = lineStart(cm, pos.line);\r\n  var line = getLine(cm.doc, start.line);\r\n  var order = getOrder(line, cm.doc.direction);\r\n  if (!order || order[0].level == 0) {\r\n    var firstNonWS = Math.max(0, line.text.search(/\\S/));\r\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\r\n    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\r\n  }\r\n  return start\r\n}\r\n\r\n// Run a handler that was bound to a key.\r\nfunction doHandleBinding(cm, bound, dropShift) {\r\n  if (typeof bound == \"string\") {\r\n    bound = commands[bound];\r\n    if (!bound) { return false }\r\n  }\r\n  // Ensure previous input has been read, so that the handler sees a\r\n  // consistent view of the document\r\n  cm.display.input.ensurePolled();\r\n  var prevShift = cm.display.shift, done = false;\r\n  try {\r\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\r\n    if (dropShift) { cm.display.shift = false; }\r\n    done = bound(cm) != Pass;\r\n  } finally {\r\n    cm.display.shift = prevShift;\r\n    cm.state.suppressEdits = false;\r\n  }\r\n  return done\r\n}\r\n\r\nfunction lookupKeyForEditor(cm, name, handle) {\r\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\r\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\r\n    if (result) { return result }\r\n  }\r\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\r\n    || lookupKey(name, cm.options.keyMap, handle, cm)\r\n}\r\n\r\nvar stopSeq = new Delayed;\r\nfunction dispatchKey(cm, name, e, handle) {\r\n  var seq = cm.state.keySeq;\r\n  if (seq) {\r\n    if (isModifierKey(name)) { return \"handled\" }\r\n    stopSeq.set(50, function () {\r\n      if (cm.state.keySeq == seq) {\r\n        cm.state.keySeq = null;\r\n        cm.display.input.reset();\r\n      }\r\n    });\r\n    name = seq + \" \" + name;\r\n  }\r\n  var result = lookupKeyForEditor(cm, name, handle);\r\n\r\n  if (result == \"multi\")\r\n    { cm.state.keySeq = name; }\r\n  if (result == \"handled\")\r\n    { signalLater(cm, \"keyHandled\", cm, name, e); }\r\n\r\n  if (result == \"handled\" || result == \"multi\") {\r\n    e_preventDefault(e);\r\n    restartBlink(cm);\r\n  }\r\n\r\n  if (seq && !result && /\\'$/.test(name)) {\r\n    e_preventDefault(e);\r\n    return true\r\n  }\r\n  return !!result\r\n}\r\n\r\n// Handle a key from the keydown event.\r\nfunction handleKeyBinding(cm, e) {\r\n  var name = keyName(e, true);\r\n  if (!name) { return false }\r\n\r\n  if (e.shiftKey && !cm.state.keySeq) {\r\n    // First try to resolve full name (including 'Shift-'). Failing\r\n    // that, see if there is a cursor-motion command (starting with\r\n    // 'go') bound to the keyname without 'Shift-'.\r\n    return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\r\n        || dispatchKey(cm, name, e, function (b) {\r\n             if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\r\n               { return doHandleBinding(cm, b) }\r\n           })\r\n  } else {\r\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\r\n  }\r\n}\r\n\r\n// Handle a key from the keypress event\r\nfunction handleCharBinding(cm, e, ch) {\r\n  return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\r\n}\r\n\r\nvar lastStoppedKey = null;\r\nfunction onKeyDown(e) {\r\n  var cm = this;\r\n  cm.curOp.focus = activeElt();\r\n  if (signalDOMEvent(cm, e)) { return }\r\n  // IE does strange things with escape.\r\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\r\n  var code = e.keyCode;\r\n  cm.display.shift = code == 16 || e.shiftKey;\r\n  var handled = handleKeyBinding(cm, e);\r\n  if (presto) {\r\n    lastStoppedKey = handled ? code : null;\r\n    // Opera has no cut event... we try to at least catch the key combo\r\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\r\n      { cm.replaceSelection(\"\", null, \"cut\"); }\r\n  }\r\n\r\n  // Turn mouse into crosshair when Alt is held on Mac.\r\n  if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\r\n    { showCrossHair(cm); }\r\n}\r\n\r\nfunction showCrossHair(cm) {\r\n  var lineDiv = cm.display.lineDiv;\r\n  addClass(lineDiv, \"CodeMirror-crosshair\");\r\n\r\n  function up(e) {\r\n    if (e.keyCode == 18 || !e.altKey) {\r\n      rmClass(lineDiv, \"CodeMirror-crosshair\");\r\n      off(document, \"keyup\", up);\r\n      off(document, \"mouseover\", up);\r\n    }\r\n  }\r\n  on(document, \"keyup\", up);\r\n  on(document, \"mouseover\", up);\r\n}\r\n\r\nfunction onKeyUp(e) {\r\n  if (e.keyCode == 16) { this.doc.sel.shift = false; }\r\n  signalDOMEvent(this, e);\r\n}\r\n\r\nfunction onKeyPress(e) {\r\n  var cm = this;\r\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\r\n  var keyCode = e.keyCode, charCode = e.charCode;\r\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\r\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\r\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\r\n  // Some browsers fire keypress events for backspace\r\n  if (ch == \"\\x08\") { return }\r\n  if (handleCharBinding(cm, e, ch)) { return }\r\n  cm.display.input.onKeyPress(e);\r\n}\r\n\r\n// A mouse down can be a single click, double click, triple click,\r\n// start of selection drag, start of text drag, new cursor\r\n// (ctrl-click), rectangle drag (alt-drag), or xwin\r\n// middle-click-paste. Or it might be a click on something we should\r\n// not interfere with, such as a scrollbar or widget.\r\nfunction onMouseDown(e) {\r\n  var cm = this, display = cm.display;\r\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\r\n  display.input.ensurePolled();\r\n  display.shift = e.shiftKey;\r\n\r\n  if (eventInWidget(display, e)) {\r\n    if (!webkit) {\r\n      // Briefly turn off draggability, to allow widgets to do\r\n      // normal dragging things.\r\n      display.scroller.draggable = false;\r\n      setTimeout(function () { return display.scroller.draggable = true; }, 100);\r\n    }\r\n    return\r\n  }\r\n  if (clickInGutter(cm, e)) { return }\r\n  var start = posFromMouse(cm, e);\r\n  window.focus();\r\n\r\n  switch (e_button(e)) {\r\n  case 1:\r\n    // #3261: make sure, that we're not starting a second selection\r\n    if (cm.state.selectingText)\r\n      { cm.state.selectingText(e); }\r\n    else if (start)\r\n      { leftButtonDown(cm, e, start); }\r\n    else if (e_target(e) == display.scroller)\r\n      { e_preventDefault(e); }\r\n    break\r\n  case 2:\r\n    if (webkit) { cm.state.lastMiddleDown = +new Date; }\r\n    if (start) { extendSelection(cm.doc, start); }\r\n    setTimeout(function () { return display.input.focus(); }, 20);\r\n    e_preventDefault(e);\r\n    break\r\n  case 3:\r\n    if (captureRightClick) { onContextMenu(cm, e); }\r\n    else { delayBlurEvent(cm); }\r\n    break\r\n  }\r\n}\r\n\r\nvar lastClick;\r\nvar lastDoubleClick;\r\nfunction leftButtonDown(cm, e, start) {\r\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\r\n  else { cm.curOp.focus = activeElt(); }\r\n\r\n  var now = +new Date, type;\r\n  if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\r\n    type = \"triple\";\r\n  } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\r\n    type = \"double\";\r\n    lastDoubleClick = {time: now, pos: start};\r\n  } else {\r\n    type = \"single\";\r\n    lastClick = {time: now, pos: start};\r\n  }\r\n\r\n  var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\r\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\r\n      type == \"single\" && (contained = sel.contains(start)) > -1 &&\r\n      (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\r\n      (cmp(contained.to(), start) > 0 || start.xRel < 0))\r\n    { leftButtonStartDrag(cm, e, start, modifier); }\r\n  else\r\n    { leftButtonSelect(cm, e, start, type, modifier); }\r\n}\r\n\r\n// Start a text drag. When it ends, see if any dragging actually\r\n// happen, and treat as a click if it didn't.\r\nfunction leftButtonStartDrag(cm, e, start, modifier) {\r\n  var display = cm.display, moved = false;\r\n  var dragEnd = operation(cm, function (e) {\r\n    if (webkit) { display.scroller.draggable = false; }\r\n    cm.state.draggingText = false;\r\n    off(document, \"mouseup\", dragEnd);\r\n    off(document, \"mousemove\", mouseMove);\r\n    off(display.scroller, \"dragstart\", dragStart);\r\n    off(display.scroller, \"drop\", dragEnd);\r\n    if (!moved) {\r\n      e_preventDefault(e);\r\n      if (!modifier)\r\n        { extendSelection(cm.doc, start); }\r\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\r\n      if (webkit || ie && ie_version == 9)\r\n        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }\r\n      else\r\n        { display.input.focus(); }\r\n    }\r\n  });\r\n  var mouseMove = function(e2) {\r\n    moved = moved || Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) >= 10;\r\n  };\r\n  var dragStart = function () { return moved = true; };\r\n  // Let the drag handler handle this.\r\n  if (webkit) { display.scroller.draggable = true; }\r\n  cm.state.draggingText = dragEnd;\r\n  dragEnd.copy = mac ? e.altKey : e.ctrlKey;\r\n  // IE's approach to draggable\r\n  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\r\n  on(document, \"mouseup\", dragEnd);\r\n  on(document, \"mousemove\", mouseMove);\r\n  on(display.scroller, \"dragstart\", dragStart);\r\n  on(display.scroller, \"drop\", dragEnd);\r\n\r\n  delayBlurEvent(cm);\r\n  setTimeout(function () { return display.input.focus(); }, 20);\r\n}\r\n\r\n// Normal selection, as opposed to text dragging.\r\nfunction leftButtonSelect(cm, e, start, type, addNew) {\r\n  var display = cm.display, doc = cm.doc;\r\n  e_preventDefault(e);\r\n\r\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\r\n  if (addNew && !e.shiftKey) {\r\n    ourIndex = doc.sel.contains(start);\r\n    if (ourIndex > -1)\r\n      { ourRange = ranges[ourIndex]; }\r\n    else\r\n      { ourRange = new Range(start, start); }\r\n  } else {\r\n    ourRange = doc.sel.primary();\r\n    ourIndex = doc.sel.primIndex;\r\n  }\r\n\r\n  if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {\r\n    type = \"rect\";\r\n    if (!addNew) { ourRange = new Range(start, start); }\r\n    start = posFromMouse(cm, e, true, true);\r\n    ourIndex = -1;\r\n  } else if (type == \"double\") {\r\n    var word = cm.findWordAt(start);\r\n    if (cm.display.shift || doc.extend)\r\n      { ourRange = extendRange(doc, ourRange, word.anchor, word.head); }\r\n    else\r\n      { ourRange = word; }\r\n  } else if (type == \"triple\") {\r\n    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\r\n    if (cm.display.shift || doc.extend)\r\n      { ourRange = extendRange(doc, ourRange, line.anchor, line.head); }\r\n    else\r\n      { ourRange = line; }\r\n  } else {\r\n    ourRange = extendRange(doc, ourRange, start);\r\n  }\r\n\r\n  if (!addNew) {\r\n    ourIndex = 0;\r\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse);\r\n    startSel = doc.sel;\r\n  } else if (ourIndex == -1) {\r\n    ourIndex = ranges.length;\r\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\r\n                 {scroll: false, origin: \"*mouse\"});\r\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\r\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\r\n                 {scroll: false, origin: \"*mouse\"});\r\n    startSel = doc.sel;\r\n  } else {\r\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\r\n  }\r\n\r\n  var lastPos = start;\r\n  function extendTo(pos) {\r\n    if (cmp(lastPos, pos) == 0) { return }\r\n    lastPos = pos;\r\n\r\n    if (type == \"rect\") {\r\n      var ranges = [], tabSize = cm.options.tabSize;\r\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\r\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\r\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\r\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\r\n           line <= end; line++) {\r\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\r\n        if (left == right)\r\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\r\n        else if (text.length > leftPos)\r\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\r\n      }\r\n      if (!ranges.length) { ranges.push(new Range(start, start)); }\r\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\r\n                   {origin: \"*mouse\", scroll: false});\r\n      cm.scrollIntoView(pos);\r\n    } else {\r\n      var oldRange = ourRange;\r\n      var anchor = oldRange.anchor, head = pos;\r\n      if (type != \"single\") {\r\n        var range$$1;\r\n        if (type == \"double\")\r\n          { range$$1 = cm.findWordAt(pos); }\r\n        else\r\n          { range$$1 = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))); }\r\n        if (cmp(range$$1.anchor, anchor) > 0) {\r\n          head = range$$1.head;\r\n          anchor = minPos(oldRange.from(), range$$1.anchor);\r\n        } else {\r\n          head = range$$1.anchor;\r\n          anchor = maxPos(oldRange.to(), range$$1.head);\r\n        }\r\n      }\r\n      var ranges$1 = startSel.ranges.slice(0);\r\n      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head);\r\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);\r\n    }\r\n  }\r\n\r\n  var editorSize = display.wrapper.getBoundingClientRect();\r\n  // Used to ensure timeout re-tries don't fire when another extend\r\n  // happened in the meantime (clearTimeout isn't reliable -- at\r\n  // least on Chrome, the timeouts still happen even when cleared,\r\n  // if the clear happens after their scheduled firing time).\r\n  var counter = 0;\r\n\r\n  function extend(e) {\r\n    var curCount = ++counter;\r\n    var cur = posFromMouse(cm, e, true, type == \"rect\");\r\n    if (!cur) { return }\r\n    if (cmp(cur, lastPos) != 0) {\r\n      cm.curOp.focus = activeElt();\r\n      extendTo(cur);\r\n      var visible = visibleLines(display, doc);\r\n      if (cur.line >= visible.to || cur.line < visible.from)\r\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\r\n    } else {\r\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\r\n      if (outside) { setTimeout(operation(cm, function () {\r\n        if (counter != curCount) { return }\r\n        display.scroller.scrollTop += outside;\r\n        extend(e);\r\n      }), 50); }\r\n    }\r\n  }\r\n\r\n  function done(e) {\r\n    cm.state.selectingText = false;\r\n    counter = Infinity;\r\n    e_preventDefault(e);\r\n    display.input.focus();\r\n    off(document, \"mousemove\", move);\r\n    off(document, \"mouseup\", up);\r\n    doc.history.lastSelOrigin = null;\r\n  }\r\n\r\n  var move = operation(cm, function (e) {\r\n    if (!e_button(e)) { done(e); }\r\n    else { extend(e); }\r\n  });\r\n  var up = operation(cm, done);\r\n  cm.state.selectingText = up;\r\n  on(document, \"mousemove\", move);\r\n  on(document, \"mouseup\", up);\r\n}\r\n\r\n\r\n// Determines whether an event happened in the gutter, and fires the\r\n// handlers for the corresponding event.\r\nfunction gutterEvent(cm, e, type, prevent) {\r\n  var mX, mY;\r\n  try { mX = e.clientX; mY = e.clientY; }\r\n  catch(e) { return false }\r\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\r\n  if (prevent) { e_preventDefault(e); }\r\n\r\n  var display = cm.display;\r\n  var lineBox = display.lineDiv.getBoundingClientRect();\r\n\r\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\r\n  mY -= lineBox.top - display.viewOffset;\r\n\r\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\r\n    var g = display.gutters.childNodes[i];\r\n    if (g && g.getBoundingClientRect().right >= mX) {\r\n      var line = lineAtHeight(cm.doc, mY);\r\n      var gutter = cm.options.gutters[i];\r\n      signal(cm, type, cm, line, gutter, e);\r\n      return e_defaultPrevented(e)\r\n    }\r\n  }\r\n}\r\n\r\nfunction clickInGutter(cm, e) {\r\n  return gutterEvent(cm, e, \"gutterClick\", true)\r\n}\r\n\r\n// CONTEXT MENU HANDLING\r\n\r\n// To make the context menu work, we need to briefly unhide the\r\n// textarea (making it as unobtrusive as possible) to let the\r\n// right-click take effect on it.\r\nfunction onContextMenu(cm, e) {\r\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\r\n  if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\r\n  cm.display.input.onContextMenu(e);\r\n}\r\n\r\nfunction contextMenuInGutter(cm, e) {\r\n  if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\r\n  return gutterEvent(cm, e, \"gutterContextMenu\", false)\r\n}\r\n\r\nfunction themeChanged(cm) {\r\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\r\n    cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\r\n  clearCaches(cm);\r\n}\r\n\r\nvar Init = {toString: function(){return \"CodeMirror.Init\"}};\r\n\r\nvar defaults = {};\r\nvar optionHandlers = {};\r\n\r\nfunction defineOptions(CodeMirror) {\r\n  var optionHandlers = CodeMirror.optionHandlers;\r\n\r\n  function option(name, deflt, handle, notOnInit) {\r\n    CodeMirror.defaults[name] = deflt;\r\n    if (handle) { optionHandlers[name] =\r\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\r\n  }\r\n\r\n  CodeMirror.defineOption = option;\r\n\r\n  // Passed to option handlers when there is no old value.\r\n  CodeMirror.Init = Init;\r\n\r\n  // These two are, on init, called from the constructor because they\r\n  // have to be initialized before the editor can start at all.\r\n  option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\r\n  option(\"mode\", null, function (cm, val) {\r\n    cm.doc.modeOption = val;\r\n    loadMode(cm);\r\n  }, true);\r\n\r\n  option(\"indentUnit\", 2, loadMode, true);\r\n  option(\"indentWithTabs\", false);\r\n  option(\"smartIndent\", true);\r\n  option(\"tabSize\", 4, function (cm) {\r\n    resetModeState(cm);\r\n    clearCaches(cm);\r\n    regChange(cm);\r\n  }, true);\r\n  option(\"lineSeparator\", null, function (cm, val) {\r\n    cm.doc.lineSep = val;\r\n    if (!val) { return }\r\n    var newBreaks = [], lineNo = cm.doc.first;\r\n    cm.doc.iter(function (line) {\r\n      for (var pos = 0;;) {\r\n        var found = line.text.indexOf(val, pos);\r\n        if (found == -1) { break }\r\n        pos = found + val.length;\r\n        newBreaks.push(Pos(lineNo, found));\r\n      }\r\n      lineNo++;\r\n    });\r\n    for (var i = newBreaks.length - 1; i >= 0; i--)\r\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\r\n  });\r\n  option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\r\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\r\n    if (old != Init) { cm.refresh(); }\r\n  });\r\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\r\n  option(\"electricChars\", true);\r\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\r\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\r\n  }, true);\r\n  option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\r\n  option(\"rtlMoveVisually\", !windows);\r\n  option(\"wholeLineUpdateBefore\", true);\r\n\r\n  option(\"theme\", \"default\", function (cm) {\r\n    themeChanged(cm);\r\n    guttersChanged(cm);\r\n  }, true);\r\n  option(\"keyMap\", \"default\", function (cm, val, old) {\r\n    var next = getKeyMap(val);\r\n    var prev = old != Init && getKeyMap(old);\r\n    if (prev && prev.detach) { prev.detach(cm, next); }\r\n    if (next.attach) { next.attach(cm, prev || null); }\r\n  });\r\n  option(\"extraKeys\", null);\r\n\r\n  option(\"lineWrapping\", false, wrappingChanged, true);\r\n  option(\"gutters\", [], function (cm) {\r\n    setGuttersForLineNumbers(cm.options);\r\n    guttersChanged(cm);\r\n  }, true);\r\n  option(\"fixedGutter\", true, function (cm, val) {\r\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\r\n    cm.refresh();\r\n  }, true);\r\n  option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\r\n  option(\"scrollbarStyle\", \"native\", function (cm) {\r\n    initScrollbars(cm);\r\n    updateScrollbars(cm);\r\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\r\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\r\n  }, true);\r\n  option(\"lineNumbers\", false, function (cm) {\r\n    setGuttersForLineNumbers(cm.options);\r\n    guttersChanged(cm);\r\n  }, true);\r\n  option(\"firstLineNumber\", 1, guttersChanged, true);\r\n  option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\r\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\r\n\r\n  option(\"resetSelectionOnContextMenu\", true);\r\n  option(\"lineWiseCopyCut\", true);\r\n\r\n  option(\"readOnly\", false, function (cm, val) {\r\n    if (val == \"nocursor\") {\r\n      onBlur(cm);\r\n      cm.display.input.blur();\r\n      cm.display.disabled = true;\r\n    } else {\r\n      cm.display.disabled = false;\r\n    }\r\n    cm.display.input.readOnlyChanged(val);\r\n  });\r\n  option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\r\n  option(\"dragDrop\", true, dragDropChanged);\r\n  option(\"allowDropFileTypes\", null);\r\n\r\n  option(\"cursorBlinkRate\", 530);\r\n  option(\"cursorScrollMargin\", 0);\r\n  option(\"cursorHeight\", 1, updateSelection, true);\r\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\r\n  option(\"workTime\", 100);\r\n  option(\"workDelay\", 100);\r\n  option(\"flattenSpans\", true, resetModeState, true);\r\n  option(\"addModeClass\", false, resetModeState, true);\r\n  option(\"pollInterval\", 100);\r\n  option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\r\n  option(\"historyEventDelay\", 1250);\r\n  option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\r\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\r\n  option(\"moveInputWithCursor\", true, function (cm, val) {\r\n    if (!val) { cm.display.input.resetPosition(); }\r\n  });\r\n\r\n  option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\r\n  option(\"autofocus\", null);\r\n  option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\r\n}\r\n\r\nfunction guttersChanged(cm) {\r\n  updateGutters(cm);\r\n  regChange(cm);\r\n  alignHorizontally(cm);\r\n}\r\n\r\nfunction dragDropChanged(cm, value, old) {\r\n  var wasOn = old && old != Init;\r\n  if (!value != !wasOn) {\r\n    var funcs = cm.display.dragFunctions;\r\n    var toggle = value ? on : off;\r\n    toggle(cm.display.scroller, \"dragstart\", funcs.start);\r\n    toggle(cm.display.scroller, \"dragenter\", funcs.enter);\r\n    toggle(cm.display.scroller, \"dragover\", funcs.over);\r\n    toggle(cm.display.scroller, \"dragleave\", funcs.leave);\r\n    toggle(cm.display.scroller, \"drop\", funcs.drop);\r\n  }\r\n}\r\n\r\nfunction wrappingChanged(cm) {\r\n  if (cm.options.lineWrapping) {\r\n    addClass(cm.display.wrapper, \"CodeMirror-wrap\");\r\n    cm.display.sizer.style.minWidth = \"\";\r\n    cm.display.sizerWidth = null;\r\n  } else {\r\n    rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\r\n    findMaxLine(cm);\r\n  }\r\n  estimateLineHeights(cm);\r\n  regChange(cm);\r\n  clearCaches(cm);\r\n  setTimeout(function () { return updateScrollbars(cm); }, 100);\r\n}\r\n\r\n// A CodeMirror instance represents an editor. This is the object\r\n// that user code is usually dealing with.\r\n\r\nfunction CodeMirror$1(place, options) {\r\n  var this$1 = this;\r\n\r\n  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }\r\n\r\n  this.options = options = options ? copyObj(options) : {};\r\n  // Determine effective options based on given values and defaults.\r\n  copyObj(defaults, options, false);\r\n  setGuttersForLineNumbers(options);\r\n\r\n  var doc = options.value;\r\n  if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\r\n  this.doc = doc;\r\n\r\n  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);\r\n  var display = this.display = new Display(place, doc, input);\r\n  display.wrapper.CodeMirror = this;\r\n  updateGutters(this);\r\n  themeChanged(this);\r\n  if (options.lineWrapping)\r\n    { this.display.wrapper.className += \" CodeMirror-wrap\"; }\r\n  initScrollbars(this);\r\n\r\n  this.state = {\r\n    keyMaps: [],  // stores maps added by addKeyMap\r\n    overlays: [], // highlighting overlays, as added by addOverlay\r\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\r\n    overwrite: false,\r\n    delayingBlurEvent: false,\r\n    focused: false,\r\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\r\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\r\n    selectingText: false,\r\n    draggingText: false,\r\n    highlight: new Delayed(), // stores highlight worker timeout\r\n    keySeq: null,  // Unfinished key sequence\r\n    specialChars: null\r\n  };\r\n\r\n  if (options.autofocus && !mobile) { display.input.focus(); }\r\n\r\n  // Override magic textarea content restore that IE sometimes does\r\n  // on our hidden textarea on reload\r\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\r\n\r\n  registerEventHandlers(this);\r\n  ensureGlobalHandlers();\r\n\r\n  startOperation(this);\r\n  this.curOp.forceUpdate = true;\r\n  attachDoc(this, doc);\r\n\r\n  if ((options.autofocus && !mobile) || this.hasFocus())\r\n    { setTimeout(bind(onFocus, this), 20); }\r\n  else\r\n    { onBlur(this); }\r\n\r\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\r\n    { optionHandlers[opt](this$1, options[opt], Init); } }\r\n  maybeUpdateLineNumberWidth(this);\r\n  if (options.finishInit) { options.finishInit(this); }\r\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\r\n  endOperation(this);\r\n  // Suppress optimizelegibility in Webkit, since it breaks text\r\n  // measuring on line wrapping boundaries.\r\n  if (webkit && options.lineWrapping &&\r\n      getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\r\n    { display.lineDiv.style.textRendering = \"auto\"; }\r\n}\r\n\r\n// The default configuration options.\r\nCodeMirror$1.defaults = defaults;\r\n// Functions to run when options are changed.\r\nCodeMirror$1.optionHandlers = optionHandlers;\r\n\r\n// Attach the necessary event handlers when initializing the editor\r\nfunction registerEventHandlers(cm) {\r\n  var d = cm.display;\r\n  on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\r\n  // Older IE's will not fire a second mousedown for a double click\r\n  if (ie && ie_version < 11)\r\n    { on(d.scroller, \"dblclick\", operation(cm, function (e) {\r\n      if (signalDOMEvent(cm, e)) { return }\r\n      var pos = posFromMouse(cm, e);\r\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\r\n      e_preventDefault(e);\r\n      var word = cm.findWordAt(pos);\r\n      extendSelection(cm.doc, word.anchor, word.head);\r\n    })); }\r\n  else\r\n    { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\r\n  // Some browsers fire contextmenu *after* opening the menu, at\r\n  // which point we can't mess with it anymore. Context menu is\r\n  // handled in onMouseDown for these browsers.\r\n  if (!captureRightClick) { on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); }); }\r\n\r\n  // Used to suppress mouse event handling when a touch happens\r\n  var touchFinished, prevTouch = {end: 0};\r\n  function finishTouch() {\r\n    if (d.activeTouch) {\r\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\r\n      prevTouch = d.activeTouch;\r\n      prevTouch.end = +new Date;\r\n    }\r\n  }\r\n  function isMouseLikeTouchEvent(e) {\r\n    if (e.touches.length != 1) { return false }\r\n    var touch = e.touches[0];\r\n    return touch.radiusX <= 1 && touch.radiusY <= 1\r\n  }\r\n  function farAway(touch, other) {\r\n    if (other.left == null) { return true }\r\n    var dx = other.left - touch.left, dy = other.top - touch.top;\r\n    return dx * dx + dy * dy > 20 * 20\r\n  }\r\n  on(d.scroller, \"touchstart\", function (e) {\r\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\r\n      d.input.ensurePolled();\r\n      clearTimeout(touchFinished);\r\n      var now = +new Date;\r\n      d.activeTouch = {start: now, moved: false,\r\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null};\r\n      if (e.touches.length == 1) {\r\n        d.activeTouch.left = e.touches[0].pageX;\r\n        d.activeTouch.top = e.touches[0].pageY;\r\n      }\r\n    }\r\n  });\r\n  on(d.scroller, \"touchmove\", function () {\r\n    if (d.activeTouch) { d.activeTouch.moved = true; }\r\n  });\r\n  on(d.scroller, \"touchend\", function (e) {\r\n    var touch = d.activeTouch;\r\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\r\n        !touch.moved && new Date - touch.start < 300) {\r\n      var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\r\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\r\n        { range = new Range(pos, pos); }\r\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\r\n        { range = cm.findWordAt(pos); }\r\n      else // Triple tap\r\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\r\n      cm.setSelection(range.anchor, range.head);\r\n      cm.focus();\r\n      e_preventDefault(e);\r\n    }\r\n    finishTouch();\r\n  });\r\n  on(d.scroller, \"touchcancel\", finishTouch);\r\n\r\n  // Sync scrolling between fake scrollbars and real scrollable\r\n  // area, ensure viewport is updated when scrolling.\r\n  on(d.scroller, \"scroll\", function () {\r\n    if (d.scroller.clientHeight) {\r\n      updateScrollTop(cm, d.scroller.scrollTop);\r\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\r\n      signal(cm, \"scroll\", cm);\r\n    }\r\n  });\r\n\r\n  // Listen to wheel events in order to try and update the viewport on time.\r\n  on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\r\n  on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\r\n\r\n  // Prevent wrapper from ever scrolling\r\n  on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\r\n\r\n  d.dragFunctions = {\r\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\r\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\r\n    start: function (e) { return onDragStart(cm, e); },\r\n    drop: operation(cm, onDrop),\r\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\r\n  };\r\n\r\n  var inp = d.input.getField();\r\n  on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\r\n  on(inp, \"keydown\", operation(cm, onKeyDown));\r\n  on(inp, \"keypress\", operation(cm, onKeyPress));\r\n  on(inp, \"focus\", function (e) { return onFocus(cm, e); });\r\n  on(inp, \"blur\", function (e) { return onBlur(cm, e); });\r\n}\r\n\r\nvar initHooks = [];\r\nCodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };\r\n\r\n// Indent the given line. The how parameter can be \"smart\",\r\n// \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\r\n// (typically set to true for forced single-line indents), empty\r\n// lines are not indented, and places where the mode returns Pass\r\n// are left alone.\r\nfunction indentLine(cm, n, how, aggressive) {\r\n  var doc = cm.doc, state;\r\n  if (how == null) { how = \"add\"; }\r\n  if (how == \"smart\") {\r\n    // Fall back to \"prev\" when the mode doesn't have an indentation\r\n    // method.\r\n    if (!doc.mode.indent) { how = \"prev\"; }\r\n    else { state = getStateBefore(cm, n); }\r\n  }\r\n\r\n  var tabSize = cm.options.tabSize;\r\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\r\n  if (line.stateAfter) { line.stateAfter = null; }\r\n  var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\r\n  if (!aggressive && !/\\S/.test(line.text)) {\r\n    indentation = 0;\r\n    how = \"not\";\r\n  } else if (how == \"smart\") {\r\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\r\n    if (indentation == Pass || indentation > 150) {\r\n      if (!aggressive) { return }\r\n      how = \"prev\";\r\n    }\r\n  }\r\n  if (how == \"prev\") {\r\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\r\n    else { indentation = 0; }\r\n  } else if (how == \"add\") {\r\n    indentation = curSpace + cm.options.indentUnit;\r\n  } else if (how == \"subtract\") {\r\n    indentation = curSpace - cm.options.indentUnit;\r\n  } else if (typeof how == \"number\") {\r\n    indentation = curSpace + how;\r\n  }\r\n  indentation = Math.max(0, indentation);\r\n\r\n  var indentString = \"\", pos = 0;\r\n  if (cm.options.indentWithTabs)\r\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\r\n  if (pos < indentation) { indentString += spaceStr(indentation - pos); }\r\n\r\n  if (indentString != curSpaceString) {\r\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\r\n    line.stateAfter = null;\r\n    return true\r\n  } else {\r\n    // Ensure that, if the cursor was in the whitespace at the start\r\n    // of the line, it is moved to the end of that space.\r\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\r\n      var range = doc.sel.ranges[i$1];\r\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\r\n        var pos$1 = Pos(n, curSpaceString.length);\r\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\r\n        break\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// This will be set to a {lineWise: bool, text: [string]} object, so\r\n// that, when pasting, we know what kind of selections the copied\r\n// text was made out of.\r\nvar lastCopied = null;\r\n\r\nfunction setLastCopied(newLastCopied) {\r\n  lastCopied = newLastCopied;\r\n}\r\n\r\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\r\n  var doc = cm.doc;\r\n  cm.display.shift = false;\r\n  if (!sel) { sel = doc.sel; }\r\n\r\n  var paste = cm.state.pasteIncoming || origin == \"paste\";\r\n  var textLines = splitLinesAuto(inserted), multiPaste = null;\r\n  // When pasing N lines into N selections, insert one line per selection\r\n  if (paste && sel.ranges.length > 1) {\r\n    if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\r\n      if (sel.ranges.length % lastCopied.text.length == 0) {\r\n        multiPaste = [];\r\n        for (var i = 0; i < lastCopied.text.length; i++)\r\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\r\n      }\r\n    } else if (textLines.length == sel.ranges.length) {\r\n      multiPaste = map(textLines, function (l) { return [l]; });\r\n    }\r\n  }\r\n\r\n  var updateInput;\r\n  // Normal behavior is to insert the new text into every selection\r\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\r\n    var range$$1 = sel.ranges[i$1];\r\n    var from = range$$1.from(), to = range$$1.to();\r\n    if (range$$1.empty()) {\r\n      if (deleted && deleted > 0) // Handle deletion\r\n        { from = Pos(from.line, from.ch - deleted); }\r\n      else if (cm.state.overwrite && !paste) // Handle overwrite\r\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\r\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\r\n        { from = to = Pos(from.line, 0); }\r\n    }\r\n    updateInput = cm.curOp.updateInput;\r\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\r\n                       origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\r\n    makeChange(cm.doc, changeEvent);\r\n    signalLater(cm, \"inputRead\", cm, changeEvent);\r\n  }\r\n  if (inserted && !paste)\r\n    { triggerElectric(cm, inserted); }\r\n\r\n  ensureCursorVisible(cm);\r\n  cm.curOp.updateInput = updateInput;\r\n  cm.curOp.typing = true;\r\n  cm.state.pasteIncoming = cm.state.cutIncoming = false;\r\n}\r\n\r\nfunction handlePaste(e, cm) {\r\n  var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\r\n  if (pasted) {\r\n    e.preventDefault();\r\n    if (!cm.isReadOnly() && !cm.options.disableInput)\r\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\r\n    return true\r\n  }\r\n}\r\n\r\nfunction triggerElectric(cm, inserted) {\r\n  // When an 'electric' character is inserted, immediately trigger a reindent\r\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\r\n  var sel = cm.doc.sel;\r\n\r\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\r\n    var range$$1 = sel.ranges[i];\r\n    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\r\n    var mode = cm.getModeAt(range$$1.head);\r\n    var indented = false;\r\n    if (mode.electricChars) {\r\n      for (var j = 0; j < mode.electricChars.length; j++)\r\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\r\n          indented = indentLine(cm, range$$1.head.line, \"smart\");\r\n          break\r\n        } }\r\n    } else if (mode.electricInput) {\r\n      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\r\n        { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\r\n    }\r\n    if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\r\n  }\r\n}\r\n\r\nfunction copyableRanges(cm) {\r\n  var text = [], ranges = [];\r\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\r\n    var line = cm.doc.sel.ranges[i].head.line;\r\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\r\n    ranges.push(lineRange);\r\n    text.push(cm.getRange(lineRange.anchor, lineRange.head));\r\n  }\r\n  return {text: text, ranges: ranges}\r\n}\r\n\r\nfunction disableBrowserMagic(field, spellcheck) {\r\n  field.setAttribute(\"autocorrect\", \"off\");\r\n  field.setAttribute(\"autocapitalize\", \"off\");\r\n  field.setAttribute(\"spellcheck\", !!spellcheck);\r\n}\r\n\r\nfunction hiddenTextarea() {\r\n  var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\r\n  var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\r\n  // The textarea is kept positioned near the cursor to prevent the\r\n  // fact that it'll be scrolled into view on input from scrolling\r\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\r\n  // very slow. So make the area wide instead.\r\n  if (webkit) { te.style.width = \"1000px\"; }\r\n  else { te.setAttribute(\"wrap\", \"off\"); }\r\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\r\n  if (ios) { te.style.border = \"1px solid black\"; }\r\n  disableBrowserMagic(te);\r\n  return div\r\n}\r\n\r\n// The publicly visible API. Note that methodOp(f) means\r\n// 'wrap f in an operation, performed on its `this` parameter'.\r\n\r\n// This is not the complete set of editor methods. Most of the\r\n// methods defined on the Doc type are also injected into\r\n// CodeMirror.prototype, for backwards compatibility and\r\n// convenience.\r\n\r\nvar addEditorMethods = function(CodeMirror) {\r\n  var optionHandlers = CodeMirror.optionHandlers;\r\n\r\n  var helpers = CodeMirror.helpers = {};\r\n\r\n  CodeMirror.prototype = {\r\n    constructor: CodeMirror,\r\n    focus: function(){window.focus(); this.display.input.focus();},\r\n\r\n    setOption: function(option, value) {\r\n      var options = this.options, old = options[option];\r\n      if (options[option] == value && option != \"mode\") { return }\r\n      options[option] = value;\r\n      if (optionHandlers.hasOwnProperty(option))\r\n        { operation(this, optionHandlers[option])(this, value, old); }\r\n      signal(this, \"optionChange\", this, option);\r\n    },\r\n\r\n    getOption: function(option) {return this.options[option]},\r\n    getDoc: function() {return this.doc},\r\n\r\n    addKeyMap: function(map$$1, bottom) {\r\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\r\n    },\r\n    removeKeyMap: function(map$$1) {\r\n      var maps = this.state.keyMaps;\r\n      for (var i = 0; i < maps.length; ++i)\r\n        { if (maps[i] == map$$1 || maps[i].name == map$$1) {\r\n          maps.splice(i, 1);\r\n          return true\r\n        } }\r\n    },\r\n\r\n    addOverlay: methodOp(function(spec, options) {\r\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\r\n      if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\r\n      insertSorted(this.state.overlays,\r\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\r\n                    priority: (options && options.priority) || 0},\r\n                   function (overlay) { return overlay.priority; });\r\n      this.state.modeGen++;\r\n      regChange(this);\r\n    }),\r\n    removeOverlay: methodOp(function(spec) {\r\n      var this$1 = this;\r\n\r\n      var overlays = this.state.overlays;\r\n      for (var i = 0; i < overlays.length; ++i) {\r\n        var cur = overlays[i].modeSpec;\r\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\r\n          overlays.splice(i, 1);\r\n          this$1.state.modeGen++;\r\n          regChange(this$1);\r\n          return\r\n        }\r\n      }\r\n    }),\r\n\r\n    indentLine: methodOp(function(n, dir, aggressive) {\r\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\r\n        if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\r\n        else { dir = dir ? \"add\" : \"subtract\"; }\r\n      }\r\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\r\n    }),\r\n    indentSelection: methodOp(function(how) {\r\n      var this$1 = this;\r\n\r\n      var ranges = this.doc.sel.ranges, end = -1;\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var range$$1 = ranges[i];\r\n        if (!range$$1.empty()) {\r\n          var from = range$$1.from(), to = range$$1.to();\r\n          var start = Math.max(end, from.line);\r\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\r\n          for (var j = start; j < end; ++j)\r\n            { indentLine(this$1, j, how); }\r\n          var newRanges = this$1.doc.sel.ranges;\r\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\r\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\r\n        } else if (range$$1.head.line > end) {\r\n          indentLine(this$1, range$$1.head.line, how, true);\r\n          end = range$$1.head.line;\r\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\r\n        }\r\n      }\r\n    }),\r\n\r\n    // Fetch the parser token for a given character. Useful for hacks\r\n    // that want to inspect the mode state (say, for completion).\r\n    getTokenAt: function(pos, precise) {\r\n      return takeToken(this, pos, precise)\r\n    },\r\n\r\n    getLineTokens: function(line, precise) {\r\n      return takeToken(this, Pos(line), precise, true)\r\n    },\r\n\r\n    getTokenTypeAt: function(pos) {\r\n      pos = clipPos(this.doc, pos);\r\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\r\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\r\n      var type;\r\n      if (ch == 0) { type = styles[2]; }\r\n      else { for (;;) {\r\n        var mid = (before + after) >> 1;\r\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\r\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\r\n        else { type = styles[mid * 2 + 2]; break }\r\n      } }\r\n      var cut = type ? type.indexOf(\"overlay \") : -1;\r\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\r\n    },\r\n\r\n    getModeAt: function(pos) {\r\n      var mode = this.doc.mode;\r\n      if (!mode.innerMode) { return mode }\r\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\r\n    },\r\n\r\n    getHelper: function(pos, type) {\r\n      return this.getHelpers(pos, type)[0]\r\n    },\r\n\r\n    getHelpers: function(pos, type) {\r\n      var this$1 = this;\r\n\r\n      var found = [];\r\n      if (!helpers.hasOwnProperty(type)) { return found }\r\n      var help = helpers[type], mode = this.getModeAt(pos);\r\n      if (typeof mode[type] == \"string\") {\r\n        if (help[mode[type]]) { found.push(help[mode[type]]); }\r\n      } else if (mode[type]) {\r\n        for (var i = 0; i < mode[type].length; i++) {\r\n          var val = help[mode[type][i]];\r\n          if (val) { found.push(val); }\r\n        }\r\n      } else if (mode.helperType && help[mode.helperType]) {\r\n        found.push(help[mode.helperType]);\r\n      } else if (help[mode.name]) {\r\n        found.push(help[mode.name]);\r\n      }\r\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\r\n        var cur = help._global[i$1];\r\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\r\n          { found.push(cur.val); }\r\n      }\r\n      return found\r\n    },\r\n\r\n    getStateAfter: function(line, precise) {\r\n      var doc = this.doc;\r\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\r\n      return getStateBefore(this, line + 1, precise)\r\n    },\r\n\r\n    cursorCoords: function(start, mode) {\r\n      var pos, range$$1 = this.doc.sel.primary();\r\n      if (start == null) { pos = range$$1.head; }\r\n      else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\r\n      else { pos = start ? range$$1.from() : range$$1.to(); }\r\n      return cursorCoords(this, pos, mode || \"page\")\r\n    },\r\n\r\n    charCoords: function(pos, mode) {\r\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\r\n    },\r\n\r\n    coordsChar: function(coords, mode) {\r\n      coords = fromCoordSystem(this, coords, mode || \"page\");\r\n      return coordsChar(this, coords.left, coords.top)\r\n    },\r\n\r\n    lineAtHeight: function(height, mode) {\r\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\r\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\r\n    },\r\n    heightAtLine: function(line, mode, includeWidgets) {\r\n      var end = false, lineObj;\r\n      if (typeof line == \"number\") {\r\n        var last = this.doc.first + this.doc.size - 1;\r\n        if (line < this.doc.first) { line = this.doc.first; }\r\n        else if (line > last) { line = last; end = true; }\r\n        lineObj = getLine(this.doc, line);\r\n      } else {\r\n        lineObj = line;\r\n      }\r\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\r\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\r\n    },\r\n\r\n    defaultTextHeight: function() { return textHeight(this.display) },\r\n    defaultCharWidth: function() { return charWidth(this.display) },\r\n\r\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\r\n\r\n    addWidget: function(pos, node, scroll, vert, horiz) {\r\n      var display = this.display;\r\n      pos = cursorCoords(this, clipPos(this.doc, pos));\r\n      var top = pos.bottom, left = pos.left;\r\n      node.style.position = \"absolute\";\r\n      node.setAttribute(\"cm-ignore-events\", \"true\");\r\n      this.display.input.setUneditable(node);\r\n      display.sizer.appendChild(node);\r\n      if (vert == \"over\") {\r\n        top = pos.top;\r\n      } else if (vert == \"above\" || vert == \"near\") {\r\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\r\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\r\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\r\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\r\n          { top = pos.top - node.offsetHeight; }\r\n        else if (pos.bottom + node.offsetHeight <= vspace)\r\n          { top = pos.bottom; }\r\n        if (left + node.offsetWidth > hspace)\r\n          { left = hspace - node.offsetWidth; }\r\n      }\r\n      node.style.top = top + \"px\";\r\n      node.style.left = node.style.right = \"\";\r\n      if (horiz == \"right\") {\r\n        left = display.sizer.clientWidth - node.offsetWidth;\r\n        node.style.right = \"0px\";\r\n      } else {\r\n        if (horiz == \"left\") { left = 0; }\r\n        else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\r\n        node.style.left = left + \"px\";\r\n      }\r\n      if (scroll)\r\n        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\r\n    },\r\n\r\n    triggerOnKeyDown: methodOp(onKeyDown),\r\n    triggerOnKeyPress: methodOp(onKeyPress),\r\n    triggerOnKeyUp: onKeyUp,\r\n\r\n    execCommand: function(cmd) {\r\n      if (commands.hasOwnProperty(cmd))\r\n        { return commands[cmd].call(null, this) }\r\n    },\r\n\r\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\r\n\r\n    findPosH: function(from, amount, unit, visually) {\r\n      var this$1 = this;\r\n\r\n      var dir = 1;\r\n      if (amount < 0) { dir = -1; amount = -amount; }\r\n      var cur = clipPos(this.doc, from);\r\n      for (var i = 0; i < amount; ++i) {\r\n        cur = findPosH(this$1.doc, cur, dir, unit, visually);\r\n        if (cur.hitSide) { break }\r\n      }\r\n      return cur\r\n    },\r\n\r\n    moveH: methodOp(function(dir, unit) {\r\n      var this$1 = this;\r\n\r\n      this.extendSelectionsBy(function (range$$1) {\r\n        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\r\n          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\r\n        else\r\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\r\n      }, sel_move);\r\n    }),\r\n\r\n    deleteH: methodOp(function(dir, unit) {\r\n      var sel = this.doc.sel, doc = this.doc;\r\n      if (sel.somethingSelected())\r\n        { doc.replaceSelection(\"\", null, \"+delete\"); }\r\n      else\r\n        { deleteNearSelection(this, function (range$$1) {\r\n          var other = findPosH(doc, range$$1.head, dir, unit, false);\r\n          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\r\n        }); }\r\n    }),\r\n\r\n    findPosV: function(from, amount, unit, goalColumn) {\r\n      var this$1 = this;\r\n\r\n      var dir = 1, x = goalColumn;\r\n      if (amount < 0) { dir = -1; amount = -amount; }\r\n      var cur = clipPos(this.doc, from);\r\n      for (var i = 0; i < amount; ++i) {\r\n        var coords = cursorCoords(this$1, cur, \"div\");\r\n        if (x == null) { x = coords.left; }\r\n        else { coords.left = x; }\r\n        cur = findPosV(this$1, coords, dir, unit);\r\n        if (cur.hitSide) { break }\r\n      }\r\n      return cur\r\n    },\r\n\r\n    moveV: methodOp(function(dir, unit) {\r\n      var this$1 = this;\r\n\r\n      var doc = this.doc, goals = [];\r\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\r\n      doc.extendSelectionsBy(function (range$$1) {\r\n        if (collapse)\r\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\r\n        var headPos = cursorCoords(this$1, range$$1.head, \"div\");\r\n        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\r\n        goals.push(headPos.left);\r\n        var pos = findPosV(this$1, headPos, dir, unit);\r\n        if (unit == \"page\" && range$$1 == doc.sel.primary())\r\n          { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\r\n        return pos\r\n      }, sel_move);\r\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\r\n        { doc.sel.ranges[i].goalColumn = goals[i]; } }\r\n    }),\r\n\r\n    // Find the word at the given position (as returned by coordsChar).\r\n    findWordAt: function(pos) {\r\n      var doc = this.doc, line = getLine(doc, pos.line).text;\r\n      var start = pos.ch, end = pos.ch;\r\n      if (line) {\r\n        var helper = this.getHelper(pos, \"wordChars\");\r\n        if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\r\n        var startChar = line.charAt(start);\r\n        var check = isWordChar(startChar, helper)\r\n          ? function (ch) { return isWordChar(ch, helper); }\r\n          : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\r\n          : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\r\n        while (start > 0 && check(line.charAt(start - 1))) { --start; }\r\n        while (end < line.length && check(line.charAt(end))) { ++end; }\r\n      }\r\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\r\n    },\r\n\r\n    toggleOverwrite: function(value) {\r\n      if (value != null && value == this.state.overwrite) { return }\r\n      if (this.state.overwrite = !this.state.overwrite)\r\n        { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\r\n      else\r\n        { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\r\n\r\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\r\n    },\r\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\r\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\r\n\r\n    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\r\n    getScrollInfo: function() {\r\n      var scroller = this.display.scroller;\r\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\r\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\r\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\r\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\r\n    },\r\n\r\n    scrollIntoView: methodOp(function(range$$1, margin) {\r\n      if (range$$1 == null) {\r\n        range$$1 = {from: this.doc.sel.primary().head, to: null};\r\n        if (margin == null) { margin = this.options.cursorScrollMargin; }\r\n      } else if (typeof range$$1 == \"number\") {\r\n        range$$1 = {from: Pos(range$$1, 0), to: null};\r\n      } else if (range$$1.from == null) {\r\n        range$$1 = {from: range$$1, to: null};\r\n      }\r\n      if (!range$$1.to) { range$$1.to = range$$1.from; }\r\n      range$$1.margin = margin || 0;\r\n\r\n      if (range$$1.from.line != null) {\r\n        scrollToRange(this, range$$1);\r\n      } else {\r\n        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\r\n      }\r\n    }),\r\n\r\n    setSize: methodOp(function(width, height) {\r\n      var this$1 = this;\r\n\r\n      var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\r\n      if (width != null) { this.display.wrapper.style.width = interpret(width); }\r\n      if (height != null) { this.display.wrapper.style.height = interpret(height); }\r\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\r\n      var lineNo$$1 = this.display.viewFrom;\r\n      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\r\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\r\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\r\n        ++lineNo$$1;\r\n      });\r\n      this.curOp.forceUpdate = true;\r\n      signal(this, \"refresh\", this);\r\n    }),\r\n\r\n    operation: function(f){return runInOp(this, f)},\r\n\r\n    refresh: methodOp(function() {\r\n      var oldHeight = this.display.cachedTextHeight;\r\n      regChange(this);\r\n      this.curOp.forceUpdate = true;\r\n      clearCaches(this);\r\n      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\r\n      updateGutterSpace(this);\r\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\r\n        { estimateLineHeights(this); }\r\n      signal(this, \"refresh\", this);\r\n    }),\r\n\r\n    swapDoc: methodOp(function(doc) {\r\n      var old = this.doc;\r\n      old.cm = null;\r\n      attachDoc(this, doc);\r\n      clearCaches(this);\r\n      this.display.input.reset();\r\n      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\r\n      this.curOp.forceScroll = true;\r\n      signalLater(this, \"swapDoc\", this, old);\r\n      return old\r\n    }),\r\n\r\n    getInputField: function(){return this.display.input.getField()},\r\n    getWrapperElement: function(){return this.display.wrapper},\r\n    getScrollerElement: function(){return this.display.scroller},\r\n    getGutterElement: function(){return this.display.gutters}\r\n  };\r\n  eventMixin(CodeMirror);\r\n\r\n  CodeMirror.registerHelper = function(type, name, value) {\r\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\r\n    helpers[type][name] = value;\r\n  };\r\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\r\n    CodeMirror.registerHelper(type, name, value);\r\n    helpers[type]._global.push({pred: predicate, val: value});\r\n  };\r\n};\r\n\r\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\r\n// right), unit can be \"char\", \"column\" (like char, but doesn't\r\n// cross line boundaries), \"word\" (across next word), or \"group\" (to\r\n// the start of next group of word or non-word-non-whitespace\r\n// chars). The visually param controls whether, in right-to-left\r\n// text, direction 1 means to move towards the next index in the\r\n// string, or towards the character to the right of the current\r\n// position. The resulting position will have a hitSide=true\r\n// property if it reached the end of the document.\r\nfunction findPosH(doc, pos, dir, unit, visually) {\r\n  var oldPos = pos;\r\n  var origDir = dir;\r\n  var lineObj = getLine(doc, pos.line);\r\n  function findNextLine() {\r\n    var l = pos.line + dir;\r\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\r\n    pos = new Pos(l, pos.ch, pos.sticky);\r\n    return lineObj = getLine(doc, l)\r\n  }\r\n  function moveOnce(boundToLine) {\r\n    var next;\r\n    if (visually) {\r\n      next = moveVisually(doc.cm, lineObj, pos, dir);\r\n    } else {\r\n      next = moveLogically(lineObj, pos, dir);\r\n    }\r\n    if (next == null) {\r\n      if (!boundToLine && findNextLine())\r\n        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\r\n      else\r\n        { return false }\r\n    } else {\r\n      pos = next;\r\n    }\r\n    return true\r\n  }\r\n\r\n  if (unit == \"char\") {\r\n    moveOnce();\r\n  } else if (unit == \"column\") {\r\n    moveOnce(true);\r\n  } else if (unit == \"word\" || unit == \"group\") {\r\n    var sawType = null, group = unit == \"group\";\r\n    var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\r\n    for (var first = true;; first = false) {\r\n      if (dir < 0 && !moveOnce(!first)) { break }\r\n      var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\r\n      var type = isWordChar(cur, helper) ? \"w\"\r\n        : group && cur == \"\\n\" ? \"n\"\r\n        : !group || /\\s/.test(cur) ? null\r\n        : \"p\";\r\n      if (group && !first && !type) { type = \"s\"; }\r\n      if (sawType && sawType != type) {\r\n        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\r\n        break\r\n      }\r\n\r\n      if (type) { sawType = type; }\r\n      if (dir > 0 && !moveOnce(!first)) { break }\r\n    }\r\n  }\r\n  var result = skipAtomic(doc, pos, oldPos, origDir, true);\r\n  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\r\n  return result\r\n}\r\n\r\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\r\n// \"page\" or \"line\". The resulting position will have a hitSide=true\r\n// property if it reached the end of the document.\r\nfunction findPosV(cm, pos, dir, unit) {\r\n  var doc = cm.doc, x = pos.left, y;\r\n  if (unit == \"page\") {\r\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\r\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\r\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\r\n\r\n  } else if (unit == \"line\") {\r\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\r\n  }\r\n  var target;\r\n  for (;;) {\r\n    target = coordsChar(cm, x, y);\r\n    if (!target.outside) { break }\r\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\r\n    y += dir * 5;\r\n  }\r\n  return target\r\n}\r\n\r\n// CONTENTEDITABLE INPUT STYLE\r\n\r\nvar ContentEditableInput = function(cm) {\r\n  this.cm = cm;\r\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\r\n  this.polling = new Delayed();\r\n  this.composing = null;\r\n  this.gracePeriod = false;\r\n  this.readDOMTimeout = null;\r\n};\r\n\r\nContentEditableInput.prototype.init = function (display) {\r\n    var this$1 = this;\r\n\r\n  var input = this, cm = input.cm;\r\n  var div = input.div = display.lineDiv;\r\n  disableBrowserMagic(div, cm.options.spellcheck);\r\n\r\n  on(div, \"paste\", function (e) {\r\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\r\n    // IE doesn't fire input events, so we schedule a read for the pasted content in this way\r\n    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\r\n  });\r\n\r\n  on(div, \"compositionstart\", function (e) {\r\n    this$1.composing = {data: e.data, done: false};\r\n  });\r\n  on(div, \"compositionupdate\", function (e) {\r\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\r\n  });\r\n  on(div, \"compositionend\", function (e) {\r\n    if (this$1.composing) {\r\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\r\n      this$1.composing.done = true;\r\n    }\r\n  });\r\n\r\n  on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\r\n\r\n  on(div, \"input\", function () {\r\n    if (!this$1.composing) { this$1.readFromDOMSoon(); }\r\n  });\r\n\r\n  function onCopyCut(e) {\r\n    if (signalDOMEvent(cm, e)) { return }\r\n    if (cm.somethingSelected()) {\r\n      setLastCopied({lineWise: false, text: cm.getSelections()});\r\n      if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\r\n    } else if (!cm.options.lineWiseCopyCut) {\r\n      return\r\n    } else {\r\n      var ranges = copyableRanges(cm);\r\n      setLastCopied({lineWise: true, text: ranges.text});\r\n      if (e.type == \"cut\") {\r\n        cm.operation(function () {\r\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll);\r\n          cm.replaceSelection(\"\", null, \"cut\");\r\n        });\r\n      }\r\n    }\r\n    if (e.clipboardData) {\r\n      e.clipboardData.clearData();\r\n      var content = lastCopied.text.join(\"\\n\");\r\n      // iOS exposes the clipboard API, but seems to discard content inserted into it\r\n      e.clipboardData.setData(\"Text\", content);\r\n      if (e.clipboardData.getData(\"Text\") == content) {\r\n        e.preventDefault();\r\n        return\r\n      }\r\n    }\r\n    // Old-fashioned briefly-focus-a-textarea hack\r\n    var kludge = hiddenTextarea(), te = kludge.firstChild;\r\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\r\n    te.value = lastCopied.text.join(\"\\n\");\r\n    var hadFocus = document.activeElement;\r\n    selectInput(te);\r\n    setTimeout(function () {\r\n      cm.display.lineSpace.removeChild(kludge);\r\n      hadFocus.focus();\r\n      if (hadFocus == div) { input.showPrimarySelection(); }\r\n    }, 50);\r\n  }\r\n  on(div, \"copy\", onCopyCut);\r\n  on(div, \"cut\", onCopyCut);\r\n};\r\n\r\nContentEditableInput.prototype.prepareSelection = function () {\r\n  var result = prepareSelection(this.cm, false);\r\n  result.focus = this.cm.state.focused;\r\n  return result\r\n};\r\n\r\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\r\n  if (!info || !this.cm.display.view.length) { return }\r\n  if (info.focus || takeFocus) { this.showPrimarySelection(); }\r\n  this.showMultipleSelections(info);\r\n};\r\n\r\nContentEditableInput.prototype.showPrimarySelection = function () {\r\n  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\r\n  var from = prim.from(), to = prim.to();\r\n\r\n  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\r\n    sel.removeAllRanges();\r\n    return\r\n  }\r\n\r\n  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\r\n  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\r\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\r\n      cmp(minPos(curAnchor, curFocus), from) == 0 &&\r\n      cmp(maxPos(curAnchor, curFocus), to) == 0)\r\n    { return }\r\n\r\n  var view = cm.display.view;\r\n  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\r\n      {node: view[0].measure.map[2], offset: 0};\r\n  var end = to.line < cm.display.viewTo && posToDOM(cm, to);\r\n  if (!end) {\r\n    var measure = view[view.length - 1].measure;\r\n    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\r\n    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\r\n  }\r\n\r\n  if (!start || !end) {\r\n    sel.removeAllRanges();\r\n    return\r\n  }\r\n\r\n  var old = sel.rangeCount && sel.getRangeAt(0), rng;\r\n  try { rng = range(start.node, start.offset, end.offset, end.node); }\r\n  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\r\n  if (rng) {\r\n    if (!gecko && cm.state.focused) {\r\n      sel.collapse(start.node, start.offset);\r\n      if (!rng.collapsed) {\r\n        sel.removeAllRanges();\r\n        sel.addRange(rng);\r\n      }\r\n    } else {\r\n      sel.removeAllRanges();\r\n      sel.addRange(rng);\r\n    }\r\n    if (old && sel.anchorNode == null) { sel.addRange(old); }\r\n    else if (gecko) { this.startGracePeriod(); }\r\n  }\r\n  this.rememberSelection();\r\n};\r\n\r\nContentEditableInput.prototype.startGracePeriod = function () {\r\n    var this$1 = this;\r\n\r\n  clearTimeout(this.gracePeriod);\r\n  this.gracePeriod = setTimeout(function () {\r\n    this$1.gracePeriod = false;\r\n    if (this$1.selectionChanged())\r\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\r\n  }, 20);\r\n};\r\n\r\nContentEditableInput.prototype.showMultipleSelections = function (info) {\r\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\r\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\r\n};\r\n\r\nContentEditableInput.prototype.rememberSelection = function () {\r\n  var sel = window.getSelection();\r\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\r\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\r\n};\r\n\r\nContentEditableInput.prototype.selectionInEditor = function () {\r\n  var sel = window.getSelection();\r\n  if (!sel.rangeCount) { return false }\r\n  var node = sel.getRangeAt(0).commonAncestorContainer;\r\n  return contains(this.div, node)\r\n};\r\n\r\nContentEditableInput.prototype.focus = function () {\r\n  if (this.cm.options.readOnly != \"nocursor\") {\r\n    if (!this.selectionInEditor())\r\n      { this.showSelection(this.prepareSelection(), true); }\r\n    this.div.focus();\r\n  }\r\n};\r\nContentEditableInput.prototype.blur = function () { this.div.blur(); };\r\nContentEditableInput.prototype.getField = function () { return this.div };\r\n\r\nContentEditableInput.prototype.supportsTouch = function () { return true };\r\n\r\nContentEditableInput.prototype.receivedFocus = function () {\r\n  var input = this;\r\n  if (this.selectionInEditor())\r\n    { this.pollSelection(); }\r\n  else\r\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\r\n\r\n  function poll() {\r\n    if (input.cm.state.focused) {\r\n      input.pollSelection();\r\n      input.polling.set(input.cm.options.pollInterval, poll);\r\n    }\r\n  }\r\n  this.polling.set(this.cm.options.pollInterval, poll);\r\n};\r\n\r\nContentEditableInput.prototype.selectionChanged = function () {\r\n  var sel = window.getSelection();\r\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\r\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\r\n};\r\n\r\nContentEditableInput.prototype.pollSelection = function () {\r\n  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\r\n  var sel = window.getSelection(), cm = this.cm;\r\n  // On Android Chrome (version 56, at least), backspacing into an\r\n  // uneditable block element will put the cursor in that element,\r\n  // and then, because it's not editable, hide the virtual keyboard.\r\n  // Because Android doesn't allow us to actually detect backspace\r\n  // presses in a sane way, this code checks for when that happens\r\n  // and simulates a backspace press in this case.\r\n  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\r\n    this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\r\n    this.blur();\r\n    this.focus();\r\n    return\r\n  }\r\n  if (this.composing) { return }\r\n  this.rememberSelection();\r\n  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\r\n  var head = domToPos(cm, sel.focusNode, sel.focusOffset);\r\n  if (anchor && head) { runInOp(cm, function () {\r\n    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\r\n    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\r\n  }); }\r\n};\r\n\r\nContentEditableInput.prototype.pollContent = function () {\r\n  if (this.readDOMTimeout != null) {\r\n    clearTimeout(this.readDOMTimeout);\r\n    this.readDOMTimeout = null;\r\n  }\r\n\r\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\r\n  var from = sel.from(), to = sel.to();\r\n  if (from.ch == 0 && from.line > cm.firstLine())\r\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\r\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\r\n    { to = Pos(to.line + 1, 0); }\r\n  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\r\n\r\n  var fromIndex, fromLine, fromNode;\r\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\r\n    fromLine = lineNo(display.view[0].line);\r\n    fromNode = display.view[0].node;\r\n  } else {\r\n    fromLine = lineNo(display.view[fromIndex].line);\r\n    fromNode = display.view[fromIndex - 1].node.nextSibling;\r\n  }\r\n  var toIndex = findViewIndex(cm, to.line);\r\n  var toLine, toNode;\r\n  if (toIndex == display.view.length - 1) {\r\n    toLine = display.viewTo - 1;\r\n    toNode = display.lineDiv.lastChild;\r\n  } else {\r\n    toLine = lineNo(display.view[toIndex + 1].line) - 1;\r\n    toNode = display.view[toIndex + 1].node.previousSibling;\r\n  }\r\n\r\n  if (!fromNode) { return false }\r\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\r\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\r\n  while (newText.length > 1 && oldText.length > 1) {\r\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\r\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\r\n    else { break }\r\n  }\r\n\r\n  var cutFront = 0, cutEnd = 0;\r\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\r\n  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\r\n    { ++cutFront; }\r\n  var newBot = lst(newText), oldBot = lst(oldText);\r\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\r\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0));\r\n  while (cutEnd < maxCutEnd &&\r\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\r\n    { ++cutEnd; }\r\n  // Try to move start of change to start of selection if ambiguous\r\n  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\r\n    while (cutFront && cutFront > from.ch &&\r\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\r\n      cutFront--;\r\n      cutEnd++;\r\n    }\r\n  }\r\n\r\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\r\n  newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\r\n\r\n  var chFrom = Pos(fromLine, cutFront);\r\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\r\n  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\r\n    replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\r\n    return true\r\n  }\r\n};\r\n\r\nContentEditableInput.prototype.ensurePolled = function () {\r\n  this.forceCompositionEnd();\r\n};\r\nContentEditableInput.prototype.reset = function () {\r\n  this.forceCompositionEnd();\r\n};\r\nContentEditableInput.prototype.forceCompositionEnd = function () {\r\n  if (!this.composing) { return }\r\n  clearTimeout(this.readDOMTimeout);\r\n  this.composing = null;\r\n  this.updateFromDOM();\r\n  this.div.blur();\r\n  this.div.focus();\r\n};\r\nContentEditableInput.prototype.readFromDOMSoon = function () {\r\n    var this$1 = this;\r\n\r\n  if (this.readDOMTimeout != null) { return }\r\n  this.readDOMTimeout = setTimeout(function () {\r\n    this$1.readDOMTimeout = null;\r\n    if (this$1.composing) {\r\n      if (this$1.composing.done) { this$1.composing = null; }\r\n      else { return }\r\n    }\r\n    this$1.updateFromDOM();\r\n  }, 80);\r\n};\r\n\r\nContentEditableInput.prototype.updateFromDOM = function () {\r\n    var this$1 = this;\r\n\r\n  if (this.cm.isReadOnly() || !this.pollContent())\r\n    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\r\n};\r\n\r\nContentEditableInput.prototype.setUneditable = function (node) {\r\n  node.contentEditable = \"false\";\r\n};\r\n\r\nContentEditableInput.prototype.onKeyPress = function (e) {\r\n  if (e.charCode == 0) { return }\r\n  e.preventDefault();\r\n  if (!this.cm.isReadOnly())\r\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\r\n};\r\n\r\nContentEditableInput.prototype.readOnlyChanged = function (val) {\r\n  this.div.contentEditable = String(val != \"nocursor\");\r\n};\r\n\r\nContentEditableInput.prototype.onContextMenu = function () {};\r\nContentEditableInput.prototype.resetPosition = function () {};\r\n\r\nContentEditableInput.prototype.needsContentAttribute = true;\r\n\r\nfunction posToDOM(cm, pos) {\r\n  var view = findViewForLine(cm, pos.line);\r\n  if (!view || view.hidden) { return null }\r\n  var line = getLine(cm.doc, pos.line);\r\n  var info = mapFromLineView(view, line, pos.line);\r\n\r\n  var order = getOrder(line, cm.doc.direction), side = \"left\";\r\n  if (order) {\r\n    var partPos = getBidiPartAt(order, pos.ch);\r\n    side = partPos % 2 ? \"right\" : \"left\";\r\n  }\r\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\r\n  result.offset = result.collapse == \"right\" ? result.end : result.start;\r\n  return result\r\n}\r\n\r\nfunction isInGutter(node) {\r\n  for (var scan = node; scan; scan = scan.parentNode)\r\n    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\r\n  return false\r\n}\r\n\r\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\r\n\r\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\r\n  var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\r\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\r\n  function close() {\r\n    if (closing) {\r\n      text += lineSep;\r\n      closing = false;\r\n    }\r\n  }\r\n  function addText(str) {\r\n    if (str) {\r\n      close();\r\n      text += str;\r\n    }\r\n  }\r\n  function walk(node) {\r\n    if (node.nodeType == 1) {\r\n      var cmText = node.getAttribute(\"cm-text\");\r\n      if (cmText != null) {\r\n        addText(cmText || node.textContent.replace(/\\u200b/g, \"\"));\r\n        return\r\n      }\r\n      var markerID = node.getAttribute(\"cm-marker\"), range$$1;\r\n      if (markerID) {\r\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\r\n        if (found.length && (range$$1 = found[0].find()))\r\n          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\r\n        return\r\n      }\r\n      if (node.getAttribute(\"contenteditable\") == \"false\") { return }\r\n      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);\r\n      if (isBlock) { close(); }\r\n      for (var i = 0; i < node.childNodes.length; i++)\r\n        { walk(node.childNodes[i]); }\r\n      if (isBlock) { closing = true; }\r\n    } else if (node.nodeType == 3) {\r\n      addText(node.nodeValue);\r\n    }\r\n  }\r\n  for (;;) {\r\n    walk(from);\r\n    if (from == to) { break }\r\n    from = from.nextSibling;\r\n  }\r\n  return text\r\n}\r\n\r\nfunction domToPos(cm, node, offset) {\r\n  var lineNode;\r\n  if (node == cm.display.lineDiv) {\r\n    lineNode = cm.display.lineDiv.childNodes[offset];\r\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\r\n    node = null; offset = 0;\r\n  } else {\r\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\r\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\r\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\r\n    }\r\n  }\r\n  for (var i = 0; i < cm.display.view.length; i++) {\r\n    var lineView = cm.display.view[i];\r\n    if (lineView.node == lineNode)\r\n      { return locateNodeInLineView(lineView, node, offset) }\r\n  }\r\n}\r\n\r\nfunction locateNodeInLineView(lineView, node, offset) {\r\n  var wrapper = lineView.text.firstChild, bad = false;\r\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\r\n  if (node == wrapper) {\r\n    bad = true;\r\n    node = wrapper.childNodes[offset];\r\n    offset = 0;\r\n    if (!node) {\r\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line;\r\n      return badPos(Pos(lineNo(line), line.text.length), bad)\r\n    }\r\n  }\r\n\r\n  var textNode = node.nodeType == 3 ? node : null, topNode = node;\r\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\r\n    textNode = node.firstChild;\r\n    if (offset) { offset = textNode.nodeValue.length; }\r\n  }\r\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\r\n  var measure = lineView.measure, maps = measure.maps;\r\n\r\n  function find(textNode, topNode, offset) {\r\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\r\n      var map$$1 = i < 0 ? measure.map : maps[i];\r\n      for (var j = 0; j < map$$1.length; j += 3) {\r\n        var curNode = map$$1[j + 2];\r\n        if (curNode == textNode || curNode == topNode) {\r\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\r\n          var ch = map$$1[j] + offset;\r\n          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\r\n          return Pos(line, ch)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  var found = find(textNode, topNode, offset);\r\n  if (found) { return badPos(found, bad) }\r\n\r\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\r\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\r\n    found = find(after, after.firstChild, 0);\r\n    if (found)\r\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\r\n    else\r\n      { dist += after.textContent.length; }\r\n  }\r\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\r\n    found = find(before, before.firstChild, -1);\r\n    if (found)\r\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\r\n    else\r\n      { dist$1 += before.textContent.length; }\r\n  }\r\n}\r\n\r\n// TEXTAREA INPUT STYLE\r\n\r\nvar TextareaInput = function(cm) {\r\n  this.cm = cm;\r\n  // See input.poll and input.reset\r\n  this.prevInput = \"\";\r\n\r\n  // Flag that indicates whether we expect input to appear real soon\r\n  // now (after some event like 'keypress' or 'input') and are\r\n  // polling intensively.\r\n  this.pollingFast = false;\r\n  // Self-resetting timeout for the poller\r\n  this.polling = new Delayed();\r\n  // Tracks when input.reset has punted to just putting a short\r\n  // string into the textarea instead of the full selection.\r\n  this.inaccurateSelection = false;\r\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\r\n  this.hasSelection = false;\r\n  this.composing = null;\r\n};\r\n\r\nTextareaInput.prototype.init = function (display) {\r\n    var this$1 = this;\r\n\r\n  var input = this, cm = this.cm;\r\n\r\n  // Wraps and hides input textarea\r\n  var div = this.wrapper = hiddenTextarea();\r\n  // The semihidden textarea that is focused when the editor is\r\n  // focused, and receives input.\r\n  var te = this.textarea = div.firstChild;\r\n  display.wrapper.insertBefore(div, display.wrapper.firstChild);\r\n\r\n  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\r\n  if (ios) { te.style.width = \"0px\"; }\r\n\r\n  on(te, \"input\", function () {\r\n    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\r\n    input.poll();\r\n  });\r\n\r\n  on(te, \"paste\", function (e) {\r\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\r\n\r\n    cm.state.pasteIncoming = true;\r\n    input.fastPoll();\r\n  });\r\n\r\n  function prepareCopyCut(e) {\r\n    if (signalDOMEvent(cm, e)) { return }\r\n    if (cm.somethingSelected()) {\r\n      setLastCopied({lineWise: false, text: cm.getSelections()});\r\n      if (input.inaccurateSelection) {\r\n        input.prevInput = \"\";\r\n        input.inaccurateSelection = false;\r\n        te.value = lastCopied.text.join(\"\\n\");\r\n        selectInput(te);\r\n      }\r\n    } else if (!cm.options.lineWiseCopyCut) {\r\n      return\r\n    } else {\r\n      var ranges = copyableRanges(cm);\r\n      setLastCopied({lineWise: true, text: ranges.text});\r\n      if (e.type == \"cut\") {\r\n        cm.setSelections(ranges.ranges, null, sel_dontScroll);\r\n      } else {\r\n        input.prevInput = \"\";\r\n        te.value = ranges.text.join(\"\\n\");\r\n        selectInput(te);\r\n      }\r\n    }\r\n    if (e.type == \"cut\") { cm.state.cutIncoming = true; }\r\n  }\r\n  on(te, \"cut\", prepareCopyCut);\r\n  on(te, \"copy\", prepareCopyCut);\r\n\r\n  on(display.scroller, \"paste\", function (e) {\r\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\r\n    cm.state.pasteIncoming = true;\r\n    input.focus();\r\n  });\r\n\r\n  // Prevent normal selection in the editor (we handle our own)\r\n  on(display.lineSpace, \"selectstart\", function (e) {\r\n    if (!eventInWidget(display, e)) { e_preventDefault(e); }\r\n  });\r\n\r\n  on(te, \"compositionstart\", function () {\r\n    var start = cm.getCursor(\"from\");\r\n    if (input.composing) { input.composing.range.clear(); }\r\n    input.composing = {\r\n      start: start,\r\n      range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\r\n    };\r\n  });\r\n  on(te, \"compositionend\", function () {\r\n    if (input.composing) {\r\n      input.poll();\r\n      input.composing.range.clear();\r\n      input.composing = null;\r\n    }\r\n  });\r\n};\r\n\r\nTextareaInput.prototype.prepareSelection = function () {\r\n  // Redraw the selection and/or cursor\r\n  var cm = this.cm, display = cm.display, doc = cm.doc;\r\n  var result = prepareSelection(cm);\r\n\r\n  // Move the hidden textarea near the cursor to prevent scrolling artifacts\r\n  if (cm.options.moveInputWithCursor) {\r\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\r\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\r\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\r\n                                        headPos.top + lineOff.top - wrapOff.top));\r\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\r\n                                         headPos.left + lineOff.left - wrapOff.left));\r\n  }\r\n\r\n  return result\r\n};\r\n\r\nTextareaInput.prototype.showSelection = function (drawn) {\r\n  var cm = this.cm, display = cm.display;\r\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\r\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection);\r\n  if (drawn.teTop != null) {\r\n    this.wrapper.style.top = drawn.teTop + \"px\";\r\n    this.wrapper.style.left = drawn.teLeft + \"px\";\r\n  }\r\n};\r\n\r\n// Reset the input to correspond to the selection (or to be empty,\r\n// when not typing and nothing is selected)\r\nTextareaInput.prototype.reset = function (typing) {\r\n  if (this.contextMenuPending || this.composing) { return }\r\n  var minimal, selected, cm = this.cm, doc = cm.doc;\r\n  if (cm.somethingSelected()) {\r\n    this.prevInput = \"\";\r\n    var range$$1 = doc.sel.primary();\r\n    minimal = hasCopyEvent &&\r\n      (range$$1.to().line - range$$1.from().line > 100 || (selected = cm.getSelection()).length > 1000);\r\n    var content = minimal ? \"-\" : selected || cm.getSelection();\r\n    this.textarea.value = content;\r\n    if (cm.state.focused) { selectInput(this.textarea); }\r\n    if (ie && ie_version >= 9) { this.hasSelection = content; }\r\n  } else if (!typing) {\r\n    this.prevInput = this.textarea.value = \"\";\r\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\r\n  }\r\n  this.inaccurateSelection = minimal;\r\n};\r\n\r\nTextareaInput.prototype.getField = function () { return this.textarea };\r\n\r\nTextareaInput.prototype.supportsTouch = function () { return false };\r\n\r\nTextareaInput.prototype.focus = function () {\r\n  if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\r\n    try { this.textarea.focus(); }\r\n    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\r\n  }\r\n};\r\n\r\nTextareaInput.prototype.blur = function () { this.textarea.blur(); };\r\n\r\nTextareaInput.prototype.resetPosition = function () {\r\n  this.wrapper.style.top = this.wrapper.style.left = 0;\r\n};\r\n\r\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\r\n\r\n// Poll for input changes, using the normal rate of polling. This\r\n// runs as long as the editor is focused.\r\nTextareaInput.prototype.slowPoll = function () {\r\n    var this$1 = this;\r\n\r\n  if (this.pollingFast) { return }\r\n  this.polling.set(this.cm.options.pollInterval, function () {\r\n    this$1.poll();\r\n    if (this$1.cm.state.focused) { this$1.slowPoll(); }\r\n  });\r\n};\r\n\r\n// When an event has just come in that is likely to add or change\r\n// something in the input textarea, we poll faster, to ensure that\r\n// the change appears on the screen quickly.\r\nTextareaInput.prototype.fastPoll = function () {\r\n  var missed = false, input = this;\r\n  input.pollingFast = true;\r\n  function p() {\r\n    var changed = input.poll();\r\n    if (!changed && !missed) {missed = true; input.polling.set(60, p);}\r\n    else {input.pollingFast = false; input.slowPoll();}\r\n  }\r\n  input.polling.set(20, p);\r\n};\r\n\r\n// Read input from the textarea, and update the document to match.\r\n// When something is selected, it is present in the textarea, and\r\n// selected (unless it is huge, in which case a placeholder is\r\n// used). When nothing is selected, the cursor sits after previously\r\n// seen text (can be empty), which is stored in prevInput (we must\r\n// not reset the textarea when typing, because that breaks IME).\r\nTextareaInput.prototype.poll = function () {\r\n    var this$1 = this;\r\n\r\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\r\n  // Since this is called a *lot*, try to bail out as cheaply as\r\n  // possible when it is clear that nothing happened. hasSelection\r\n  // will be the case when there is a lot of text in the textarea,\r\n  // in which case reading its value would be expensive.\r\n  if (this.contextMenuPending || !cm.state.focused ||\r\n      (hasSelection(input) && !prevInput && !this.composing) ||\r\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\r\n    { return false }\r\n\r\n  var text = input.value;\r\n  // If nothing changed, bail.\r\n  if (text == prevInput && !cm.somethingSelected()) { return false }\r\n  // Work around nonsensical selection resetting in IE9/10, and\r\n  // inexplicable appearance of private area unicode characters on\r\n  // some key combos in Mac (#2689).\r\n  if (ie && ie_version >= 9 && this.hasSelection === text ||\r\n      mac && /[\\uf700-\\uf7ff]/.test(text)) {\r\n    cm.display.input.reset();\r\n    return false\r\n  }\r\n\r\n  if (cm.doc.sel == cm.display.selForContextMenu) {\r\n    var first = text.charCodeAt(0);\r\n    if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\r\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\r\n  }\r\n  // Find the part of the input that is actually new\r\n  var same = 0, l = Math.min(prevInput.length, text.length);\r\n  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\r\n\r\n  runInOp(cm, function () {\r\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\r\n                   null, this$1.composing ? \"*compose\" : null);\r\n\r\n    // Don't leave long text in the textarea, since it makes further polling slow\r\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\r\n    else { this$1.prevInput = text; }\r\n\r\n    if (this$1.composing) {\r\n      this$1.composing.range.clear();\r\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\r\n                                         {className: \"CodeMirror-composing\"});\r\n    }\r\n  });\r\n  return true\r\n};\r\n\r\nTextareaInput.prototype.ensurePolled = function () {\r\n  if (this.pollingFast && this.poll()) { this.pollingFast = false; }\r\n};\r\n\r\nTextareaInput.prototype.onKeyPress = function () {\r\n  if (ie && ie_version >= 9) { this.hasSelection = null; }\r\n  this.fastPoll();\r\n};\r\n\r\nTextareaInput.prototype.onContextMenu = function (e) {\r\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea;\r\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\r\n  if (!pos || presto) { return } // Opera is difficult.\r\n\r\n  // Reset the current text selection only if the click is done outside of the selection\r\n  // and 'resetSelectionOnContextMenu' option is true.\r\n  var reset = cm.options.resetSelectionOnContextMenu;\r\n  if (reset && cm.doc.sel.contains(pos) == -1)\r\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\r\n\r\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\r\n  input.wrapper.style.cssText = \"position: absolute\";\r\n  var wrapperBox = input.wrapper.getBoundingClientRect();\r\n  te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\r\n  var oldScrollY;\r\n  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\r\n  display.input.focus();\r\n  if (webkit) { window.scrollTo(null, oldScrollY); }\r\n  display.input.reset();\r\n  // Adds \"Select all\" to context menu in FF\r\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\r\n  input.contextMenuPending = true;\r\n  display.selForContextMenu = cm.doc.sel;\r\n  clearTimeout(display.detectingSelectAll);\r\n\r\n  // Select-all will be greyed out if there's nothing to select, so\r\n  // this adds a zero-width space so that we can later check whether\r\n  // it got selected.\r\n  function prepareSelectAllHack() {\r\n    if (te.selectionStart != null) {\r\n      var selected = cm.somethingSelected();\r\n      var extval = \"\\u200b\" + (selected ? te.value : \"\");\r\n      te.value = \"\\u21da\"; // Used to catch context-menu undo\r\n      te.value = extval;\r\n      input.prevInput = selected ? \"\" : \"\\u200b\";\r\n      te.selectionStart = 1; te.selectionEnd = extval.length;\r\n      // Re-set this, in case some other handler touched the\r\n      // selection in the meantime.\r\n      display.selForContextMenu = cm.doc.sel;\r\n    }\r\n  }\r\n  function rehide() {\r\n    input.contextMenuPending = false;\r\n    input.wrapper.style.cssText = oldWrapperCSS;\r\n    te.style.cssText = oldCSS;\r\n    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\r\n\r\n    // Try to detect the user choosing select-all\r\n    if (te.selectionStart != null) {\r\n      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\r\n      var i = 0, poll = function () {\r\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\r\n            te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\r\n          operation(cm, selectAll)(cm);\r\n        } else if (i++ < 10) {\r\n          display.detectingSelectAll = setTimeout(poll, 500);\r\n        } else {\r\n          display.selForContextMenu = null;\r\n          display.input.reset();\r\n        }\r\n      };\r\n      display.detectingSelectAll = setTimeout(poll, 200);\r\n    }\r\n  }\r\n\r\n  if (ie && ie_version >= 9) { prepareSelectAllHack(); }\r\n  if (captureRightClick) {\r\n    e_stop(e);\r\n    var mouseup = function () {\r\n      off(window, \"mouseup\", mouseup);\r\n      setTimeout(rehide, 20);\r\n    };\r\n    on(window, \"mouseup\", mouseup);\r\n  } else {\r\n    setTimeout(rehide, 50);\r\n  }\r\n};\r\n\r\nTextareaInput.prototype.readOnlyChanged = function (val) {\r\n  if (!val) { this.reset(); }\r\n};\r\n\r\nTextareaInput.prototype.setUneditable = function () {};\r\n\r\nTextareaInput.prototype.needsContentAttribute = false;\r\n\r\nfunction fromTextArea(textarea, options) {\r\n  options = options ? copyObj(options) : {};\r\n  options.value = textarea.value;\r\n  if (!options.tabindex && textarea.tabIndex)\r\n    { options.tabindex = textarea.tabIndex; }\r\n  if (!options.placeholder && textarea.placeholder)\r\n    { options.placeholder = textarea.placeholder; }\r\n  // Set autofocus to true if this textarea is focused, or if it has\r\n  // autofocus and no other element is focused.\r\n  if (options.autofocus == null) {\r\n    var hasFocus = activeElt();\r\n    options.autofocus = hasFocus == textarea ||\r\n      textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\r\n  }\r\n\r\n  function save() {textarea.value = cm.getValue();}\r\n\r\n  var realSubmit;\r\n  if (textarea.form) {\r\n    on(textarea.form, \"submit\", save);\r\n    // Deplorable hack to make the submit method do the right thing.\r\n    if (!options.leaveSubmitMethodAlone) {\r\n      var form = textarea.form;\r\n      realSubmit = form.submit;\r\n      try {\r\n        var wrappedSubmit = form.submit = function () {\r\n          save();\r\n          form.submit = realSubmit;\r\n          form.submit();\r\n          form.submit = wrappedSubmit;\r\n        };\r\n      } catch(e) {}\r\n    }\r\n  }\r\n\r\n  options.finishInit = function (cm) {\r\n    cm.save = save;\r\n    cm.getTextArea = function () { return textarea; };\r\n    cm.toTextArea = function () {\r\n      cm.toTextArea = isNaN; // Prevent this from being ran twice\r\n      save();\r\n      textarea.parentNode.removeChild(cm.getWrapperElement());\r\n      textarea.style.display = \"\";\r\n      if (textarea.form) {\r\n        off(textarea.form, \"submit\", save);\r\n        if (typeof textarea.form.submit == \"function\")\r\n          { textarea.form.submit = realSubmit; }\r\n      }\r\n    };\r\n  };\r\n\r\n  textarea.style.display = \"none\";\r\n  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\r\n    options);\r\n  return cm\r\n}\r\n\r\nfunction addLegacyProps(CodeMirror) {\r\n  CodeMirror.off = off;\r\n  CodeMirror.on = on;\r\n  CodeMirror.wheelEventPixels = wheelEventPixels;\r\n  CodeMirror.Doc = Doc;\r\n  CodeMirror.splitLines = splitLinesAuto;\r\n  CodeMirror.countColumn = countColumn;\r\n  CodeMirror.findColumn = findColumn;\r\n  CodeMirror.isWordChar = isWordCharBasic;\r\n  CodeMirror.Pass = Pass;\r\n  CodeMirror.signal = signal;\r\n  CodeMirror.Line = Line;\r\n  CodeMirror.changeEnd = changeEnd;\r\n  CodeMirror.scrollbarModel = scrollbarModel;\r\n  CodeMirror.Pos = Pos;\r\n  CodeMirror.cmpPos = cmp;\r\n  CodeMirror.modes = modes;\r\n  CodeMirror.mimeModes = mimeModes;\r\n  CodeMirror.resolveMode = resolveMode;\r\n  CodeMirror.getMode = getMode;\r\n  CodeMirror.modeExtensions = modeExtensions;\r\n  CodeMirror.extendMode = extendMode;\r\n  CodeMirror.copyState = copyState;\r\n  CodeMirror.startState = startState;\r\n  CodeMirror.innerMode = innerMode;\r\n  CodeMirror.commands = commands;\r\n  CodeMirror.keyMap = keyMap;\r\n  CodeMirror.keyName = keyName;\r\n  CodeMirror.isModifierKey = isModifierKey;\r\n  CodeMirror.lookupKey = lookupKey;\r\n  CodeMirror.normalizeKeyMap = normalizeKeyMap;\r\n  CodeMirror.StringStream = StringStream;\r\n  CodeMirror.SharedTextMarker = SharedTextMarker;\r\n  CodeMirror.TextMarker = TextMarker;\r\n  CodeMirror.LineWidget = LineWidget;\r\n  CodeMirror.e_preventDefault = e_preventDefault;\r\n  CodeMirror.e_stopPropagation = e_stopPropagation;\r\n  CodeMirror.e_stop = e_stop;\r\n  CodeMirror.addClass = addClass;\r\n  CodeMirror.contains = contains;\r\n  CodeMirror.rmClass = rmClass;\r\n  CodeMirror.keyNames = keyNames;\r\n}\r\n\r\n// EDITOR CONSTRUCTOR\r\n\r\ndefineOptions(CodeMirror$1);\r\n\r\naddEditorMethods(CodeMirror$1);\r\n\r\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\r\nvar dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\r\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\r\n  { CodeMirror$1.prototype[prop] = (function(method) {\r\n    return function() {return method.apply(this.doc, arguments)}\r\n  })(Doc.prototype[prop]); } }\r\n\r\neventMixin(Doc);\r\n\r\n// INPUT HANDLING\r\n\r\nCodeMirror$1.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\r\n\r\n// MODE DEFINITION AND QUERYING\r\n\r\n// Extra arguments are stored as the mode's dependencies, which is\r\n// used by (legacy) mechanisms like loadmode.js to automatically\r\n// load a mode. (Preferred mechanism is the require/define calls.)\r\nCodeMirror$1.defineMode = function(name/*, mode, …*/) {\r\n  if (!CodeMirror$1.defaults.mode && name != \"null\") { CodeMirror$1.defaults.mode = name; }\r\n  defineMode.apply(this, arguments);\r\n};\r\n\r\nCodeMirror$1.defineMIME = defineMIME;\r\n\r\n// Minimal default mode.\r\nCodeMirror$1.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\r\nCodeMirror$1.defineMIME(\"text/plain\", \"null\");\r\n\r\n// EXTENSIONS\r\n\r\nCodeMirror$1.defineExtension = function (name, func) {\r\n  CodeMirror$1.prototype[name] = func;\r\n};\r\nCodeMirror$1.defineDocExtension = function (name, func) {\r\n  Doc.prototype[name] = func;\r\n};\r\n\r\nCodeMirror$1.fromTextArea = fromTextArea;\r\n\r\naddLegacyProps(CodeMirror$1);\r\n\r\nCodeMirror$1.version = \"5.26.0\";\r\n\r\nreturn CodeMirror$1;\r\n\r\n})));\r\n\n\n/***/ }),\n\n/***/ 932:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nexports.byteLength = byteLength\r\nexports.toByteArray = toByteArray\r\nexports.fromByteArray = fromByteArray\r\n\r\nvar lookup = []\r\nvar revLookup = []\r\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\r\n\r\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\nfor (var i = 0, len = code.length; i < len; ++i) {\r\n  lookup[i] = code[i]\r\n  revLookup[code.charCodeAt(i)] = i\r\n}\r\n\r\nrevLookup['-'.charCodeAt(0)] = 62\r\nrevLookup['_'.charCodeAt(0)] = 63\r\n\r\nfunction placeHoldersCount (b64) {\r\n  var len = b64.length\r\n  if (len % 4 > 0) {\r\n    throw new Error('Invalid string. Length must be a multiple of 4')\r\n  }\r\n\r\n  // the number of equal signs (place holders)\r\n  // if there are two placeholders, than the two characters before it\r\n  // represent one byte\r\n  // if there is only one, then the three characters before it represent 2 bytes\r\n  // this is just a cheap hack to not do indexOf twice\r\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\r\n}\r\n\r\nfunction byteLength (b64) {\r\n  // base64 is 4/3 + up to two characters of the original data\r\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\r\n}\r\n\r\nfunction toByteArray (b64) {\r\n  var i, l, tmp, placeHolders, arr\r\n  var len = b64.length\r\n  placeHolders = placeHoldersCount(b64)\r\n\r\n  arr = new Arr((len * 3 / 4) - placeHolders)\r\n\r\n  // if there are placeholders, only get up to the last complete 4 chars\r\n  l = placeHolders > 0 ? len - 4 : len\r\n\r\n  var L = 0\r\n\r\n  for (i = 0; i < l; i += 4) {\r\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\r\n    arr[L++] = (tmp >> 16) & 0xFF\r\n    arr[L++] = (tmp >> 8) & 0xFF\r\n    arr[L++] = tmp & 0xFF\r\n  }\r\n\r\n  if (placeHolders === 2) {\r\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\r\n    arr[L++] = tmp & 0xFF\r\n  } else if (placeHolders === 1) {\r\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\r\n    arr[L++] = (tmp >> 8) & 0xFF\r\n    arr[L++] = tmp & 0xFF\r\n  }\r\n\r\n  return arr\r\n}\r\n\r\nfunction tripletToBase64 (num) {\r\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\r\n}\r\n\r\nfunction encodeChunk (uint8, start, end) {\r\n  var tmp\r\n  var output = []\r\n  for (var i = start; i < end; i += 3) {\r\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\r\n    output.push(tripletToBase64(tmp))\r\n  }\r\n  return output.join('')\r\n}\r\n\r\nfunction fromByteArray (uint8) {\r\n  var tmp\r\n  var len = uint8.length\r\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\r\n  var output = ''\r\n  var parts = []\r\n  var maxChunkLength = 16383 // must be multiple of 3\r\n\r\n  // go through the array every three bytes, we'll deal with trailing stuff later\r\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\r\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\r\n  }\r\n\r\n  // pad the end with zeros, but make sure to not forget the extra bytes\r\n  if (extraBytes === 1) {\r\n    tmp = uint8[len - 1]\r\n    output += lookup[tmp >> 2]\r\n    output += lookup[(tmp << 4) & 0x3F]\r\n    output += '=='\r\n  } else if (extraBytes === 2) {\r\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\r\n    output += lookup[tmp >> 10]\r\n    output += lookup[(tmp >> 4) & 0x3F]\r\n    output += lookup[(tmp << 2) & 0x3F]\r\n    output += '='\r\n  }\r\n\r\n  parts.push(output)\r\n\r\n  return parts.join('')\r\n}\r\n\n\n/***/ }),\n\n/***/ 933:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\r\n * The buffer module from node.js, for the browser.\r\n *\r\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\r\n * @license  MIT\r\n */\r\n/* eslint-disable no-proto */\r\n\r\n\r\n\r\nvar base64 = __webpack_require__(932)\r\nvar ieee754 = __webpack_require__(944)\r\nvar isArray = __webpack_require__(945)\r\n\r\nexports.Buffer = Buffer\r\nexports.SlowBuffer = SlowBuffer\r\nexports.INSPECT_MAX_BYTES = 50\r\n\r\n/**\r\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\r\n *   === true    Use Uint8Array implementation (fastest)\r\n *   === false   Use Object implementation (most compatible, even IE6)\r\n *\r\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\r\n * Opera 11.6+, iOS 4.2+.\r\n *\r\n * Due to various browser bugs, sometimes the Object implementation will be used even\r\n * when the browser supports typed arrays.\r\n *\r\n * Note:\r\n *\r\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\r\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\r\n *\r\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\r\n *\r\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\r\n *     incorrect length in some situations.\r\n\r\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\r\n * get the Object implementation, which is slower but behaves correctly.\r\n */\r\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\r\n  ? global.TYPED_ARRAY_SUPPORT\r\n  : typedArraySupport()\r\n\r\n/*\r\n * Export kMaxLength after typed array support is determined.\r\n */\r\nexports.kMaxLength = kMaxLength()\r\n\r\nfunction typedArraySupport () {\r\n  try {\r\n    var arr = new Uint8Array(1)\r\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\r\n    return arr.foo() === 42 && // typed array instances can be augmented\r\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\r\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\r\n  } catch (e) {\r\n    return false\r\n  }\r\n}\r\n\r\nfunction kMaxLength () {\r\n  return Buffer.TYPED_ARRAY_SUPPORT\r\n    ? 0x7fffffff\r\n    : 0x3fffffff\r\n}\r\n\r\nfunction createBuffer (that, length) {\r\n  if (kMaxLength() < length) {\r\n    throw new RangeError('Invalid typed array length')\r\n  }\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    // Return an augmented `Uint8Array` instance, for best performance\r\n    that = new Uint8Array(length)\r\n    that.__proto__ = Buffer.prototype\r\n  } else {\r\n    // Fallback: Return an object instance of the Buffer class\r\n    if (that === null) {\r\n      that = new Buffer(length)\r\n    }\r\n    that.length = length\r\n  }\r\n\r\n  return that\r\n}\r\n\r\n/**\r\n * The Buffer constructor returns instances of `Uint8Array` that have their\r\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\r\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\r\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\r\n * returns a single octet.\r\n *\r\n * The `Uint8Array` prototype remains unmodified.\r\n */\r\n\r\nfunction Buffer (arg, encodingOrOffset, length) {\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\r\n    return new Buffer(arg, encodingOrOffset, length)\r\n  }\r\n\r\n  // Common case.\r\n  if (typeof arg === 'number') {\r\n    if (typeof encodingOrOffset === 'string') {\r\n      throw new Error(\r\n        'If encoding is specified then the first argument must be a string'\r\n      )\r\n    }\r\n    return allocUnsafe(this, arg)\r\n  }\r\n  return from(this, arg, encodingOrOffset, length)\r\n}\r\n\r\nBuffer.poolSize = 8192 // not used by this implementation\r\n\r\n// TODO: Legacy, not needed anymore. Remove in next major version.\r\nBuffer._augment = function (arr) {\r\n  arr.__proto__ = Buffer.prototype\r\n  return arr\r\n}\r\n\r\nfunction from (that, value, encodingOrOffset, length) {\r\n  if (typeof value === 'number') {\r\n    throw new TypeError('\"value\" argument must not be a number')\r\n  }\r\n\r\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\r\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\r\n  }\r\n\r\n  if (typeof value === 'string') {\r\n    return fromString(that, value, encodingOrOffset)\r\n  }\r\n\r\n  return fromObject(that, value)\r\n}\r\n\r\n/**\r\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\r\n * if value is a number.\r\n * Buffer.from(str[, encoding])\r\n * Buffer.from(array)\r\n * Buffer.from(buffer)\r\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\r\n **/\r\nBuffer.from = function (value, encodingOrOffset, length) {\r\n  return from(null, value, encodingOrOffset, length)\r\n}\r\n\r\nif (Buffer.TYPED_ARRAY_SUPPORT) {\r\n  Buffer.prototype.__proto__ = Uint8Array.prototype\r\n  Buffer.__proto__ = Uint8Array\r\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\r\n      Buffer[Symbol.species] === Buffer) {\r\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\r\n    Object.defineProperty(Buffer, Symbol.species, {\r\n      value: null,\r\n      configurable: true\r\n    })\r\n  }\r\n}\r\n\r\nfunction assertSize (size) {\r\n  if (typeof size !== 'number') {\r\n    throw new TypeError('\"size\" argument must be a number')\r\n  } else if (size < 0) {\r\n    throw new RangeError('\"size\" argument must not be negative')\r\n  }\r\n}\r\n\r\nfunction alloc (that, size, fill, encoding) {\r\n  assertSize(size)\r\n  if (size <= 0) {\r\n    return createBuffer(that, size)\r\n  }\r\n  if (fill !== undefined) {\r\n    // Only pay attention to encoding if it's a string. This\r\n    // prevents accidentally sending in a number that would\r\n    // be interpretted as a start offset.\r\n    return typeof encoding === 'string'\r\n      ? createBuffer(that, size).fill(fill, encoding)\r\n      : createBuffer(that, size).fill(fill)\r\n  }\r\n  return createBuffer(that, size)\r\n}\r\n\r\n/**\r\n * Creates a new filled Buffer instance.\r\n * alloc(size[, fill[, encoding]])\r\n **/\r\nBuffer.alloc = function (size, fill, encoding) {\r\n  return alloc(null, size, fill, encoding)\r\n}\r\n\r\nfunction allocUnsafe (that, size) {\r\n  assertSize(size)\r\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\r\n    for (var i = 0; i < size; ++i) {\r\n      that[i] = 0\r\n    }\r\n  }\r\n  return that\r\n}\r\n\r\n/**\r\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\r\n * */\r\nBuffer.allocUnsafe = function (size) {\r\n  return allocUnsafe(null, size)\r\n}\r\n/**\r\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\r\n */\r\nBuffer.allocUnsafeSlow = function (size) {\r\n  return allocUnsafe(null, size)\r\n}\r\n\r\nfunction fromString (that, string, encoding) {\r\n  if (typeof encoding !== 'string' || encoding === '') {\r\n    encoding = 'utf8'\r\n  }\r\n\r\n  if (!Buffer.isEncoding(encoding)) {\r\n    throw new TypeError('\"encoding\" must be a valid string encoding')\r\n  }\r\n\r\n  var length = byteLength(string, encoding) | 0\r\n  that = createBuffer(that, length)\r\n\r\n  var actual = that.write(string, encoding)\r\n\r\n  if (actual !== length) {\r\n    // Writing a hex string, for example, that contains invalid characters will\r\n    // cause everything after the first invalid character to be ignored. (e.g.\r\n    // 'abxxcd' will be treated as 'ab')\r\n    that = that.slice(0, actual)\r\n  }\r\n\r\n  return that\r\n}\r\n\r\nfunction fromArrayLike (that, array) {\r\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\r\n  that = createBuffer(that, length)\r\n  for (var i = 0; i < length; i += 1) {\r\n    that[i] = array[i] & 255\r\n  }\r\n  return that\r\n}\r\n\r\nfunction fromArrayBuffer (that, array, byteOffset, length) {\r\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\r\n\r\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\r\n    throw new RangeError('\\'offset\\' is out of bounds')\r\n  }\r\n\r\n  if (array.byteLength < byteOffset + (length || 0)) {\r\n    throw new RangeError('\\'length\\' is out of bounds')\r\n  }\r\n\r\n  if (byteOffset === undefined && length === undefined) {\r\n    array = new Uint8Array(array)\r\n  } else if (length === undefined) {\r\n    array = new Uint8Array(array, byteOffset)\r\n  } else {\r\n    array = new Uint8Array(array, byteOffset, length)\r\n  }\r\n\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    // Return an augmented `Uint8Array` instance, for best performance\r\n    that = array\r\n    that.__proto__ = Buffer.prototype\r\n  } else {\r\n    // Fallback: Return an object instance of the Buffer class\r\n    that = fromArrayLike(that, array)\r\n  }\r\n  return that\r\n}\r\n\r\nfunction fromObject (that, obj) {\r\n  if (Buffer.isBuffer(obj)) {\r\n    var len = checked(obj.length) | 0\r\n    that = createBuffer(that, len)\r\n\r\n    if (that.length === 0) {\r\n      return that\r\n    }\r\n\r\n    obj.copy(that, 0, 0, len)\r\n    return that\r\n  }\r\n\r\n  if (obj) {\r\n    if ((typeof ArrayBuffer !== 'undefined' &&\r\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\r\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\r\n        return createBuffer(that, 0)\r\n      }\r\n      return fromArrayLike(that, obj)\r\n    }\r\n\r\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\r\n      return fromArrayLike(that, obj.data)\r\n    }\r\n  }\r\n\r\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\r\n}\r\n\r\nfunction checked (length) {\r\n  // Note: cannot use `length < kMaxLength()` here because that fails when\r\n  // length is NaN (which is otherwise coerced to zero.)\r\n  if (length >= kMaxLength()) {\r\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\r\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\r\n  }\r\n  return length | 0\r\n}\r\n\r\nfunction SlowBuffer (length) {\r\n  if (+length != length) { // eslint-disable-line eqeqeq\r\n    length = 0\r\n  }\r\n  return Buffer.alloc(+length)\r\n}\r\n\r\nBuffer.isBuffer = function isBuffer (b) {\r\n  return !!(b != null && b._isBuffer)\r\n}\r\n\r\nBuffer.compare = function compare (a, b) {\r\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\r\n    throw new TypeError('Arguments must be Buffers')\r\n  }\r\n\r\n  if (a === b) return 0\r\n\r\n  var x = a.length\r\n  var y = b.length\r\n\r\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\r\n    if (a[i] !== b[i]) {\r\n      x = a[i]\r\n      y = b[i]\r\n      break\r\n    }\r\n  }\r\n\r\n  if (x < y) return -1\r\n  if (y < x) return 1\r\n  return 0\r\n}\r\n\r\nBuffer.isEncoding = function isEncoding (encoding) {\r\n  switch (String(encoding).toLowerCase()) {\r\n    case 'hex':\r\n    case 'utf8':\r\n    case 'utf-8':\r\n    case 'ascii':\r\n    case 'latin1':\r\n    case 'binary':\r\n    case 'base64':\r\n    case 'ucs2':\r\n    case 'ucs-2':\r\n    case 'utf16le':\r\n    case 'utf-16le':\r\n      return true\r\n    default:\r\n      return false\r\n  }\r\n}\r\n\r\nBuffer.concat = function concat (list, length) {\r\n  if (!isArray(list)) {\r\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n  }\r\n\r\n  if (list.length === 0) {\r\n    return Buffer.alloc(0)\r\n  }\r\n\r\n  var i\r\n  if (length === undefined) {\r\n    length = 0\r\n    for (i = 0; i < list.length; ++i) {\r\n      length += list[i].length\r\n    }\r\n  }\r\n\r\n  var buffer = Buffer.allocUnsafe(length)\r\n  var pos = 0\r\n  for (i = 0; i < list.length; ++i) {\r\n    var buf = list[i]\r\n    if (!Buffer.isBuffer(buf)) {\r\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n    }\r\n    buf.copy(buffer, pos)\r\n    pos += buf.length\r\n  }\r\n  return buffer\r\n}\r\n\r\nfunction byteLength (string, encoding) {\r\n  if (Buffer.isBuffer(string)) {\r\n    return string.length\r\n  }\r\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\r\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\r\n    return string.byteLength\r\n  }\r\n  if (typeof string !== 'string') {\r\n    string = '' + string\r\n  }\r\n\r\n  var len = string.length\r\n  if (len === 0) return 0\r\n\r\n  // Use a for loop to avoid recursion\r\n  var loweredCase = false\r\n  for (;;) {\r\n    switch (encoding) {\r\n      case 'ascii':\r\n      case 'latin1':\r\n      case 'binary':\r\n        return len\r\n      case 'utf8':\r\n      case 'utf-8':\r\n      case undefined:\r\n        return utf8ToBytes(string).length\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return len * 2\r\n      case 'hex':\r\n        return len >>> 1\r\n      case 'base64':\r\n        return base64ToBytes(string).length\r\n      default:\r\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\r\n        encoding = ('' + encoding).toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\nBuffer.byteLength = byteLength\r\n\r\nfunction slowToString (encoding, start, end) {\r\n  var loweredCase = false\r\n\r\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\r\n  // property of a typed array.\r\n\r\n  // This behaves neither like String nor Uint8Array in that we set start/end\r\n  // to their upper/lower bounds if the value passed is out of range.\r\n  // undefined is handled specially as per ECMA-262 6th Edition,\r\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\r\n  if (start === undefined || start < 0) {\r\n    start = 0\r\n  }\r\n  // Return early if start > this.length. Done here to prevent potential uint32\r\n  // coercion fail below.\r\n  if (start > this.length) {\r\n    return ''\r\n  }\r\n\r\n  if (end === undefined || end > this.length) {\r\n    end = this.length\r\n  }\r\n\r\n  if (end <= 0) {\r\n    return ''\r\n  }\r\n\r\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\r\n  end >>>= 0\r\n  start >>>= 0\r\n\r\n  if (end <= start) {\r\n    return ''\r\n  }\r\n\r\n  if (!encoding) encoding = 'utf8'\r\n\r\n  while (true) {\r\n    switch (encoding) {\r\n      case 'hex':\r\n        return hexSlice(this, start, end)\r\n\r\n      case 'utf8':\r\n      case 'utf-8':\r\n        return utf8Slice(this, start, end)\r\n\r\n      case 'ascii':\r\n        return asciiSlice(this, start, end)\r\n\r\n      case 'latin1':\r\n      case 'binary':\r\n        return latin1Slice(this, start, end)\r\n\r\n      case 'base64':\r\n        return base64Slice(this, start, end)\r\n\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return utf16leSlice(this, start, end)\r\n\r\n      default:\r\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n        encoding = (encoding + '').toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\n\r\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\r\n// Buffer instances.\r\nBuffer.prototype._isBuffer = true\r\n\r\nfunction swap (b, n, m) {\r\n  var i = b[n]\r\n  b[n] = b[m]\r\n  b[m] = i\r\n}\r\n\r\nBuffer.prototype.swap16 = function swap16 () {\r\n  var len = this.length\r\n  if (len % 2 !== 0) {\r\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\r\n  }\r\n  for (var i = 0; i < len; i += 2) {\r\n    swap(this, i, i + 1)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.swap32 = function swap32 () {\r\n  var len = this.length\r\n  if (len % 4 !== 0) {\r\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\r\n  }\r\n  for (var i = 0; i < len; i += 4) {\r\n    swap(this, i, i + 3)\r\n    swap(this, i + 1, i + 2)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.swap64 = function swap64 () {\r\n  var len = this.length\r\n  if (len % 8 !== 0) {\r\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\r\n  }\r\n  for (var i = 0; i < len; i += 8) {\r\n    swap(this, i, i + 7)\r\n    swap(this, i + 1, i + 6)\r\n    swap(this, i + 2, i + 5)\r\n    swap(this, i + 3, i + 4)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.toString = function toString () {\r\n  var length = this.length | 0\r\n  if (length === 0) return ''\r\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\r\n  return slowToString.apply(this, arguments)\r\n}\r\n\r\nBuffer.prototype.equals = function equals (b) {\r\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\r\n  if (this === b) return true\r\n  return Buffer.compare(this, b) === 0\r\n}\r\n\r\nBuffer.prototype.inspect = function inspect () {\r\n  var str = ''\r\n  var max = exports.INSPECT_MAX_BYTES\r\n  if (this.length > 0) {\r\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\r\n    if (this.length > max) str += ' ... '\r\n  }\r\n  return '<Buffer ' + str + '>'\r\n}\r\n\r\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\r\n  if (!Buffer.isBuffer(target)) {\r\n    throw new TypeError('Argument must be a Buffer')\r\n  }\r\n\r\n  if (start === undefined) {\r\n    start = 0\r\n  }\r\n  if (end === undefined) {\r\n    end = target ? target.length : 0\r\n  }\r\n  if (thisStart === undefined) {\r\n    thisStart = 0\r\n  }\r\n  if (thisEnd === undefined) {\r\n    thisEnd = this.length\r\n  }\r\n\r\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\r\n    throw new RangeError('out of range index')\r\n  }\r\n\r\n  if (thisStart >= thisEnd && start >= end) {\r\n    return 0\r\n  }\r\n  if (thisStart >= thisEnd) {\r\n    return -1\r\n  }\r\n  if (start >= end) {\r\n    return 1\r\n  }\r\n\r\n  start >>>= 0\r\n  end >>>= 0\r\n  thisStart >>>= 0\r\n  thisEnd >>>= 0\r\n\r\n  if (this === target) return 0\r\n\r\n  var x = thisEnd - thisStart\r\n  var y = end - start\r\n  var len = Math.min(x, y)\r\n\r\n  var thisCopy = this.slice(thisStart, thisEnd)\r\n  var targetCopy = target.slice(start, end)\r\n\r\n  for (var i = 0; i < len; ++i) {\r\n    if (thisCopy[i] !== targetCopy[i]) {\r\n      x = thisCopy[i]\r\n      y = targetCopy[i]\r\n      break\r\n    }\r\n  }\r\n\r\n  if (x < y) return -1\r\n  if (y < x) return 1\r\n  return 0\r\n}\r\n\r\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\r\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\r\n//\r\n// Arguments:\r\n// - buffer - a Buffer to search\r\n// - val - a string, Buffer, or number\r\n// - byteOffset - an index into `buffer`; will be clamped to an int32\r\n// - encoding - an optional encoding, relevant is val is a string\r\n// - dir - true for indexOf, false for lastIndexOf\r\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\r\n  // Empty buffer means no match\r\n  if (buffer.length === 0) return -1\r\n\r\n  // Normalize byteOffset\r\n  if (typeof byteOffset === 'string') {\r\n    encoding = byteOffset\r\n    byteOffset = 0\r\n  } else if (byteOffset > 0x7fffffff) {\r\n    byteOffset = 0x7fffffff\r\n  } else if (byteOffset < -0x80000000) {\r\n    byteOffset = -0x80000000\r\n  }\r\n  byteOffset = +byteOffset  // Coerce to Number.\r\n  if (isNaN(byteOffset)) {\r\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\r\n    byteOffset = dir ? 0 : (buffer.length - 1)\r\n  }\r\n\r\n  // Normalize byteOffset: negative offsets start from the end of the buffer\r\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\r\n  if (byteOffset >= buffer.length) {\r\n    if (dir) return -1\r\n    else byteOffset = buffer.length - 1\r\n  } else if (byteOffset < 0) {\r\n    if (dir) byteOffset = 0\r\n    else return -1\r\n  }\r\n\r\n  // Normalize val\r\n  if (typeof val === 'string') {\r\n    val = Buffer.from(val, encoding)\r\n  }\r\n\r\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\r\n  if (Buffer.isBuffer(val)) {\r\n    // Special case: looking for empty string/buffer always fails\r\n    if (val.length === 0) {\r\n      return -1\r\n    }\r\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\r\n  } else if (typeof val === 'number') {\r\n    val = val & 0xFF // Search for a byte value [0-255]\r\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\r\n        typeof Uint8Array.prototype.indexOf === 'function') {\r\n      if (dir) {\r\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\r\n      } else {\r\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\r\n      }\r\n    }\r\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\r\n  }\r\n\r\n  throw new TypeError('val must be string, number or Buffer')\r\n}\r\n\r\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\r\n  var indexSize = 1\r\n  var arrLength = arr.length\r\n  var valLength = val.length\r\n\r\n  if (encoding !== undefined) {\r\n    encoding = String(encoding).toLowerCase()\r\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\r\n        encoding === 'utf16le' || encoding === 'utf-16le') {\r\n      if (arr.length < 2 || val.length < 2) {\r\n        return -1\r\n      }\r\n      indexSize = 2\r\n      arrLength /= 2\r\n      valLength /= 2\r\n      byteOffset /= 2\r\n    }\r\n  }\r\n\r\n  function read (buf, i) {\r\n    if (indexSize === 1) {\r\n      return buf[i]\r\n    } else {\r\n      return buf.readUInt16BE(i * indexSize)\r\n    }\r\n  }\r\n\r\n  var i\r\n  if (dir) {\r\n    var foundIndex = -1\r\n    for (i = byteOffset; i < arrLength; i++) {\r\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\r\n        if (foundIndex === -1) foundIndex = i\r\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\r\n      } else {\r\n        if (foundIndex !== -1) i -= i - foundIndex\r\n        foundIndex = -1\r\n      }\r\n    }\r\n  } else {\r\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\r\n    for (i = byteOffset; i >= 0; i--) {\r\n      var found = true\r\n      for (var j = 0; j < valLength; j++) {\r\n        if (read(arr, i + j) !== read(val, j)) {\r\n          found = false\r\n          break\r\n        }\r\n      }\r\n      if (found) return i\r\n    }\r\n  }\r\n\r\n  return -1\r\n}\r\n\r\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\r\n  return this.indexOf(val, byteOffset, encoding) !== -1\r\n}\r\n\r\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\r\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\r\n}\r\n\r\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\r\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\r\n}\r\n\r\nfunction hexWrite (buf, string, offset, length) {\r\n  offset = Number(offset) || 0\r\n  var remaining = buf.length - offset\r\n  if (!length) {\r\n    length = remaining\r\n  } else {\r\n    length = Number(length)\r\n    if (length > remaining) {\r\n      length = remaining\r\n    }\r\n  }\r\n\r\n  // must be an even number of digits\r\n  var strLen = string.length\r\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\r\n\r\n  if (length > strLen / 2) {\r\n    length = strLen / 2\r\n  }\r\n  for (var i = 0; i < length; ++i) {\r\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\r\n    if (isNaN(parsed)) return i\r\n    buf[offset + i] = parsed\r\n  }\r\n  return i\r\n}\r\n\r\nfunction utf8Write (buf, string, offset, length) {\r\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\r\n}\r\n\r\nfunction asciiWrite (buf, string, offset, length) {\r\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\r\n}\r\n\r\nfunction latin1Write (buf, string, offset, length) {\r\n  return asciiWrite(buf, string, offset, length)\r\n}\r\n\r\nfunction base64Write (buf, string, offset, length) {\r\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\r\n}\r\n\r\nfunction ucs2Write (buf, string, offset, length) {\r\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\r\n}\r\n\r\nBuffer.prototype.write = function write (string, offset, length, encoding) {\r\n  // Buffer#write(string)\r\n  if (offset === undefined) {\r\n    encoding = 'utf8'\r\n    length = this.length\r\n    offset = 0\r\n  // Buffer#write(string, encoding)\r\n  } else if (length === undefined && typeof offset === 'string') {\r\n    encoding = offset\r\n    length = this.length\r\n    offset = 0\r\n  // Buffer#write(string, offset[, length][, encoding])\r\n  } else if (isFinite(offset)) {\r\n    offset = offset | 0\r\n    if (isFinite(length)) {\r\n      length = length | 0\r\n      if (encoding === undefined) encoding = 'utf8'\r\n    } else {\r\n      encoding = length\r\n      length = undefined\r\n    }\r\n  // legacy write(string, encoding, offset, length) - remove in v0.13\r\n  } else {\r\n    throw new Error(\r\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\r\n    )\r\n  }\r\n\r\n  var remaining = this.length - offset\r\n  if (length === undefined || length > remaining) length = remaining\r\n\r\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\r\n    throw new RangeError('Attempt to write outside buffer bounds')\r\n  }\r\n\r\n  if (!encoding) encoding = 'utf8'\r\n\r\n  var loweredCase = false\r\n  for (;;) {\r\n    switch (encoding) {\r\n      case 'hex':\r\n        return hexWrite(this, string, offset, length)\r\n\r\n      case 'utf8':\r\n      case 'utf-8':\r\n        return utf8Write(this, string, offset, length)\r\n\r\n      case 'ascii':\r\n        return asciiWrite(this, string, offset, length)\r\n\r\n      case 'latin1':\r\n      case 'binary':\r\n        return latin1Write(this, string, offset, length)\r\n\r\n      case 'base64':\r\n        // Warning: maxLength not taken into account in base64Write\r\n        return base64Write(this, string, offset, length)\r\n\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return ucs2Write(this, string, offset, length)\r\n\r\n      default:\r\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n        encoding = ('' + encoding).toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\n\r\nBuffer.prototype.toJSON = function toJSON () {\r\n  return {\r\n    type: 'Buffer',\r\n    data: Array.prototype.slice.call(this._arr || this, 0)\r\n  }\r\n}\r\n\r\nfunction base64Slice (buf, start, end) {\r\n  if (start === 0 && end === buf.length) {\r\n    return base64.fromByteArray(buf)\r\n  } else {\r\n    return base64.fromByteArray(buf.slice(start, end))\r\n  }\r\n}\r\n\r\nfunction utf8Slice (buf, start, end) {\r\n  end = Math.min(buf.length, end)\r\n  var res = []\r\n\r\n  var i = start\r\n  while (i < end) {\r\n    var firstByte = buf[i]\r\n    var codePoint = null\r\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\r\n      : (firstByte > 0xDF) ? 3\r\n      : (firstByte > 0xBF) ? 2\r\n      : 1\r\n\r\n    if (i + bytesPerSequence <= end) {\r\n      var secondByte, thirdByte, fourthByte, tempCodePoint\r\n\r\n      switch (bytesPerSequence) {\r\n        case 1:\r\n          if (firstByte < 0x80) {\r\n            codePoint = firstByte\r\n          }\r\n          break\r\n        case 2:\r\n          secondByte = buf[i + 1]\r\n          if ((secondByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\r\n            if (tempCodePoint > 0x7F) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n          break\r\n        case 3:\r\n          secondByte = buf[i + 1]\r\n          thirdByte = buf[i + 2]\r\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\r\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n          break\r\n        case 4:\r\n          secondByte = buf[i + 1]\r\n          thirdByte = buf[i + 2]\r\n          fourthByte = buf[i + 3]\r\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\r\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n      }\r\n    }\r\n\r\n    if (codePoint === null) {\r\n      // we did not generate a valid codePoint so insert a\r\n      // replacement char (U+FFFD) and advance only 1 byte\r\n      codePoint = 0xFFFD\r\n      bytesPerSequence = 1\r\n    } else if (codePoint > 0xFFFF) {\r\n      // encode to utf16 (surrogate pair dance)\r\n      codePoint -= 0x10000\r\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\r\n      codePoint = 0xDC00 | codePoint & 0x3FF\r\n    }\r\n\r\n    res.push(codePoint)\r\n    i += bytesPerSequence\r\n  }\r\n\r\n  return decodeCodePointsArray(res)\r\n}\r\n\r\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\r\n// the lowest limit is Chrome, with 0x10000 args.\r\n// We go 1 magnitude less, for safety\r\nvar MAX_ARGUMENTS_LENGTH = 0x1000\r\n\r\nfunction decodeCodePointsArray (codePoints) {\r\n  var len = codePoints.length\r\n  if (len <= MAX_ARGUMENTS_LENGTH) {\r\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\r\n  }\r\n\r\n  // Decode in chunks to avoid \"call stack size exceeded\".\r\n  var res = ''\r\n  var i = 0\r\n  while (i < len) {\r\n    res += String.fromCharCode.apply(\r\n      String,\r\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\r\n    )\r\n  }\r\n  return res\r\n}\r\n\r\nfunction asciiSlice (buf, start, end) {\r\n  var ret = ''\r\n  end = Math.min(buf.length, end)\r\n\r\n  for (var i = start; i < end; ++i) {\r\n    ret += String.fromCharCode(buf[i] & 0x7F)\r\n  }\r\n  return ret\r\n}\r\n\r\nfunction latin1Slice (buf, start, end) {\r\n  var ret = ''\r\n  end = Math.min(buf.length, end)\r\n\r\n  for (var i = start; i < end; ++i) {\r\n    ret += String.fromCharCode(buf[i])\r\n  }\r\n  return ret\r\n}\r\n\r\nfunction hexSlice (buf, start, end) {\r\n  var len = buf.length\r\n\r\n  if (!start || start < 0) start = 0\r\n  if (!end || end < 0 || end > len) end = len\r\n\r\n  var out = ''\r\n  for (var i = start; i < end; ++i) {\r\n    out += toHex(buf[i])\r\n  }\r\n  return out\r\n}\r\n\r\nfunction utf16leSlice (buf, start, end) {\r\n  var bytes = buf.slice(start, end)\r\n  var res = ''\r\n  for (var i = 0; i < bytes.length; i += 2) {\r\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\r\n  }\r\n  return res\r\n}\r\n\r\nBuffer.prototype.slice = function slice (start, end) {\r\n  var len = this.length\r\n  start = ~~start\r\n  end = end === undefined ? len : ~~end\r\n\r\n  if (start < 0) {\r\n    start += len\r\n    if (start < 0) start = 0\r\n  } else if (start > len) {\r\n    start = len\r\n  }\r\n\r\n  if (end < 0) {\r\n    end += len\r\n    if (end < 0) end = 0\r\n  } else if (end > len) {\r\n    end = len\r\n  }\r\n\r\n  if (end < start) end = start\r\n\r\n  var newBuf\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    newBuf = this.subarray(start, end)\r\n    newBuf.__proto__ = Buffer.prototype\r\n  } else {\r\n    var sliceLen = end - start\r\n    newBuf = new Buffer(sliceLen, undefined)\r\n    for (var i = 0; i < sliceLen; ++i) {\r\n      newBuf[i] = this[i + start]\r\n    }\r\n  }\r\n\r\n  return newBuf\r\n}\r\n\r\n/*\r\n * Need to make sure that buffer isn't trying to write out of bounds.\r\n */\r\nfunction checkOffset (offset, ext, length) {\r\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\r\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\r\n}\r\n\r\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  var val = this[offset]\r\n  var mul = 1\r\n  var i = 0\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    val += this[offset + i] * mul\r\n  }\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) {\r\n    checkOffset(offset, byteLength, this.length)\r\n  }\r\n\r\n  var val = this[offset + --byteLength]\r\n  var mul = 1\r\n  while (byteLength > 0 && (mul *= 0x100)) {\r\n    val += this[offset + --byteLength] * mul\r\n  }\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 1, this.length)\r\n  return this[offset]\r\n}\r\n\r\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  return this[offset] | (this[offset + 1] << 8)\r\n}\r\n\r\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  return (this[offset] << 8) | this[offset + 1]\r\n}\r\n\r\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return ((this[offset]) |\r\n      (this[offset + 1] << 8) |\r\n      (this[offset + 2] << 16)) +\r\n      (this[offset + 3] * 0x1000000)\r\n}\r\n\r\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset] * 0x1000000) +\r\n    ((this[offset + 1] << 16) |\r\n    (this[offset + 2] << 8) |\r\n    this[offset + 3])\r\n}\r\n\r\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  var val = this[offset]\r\n  var mul = 1\r\n  var i = 0\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    val += this[offset + i] * mul\r\n  }\r\n  mul *= 0x80\r\n\r\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  var i = byteLength\r\n  var mul = 1\r\n  var val = this[offset + --i]\r\n  while (i > 0 && (mul *= 0x100)) {\r\n    val += this[offset + --i] * mul\r\n  }\r\n  mul *= 0x80\r\n\r\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 1, this.length)\r\n  if (!(this[offset] & 0x80)) return (this[offset])\r\n  return ((0xff - this[offset] + 1) * -1)\r\n}\r\n\r\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  var val = this[offset] | (this[offset + 1] << 8)\r\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n}\r\n\r\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  var val = this[offset + 1] | (this[offset] << 8)\r\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n}\r\n\r\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset]) |\r\n    (this[offset + 1] << 8) |\r\n    (this[offset + 2] << 16) |\r\n    (this[offset + 3] << 24)\r\n}\r\n\r\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset] << 24) |\r\n    (this[offset + 1] << 16) |\r\n    (this[offset + 2] << 8) |\r\n    (this[offset + 3])\r\n}\r\n\r\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n  return ieee754.read(this, offset, true, 23, 4)\r\n}\r\n\r\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n  return ieee754.read(this, offset, false, 23, 4)\r\n}\r\n\r\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 8, this.length)\r\n  return ieee754.read(this, offset, true, 52, 8)\r\n}\r\n\r\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 8, this.length)\r\n  return ieee754.read(this, offset, false, 52, 8)\r\n}\r\n\r\nfunction checkInt (buf, value, offset, ext, max, min) {\r\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\r\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\r\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n}\r\n\r\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) {\r\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n  }\r\n\r\n  var mul = 1\r\n  var i = 0\r\n  this[offset] = value & 0xFF\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    this[offset + i] = (value / mul) & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) {\r\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n  }\r\n\r\n  var i = byteLength - 1\r\n  var mul = 1\r\n  this[offset + i] = value & 0xFF\r\n  while (--i >= 0 && (mul *= 0x100)) {\r\n    this[offset + i] = (value / mul) & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\r\n  this[offset] = (value & 0xff)\r\n  return offset + 1\r\n}\r\n\r\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\r\n  if (value < 0) value = 0xffff + value + 1\r\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\r\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\r\n      (littleEndian ? i : 1 - i) * 8\r\n  }\r\n}\r\n\r\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, true)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, false)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\r\n  if (value < 0) value = 0xffffffff + value + 1\r\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\r\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\r\n  }\r\n}\r\n\r\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset + 3] = (value >>> 24)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, true)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, false)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) {\r\n    var limit = Math.pow(2, 8 * byteLength - 1)\r\n\r\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n  }\r\n\r\n  var i = 0\r\n  var mul = 1\r\n  var sub = 0\r\n  this[offset] = value & 0xFF\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\r\n      sub = 1\r\n    }\r\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) {\r\n    var limit = Math.pow(2, 8 * byteLength - 1)\r\n\r\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n  }\r\n\r\n  var i = byteLength - 1\r\n  var mul = 1\r\n  var sub = 0\r\n  this[offset + i] = value & 0xFF\r\n  while (--i >= 0 && (mul *= 0x100)) {\r\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\r\n      sub = 1\r\n    }\r\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\r\n  if (value < 0) value = 0xff + value + 1\r\n  this[offset] = (value & 0xff)\r\n  return offset + 1\r\n}\r\n\r\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, true)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, false)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 3] = (value >>> 24)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, true)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n  if (value < 0) value = 0xffffffff + value + 1\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, false)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\r\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n  if (offset < 0) throw new RangeError('Index out of range')\r\n}\r\n\r\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\r\n  if (!noAssert) {\r\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\r\n  }\r\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\r\n  return writeFloat(this, value, offset, true, noAssert)\r\n}\r\n\r\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\r\n  return writeFloat(this, value, offset, false, noAssert)\r\n}\r\n\r\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\r\n  if (!noAssert) {\r\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\r\n  }\r\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\r\n  return offset + 8\r\n}\r\n\r\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\r\n  return writeDouble(this, value, offset, true, noAssert)\r\n}\r\n\r\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\r\n  return writeDouble(this, value, offset, false, noAssert)\r\n}\r\n\r\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\r\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\r\n  if (!start) start = 0\r\n  if (!end && end !== 0) end = this.length\r\n  if (targetStart >= target.length) targetStart = target.length\r\n  if (!targetStart) targetStart = 0\r\n  if (end > 0 && end < start) end = start\r\n\r\n  // Copy 0 bytes; we're done\r\n  if (end === start) return 0\r\n  if (target.length === 0 || this.length === 0) return 0\r\n\r\n  // Fatal error conditions\r\n  if (targetStart < 0) {\r\n    throw new RangeError('targetStart out of bounds')\r\n  }\r\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\r\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\r\n\r\n  // Are we oob?\r\n  if (end > this.length) end = this.length\r\n  if (target.length - targetStart < end - start) {\r\n    end = target.length - targetStart + start\r\n  }\r\n\r\n  var len = end - start\r\n  var i\r\n\r\n  if (this === target && start < targetStart && targetStart < end) {\r\n    // descending copy from end\r\n    for (i = len - 1; i >= 0; --i) {\r\n      target[i + targetStart] = this[i + start]\r\n    }\r\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\r\n    // ascending copy from start\r\n    for (i = 0; i < len; ++i) {\r\n      target[i + targetStart] = this[i + start]\r\n    }\r\n  } else {\r\n    Uint8Array.prototype.set.call(\r\n      target,\r\n      this.subarray(start, start + len),\r\n      targetStart\r\n    )\r\n  }\r\n\r\n  return len\r\n}\r\n\r\n// Usage:\r\n//    buffer.fill(number[, offset[, end]])\r\n//    buffer.fill(buffer[, offset[, end]])\r\n//    buffer.fill(string[, offset[, end]][, encoding])\r\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\r\n  // Handle string cases:\r\n  if (typeof val === 'string') {\r\n    if (typeof start === 'string') {\r\n      encoding = start\r\n      start = 0\r\n      end = this.length\r\n    } else if (typeof end === 'string') {\r\n      encoding = end\r\n      end = this.length\r\n    }\r\n    if (val.length === 1) {\r\n      var code = val.charCodeAt(0)\r\n      if (code < 256) {\r\n        val = code\r\n      }\r\n    }\r\n    if (encoding !== undefined && typeof encoding !== 'string') {\r\n      throw new TypeError('encoding must be a string')\r\n    }\r\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\r\n      throw new TypeError('Unknown encoding: ' + encoding)\r\n    }\r\n  } else if (typeof val === 'number') {\r\n    val = val & 255\r\n  }\r\n\r\n  // Invalid ranges are not set to a default, so can range check early.\r\n  if (start < 0 || this.length < start || this.length < end) {\r\n    throw new RangeError('Out of range index')\r\n  }\r\n\r\n  if (end <= start) {\r\n    return this\r\n  }\r\n\r\n  start = start >>> 0\r\n  end = end === undefined ? this.length : end >>> 0\r\n\r\n  if (!val) val = 0\r\n\r\n  var i\r\n  if (typeof val === 'number') {\r\n    for (i = start; i < end; ++i) {\r\n      this[i] = val\r\n    }\r\n  } else {\r\n    var bytes = Buffer.isBuffer(val)\r\n      ? val\r\n      : utf8ToBytes(new Buffer(val, encoding).toString())\r\n    var len = bytes.length\r\n    for (i = 0; i < end - start; ++i) {\r\n      this[i + start] = bytes[i % len]\r\n    }\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n// HELPER FUNCTIONS\r\n// ================\r\n\r\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\r\n\r\nfunction base64clean (str) {\r\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\r\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\r\n  // Node converts strings with length < 2 to ''\r\n  if (str.length < 2) return ''\r\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\r\n  while (str.length % 4 !== 0) {\r\n    str = str + '='\r\n  }\r\n  return str\r\n}\r\n\r\nfunction stringtrim (str) {\r\n  if (str.trim) return str.trim()\r\n  return str.replace(/^\\s+|\\s+$/g, '')\r\n}\r\n\r\nfunction toHex (n) {\r\n  if (n < 16) return '0' + n.toString(16)\r\n  return n.toString(16)\r\n}\r\n\r\nfunction utf8ToBytes (string, units) {\r\n  units = units || Infinity\r\n  var codePoint\r\n  var length = string.length\r\n  var leadSurrogate = null\r\n  var bytes = []\r\n\r\n  for (var i = 0; i < length; ++i) {\r\n    codePoint = string.charCodeAt(i)\r\n\r\n    // is surrogate component\r\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\r\n      // last char was a lead\r\n      if (!leadSurrogate) {\r\n        // no lead yet\r\n        if (codePoint > 0xDBFF) {\r\n          // unexpected trail\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          continue\r\n        } else if (i + 1 === length) {\r\n          // unpaired lead\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          continue\r\n        }\r\n\r\n        // valid lead\r\n        leadSurrogate = codePoint\r\n\r\n        continue\r\n      }\r\n\r\n      // 2 leads in a row\r\n      if (codePoint < 0xDC00) {\r\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n        leadSurrogate = codePoint\r\n        continue\r\n      }\r\n\r\n      // valid surrogate pair\r\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\r\n    } else if (leadSurrogate) {\r\n      // valid bmp char, but last char was a lead\r\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n    }\r\n\r\n    leadSurrogate = null\r\n\r\n    // encode utf8\r\n    if (codePoint < 0x80) {\r\n      if ((units -= 1) < 0) break\r\n      bytes.push(codePoint)\r\n    } else if (codePoint < 0x800) {\r\n      if ((units -= 2) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0x6 | 0xC0,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else if (codePoint < 0x10000) {\r\n      if ((units -= 3) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0xC | 0xE0,\r\n        codePoint >> 0x6 & 0x3F | 0x80,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else if (codePoint < 0x110000) {\r\n      if ((units -= 4) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0x12 | 0xF0,\r\n        codePoint >> 0xC & 0x3F | 0x80,\r\n        codePoint >> 0x6 & 0x3F | 0x80,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else {\r\n      throw new Error('Invalid code point')\r\n    }\r\n  }\r\n\r\n  return bytes\r\n}\r\n\r\nfunction asciiToBytes (str) {\r\n  var byteArray = []\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Node's code seems to be doing this and not & 0x7F..\r\n    byteArray.push(str.charCodeAt(i) & 0xFF)\r\n  }\r\n  return byteArray\r\n}\r\n\r\nfunction utf16leToBytes (str, units) {\r\n  var c, hi, lo\r\n  var byteArray = []\r\n  for (var i = 0; i < str.length; ++i) {\r\n    if ((units -= 2) < 0) break\r\n\r\n    c = str.charCodeAt(i)\r\n    hi = c >> 8\r\n    lo = c % 256\r\n    byteArray.push(lo)\r\n    byteArray.push(hi)\r\n  }\r\n\r\n  return byteArray\r\n}\r\n\r\nfunction base64ToBytes (str) {\r\n  return base64.toByteArray(base64clean(str))\r\n}\r\n\r\nfunction blitBuffer (src, dst, offset, length) {\r\n  for (var i = 0; i < length; ++i) {\r\n    if ((i + offset >= dst.length) || (i >= src.length)) break\r\n    dst[i + offset] = src[i]\r\n  }\r\n  return i\r\n}\r\n\r\nfunction isnan (val) {\r\n  return val !== val // eslint-disable-line no-self-compare\r\n}\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(79)))\n\n/***/ }),\n\n/***/ 944:\n/***/ (function(module, exports) {\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\r\n  var e, m\r\n  var eLen = nBytes * 8 - mLen - 1\r\n  var eMax = (1 << eLen) - 1\r\n  var eBias = eMax >> 1\r\n  var nBits = -7\r\n  var i = isLE ? (nBytes - 1) : 0\r\n  var d = isLE ? -1 : 1\r\n  var s = buffer[offset + i]\r\n\r\n  i += d\r\n\r\n  e = s & ((1 << (-nBits)) - 1)\r\n  s >>= (-nBits)\r\n  nBits += eLen\r\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n  m = e & ((1 << (-nBits)) - 1)\r\n  e >>= (-nBits)\r\n  nBits += mLen\r\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n  if (e === 0) {\r\n    e = 1 - eBias\r\n  } else if (e === eMax) {\r\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\r\n  } else {\r\n    m = m + Math.pow(2, mLen)\r\n    e = e - eBias\r\n  }\r\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\r\n}\r\n\r\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\r\n  var e, m, c\r\n  var eLen = nBytes * 8 - mLen - 1\r\n  var eMax = (1 << eLen) - 1\r\n  var eBias = eMax >> 1\r\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\r\n  var i = isLE ? 0 : (nBytes - 1)\r\n  var d = isLE ? 1 : -1\r\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\r\n\r\n  value = Math.abs(value)\r\n\r\n  if (isNaN(value) || value === Infinity) {\r\n    m = isNaN(value) ? 1 : 0\r\n    e = eMax\r\n  } else {\r\n    e = Math.floor(Math.log(value) / Math.LN2)\r\n    if (value * (c = Math.pow(2, -e)) < 1) {\r\n      e--\r\n      c *= 2\r\n    }\r\n    if (e + eBias >= 1) {\r\n      value += rt / c\r\n    } else {\r\n      value += rt * Math.pow(2, 1 - eBias)\r\n    }\r\n    if (value * c >= 2) {\r\n      e++\r\n      c /= 2\r\n    }\r\n\r\n    if (e + eBias >= eMax) {\r\n      m = 0\r\n      e = eMax\r\n    } else if (e + eBias >= 1) {\r\n      m = (value * c - 1) * Math.pow(2, mLen)\r\n      e = e + eBias\r\n    } else {\r\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\r\n      e = 0\r\n    }\r\n  }\r\n\r\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\r\n\r\n  e = (e << mLen) | m\r\n  eLen += mLen\r\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\r\n\r\n  buffer[offset + i - d] |= s * 128\r\n}\r\n\n\n/***/ }),\n\n/***/ 945:\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\r\n\r\nmodule.exports = Array.isArray || function (arr) {\r\n  return toString.call(arr) == '[object Array]';\r\n};\r\n\n\n/***/ }),\n\n/***/ 959:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// Utility function that allows modes to be combined. The mode given\r\n// as the base argument takes care of most of the normal mode\r\n// functionality, but a second (typically simple) mode is used, which\r\n// can override the style of text. Both modes get to parse all of the\r\n// text, but when both assign a non-null style to a piece of code, the\r\n// overlay wins, unless the combine argument was true and not overridden,\r\n// or state.overlay.combineTokens was true, in which case the styles are\r\n// combined.\r\n\r\n(function(mod) {\r\n  if (true) // CommonJS\r\n    mod(__webpack_require__(877));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n\"use strict\";\r\n\r\nCodeMirror.overlayMode = function(base, overlay, combine) {\r\n  return {\r\n    startState: function() {\r\n      return {\r\n        base: CodeMirror.startState(base),\r\n        overlay: CodeMirror.startState(overlay),\r\n        basePos: 0, baseCur: null,\r\n        overlayPos: 0, overlayCur: null,\r\n        streamSeen: null\r\n      };\r\n    },\r\n    copyState: function(state) {\r\n      return {\r\n        base: CodeMirror.copyState(base, state.base),\r\n        overlay: CodeMirror.copyState(overlay, state.overlay),\r\n        basePos: state.basePos, baseCur: null,\r\n        overlayPos: state.overlayPos, overlayCur: null\r\n      };\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      if (stream != state.streamSeen ||\r\n          Math.min(state.basePos, state.overlayPos) < stream.start) {\r\n        state.streamSeen = stream;\r\n        state.basePos = state.overlayPos = stream.start;\r\n      }\r\n\r\n      if (stream.start == state.basePos) {\r\n        state.baseCur = base.token(stream, state.base);\r\n        state.basePos = stream.pos;\r\n      }\r\n      if (stream.start == state.overlayPos) {\r\n        stream.pos = stream.start;\r\n        state.overlayCur = overlay.token(stream, state.overlay);\r\n        state.overlayPos = stream.pos;\r\n      }\r\n      stream.pos = Math.min(state.basePos, state.overlayPos);\r\n\r\n      // state.overlay.combineTokens always takes precedence over combine,\r\n      // unless set to null\r\n      if (state.overlayCur == null) return state.baseCur;\r\n      else if (state.baseCur != null &&\r\n               state.overlay.combineTokens ||\r\n               combine && state.overlay.combineTokens == null)\r\n        return state.baseCur + \" \" + state.overlayCur;\r\n      else return state.overlayCur;\r\n    },\r\n\r\n    indent: base.indent && function(state, textAfter) {\r\n      return base.indent(state.base, textAfter);\r\n    },\r\n    electricChars: base.electricChars,\r\n\r\n    innerMode: function(state) { return {state: state.base, mode: base}; },\r\n\r\n    blankLine: function(state) {\r\n      var baseToken, overlayToken;\r\n      if (base.blankLine) baseToken = base.blankLine(state.base);\r\n      if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);\r\n\r\n      return overlayToken == null ?\r\n        baseToken :\r\n        (combine && baseToken != null ? baseToken + \" \" + overlayToken : overlayToken);\r\n    }\r\n  };\r\n};\r\n\r\n});\r\n\n\n/***/ }),\n\n/***/ 960:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (true) // CommonJS\r\n    mod(__webpack_require__(877), __webpack_require__(961), __webpack_require__(1079));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../meta\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n\"use strict\";\r\n\r\nCodeMirror.defineMode(\"markdown\", function(cmCfg, modeCfg) {\r\n\r\n  var htmlMode = CodeMirror.getMode(cmCfg, \"text/html\");\r\n  var htmlModeMissing = htmlMode.name == \"null\"\r\n\r\n  function getMode(name) {\r\n    if (CodeMirror.findModeByName) {\r\n      var found = CodeMirror.findModeByName(name);\r\n      if (found) name = found.mime || found.mimes[0];\r\n    }\r\n    var mode = CodeMirror.getMode(cmCfg, name);\r\n    return mode.name == \"null\" ? null : mode;\r\n  }\r\n\r\n  // Should characters that affect highlighting be highlighted separate?\r\n  // Does not include characters that will be output (such as `1.` and `-` for lists)\r\n  if (modeCfg.highlightFormatting === undefined)\r\n    modeCfg.highlightFormatting = false;\r\n\r\n  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.\r\n  // Excess `>` will emit `error` token.\r\n  if (modeCfg.maxBlockquoteDepth === undefined)\r\n    modeCfg.maxBlockquoteDepth = 0;\r\n\r\n  // Use `fencedCodeBlocks` to configure fenced code blocks. false to\r\n  // disable, string to specify a precise regexp that the fence should\r\n  // match, and true to allow three or more backticks or tildes (as\r\n  // per CommonMark).\r\n\r\n  // Turn on task lists? (\"- [ ] \" and \"- [x] \")\r\n  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;\r\n\r\n  // Turn on strikethrough syntax\r\n  if (modeCfg.strikethrough === undefined)\r\n    modeCfg.strikethrough = false;\r\n\r\n  // Allow token types to be overridden by user-provided token types.\r\n  if (modeCfg.tokenTypeOverrides === undefined)\r\n    modeCfg.tokenTypeOverrides = {};\r\n\r\n  var tokenTypes = {\r\n    header: \"header\",\r\n    code: \"comment\",\r\n    quote: \"quote\",\r\n    list1: \"variable-2\",\r\n    list2: \"variable-3\",\r\n    list3: \"keyword\",\r\n    hr: \"hr\",\r\n    image: \"image\",\r\n    imageAltText: \"image-alt-text\",\r\n    imageMarker: \"image-marker\",\r\n    formatting: \"formatting\",\r\n    linkInline: \"link\",\r\n    linkEmail: \"link\",\r\n    linkText: \"link\",\r\n    linkHref: \"string\",\r\n    em: \"em\",\r\n    strong: \"strong\",\r\n    strikethrough: \"strikethrough\"\r\n  };\r\n\r\n  for (var tokenType in tokenTypes) {\r\n    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {\r\n      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];\r\n    }\r\n  }\r\n\r\n  var hrRE = /^([*\\-_])(?:\\s*\\1){2,}\\s*$/\r\n  ,   listRE = /^(?:[*\\-+]|^[0-9]+([.)]))\\s+/\r\n  ,   taskListRE = /^\\[(x| )\\](?=\\s)/ // Must follow listRE\r\n  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/\r\n  ,   setextHeaderRE = /^ *(?:\\={1,}|-{1,})\\s*$/\r\n  ,   textRE = /^[^#!\\[\\]*_\\\\<>` \"'(~]+/\r\n  ,   fencedCodeRE = new RegExp(\"^(\" + (modeCfg.fencedCodeBlocks === true ? \"~~~+|```+\" : modeCfg.fencedCodeBlocks) +\r\n                                \")[ \\\\t]*([\\\\w+#\\-]*)\")\r\n  ,   punctuation = /[!\\\"#$%&\\'()*+,\\-\\.\\/:;<=>?@\\[\\\\\\]^_`{|}~—]/\r\n\r\n  function switchInline(stream, state, f) {\r\n    state.f = state.inline = f;\r\n    return f(stream, state);\r\n  }\r\n\r\n  function switchBlock(stream, state, f) {\r\n    state.f = state.block = f;\r\n    return f(stream, state);\r\n  }\r\n\r\n  function lineIsEmpty(line) {\r\n    return !line || !/\\S/.test(line.string)\r\n  }\r\n\r\n  // Blocks\r\n\r\n  function blankLine(state) {\r\n    // Reset linkTitle state\r\n    state.linkTitle = false;\r\n    // Reset EM state\r\n    state.em = false;\r\n    // Reset STRONG state\r\n    state.strong = false;\r\n    // Reset strikethrough state\r\n    state.strikethrough = false;\r\n    // Reset state.quote\r\n    state.quote = 0;\r\n    // Reset state.indentedCode\r\n    state.indentedCode = false;\r\n    if (state.f == htmlBlock) {\r\n      state.f = inlineNormal;\r\n      state.block = blockNormal;\r\n    }\r\n    // Reset state.trailingSpace\r\n    state.trailingSpace = 0;\r\n    state.trailingSpaceNewLine = false;\r\n    // Mark this line as blank\r\n    state.prevLine = state.thisLine\r\n    state.thisLine = null\r\n    return null;\r\n  }\r\n\r\n  function blockNormal(stream, state) {\r\n\r\n    var sol = stream.sol();\r\n\r\n    var prevLineIsList = state.list !== false,\r\n        prevLineIsIndentedCode = state.indentedCode;\r\n\r\n    state.indentedCode = false;\r\n\r\n    if (prevLineIsList) {\r\n      if (state.indentationDiff >= 0) { // Continued list\r\n        if (state.indentationDiff < 4) { // Only adjust indentation if *not* a code block\r\n          state.indentation -= state.indentationDiff;\r\n        }\r\n        state.list = null;\r\n      } else if (state.indentation > 0) {\r\n        state.list = null;\r\n      } else { // No longer a list\r\n        state.list = false;\r\n      }\r\n    }\r\n\r\n    var match = null;\r\n    if (state.indentationDiff >= 4) {\r\n      stream.skipToEnd();\r\n      if (prevLineIsIndentedCode || lineIsEmpty(state.prevLine)) {\r\n        state.indentation -= 4;\r\n        state.indentedCode = true;\r\n        return tokenTypes.code;\r\n      } else {\r\n        return null;\r\n      }\r\n    } else if (stream.eatSpace()) {\r\n      return null;\r\n    } else if ((match = stream.match(atxHeaderRE)) && match[1].length <= 6) {\r\n      state.header = match[1].length;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\r\n      state.f = state.inline;\r\n      return getType(state);\r\n    } else if (!lineIsEmpty(state.prevLine) && !state.quote && !prevLineIsList &&\r\n               !prevLineIsIndentedCode && (match = stream.match(setextHeaderRE))) {\r\n      state.header = match[0].charAt(0) == '=' ? 1 : 2;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\r\n      state.f = state.inline;\r\n      return getType(state);\r\n    } else if (stream.eat('>')) {\r\n      state.quote = sol ? 1 : state.quote + 1;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"quote\";\r\n      stream.eatSpace();\r\n      return getType(state);\r\n    } else if (stream.peek() === '[') {\r\n      return switchInline(stream, state, footnoteLink);\r\n    } else if (stream.match(hrRE, true)) {\r\n      state.hr = true;\r\n      return tokenTypes.hr;\r\n    } else if (match = stream.match(listRE)) {\r\n      var listType = match[1] ? \"ol\" : \"ul\";\r\n      state.indentation = stream.column() + stream.current().length;\r\n      state.list = true;\r\n\r\n      // While this list item's marker's indentation\r\n      // is less than the deepest list item's content's indentation,\r\n      // pop the deepest list item indentation off the stack.\r\n      while (state.listStack && stream.column() < state.listStack[state.listStack.length - 1]) {\r\n        state.listStack.pop();\r\n      }\r\n\r\n      // Add this list item's content's indentation to the stack\r\n      state.listStack.push(state.indentation);\r\n\r\n      if (modeCfg.taskLists && stream.match(taskListRE, false)) {\r\n        state.taskList = true;\r\n      }\r\n      state.f = state.inline;\r\n      if (modeCfg.highlightFormatting) state.formatting = [\"list\", \"list-\" + listType];\r\n      return getType(state);\r\n    } else if (modeCfg.fencedCodeBlocks && (match = stream.match(fencedCodeRE, true))) {\r\n      state.fencedChars = match[1]\r\n      // try switching mode\r\n      state.localMode = getMode(match[2]);\r\n      if (state.localMode) state.localState = CodeMirror.startState(state.localMode);\r\n      state.f = state.block = local;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\r\n      state.code = -1\r\n      return getType(state);\r\n    }\r\n\r\n    return switchInline(stream, state, state.inline);\r\n  }\r\n\r\n  function htmlBlock(stream, state) {\r\n    var style = htmlMode.token(stream, state.htmlState);\r\n    if (!htmlModeMissing) {\r\n      var inner = CodeMirror.innerMode(htmlMode, state.htmlState)\r\n      if ((inner.mode.name == \"xml\" && inner.state.tagStart === null &&\r\n           (!inner.state.context && inner.state.tokenize.isInText)) ||\r\n          (state.md_inside && stream.current().indexOf(\">\") > -1)) {\r\n        state.f = inlineNormal;\r\n        state.block = blockNormal;\r\n        state.htmlState = null;\r\n      }\r\n    }\r\n    return style;\r\n  }\r\n\r\n  function local(stream, state) {\r\n    if (state.fencedChars && stream.match(state.fencedChars)) {\r\n      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\r\n      var returnType = getType(state)\r\n      state.localMode = state.localState = null;\r\n      state.block = blockNormal;\r\n      state.f = inlineNormal;\r\n      state.fencedChars = null;\r\n      state.code = 0\r\n      return returnType;\r\n    } else if (state.fencedChars && stream.skipTo(state.fencedChars)) {\r\n      return \"comment\"\r\n    } else if (state.localMode) {\r\n      return state.localMode.token(stream, state.localState);\r\n    } else {\r\n      stream.skipToEnd();\r\n      return tokenTypes.code;\r\n    }\r\n  }\r\n\r\n  // Inline\r\n  function getType(state) {\r\n    var styles = [];\r\n\r\n    if (state.formatting) {\r\n      styles.push(tokenTypes.formatting);\r\n\r\n      if (typeof state.formatting === \"string\") state.formatting = [state.formatting];\r\n\r\n      for (var i = 0; i < state.formatting.length; i++) {\r\n        styles.push(tokenTypes.formatting + \"-\" + state.formatting[i]);\r\n\r\n        if (state.formatting[i] === \"header\") {\r\n          styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.header);\r\n        }\r\n\r\n        // Add `formatting-quote` and `formatting-quote-#` for blockquotes\r\n        // Add `error` instead if the maximum blockquote nesting depth is passed\r\n        if (state.formatting[i] === \"quote\") {\r\n          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\r\n            styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.quote);\r\n          } else {\r\n            styles.push(\"error\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (state.taskOpen) {\r\n      styles.push(\"meta\");\r\n      return styles.length ? styles.join(' ') : null;\r\n    }\r\n    if (state.taskClosed) {\r\n      styles.push(\"property\");\r\n      return styles.length ? styles.join(' ') : null;\r\n    }\r\n\r\n    if (state.linkHref) {\r\n      styles.push(tokenTypes.linkHref, \"url\");\r\n    } else { // Only apply inline styles to non-url text\r\n      if (state.strong) { styles.push(tokenTypes.strong); }\r\n      if (state.em) { styles.push(tokenTypes.em); }\r\n      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }\r\n      if (state.linkText) { styles.push(tokenTypes.linkText); }\r\n      if (state.code) { styles.push(tokenTypes.code); }\r\n      if (state.image) { styles.push(tokenTypes.image); }\r\n      if (state.imageAltText) { styles.push(tokenTypes.imageAltText, \"link\"); }\r\n      if (state.imageMarker) { styles.push(tokenTypes.imageMarker); }\r\n    }\r\n\r\n    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + \"-\" + state.header); }\r\n\r\n    if (state.quote) {\r\n      styles.push(tokenTypes.quote);\r\n\r\n      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth\r\n      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\r\n        styles.push(tokenTypes.quote + \"-\" + state.quote);\r\n      } else {\r\n        styles.push(tokenTypes.quote + \"-\" + modeCfg.maxBlockquoteDepth);\r\n      }\r\n    }\r\n\r\n    if (state.list !== false) {\r\n      var listMod = (state.listStack.length - 1) % 3;\r\n      if (!listMod) {\r\n        styles.push(tokenTypes.list1);\r\n      } else if (listMod === 1) {\r\n        styles.push(tokenTypes.list2);\r\n      } else {\r\n        styles.push(tokenTypes.list3);\r\n      }\r\n    }\r\n\r\n    if (state.trailingSpaceNewLine) {\r\n      styles.push(\"trailing-space-new-line\");\r\n    } else if (state.trailingSpace) {\r\n      styles.push(\"trailing-space-\" + (state.trailingSpace % 2 ? \"a\" : \"b\"));\r\n    }\r\n\r\n    return styles.length ? styles.join(' ') : null;\r\n  }\r\n\r\n  function handleText(stream, state) {\r\n    if (stream.match(textRE, true)) {\r\n      return getType(state);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  function inlineNormal(stream, state) {\r\n    var style = state.text(stream, state);\r\n    if (typeof style !== 'undefined')\r\n      return style;\r\n\r\n    if (state.list) { // List marker (*, +, -, 1., etc)\r\n      state.list = null;\r\n      return getType(state);\r\n    }\r\n\r\n    if (state.taskList) {\r\n      var taskOpen = stream.match(taskListRE, true)[1] !== \"x\";\r\n      if (taskOpen) state.taskOpen = true;\r\n      else state.taskClosed = true;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"task\";\r\n      state.taskList = false;\r\n      return getType(state);\r\n    }\r\n\r\n    state.taskOpen = false;\r\n    state.taskClosed = false;\r\n\r\n    if (state.header && stream.match(/^#+$/, true)) {\r\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\r\n      return getType(state);\r\n    }\r\n\r\n    var ch = stream.next();\r\n\r\n    // Matches link titles present on next line\r\n    if (state.linkTitle) {\r\n      state.linkTitle = false;\r\n      var matchCh = ch;\r\n      if (ch === '(') {\r\n        matchCh = ')';\r\n      }\r\n      matchCh = (matchCh+'').replace(/([.?*+^\\[\\]\\\\(){}|-])/g, \"\\\\$1\");\r\n      var regex = '^\\\\s*(?:[^' + matchCh + '\\\\\\\\]+|\\\\\\\\\\\\\\\\|\\\\\\\\.)' + matchCh;\r\n      if (stream.match(new RegExp(regex), true)) {\r\n        return tokenTypes.linkHref;\r\n      }\r\n    }\r\n\r\n    // If this block is changed, it may need to be updated in GFM mode\r\n    if (ch === '`') {\r\n      var previousFormatting = state.formatting;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"code\";\r\n      stream.eatWhile('`');\r\n      var count = stream.current().length\r\n      if (state.code == 0) {\r\n        state.code = count\r\n        return getType(state)\r\n      } else if (count == state.code) { // Must be exact\r\n        var t = getType(state)\r\n        state.code = 0\r\n        return t\r\n      } else {\r\n        state.formatting = previousFormatting\r\n        return getType(state)\r\n      }\r\n    } else if (state.code) {\r\n      return getType(state);\r\n    }\r\n\r\n    if (ch === '\\\\') {\r\n      stream.next();\r\n      if (modeCfg.highlightFormatting) {\r\n        var type = getType(state);\r\n        var formattingEscape = tokenTypes.formatting + \"-escape\";\r\n        return type ? type + \" \" + formattingEscape : formattingEscape;\r\n      }\r\n    }\r\n\r\n    if (ch === '!' && stream.match(/\\[[^\\]]*\\] ?(?:\\(|\\[)/, false)) {\r\n      state.imageMarker = true;\r\n      state.image = true;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\r\n      return getType(state);\r\n    }\r\n\r\n    if (ch === '[' && state.imageMarker && stream.match(/[^\\]]*\\](\\(.*?\\)| ?\\[.*?\\])/, false)) {\r\n      state.imageMarker = false;\r\n      state.imageAltText = true\r\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\r\n      return getType(state);\r\n    }\r\n\r\n    if (ch === ']' && state.imageAltText) {\r\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\r\n      var type = getType(state);\r\n      state.imageAltText = false;\r\n      state.image = false;\r\n      state.inline = state.f = linkHref;\r\n      return type;\r\n    }\r\n\r\n    if (ch === '[' && !state.image) {\r\n      state.linkText = true;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      return getType(state);\r\n    }\r\n\r\n    if (ch === ']' && state.linkText) {\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var type = getType(state);\r\n      state.linkText = false;\r\n      state.inline = state.f = stream.match(/\\(.*?\\)| ?\\[.*?\\]/, false) ? linkHref : inlineNormal\r\n      return type;\r\n    }\r\n\r\n    if (ch === '<' && stream.match(/^(https?|ftps?):\\/\\/(?:[^\\\\>]|\\\\.)+>/, false)) {\r\n      state.f = state.inline = linkInline;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var type = getType(state);\r\n      if (type){\r\n        type += \" \";\r\n      } else {\r\n        type = \"\";\r\n      }\r\n      return type + tokenTypes.linkInline;\r\n    }\r\n\r\n    if (ch === '<' && stream.match(/^[^> \\\\]+@(?:[^\\\\>]|\\\\.)+>/, false)) {\r\n      state.f = state.inline = linkInline;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var type = getType(state);\r\n      if (type){\r\n        type += \" \";\r\n      } else {\r\n        type = \"\";\r\n      }\r\n      return type + tokenTypes.linkEmail;\r\n    }\r\n\r\n    if (ch === '<' && stream.match(/^(!--|[a-z]+(?:\\s+[a-z_:.\\-]+(?:\\s*=\\s*[^ >]+)?)*\\s*>)/i, false)) {\r\n      var end = stream.string.indexOf(\">\", stream.pos);\r\n      if (end != -1) {\r\n        var atts = stream.string.substring(stream.start, end);\r\n        if (/markdown\\s*=\\s*('|\"){0,1}1('|\"){0,1}/.test(atts)) state.md_inside = true;\r\n      }\r\n      stream.backUp(1);\r\n      state.htmlState = CodeMirror.startState(htmlMode);\r\n      return switchBlock(stream, state, htmlBlock);\r\n    }\r\n\r\n    if (ch === '<' && stream.match(/^\\/\\w*?>/)) {\r\n      state.md_inside = false;\r\n      return \"tag\";\r\n    } else if (ch === \"*\" || ch === \"_\") {\r\n      var len = 1, before = stream.pos == 1 ? \" \" : stream.string.charAt(stream.pos - 2)\r\n      while (len < 3 && stream.eat(ch)) len++\r\n      var after = stream.peek() || \" \"\r\n      // See http://spec.commonmark.org/0.27/#emphasis-and-strong-emphasis\r\n      var leftFlanking = !/\\s/.test(after) && (!punctuation.test(after) || /\\s/.test(before) || punctuation.test(before))\r\n      var rightFlanking = !/\\s/.test(before) && (!punctuation.test(before) || /\\s/.test(after) || punctuation.test(after))\r\n      var setEm = null, setStrong = null\r\n      if (len % 2) { // Em\r\n        if (!state.em && leftFlanking && (ch === \"*\" || !rightFlanking || punctuation.test(before)))\r\n          setEm = true\r\n        else if (state.em == ch && rightFlanking && (ch === \"*\" || !leftFlanking || punctuation.test(after)))\r\n          setEm = false\r\n      }\r\n      if (len > 1) { // Strong\r\n        if (!state.strong && leftFlanking && (ch === \"*\" || !rightFlanking || punctuation.test(before)))\r\n          setStrong = true\r\n        else if (state.strong == ch && rightFlanking && (ch === \"*\" || !leftFlanking || punctuation.test(after)))\r\n          setStrong = false\r\n      }\r\n      if (setStrong != null || setEm != null) {\r\n        if (modeCfg.highlightFormatting) state.formatting = setEm == null ? \"strong\" : setStrong == null ? \"em\" : \"strong em\"\r\n        if (setEm === true) state.em = ch\r\n        if (setStrong === true) state.strong = ch\r\n        var t = getType(state)\r\n        if (setEm === false) state.em = false\r\n        if (setStrong === false) state.strong = false\r\n        return t\r\n      }\r\n    } else if (ch === ' ') {\r\n      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces\r\n        if (stream.peek() === ' ') { // Surrounded by spaces, ignore\r\n          return getType(state);\r\n        } else { // Not surrounded by spaces, back up pointer\r\n          stream.backUp(1);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (modeCfg.strikethrough) {\r\n      if (ch === '~' && stream.eatWhile(ch)) {\r\n        if (state.strikethrough) {// Remove strikethrough\r\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\r\n          var t = getType(state);\r\n          state.strikethrough = false;\r\n          return t;\r\n        } else if (stream.match(/^[^\\s]/, false)) {// Add strikethrough\r\n          state.strikethrough = true;\r\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\r\n          return getType(state);\r\n        }\r\n      } else if (ch === ' ') {\r\n        if (stream.match(/^~~/, true)) { // Probably surrounded by space\r\n          if (stream.peek() === ' ') { // Surrounded by spaces, ignore\r\n            return getType(state);\r\n          } else { // Not surrounded by spaces, back up pointer\r\n            stream.backUp(2);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (ch === ' ') {\r\n      if (stream.match(/ +$/, false)) {\r\n        state.trailingSpace++;\r\n      } else if (state.trailingSpace) {\r\n        state.trailingSpaceNewLine = true;\r\n      }\r\n    }\r\n\r\n    return getType(state);\r\n  }\r\n\r\n  function linkInline(stream, state) {\r\n    var ch = stream.next();\r\n\r\n    if (ch === \">\") {\r\n      state.f = state.inline = inlineNormal;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var type = getType(state);\r\n      if (type){\r\n        type += \" \";\r\n      } else {\r\n        type = \"\";\r\n      }\r\n      return type + tokenTypes.linkInline;\r\n    }\r\n\r\n    stream.match(/^[^>]+/, true);\r\n\r\n    return tokenTypes.linkInline;\r\n  }\r\n\r\n  function linkHref(stream, state) {\r\n    // Check if space, and return NULL if so (to avoid marking the space)\r\n    if(stream.eatSpace()){\r\n      return null;\r\n    }\r\n    var ch = stream.next();\r\n    if (ch === '(' || ch === '[') {\r\n      state.f = state.inline = getLinkHrefInside(ch === \"(\" ? \")\" : \"]\");\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\r\n      state.linkHref = true;\r\n      return getType(state);\r\n    }\r\n    return 'error';\r\n  }\r\n\r\n  var linkRE = {\r\n    \")\": /^(?:[^\\\\\\(\\)]|\\\\.|\\((?:[^\\\\\\(\\)]|\\\\.)*\\))*?(?=\\))/,\r\n    \"]\": /^(?:[^\\\\\\[\\]]|\\\\.|\\[(?:[^\\\\\\[\\]]|\\\\.)*\\])*?(?=\\])/\r\n  }\r\n\r\n  function getLinkHrefInside(endChar) {\r\n    return function(stream, state) {\r\n      var ch = stream.next();\r\n\r\n      if (ch === endChar) {\r\n        state.f = state.inline = inlineNormal;\r\n        if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\r\n        var returnState = getType(state);\r\n        state.linkHref = false;\r\n        return returnState;\r\n      }\r\n\r\n      stream.match(linkRE[endChar])\r\n      state.linkHref = true;\r\n      return getType(state);\r\n    };\r\n  }\r\n\r\n  function footnoteLink(stream, state) {\r\n    if (stream.match(/^([^\\]\\\\]|\\\\.)*\\]:/, false)) {\r\n      state.f = footnoteLinkInside;\r\n      stream.next(); // Consume [\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      state.linkText = true;\r\n      return getType(state);\r\n    }\r\n    return switchInline(stream, state, inlineNormal);\r\n  }\r\n\r\n  function footnoteLinkInside(stream, state) {\r\n    if (stream.match(/^\\]:/, true)) {\r\n      state.f = state.inline = footnoteUrl;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var returnType = getType(state);\r\n      state.linkText = false;\r\n      return returnType;\r\n    }\r\n\r\n    stream.match(/^([^\\]\\\\]|\\\\.)+/, true);\r\n\r\n    return tokenTypes.linkText;\r\n  }\r\n\r\n  function footnoteUrl(stream, state) {\r\n    // Check if space, and return NULL if so (to avoid marking the space)\r\n    if(stream.eatSpace()){\r\n      return null;\r\n    }\r\n    // Match URL\r\n    stream.match(/^[^\\s]+/, true);\r\n    // Check for link title\r\n    if (stream.peek() === undefined) { // End of line, set flag to check next line\r\n      state.linkTitle = true;\r\n    } else { // More content on line, check if link title\r\n      stream.match(/^(?:\\s+(?:\"(?:[^\"\\\\]|\\\\\\\\|\\\\.)+\"|'(?:[^'\\\\]|\\\\\\\\|\\\\.)+'|\\((?:[^)\\\\]|\\\\\\\\|\\\\.)+\\)))?/, true);\r\n    }\r\n    state.f = state.inline = inlineNormal;\r\n    return tokenTypes.linkHref + \" url\";\r\n  }\r\n\r\n  var mode = {\r\n    startState: function() {\r\n      return {\r\n        f: blockNormal,\r\n\r\n        prevLine: null,\r\n        thisLine: null,\r\n\r\n        block: blockNormal,\r\n        htmlState: null,\r\n        indentation: 0,\r\n\r\n        inline: inlineNormal,\r\n        text: handleText,\r\n\r\n        formatting: false,\r\n        linkText: false,\r\n        linkHref: false,\r\n        linkTitle: false,\r\n        code: 0,\r\n        em: false,\r\n        strong: false,\r\n        header: 0,\r\n        hr: false,\r\n        taskList: false,\r\n        list: false,\r\n        listStack: [],\r\n        quote: 0,\r\n        trailingSpace: 0,\r\n        trailingSpaceNewLine: false,\r\n        strikethrough: false,\r\n        fencedChars: null\r\n      };\r\n    },\r\n\r\n    copyState: function(s) {\r\n      return {\r\n        f: s.f,\r\n\r\n        prevLine: s.prevLine,\r\n        thisLine: s.thisLine,\r\n\r\n        block: s.block,\r\n        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),\r\n        indentation: s.indentation,\r\n\r\n        localMode: s.localMode,\r\n        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,\r\n\r\n        inline: s.inline,\r\n        text: s.text,\r\n        formatting: false,\r\n        linkText: s.linkText,\r\n        linkTitle: s.linkTitle,\r\n        code: s.code,\r\n        em: s.em,\r\n        strong: s.strong,\r\n        strikethrough: s.strikethrough,\r\n        header: s.header,\r\n        hr: s.hr,\r\n        taskList: s.taskList,\r\n        list: s.list,\r\n        listStack: s.listStack.slice(0),\r\n        quote: s.quote,\r\n        indentedCode: s.indentedCode,\r\n        trailingSpace: s.trailingSpace,\r\n        trailingSpaceNewLine: s.trailingSpaceNewLine,\r\n        md_inside: s.md_inside,\r\n        fencedChars: s.fencedChars\r\n      };\r\n    },\r\n\r\n    token: function(stream, state) {\r\n\r\n      // Reset state.formatting\r\n      state.formatting = false;\r\n\r\n      if (stream != state.thisLine) {\r\n        var forceBlankLine = state.header || state.hr;\r\n\r\n        // Reset state.header and state.hr\r\n        state.header = 0;\r\n        state.hr = false;\r\n\r\n        if (stream.match(/^\\s*$/, true) || forceBlankLine) {\r\n          blankLine(state);\r\n          if (!forceBlankLine) return null\r\n          state.prevLine = null\r\n        }\r\n\r\n        state.prevLine = state.thisLine\r\n        state.thisLine = stream\r\n\r\n        // Reset state.taskList\r\n        state.taskList = false;\r\n\r\n        // Reset state.trailingSpace\r\n        state.trailingSpace = 0;\r\n        state.trailingSpaceNewLine = false;\r\n\r\n        state.f = state.block;\r\n        var indentation = stream.match(/^\\s*/, true)[0].replace(/\\t/g, '    ').length;\r\n        state.indentationDiff = Math.min(indentation - state.indentation, 4);\r\n        state.indentation = state.indentation + state.indentationDiff;\r\n        if (indentation > 0) return null;\r\n      }\r\n      return state.f(stream, state);\r\n    },\r\n\r\n    innerMode: function(state) {\r\n      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};\r\n      if (state.localState) return {state: state.localState, mode: state.localMode};\r\n      return {state: state, mode: mode};\r\n    },\r\n\r\n    blankLine: blankLine,\r\n\r\n    getType: getType,\r\n\r\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\r\n    fold: \"markdown\"\r\n  };\r\n  return mode;\r\n}, \"xml\");\r\n\r\nCodeMirror.defineMIME(\"text/x-markdown\", \"markdown\");\r\n\r\n});\r\n\n\n/***/ }),\n\n/***/ 961:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (true) // CommonJS\r\n    mod(__webpack_require__(877));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n\"use strict\";\r\n\r\nvar htmlConfig = {\r\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\r\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\r\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\r\n                    'track': true, 'wbr': true, 'menuitem': true},\r\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\r\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\r\n                     'th': true, 'tr': true},\r\n  contextGrabbers: {\r\n    'dd': {'dd': true, 'dt': true},\r\n    'dt': {'dd': true, 'dt': true},\r\n    'li': {'li': true},\r\n    'option': {'option': true, 'optgroup': true},\r\n    'optgroup': {'optgroup': true},\r\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\r\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\r\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\r\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\r\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\r\n    'rp': {'rp': true, 'rt': true},\r\n    'rt': {'rp': true, 'rt': true},\r\n    'tbody': {'tbody': true, 'tfoot': true},\r\n    'td': {'td': true, 'th': true},\r\n    'tfoot': {'tbody': true},\r\n    'th': {'td': true, 'th': true},\r\n    'thead': {'tbody': true, 'tfoot': true},\r\n    'tr': {'tr': true}\r\n  },\r\n  doNotIndent: {\"pre\": true},\r\n  allowUnquoted: true,\r\n  allowMissing: true,\r\n  caseFold: true\r\n}\r\n\r\nvar xmlConfig = {\r\n  autoSelfClosers: {},\r\n  implicitlyClosed: {},\r\n  contextGrabbers: {},\r\n  doNotIndent: {},\r\n  allowUnquoted: false,\r\n  allowMissing: false,\r\n  caseFold: false\r\n}\r\n\r\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\r\n  var indentUnit = editorConf.indentUnit\r\n  var config = {}\r\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\r\n  for (var prop in defaults) config[prop] = defaults[prop]\r\n  for (var prop in config_) config[prop] = config_[prop]\r\n\r\n  // Return variables for tokenizers\r\n  var type, setStyle;\r\n\r\n  function inText(stream, state) {\r\n    function chain(parser) {\r\n      state.tokenize = parser;\r\n      return parser(stream, state);\r\n    }\r\n\r\n    var ch = stream.next();\r\n    if (ch == \"<\") {\r\n      if (stream.eat(\"!\")) {\r\n        if (stream.eat(\"[\")) {\r\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\r\n          else return null;\r\n        } else if (stream.match(\"--\")) {\r\n          return chain(inBlock(\"comment\", \"-->\"));\r\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\r\n          stream.eatWhile(/[\\w\\._\\-]/);\r\n          return chain(doctype(1));\r\n        } else {\r\n          return null;\r\n        }\r\n      } else if (stream.eat(\"?\")) {\r\n        stream.eatWhile(/[\\w\\._\\-]/);\r\n        state.tokenize = inBlock(\"meta\", \"?>\");\r\n        return \"meta\";\r\n      } else {\r\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\r\n        state.tokenize = inTag;\r\n        return \"tag bracket\";\r\n      }\r\n    } else if (ch == \"&\") {\r\n      var ok;\r\n      if (stream.eat(\"#\")) {\r\n        if (stream.eat(\"x\")) {\r\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\r\n        } else {\r\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\r\n        }\r\n      } else {\r\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\r\n      }\r\n      return ok ? \"atom\" : \"error\";\r\n    } else {\r\n      stream.eatWhile(/[^&<]/);\r\n      return null;\r\n    }\r\n  }\r\n  inText.isInText = true;\r\n\r\n  function inTag(stream, state) {\r\n    var ch = stream.next();\r\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\r\n      state.tokenize = inText;\r\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\r\n      return \"tag bracket\";\r\n    } else if (ch == \"=\") {\r\n      type = \"equals\";\r\n      return null;\r\n    } else if (ch == \"<\") {\r\n      state.tokenize = inText;\r\n      state.state = baseState;\r\n      state.tagName = state.tagStart = null;\r\n      var next = state.tokenize(stream, state);\r\n      return next ? next + \" tag error\" : \"tag error\";\r\n    } else if (/[\\'\\\"]/.test(ch)) {\r\n      state.tokenize = inAttribute(ch);\r\n      state.stringStartCol = stream.column();\r\n      return state.tokenize(stream, state);\r\n    } else {\r\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\r\n      return \"word\";\r\n    }\r\n  }\r\n\r\n  function inAttribute(quote) {\r\n    var closure = function(stream, state) {\r\n      while (!stream.eol()) {\r\n        if (stream.next() == quote) {\r\n          state.tokenize = inTag;\r\n          break;\r\n        }\r\n      }\r\n      return \"string\";\r\n    };\r\n    closure.isInAttribute = true;\r\n    return closure;\r\n  }\r\n\r\n  function inBlock(style, terminator) {\r\n    return function(stream, state) {\r\n      while (!stream.eol()) {\r\n        if (stream.match(terminator)) {\r\n          state.tokenize = inText;\r\n          break;\r\n        }\r\n        stream.next();\r\n      }\r\n      return style;\r\n    };\r\n  }\r\n  function doctype(depth) {\r\n    return function(stream, state) {\r\n      var ch;\r\n      while ((ch = stream.next()) != null) {\r\n        if (ch == \"<\") {\r\n          state.tokenize = doctype(depth + 1);\r\n          return state.tokenize(stream, state);\r\n        } else if (ch == \">\") {\r\n          if (depth == 1) {\r\n            state.tokenize = inText;\r\n            break;\r\n          } else {\r\n            state.tokenize = doctype(depth - 1);\r\n            return state.tokenize(stream, state);\r\n          }\r\n        }\r\n      }\r\n      return \"meta\";\r\n    };\r\n  }\r\n\r\n  function Context(state, tagName, startOfLine) {\r\n    this.prev = state.context;\r\n    this.tagName = tagName;\r\n    this.indent = state.indented;\r\n    this.startOfLine = startOfLine;\r\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\r\n      this.noIndent = true;\r\n  }\r\n  function popContext(state) {\r\n    if (state.context) state.context = state.context.prev;\r\n  }\r\n  function maybePopContext(state, nextTagName) {\r\n    var parentTagName;\r\n    while (true) {\r\n      if (!state.context) {\r\n        return;\r\n      }\r\n      parentTagName = state.context.tagName;\r\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\r\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\r\n        return;\r\n      }\r\n      popContext(state);\r\n    }\r\n  }\r\n\r\n  function baseState(type, stream, state) {\r\n    if (type == \"openTag\") {\r\n      state.tagStart = stream.column();\r\n      return tagNameState;\r\n    } else if (type == \"closeTag\") {\r\n      return closeTagNameState;\r\n    } else {\r\n      return baseState;\r\n    }\r\n  }\r\n  function tagNameState(type, stream, state) {\r\n    if (type == \"word\") {\r\n      state.tagName = stream.current();\r\n      setStyle = \"tag\";\r\n      return attrState;\r\n    } else {\r\n      setStyle = \"error\";\r\n      return tagNameState;\r\n    }\r\n  }\r\n  function closeTagNameState(type, stream, state) {\r\n    if (type == \"word\") {\r\n      var tagName = stream.current();\r\n      if (state.context && state.context.tagName != tagName &&\r\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\r\n        popContext(state);\r\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\r\n        setStyle = \"tag\";\r\n        return closeState;\r\n      } else {\r\n        setStyle = \"tag error\";\r\n        return closeStateErr;\r\n      }\r\n    } else {\r\n      setStyle = \"error\";\r\n      return closeStateErr;\r\n    }\r\n  }\r\n\r\n  function closeState(type, _stream, state) {\r\n    if (type != \"endTag\") {\r\n      setStyle = \"error\";\r\n      return closeState;\r\n    }\r\n    popContext(state);\r\n    return baseState;\r\n  }\r\n  function closeStateErr(type, stream, state) {\r\n    setStyle = \"error\";\r\n    return closeState(type, stream, state);\r\n  }\r\n\r\n  function attrState(type, _stream, state) {\r\n    if (type == \"word\") {\r\n      setStyle = \"attribute\";\r\n      return attrEqState;\r\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\r\n      var tagName = state.tagName, tagStart = state.tagStart;\r\n      state.tagName = state.tagStart = null;\r\n      if (type == \"selfcloseTag\" ||\r\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\r\n        maybePopContext(state, tagName);\r\n      } else {\r\n        maybePopContext(state, tagName);\r\n        state.context = new Context(state, tagName, tagStart == state.indented);\r\n      }\r\n      return baseState;\r\n    }\r\n    setStyle = \"error\";\r\n    return attrState;\r\n  }\r\n  function attrEqState(type, stream, state) {\r\n    if (type == \"equals\") return attrValueState;\r\n    if (!config.allowMissing) setStyle = \"error\";\r\n    return attrState(type, stream, state);\r\n  }\r\n  function attrValueState(type, stream, state) {\r\n    if (type == \"string\") return attrContinuedState;\r\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\r\n    setStyle = \"error\";\r\n    return attrState(type, stream, state);\r\n  }\r\n  function attrContinuedState(type, stream, state) {\r\n    if (type == \"string\") return attrContinuedState;\r\n    return attrState(type, stream, state);\r\n  }\r\n\r\n  return {\r\n    startState: function(baseIndent) {\r\n      var state = {tokenize: inText,\r\n                   state: baseState,\r\n                   indented: baseIndent || 0,\r\n                   tagName: null, tagStart: null,\r\n                   context: null}\r\n      if (baseIndent != null) state.baseIndent = baseIndent\r\n      return state\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      if (!state.tagName && stream.sol())\r\n        state.indented = stream.indentation();\r\n\r\n      if (stream.eatSpace()) return null;\r\n      type = null;\r\n      var style = state.tokenize(stream, state);\r\n      if ((style || type) && style != \"comment\") {\r\n        setStyle = null;\r\n        state.state = state.state(type || style, stream, state);\r\n        if (setStyle)\r\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\r\n      }\r\n      return style;\r\n    },\r\n\r\n    indent: function(state, textAfter, fullLine) {\r\n      var context = state.context;\r\n      // Indent multi-line strings (e.g. css).\r\n      if (state.tokenize.isInAttribute) {\r\n        if (state.tagStart == state.indented)\r\n          return state.stringStartCol + 1;\r\n        else\r\n          return state.indented + indentUnit;\r\n      }\r\n      if (context && context.noIndent) return CodeMirror.Pass;\r\n      if (state.tokenize != inTag && state.tokenize != inText)\r\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\r\n      // Indent the starts of attribute names.\r\n      if (state.tagName) {\r\n        if (config.multilineTagIndentPastTag !== false)\r\n          return state.tagStart + state.tagName.length + 2;\r\n        else\r\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\r\n      }\r\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\r\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\r\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\r\n        while (context) {\r\n          if (context.tagName == tagAfter[2]) {\r\n            context = context.prev;\r\n            break;\r\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\r\n            context = context.prev;\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n      } else if (tagAfter) { // Opening tag spotted\r\n        while (context) {\r\n          var grabbers = config.contextGrabbers[context.tagName];\r\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\r\n            context = context.prev;\r\n          else\r\n            break;\r\n        }\r\n      }\r\n      while (context && context.prev && !context.startOfLine)\r\n        context = context.prev;\r\n      if (context) return context.indent + indentUnit;\r\n      else return state.baseIndent || 0;\r\n    },\r\n\r\n    electricInput: /<\\/[\\s\\w:]+>$/,\r\n    blockCommentStart: \"<!--\",\r\n    blockCommentEnd: \"-->\",\r\n\r\n    configuration: config.htmlMode ? \"html\" : \"xml\",\r\n    helperType: config.htmlMode ? \"html\" : \"xml\",\r\n\r\n    skipAttribute: function(state) {\r\n      if (state.state == attrValueState)\r\n        state.state = attrState\r\n    }\r\n  };\r\n});\r\n\r\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\r\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\r\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\r\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\r\n\r\n});\r\n\n\n/***/ }),\n\n/***/ 968:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_simplemde_dist_simplemde_min_css__ = __webpack_require__(1180);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_simplemde_dist_simplemde_min_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_simplemde_dist_simplemde_min_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_simplemde__ = __webpack_require__(1282);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_simplemde___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_simplemde__);\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'Sticky',\n  props: {\n    value: String,\n    id: {\n      type: String,\n      default: 'markdown-editor'\n    },\n    autofocus: {\n      type: Boolean,\n      default: false\n    },\n    placeholder: {\n      type: String,\n      default: ''\n    },\n    height: {\n      type: Number,\n      default: 150\n    },\n    zIndex: {\n      type: Number,\n      default: 10\n    },\n    toolbar: {\n      type: Array\n    }\n  },\n  data: function data() {\n    return {\n      simplemde: null,\n      hasChange: false\n    };\n  },\n\n  watch: {\n    value: function value(val) {\n      if (val === this.simplemde.value() && !this.hasChange) return;\n      this.simplemde.value(val);\n    }\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.simplemde = new __WEBPACK_IMPORTED_MODULE_1_simplemde___default.a({\n      element: document.getElementById(this.id),\n      autofocus: this.autofocus,\n      toolbar: this.toolbar,\n      spellChecker: false,\n      insertTexts: {\n        link: ['[', ']( )']\n      },\n\n      placeholder: this.placeholder\n    });\n    if (this.value) {\n      this.simplemde.value(this.value);\n    }\n    this.simplemde.codemirror.on('change', function () {\n      if (_this.hasChange) {\n        _this.hasChange = true;\n      }\n      _this.$emit('input', _this.simplemde.value());\n    });\n  },\n  destroyed: function destroyed() {\n    this.simplemde = null;\n  }\n});\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/18.62c8ddde412edea93a7e.js","<template>\r\n  <div class=\"components-container\">\r\n    <code>Markdown 我们这里选用了 <a href=\"https://github.com/sparksuite/simplemde-markdown-editor\" target=\"_blank\">simplemde-markdown-editor</a> ，简单的用vue封装了一下<a target='_blank' href='https://segmentfault.com/a/1190000009762198#articleHeader14'> 相关文章 </a></code>\r\n    <div class=\"editor-container\">\r\n      <md-editor id='contentEditor' ref=\"contentEditor\" v-model='content' :height=\"300\" :zIndex='20'></md-editor>\r\n    </div>\r\n    <el-button @click='markdown2Html' style=\"margin-top:80px;\" type=\"primary\">转为HTML<i class=\"el-icon-document el-icon--right\"></i></el-button>\r\n    <div v-html=\"html\"></div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  import MdEditor from 'components/MdEditor';\r\n  export default {\r\n    components: { MdEditor },\r\n    data() {\r\n      return {\r\n        content: '## Simplemde',\r\n        html: ''\r\n      }\r\n    },\r\n    methods: {\r\n      markdown2Html() {\r\n        import('showdown').then(showdown => {\r\n          const converter = new showdown.Converter();\r\n          this.html = converter.makeHtml(this.content)\r\n        })\r\n      }\r\n    }\r\n  };\r\n</script>\r\n\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// markdown.vue?3535611b","// Use strict mode (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)\r\n\"use strict\";\r\n\r\n\r\n// Requires\r\nvar Typo = require(\"typo-js\");\r\n\r\n\r\n// Create function\r\nfunction CodeMirrorSpellChecker(options) {\r\n\t// Initialize\r\n\toptions = options || {};\r\n\r\n\r\n\t// Verify\r\n\tif(typeof options.codeMirrorInstance !== \"function\" || typeof options.codeMirrorInstance.defineMode !== \"function\") {\r\n\t\tconsole.log(\"CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`\");\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\t// Because some browsers don't support this functionality yet\r\n\tif(!String.prototype.includes) {\r\n\t\tString.prototype.includes = function() {\r\n\t\t\t\"use strict\";\r\n\t\t\treturn String.prototype.indexOf.apply(this, arguments) !== -1;\r\n\t\t};\r\n\t}\r\n\r\n\r\n\t// Define the new mode\r\n\toptions.codeMirrorInstance.defineMode(\"spell-checker\", function(config) {\r\n\t\t// Load AFF/DIC data\r\n\t\tif(!CodeMirrorSpellChecker.aff_loading) {\r\n\t\t\tCodeMirrorSpellChecker.aff_loading = true;\r\n\t\t\tvar xhr_aff = new XMLHttpRequest();\r\n\t\t\txhr_aff.open(\"GET\", \"https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff\", true);\r\n\t\t\txhr_aff.onload = function() {\r\n\t\t\t\tif(xhr_aff.readyState === 4 && xhr_aff.status === 200) {\r\n\t\t\t\t\tCodeMirrorSpellChecker.aff_data = xhr_aff.responseText;\r\n\t\t\t\t\tCodeMirrorSpellChecker.num_loaded++;\r\n\r\n\t\t\t\t\tif(CodeMirrorSpellChecker.num_loaded == 2) {\r\n\t\t\t\t\t\tCodeMirrorSpellChecker.typo = new Typo(\"en_US\", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {\r\n\t\t\t\t\t\t\tplatform: \"any\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\txhr_aff.send(null);\r\n\t\t}\r\n\r\n\t\tif(!CodeMirrorSpellChecker.dic_loading) {\r\n\t\t\tCodeMirrorSpellChecker.dic_loading = true;\r\n\t\t\tvar xhr_dic = new XMLHttpRequest();\r\n\t\t\txhr_dic.open(\"GET\", \"https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic\", true);\r\n\t\t\txhr_dic.onload = function() {\r\n\t\t\t\tif(xhr_dic.readyState === 4 && xhr_dic.status === 200) {\r\n\t\t\t\t\tCodeMirrorSpellChecker.dic_data = xhr_dic.responseText;\r\n\t\t\t\t\tCodeMirrorSpellChecker.num_loaded++;\r\n\r\n\t\t\t\t\tif(CodeMirrorSpellChecker.num_loaded == 2) {\r\n\t\t\t\t\t\tCodeMirrorSpellChecker.typo = new Typo(\"en_US\", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {\r\n\t\t\t\t\t\t\tplatform: \"any\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\txhr_dic.send(null);\r\n\t\t}\r\n\r\n\r\n\t\t// Define what separates a word\r\n\t\tvar rx_word = \"!\\\"#$%&()*+,-./:;<=>?@[\\\\]^_`{|}~ \";\r\n\r\n\r\n\t\t// Create the overlay and such\r\n\t\tvar overlay = {\r\n\t\t\ttoken: function(stream) {\r\n\t\t\t\tvar ch = stream.peek();\r\n\t\t\t\tvar word = \"\";\r\n\r\n\t\t\t\tif(rx_word.includes(ch)) {\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhile((ch = stream.peek()) != null && !rx_word.includes(ch)) {\r\n\t\t\t\t\tword += ch;\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(CodeMirrorSpellChecker.typo && !CodeMirrorSpellChecker.typo.check(word))\r\n\t\t\t\t\treturn \"spell-error\"; // CSS class: cm-spell-error\r\n\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar mode = options.codeMirrorInstance.getMode(\r\n\t\t\tconfig, config.backdrop || \"text/plain\"\r\n\t\t);\r\n\r\n\t\treturn options.codeMirrorInstance.overlayMode(mode, overlay, true);\r\n\t});\r\n}\r\n\r\n\r\n// Initialize data globally to reduce memory consumption\r\nCodeMirrorSpellChecker.num_loaded = 0;\r\nCodeMirrorSpellChecker.aff_loading = false;\r\nCodeMirrorSpellChecker.dic_loading = false;\r\nCodeMirrorSpellChecker.aff_data = \"\";\r\nCodeMirrorSpellChecker.dic_data = \"\";\r\nCodeMirrorSpellChecker.typo;\r\n\r\n\r\n// Export\r\nmodule.exports = CodeMirrorSpellChecker;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror-spell-checker/src/js/spell-checker.js\n// module id = 1070\n// module chunks = 18","// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\r\n    mod(require(\"../../lib/codemirror\"));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  CodeMirror.defineOption(\"fullScreen\", false, function(cm, val, old) {\r\n    if (old == CodeMirror.Init) old = false;\r\n    if (!old == !val) return;\r\n    if (val) setFullscreen(cm);\r\n    else setNormal(cm);\r\n  });\r\n\r\n  function setFullscreen(cm) {\r\n    var wrap = cm.getWrapperElement();\r\n    cm.state.fullScreenRestore = {scrollTop: window.pageYOffset, scrollLeft: window.pageXOffset,\r\n                                  width: wrap.style.width, height: wrap.style.height};\r\n    wrap.style.width = \"\";\r\n    wrap.style.height = \"auto\";\r\n    wrap.className += \" CodeMirror-fullscreen\";\r\n    document.documentElement.style.overflow = \"hidden\";\r\n    cm.refresh();\r\n  }\r\n\r\n  function setNormal(cm) {\r\n    var wrap = cm.getWrapperElement();\r\n    wrap.className = wrap.className.replace(/\\s*CodeMirror-fullscreen\\b/, \"\");\r\n    document.documentElement.style.overflow = \"\";\r\n    var info = cm.state.fullScreenRestore;\r\n    wrap.style.width = info.width; wrap.style.height = info.height;\r\n    window.scrollTo(info.scrollLeft, info.scrollTop);\r\n    cm.refresh();\r\n  }\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/display/fullscreen.js\n// module id = 1071\n// module chunks = 18","// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\r\n    mod(require(\"../../lib/codemirror\"));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  CodeMirror.defineOption(\"placeholder\", \"\", function(cm, val, old) {\r\n    var prev = old && old != CodeMirror.Init;\r\n    if (val && !prev) {\r\n      cm.on(\"blur\", onBlur);\r\n      cm.on(\"change\", onChange);\r\n      cm.on(\"swapDoc\", onChange);\r\n      onChange(cm);\r\n    } else if (!val && prev) {\r\n      cm.off(\"blur\", onBlur);\r\n      cm.off(\"change\", onChange);\r\n      cm.off(\"swapDoc\", onChange);\r\n      clearPlaceholder(cm);\r\n      var wrapper = cm.getWrapperElement();\r\n      wrapper.className = wrapper.className.replace(\" CodeMirror-empty\", \"\");\r\n    }\r\n\r\n    if (val && !cm.hasFocus()) onBlur(cm);\r\n  });\r\n\r\n  function clearPlaceholder(cm) {\r\n    if (cm.state.placeholder) {\r\n      cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);\r\n      cm.state.placeholder = null;\r\n    }\r\n  }\r\n  function setPlaceholder(cm) {\r\n    clearPlaceholder(cm);\r\n    var elt = cm.state.placeholder = document.createElement(\"pre\");\r\n    elt.style.cssText = \"height: 0; overflow: visible\";\r\n    elt.className = \"CodeMirror-placeholder\";\r\n    var placeHolder = cm.getOption(\"placeholder\")\r\n    if (typeof placeHolder == \"string\") placeHolder = document.createTextNode(placeHolder)\r\n    elt.appendChild(placeHolder)\r\n    cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);\r\n  }\r\n\r\n  function onBlur(cm) {\r\n    if (isEmpty(cm)) setPlaceholder(cm);\r\n  }\r\n  function onChange(cm) {\r\n    var wrapper = cm.getWrapperElement(), empty = isEmpty(cm);\r\n    wrapper.className = wrapper.className.replace(\" CodeMirror-empty\", \"\") + (empty ? \" CodeMirror-empty\" : \"\");\r\n\r\n    if (empty) setPlaceholder(cm);\r\n    else clearPlaceholder(cm);\r\n  }\r\n\r\n  function isEmpty(cm) {\r\n    return (cm.lineCount() === 1) && (cm.getLine(0) === \"\");\r\n  }\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/display/placeholder.js\n// module id = 1072\n// module chunks = 18","// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\r\n    mod(require(\"../../lib/codemirror\"));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  var listRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]\\s|[*+-]\\s|(\\d+)([.)]))(\\s*)/,\r\n      emptyListRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]|[*+-]|(\\d+)[.)])(\\s*)$/,\r\n      unorderedListRE = /[*+-]\\s/;\r\n\r\n  CodeMirror.commands.newlineAndIndentContinueMarkdownList = function(cm) {\r\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\r\n    var ranges = cm.listSelections(), replacements = [];\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var pos = ranges[i].head;\r\n      var eolState = cm.getStateAfter(pos.line);\r\n      var inList = eolState.list !== false;\r\n      var inQuote = eolState.quote !== 0;\r\n\r\n      var line = cm.getLine(pos.line), match = listRE.exec(line);\r\n      if (!ranges[i].empty() || (!inList && !inQuote) || !match) {\r\n        cm.execCommand(\"newlineAndIndent\");\r\n        return;\r\n      }\r\n      if (emptyListRE.test(line)) {\r\n        if (!/>\\s*$/.test(line)) cm.replaceRange(\"\", {\r\n          line: pos.line, ch: 0\r\n        }, {\r\n          line: pos.line, ch: pos.ch + 1\r\n        });\r\n        replacements[i] = \"\\n\";\r\n      } else {\r\n        var indent = match[1], after = match[5];\r\n        var bullet = unorderedListRE.test(match[2]) || match[2].indexOf(\">\") >= 0\r\n          ? match[2].replace(\"x\", \" \")\r\n          : (parseInt(match[3], 10) + 1) + match[4];\r\n\r\n        replacements[i] = \"\\n\" + indent + bullet + after;\r\n      }\r\n    }\r\n\r\n    cm.replaceSelections(replacements);\r\n  };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/edit/continuelist.js\n// module id = 1073\n// module chunks = 18","// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// Because sometimes you need to mark the selected *text*.\r\n//\r\n// Adds an option 'styleSelectedText' which, when enabled, gives\r\n// selected text the CSS class given as option value, or\r\n// \"CodeMirror-selectedtext\" when the value is not a string.\r\n\r\n(function(mod) {\r\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\r\n    mod(require(\"../../lib/codemirror\"));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  CodeMirror.defineOption(\"styleSelectedText\", false, function(cm, val, old) {\r\n    var prev = old && old != CodeMirror.Init;\r\n    if (val && !prev) {\r\n      cm.state.markedSelection = [];\r\n      cm.state.markedSelectionStyle = typeof val == \"string\" ? val : \"CodeMirror-selectedtext\";\r\n      reset(cm);\r\n      cm.on(\"cursorActivity\", onCursorActivity);\r\n      cm.on(\"change\", onChange);\r\n    } else if (!val && prev) {\r\n      cm.off(\"cursorActivity\", onCursorActivity);\r\n      cm.off(\"change\", onChange);\r\n      clear(cm);\r\n      cm.state.markedSelection = cm.state.markedSelectionStyle = null;\r\n    }\r\n  });\r\n\r\n  function onCursorActivity(cm) {\r\n    if (cm.state.markedSelection)\r\n      cm.operation(function() { update(cm); });\r\n  }\r\n\r\n  function onChange(cm) {\r\n    if (cm.state.markedSelection && cm.state.markedSelection.length)\r\n      cm.operation(function() { clear(cm); });\r\n  }\r\n\r\n  var CHUNK_SIZE = 8;\r\n  var Pos = CodeMirror.Pos;\r\n  var cmp = CodeMirror.cmpPos;\r\n\r\n  function coverRange(cm, from, to, addAt) {\r\n    if (cmp(from, to) == 0) return;\r\n    var array = cm.state.markedSelection;\r\n    var cls = cm.state.markedSelectionStyle;\r\n    for (var line = from.line;;) {\r\n      var start = line == from.line ? from : Pos(line, 0);\r\n      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;\r\n      var end = atEnd ? to : Pos(endLine, 0);\r\n      var mark = cm.markText(start, end, {className: cls});\r\n      if (addAt == null) array.push(mark);\r\n      else array.splice(addAt++, 0, mark);\r\n      if (atEnd) break;\r\n      line = endLine;\r\n    }\r\n  }\r\n\r\n  function clear(cm) {\r\n    var array = cm.state.markedSelection;\r\n    for (var i = 0; i < array.length; ++i) array[i].clear();\r\n    array.length = 0;\r\n  }\r\n\r\n  function reset(cm) {\r\n    clear(cm);\r\n    var ranges = cm.listSelections();\r\n    for (var i = 0; i < ranges.length; i++)\r\n      coverRange(cm, ranges[i].from(), ranges[i].to());\r\n  }\r\n\r\n  function update(cm) {\r\n    if (!cm.somethingSelected()) return clear(cm);\r\n    if (cm.listSelections().length > 1) return reset(cm);\r\n\r\n    var from = cm.getCursor(\"start\"), to = cm.getCursor(\"end\");\r\n\r\n    var array = cm.state.markedSelection;\r\n    if (!array.length) return coverRange(cm, from, to);\r\n\r\n    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();\r\n    if (!coverStart || !coverEnd || to.line - from.line < CHUNK_SIZE ||\r\n        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)\r\n      return reset(cm);\r\n\r\n    while (cmp(from, coverStart.from) > 0) {\r\n      array.shift().clear();\r\n      coverStart = array[0].find();\r\n    }\r\n    if (cmp(from, coverStart.from) < 0) {\r\n      if (coverStart.to.line - from.line < CHUNK_SIZE) {\r\n        array.shift().clear();\r\n        coverRange(cm, from, coverStart.to, 0);\r\n      } else {\r\n        coverRange(cm, from, coverStart.from, 0);\r\n      }\r\n    }\r\n\r\n    while (cmp(to, coverEnd.to) < 0) {\r\n      array.pop().clear();\r\n      coverEnd = array[array.length - 1].find();\r\n    }\r\n    if (cmp(to, coverEnd.to) > 0) {\r\n      if (to.line - coverEnd.from.line < CHUNK_SIZE) {\r\n        array.pop().clear();\r\n        coverRange(cm, coverEnd.from, to);\r\n      } else {\r\n        coverRange(cm, coverEnd.to, to);\r\n      }\r\n    }\r\n  }\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/selection/mark-selection.js\n// module id = 1076\n// module chunks = 18","// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\r\n    mod(require(\"../../lib/codemirror\"), require(\"../markdown/markdown\"), require(\"../../addon/mode/overlay\"));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\", \"../markdown/markdown\", \"../../addon/mode/overlay\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n\"use strict\";\r\n\r\nvar urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\\.beep|\\.lwz|\\.xpc|\\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\\.beeps?|xmpp|xri|ymsgr|z39\\.50[rs]?):(?:\\/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]|\\([^\\s()<>]*\\))+(?:\\([^\\s()<>]*\\)|[^\\s`*!()\\[\\]{};:'\".,<>?«»“”‘’]))/i\r\n\r\nCodeMirror.defineMode(\"gfm\", function(config, modeConfig) {\r\n  var codeDepth = 0;\r\n  function blankLine(state) {\r\n    state.code = false;\r\n    return null;\r\n  }\r\n  var gfmOverlay = {\r\n    startState: function() {\r\n      return {\r\n        code: false,\r\n        codeBlock: false,\r\n        ateSpace: false\r\n      };\r\n    },\r\n    copyState: function(s) {\r\n      return {\r\n        code: s.code,\r\n        codeBlock: s.codeBlock,\r\n        ateSpace: s.ateSpace\r\n      };\r\n    },\r\n    token: function(stream, state) {\r\n      state.combineTokens = null;\r\n\r\n      // Hack to prevent formatting override inside code blocks (block and inline)\r\n      if (state.codeBlock) {\r\n        if (stream.match(/^```+/)) {\r\n          state.codeBlock = false;\r\n          return null;\r\n        }\r\n        stream.skipToEnd();\r\n        return null;\r\n      }\r\n      if (stream.sol()) {\r\n        state.code = false;\r\n      }\r\n      if (stream.sol() && stream.match(/^```+/)) {\r\n        stream.skipToEnd();\r\n        state.codeBlock = true;\r\n        return null;\r\n      }\r\n      // If this block is changed, it may need to be updated in Markdown mode\r\n      if (stream.peek() === '`') {\r\n        stream.next();\r\n        var before = stream.pos;\r\n        stream.eatWhile('`');\r\n        var difference = 1 + stream.pos - before;\r\n        if (!state.code) {\r\n          codeDepth = difference;\r\n          state.code = true;\r\n        } else {\r\n          if (difference === codeDepth) { // Must be exact\r\n            state.code = false;\r\n          }\r\n        }\r\n        return null;\r\n      } else if (state.code) {\r\n        stream.next();\r\n        return null;\r\n      }\r\n      // Check if space. If so, links can be formatted later on\r\n      if (stream.eatSpace()) {\r\n        state.ateSpace = true;\r\n        return null;\r\n      }\r\n      if (stream.sol() || state.ateSpace) {\r\n        state.ateSpace = false;\r\n        if (modeConfig.gitHubSpice !== false) {\r\n          if(stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+@)?(?:[a-f0-9]{7,40}\\b)/)) {\r\n            // User/Project@SHA\r\n            // User@SHA\r\n            // SHA\r\n            state.combineTokens = true;\r\n            return \"link\";\r\n          } else if (stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+)?#[0-9]+\\b/)) {\r\n            // User/Project#Num\r\n            // User#Num\r\n            // #Num\r\n            state.combineTokens = true;\r\n            return \"link\";\r\n          }\r\n        }\r\n      }\r\n      if (stream.match(urlRE) &&\r\n          stream.string.slice(stream.start - 2, stream.start) != \"](\" &&\r\n          (stream.start == 0 || /\\W/.test(stream.string.charAt(stream.start - 1)))) {\r\n        // URLs\r\n        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls\r\n        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine\r\n        // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL\r\n        state.combineTokens = true;\r\n        return \"link\";\r\n      }\r\n      stream.next();\r\n      return null;\r\n    },\r\n    blankLine: blankLine\r\n  };\r\n\r\n  var markdownConfig = {\r\n    taskLists: true,\r\n    fencedCodeBlocks: '```',\r\n    strikethrough: true\r\n  };\r\n  for (var attr in modeConfig) {\r\n    markdownConfig[attr] = modeConfig[attr];\r\n  }\r\n  markdownConfig.name = \"markdown\";\r\n  return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);\r\n\r\n}, \"markdown\");\r\n\r\n  CodeMirror.defineMIME(\"text/x-gfm\", \"gfm\");\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/mode/gfm/gfm.js\n// module id = 1077\n// module chunks = 18","// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\r\n    mod(require(\"../lib/codemirror\"));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  CodeMirror.modeInfo = [\r\n    {name: \"APL\", mime: \"text/apl\", mode: \"apl\", ext: [\"dyalog\", \"apl\"]},\r\n    {name: \"PGP\", mimes: [\"application/pgp\", \"application/pgp-keys\", \"application/pgp-signature\"], mode: \"asciiarmor\", ext: [\"pgp\"]},\r\n    {name: \"ASN.1\", mime: \"text/x-ttcn-asn\", mode: \"asn.1\", ext: [\"asn\", \"asn1\"]},\r\n    {name: \"Asterisk\", mime: \"text/x-asterisk\", mode: \"asterisk\", file: /^extensions\\.conf$/i},\r\n    {name: \"Brainfuck\", mime: \"text/x-brainfuck\", mode: \"brainfuck\", ext: [\"b\", \"bf\"]},\r\n    {name: \"C\", mime: \"text/x-csrc\", mode: \"clike\", ext: [\"c\", \"h\"]},\r\n    {name: \"C++\", mime: \"text/x-c++src\", mode: \"clike\", ext: [\"cpp\", \"c++\", \"cc\", \"cxx\", \"hpp\", \"h++\", \"hh\", \"hxx\"], alias: [\"cpp\"]},\r\n    {name: \"Cobol\", mime: \"text/x-cobol\", mode: \"cobol\", ext: [\"cob\", \"cpy\"]},\r\n    {name: \"C#\", mime: \"text/x-csharp\", mode: \"clike\", ext: [\"cs\"], alias: [\"csharp\"]},\r\n    {name: \"Clojure\", mime: \"text/x-clojure\", mode: \"clojure\", ext: [\"clj\", \"cljc\", \"cljx\"]},\r\n    {name: \"ClojureScript\", mime: \"text/x-clojurescript\", mode: \"clojure\", ext: [\"cljs\"]},\r\n    {name: \"Closure Stylesheets (GSS)\", mime: \"text/x-gss\", mode: \"css\", ext: [\"gss\"]},\r\n    {name: \"CMake\", mime: \"text/x-cmake\", mode: \"cmake\", ext: [\"cmake\", \"cmake.in\"], file: /^CMakeLists.txt$/},\r\n    {name: \"CoffeeScript\", mime: \"text/x-coffeescript\", mode: \"coffeescript\", ext: [\"coffee\"], alias: [\"coffee\", \"coffee-script\"]},\r\n    {name: \"Common Lisp\", mime: \"text/x-common-lisp\", mode: \"commonlisp\", ext: [\"cl\", \"lisp\", \"el\"], alias: [\"lisp\"]},\r\n    {name: \"Cypher\", mime: \"application/x-cypher-query\", mode: \"cypher\", ext: [\"cyp\", \"cypher\"]},\r\n    {name: \"Cython\", mime: \"text/x-cython\", mode: \"python\", ext: [\"pyx\", \"pxd\", \"pxi\"]},\r\n    {name: \"Crystal\", mime: \"text/x-crystal\", mode: \"crystal\", ext: [\"cr\"]},\r\n    {name: \"CSS\", mime: \"text/css\", mode: \"css\", ext: [\"css\"]},\r\n    {name: \"CQL\", mime: \"text/x-cassandra\", mode: \"sql\", ext: [\"cql\"]},\r\n    {name: \"D\", mime: \"text/x-d\", mode: \"d\", ext: [\"d\"]},\r\n    {name: \"Dart\", mimes: [\"application/dart\", \"text/x-dart\"], mode: \"dart\", ext: [\"dart\"]},\r\n    {name: \"diff\", mime: \"text/x-diff\", mode: \"diff\", ext: [\"diff\", \"patch\"]},\r\n    {name: \"Django\", mime: \"text/x-django\", mode: \"django\"},\r\n    {name: \"Dockerfile\", mime: \"text/x-dockerfile\", mode: \"dockerfile\", file: /^Dockerfile$/},\r\n    {name: \"DTD\", mime: \"application/xml-dtd\", mode: \"dtd\", ext: [\"dtd\"]},\r\n    {name: \"Dylan\", mime: \"text/x-dylan\", mode: \"dylan\", ext: [\"dylan\", \"dyl\", \"intr\"]},\r\n    {name: \"EBNF\", mime: \"text/x-ebnf\", mode: \"ebnf\"},\r\n    {name: \"ECL\", mime: \"text/x-ecl\", mode: \"ecl\", ext: [\"ecl\"]},\r\n    {name: \"edn\", mime: \"application/edn\", mode: \"clojure\", ext: [\"edn\"]},\r\n    {name: \"Eiffel\", mime: \"text/x-eiffel\", mode: \"eiffel\", ext: [\"e\"]},\r\n    {name: \"Elm\", mime: \"text/x-elm\", mode: \"elm\", ext: [\"elm\"]},\r\n    {name: \"Embedded Javascript\", mime: \"application/x-ejs\", mode: \"htmlembedded\", ext: [\"ejs\"]},\r\n    {name: \"Embedded Ruby\", mime: \"application/x-erb\", mode: \"htmlembedded\", ext: [\"erb\"]},\r\n    {name: \"Erlang\", mime: \"text/x-erlang\", mode: \"erlang\", ext: [\"erl\"]},\r\n    {name: \"Factor\", mime: \"text/x-factor\", mode: \"factor\", ext: [\"factor\"]},\r\n    {name: \"FCL\", mime: \"text/x-fcl\", mode: \"fcl\"},\r\n    {name: \"Forth\", mime: \"text/x-forth\", mode: \"forth\", ext: [\"forth\", \"fth\", \"4th\"]},\r\n    {name: \"Fortran\", mime: \"text/x-fortran\", mode: \"fortran\", ext: [\"f\", \"for\", \"f77\", \"f90\"]},\r\n    {name: \"F#\", mime: \"text/x-fsharp\", mode: \"mllike\", ext: [\"fs\"], alias: [\"fsharp\"]},\r\n    {name: \"Gas\", mime: \"text/x-gas\", mode: \"gas\", ext: [\"s\"]},\r\n    {name: \"Gherkin\", mime: \"text/x-feature\", mode: \"gherkin\", ext: [\"feature\"]},\r\n    {name: \"GitHub Flavored Markdown\", mime: \"text/x-gfm\", mode: \"gfm\", file: /^(readme|contributing|history).md$/i},\r\n    {name: \"Go\", mime: \"text/x-go\", mode: \"go\", ext: [\"go\"]},\r\n    {name: \"Groovy\", mime: \"text/x-groovy\", mode: \"groovy\", ext: [\"groovy\", \"gradle\"], file: /^Jenkinsfile$/},\r\n    {name: \"HAML\", mime: \"text/x-haml\", mode: \"haml\", ext: [\"haml\"]},\r\n    {name: \"Haskell\", mime: \"text/x-haskell\", mode: \"haskell\", ext: [\"hs\"]},\r\n    {name: \"Haskell (Literate)\", mime: \"text/x-literate-haskell\", mode: \"haskell-literate\", ext: [\"lhs\"]},\r\n    {name: \"Haxe\", mime: \"text/x-haxe\", mode: \"haxe\", ext: [\"hx\"]},\r\n    {name: \"HXML\", mime: \"text/x-hxml\", mode: \"haxe\", ext: [\"hxml\"]},\r\n    {name: \"ASP.NET\", mime: \"application/x-aspx\", mode: \"htmlembedded\", ext: [\"aspx\"], alias: [\"asp\", \"aspx\"]},\r\n    {name: \"HTML\", mime: \"text/html\", mode: \"htmlmixed\", ext: [\"html\", \"htm\"], alias: [\"xhtml\"]},\r\n    {name: \"HTTP\", mime: \"message/http\", mode: \"http\"},\r\n    {name: \"IDL\", mime: \"text/x-idl\", mode: \"idl\", ext: [\"pro\"]},\r\n    {name: \"Pug\", mime: \"text/x-pug\", mode: \"pug\", ext: [\"jade\", \"pug\"], alias: [\"jade\"]},\r\n    {name: \"Java\", mime: \"text/x-java\", mode: \"clike\", ext: [\"java\"]},\r\n    {name: \"Java Server Pages\", mime: \"application/x-jsp\", mode: \"htmlembedded\", ext: [\"jsp\"], alias: [\"jsp\"]},\r\n    {name: \"JavaScript\", mimes: [\"text/javascript\", \"text/ecmascript\", \"application/javascript\", \"application/x-javascript\", \"application/ecmascript\"],\r\n     mode: \"javascript\", ext: [\"js\"], alias: [\"ecmascript\", \"js\", \"node\"]},\r\n    {name: \"JSON\", mimes: [\"application/json\", \"application/x-json\"], mode: \"javascript\", ext: [\"json\", \"map\"], alias: [\"json5\"]},\r\n    {name: \"JSON-LD\", mime: \"application/ld+json\", mode: \"javascript\", ext: [\"jsonld\"], alias: [\"jsonld\"]},\r\n    {name: \"JSX\", mime: \"text/jsx\", mode: \"jsx\", ext: [\"jsx\"]},\r\n    {name: \"Jinja2\", mime: \"null\", mode: \"jinja2\"},\r\n    {name: \"Julia\", mime: \"text/x-julia\", mode: \"julia\", ext: [\"jl\"]},\r\n    {name: \"Kotlin\", mime: \"text/x-kotlin\", mode: \"clike\", ext: [\"kt\"]},\r\n    {name: \"LESS\", mime: \"text/x-less\", mode: \"css\", ext: [\"less\"]},\r\n    {name: \"LiveScript\", mime: \"text/x-livescript\", mode: \"livescript\", ext: [\"ls\"], alias: [\"ls\"]},\r\n    {name: \"Lua\", mime: \"text/x-lua\", mode: \"lua\", ext: [\"lua\"]},\r\n    {name: \"Markdown\", mime: \"text/x-markdown\", mode: \"markdown\", ext: [\"markdown\", \"md\", \"mkd\"]},\r\n    {name: \"mIRC\", mime: \"text/mirc\", mode: \"mirc\"},\r\n    {name: \"MariaDB SQL\", mime: \"text/x-mariadb\", mode: \"sql\"},\r\n    {name: \"Mathematica\", mime: \"text/x-mathematica\", mode: \"mathematica\", ext: [\"m\", \"nb\"]},\r\n    {name: \"Modelica\", mime: \"text/x-modelica\", mode: \"modelica\", ext: [\"mo\"]},\r\n    {name: \"MUMPS\", mime: \"text/x-mumps\", mode: \"mumps\", ext: [\"mps\"]},\r\n    {name: \"MS SQL\", mime: \"text/x-mssql\", mode: \"sql\"},\r\n    {name: \"mbox\", mime: \"application/mbox\", mode: \"mbox\", ext: [\"mbox\"]},\r\n    {name: \"MySQL\", mime: \"text/x-mysql\", mode: \"sql\"},\r\n    {name: \"Nginx\", mime: \"text/x-nginx-conf\", mode: \"nginx\", file: /nginx.*\\.conf$/i},\r\n    {name: \"NSIS\", mime: \"text/x-nsis\", mode: \"nsis\", ext: [\"nsh\", \"nsi\"]},\r\n    {name: \"NTriples\", mime: \"text/n-triples\", mode: \"ntriples\", ext: [\"nt\"]},\r\n    {name: \"Objective C\", mime: \"text/x-objectivec\", mode: \"clike\", ext: [\"m\", \"mm\"], alias: [\"objective-c\", \"objc\"]},\r\n    {name: \"OCaml\", mime: \"text/x-ocaml\", mode: \"mllike\", ext: [\"ml\", \"mli\", \"mll\", \"mly\"]},\r\n    {name: \"Octave\", mime: \"text/x-octave\", mode: \"octave\", ext: [\"m\"]},\r\n    {name: \"Oz\", mime: \"text/x-oz\", mode: \"oz\", ext: [\"oz\"]},\r\n    {name: \"Pascal\", mime: \"text/x-pascal\", mode: \"pascal\", ext: [\"p\", \"pas\"]},\r\n    {name: \"PEG.js\", mime: \"null\", mode: \"pegjs\", ext: [\"jsonld\"]},\r\n    {name: \"Perl\", mime: \"text/x-perl\", mode: \"perl\", ext: [\"pl\", \"pm\"]},\r\n    {name: \"PHP\", mime: \"application/x-httpd-php\", mode: \"php\", ext: [\"php\", \"php3\", \"php4\", \"php5\", \"phtml\"]},\r\n    {name: \"Pig\", mime: \"text/x-pig\", mode: \"pig\", ext: [\"pig\"]},\r\n    {name: \"Plain Text\", mime: \"text/plain\", mode: \"null\", ext: [\"txt\", \"text\", \"conf\", \"def\", \"list\", \"log\"]},\r\n    {name: \"PLSQL\", mime: \"text/x-plsql\", mode: \"sql\", ext: [\"pls\"]},\r\n    {name: \"PowerShell\", mime: \"application/x-powershell\", mode: \"powershell\", ext: [\"ps1\", \"psd1\", \"psm1\"]},\r\n    {name: \"Properties files\", mime: \"text/x-properties\", mode: \"properties\", ext: [\"properties\", \"ini\", \"in\"], alias: [\"ini\", \"properties\"]},\r\n    {name: \"ProtoBuf\", mime: \"text/x-protobuf\", mode: \"protobuf\", ext: [\"proto\"]},\r\n    {name: \"Python\", mime: \"text/x-python\", mode: \"python\", ext: [\"BUILD\", \"bzl\", \"py\", \"pyw\"], file: /^(BUCK|BUILD)$/},\r\n    {name: \"Puppet\", mime: \"text/x-puppet\", mode: \"puppet\", ext: [\"pp\"]},\r\n    {name: \"Q\", mime: \"text/x-q\", mode: \"q\", ext: [\"q\"]},\r\n    {name: \"R\", mime: \"text/x-rsrc\", mode: \"r\", ext: [\"r\", \"R\"], alias: [\"rscript\"]},\r\n    {name: \"reStructuredText\", mime: \"text/x-rst\", mode: \"rst\", ext: [\"rst\"], alias: [\"rst\"]},\r\n    {name: \"RPM Changes\", mime: \"text/x-rpm-changes\", mode: \"rpm\"},\r\n    {name: \"RPM Spec\", mime: \"text/x-rpm-spec\", mode: \"rpm\", ext: [\"spec\"]},\r\n    {name: \"Ruby\", mime: \"text/x-ruby\", mode: \"ruby\", ext: [\"rb\"], alias: [\"jruby\", \"macruby\", \"rake\", \"rb\", \"rbx\"]},\r\n    {name: \"Rust\", mime: \"text/x-rustsrc\", mode: \"rust\", ext: [\"rs\"]},\r\n    {name: \"SAS\", mime: \"text/x-sas\", mode: \"sas\", ext: [\"sas\"]},\r\n    {name: \"Sass\", mime: \"text/x-sass\", mode: \"sass\", ext: [\"sass\"]},\r\n    {name: \"Scala\", mime: \"text/x-scala\", mode: \"clike\", ext: [\"scala\"]},\r\n    {name: \"Scheme\", mime: \"text/x-scheme\", mode: \"scheme\", ext: [\"scm\", \"ss\"]},\r\n    {name: \"SCSS\", mime: \"text/x-scss\", mode: \"css\", ext: [\"scss\"]},\r\n    {name: \"Shell\", mime: \"text/x-sh\", mode: \"shell\", ext: [\"sh\", \"ksh\", \"bash\"], alias: [\"bash\", \"sh\", \"zsh\"], file: /^PKGBUILD$/},\r\n    {name: \"Sieve\", mime: \"application/sieve\", mode: \"sieve\", ext: [\"siv\", \"sieve\"]},\r\n    {name: \"Slim\", mimes: [\"text/x-slim\", \"application/x-slim\"], mode: \"slim\", ext: [\"slim\"]},\r\n    {name: \"Smalltalk\", mime: \"text/x-stsrc\", mode: \"smalltalk\", ext: [\"st\"]},\r\n    {name: \"Smarty\", mime: \"text/x-smarty\", mode: \"smarty\", ext: [\"tpl\"]},\r\n    {name: \"Solr\", mime: \"text/x-solr\", mode: \"solr\"},\r\n    {name: \"Soy\", mime: \"text/x-soy\", mode: \"soy\", ext: [\"soy\"], alias: [\"closure template\"]},\r\n    {name: \"SPARQL\", mime: \"application/sparql-query\", mode: \"sparql\", ext: [\"rq\", \"sparql\"], alias: [\"sparul\"]},\r\n    {name: \"Spreadsheet\", mime: \"text/x-spreadsheet\", mode: \"spreadsheet\", alias: [\"excel\", \"formula\"]},\r\n    {name: \"SQL\", mime: \"text/x-sql\", mode: \"sql\", ext: [\"sql\"]},\r\n    {name: \"SQLite\", mime: \"text/x-sqlite\", mode: \"sql\"},\r\n    {name: \"Squirrel\", mime: \"text/x-squirrel\", mode: \"clike\", ext: [\"nut\"]},\r\n    {name: \"Stylus\", mime: \"text/x-styl\", mode: \"stylus\", ext: [\"styl\"]},\r\n    {name: \"Swift\", mime: \"text/x-swift\", mode: \"swift\", ext: [\"swift\"]},\r\n    {name: \"sTeX\", mime: \"text/x-stex\", mode: \"stex\"},\r\n    {name: \"LaTeX\", mime: \"text/x-latex\", mode: \"stex\", ext: [\"text\", \"ltx\"], alias: [\"tex\"]},\r\n    {name: \"SystemVerilog\", mime: \"text/x-systemverilog\", mode: \"verilog\", ext: [\"v\"]},\r\n    {name: \"Tcl\", mime: \"text/x-tcl\", mode: \"tcl\", ext: [\"tcl\"]},\r\n    {name: \"Textile\", mime: \"text/x-textile\", mode: \"textile\", ext: [\"textile\"]},\r\n    {name: \"TiddlyWiki \", mime: \"text/x-tiddlywiki\", mode: \"tiddlywiki\"},\r\n    {name: \"Tiki wiki\", mime: \"text/tiki\", mode: \"tiki\"},\r\n    {name: \"TOML\", mime: \"text/x-toml\", mode: \"toml\", ext: [\"toml\"]},\r\n    {name: \"Tornado\", mime: \"text/x-tornado\", mode: \"tornado\"},\r\n    {name: \"troff\", mime: \"text/troff\", mode: \"troff\", ext: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]},\r\n    {name: \"TTCN\", mime: \"text/x-ttcn\", mode: \"ttcn\", ext: [\"ttcn\", \"ttcn3\", \"ttcnpp\"]},\r\n    {name: \"TTCN_CFG\", mime: \"text/x-ttcn-cfg\", mode: \"ttcn-cfg\", ext: [\"cfg\"]},\r\n    {name: \"Turtle\", mime: \"text/turtle\", mode: \"turtle\", ext: [\"ttl\"]},\r\n    {name: \"TypeScript\", mime: \"application/typescript\", mode: \"javascript\", ext: [\"ts\"], alias: [\"ts\"]},\r\n    {name: \"TypeScript-JSX\", mime: \"text/typescript-jsx\", mode: \"jsx\", ext: [\"tsx\"], alias: [\"tsx\"]},\r\n    {name: \"Twig\", mime: \"text/x-twig\", mode: \"twig\"},\r\n    {name: \"Web IDL\", mime: \"text/x-webidl\", mode: \"webidl\", ext: [\"webidl\"]},\r\n    {name: \"VB.NET\", mime: \"text/x-vb\", mode: \"vb\", ext: [\"vb\"]},\r\n    {name: \"VBScript\", mime: \"text/vbscript\", mode: \"vbscript\", ext: [\"vbs\"]},\r\n    {name: \"Velocity\", mime: \"text/velocity\", mode: \"velocity\", ext: [\"vtl\"]},\r\n    {name: \"Verilog\", mime: \"text/x-verilog\", mode: \"verilog\", ext: [\"v\"]},\r\n    {name: \"VHDL\", mime: \"text/x-vhdl\", mode: \"vhdl\", ext: [\"vhd\", \"vhdl\"]},\r\n    {name: \"Vue.js Component\", mimes: [\"script/x-vue\", \"text/x-vue\"], mode: \"vue\", ext: [\"vue\"]},\r\n    {name: \"XML\", mimes: [\"application/xml\", \"text/xml\"], mode: \"xml\", ext: [\"xml\", \"xsl\", \"xsd\", \"svg\"], alias: [\"rss\", \"wsdl\", \"xsd\"]},\r\n    {name: \"XQuery\", mime: \"application/xquery\", mode: \"xquery\", ext: [\"xy\", \"xquery\"]},\r\n    {name: \"Yacas\", mime: \"text/x-yacas\", mode: \"yacas\", ext: [\"ys\"]},\r\n    {name: \"YAML\", mimes: [\"text/x-yaml\", \"text/yaml\"], mode: \"yaml\", ext: [\"yaml\", \"yml\"], alias: [\"yml\"]},\r\n    {name: \"Z80\", mime: \"text/x-z80\", mode: \"z80\", ext: [\"z80\"]},\r\n    {name: \"mscgen\", mime: \"text/x-mscgen\", mode: \"mscgen\", ext: [\"mscgen\", \"mscin\", \"msc\"]},\r\n    {name: \"xu\", mime: \"text/x-xu\", mode: \"mscgen\", ext: [\"xu\"]},\r\n    {name: \"msgenny\", mime: \"text/x-msgenny\", mode: \"mscgen\", ext: [\"msgenny\"]}\r\n  ];\r\n  // Ensure all modes have a mime property for backwards compatibility\r\n  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n    var info = CodeMirror.modeInfo[i];\r\n    if (info.mimes) info.mime = info.mimes[0];\r\n  }\r\n\r\n  CodeMirror.findModeByMIME = function(mime) {\r\n    mime = mime.toLowerCase();\r\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n      var info = CodeMirror.modeInfo[i];\r\n      if (info.mime == mime) return info;\r\n      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)\r\n        if (info.mimes[j] == mime) return info;\r\n    }\r\n    if (/\\+xml$/.test(mime)) return CodeMirror.findModeByMIME(\"application/xml\")\r\n    if (/\\+json$/.test(mime)) return CodeMirror.findModeByMIME(\"application/json\")\r\n  };\r\n\r\n  CodeMirror.findModeByExtension = function(ext) {\r\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n      var info = CodeMirror.modeInfo[i];\r\n      if (info.ext) for (var j = 0; j < info.ext.length; j++)\r\n        if (info.ext[j] == ext) return info;\r\n    }\r\n  };\r\n\r\n  CodeMirror.findModeByFileName = function(filename) {\r\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n      var info = CodeMirror.modeInfo[i];\r\n      if (info.file && info.file.test(filename)) return info;\r\n    }\r\n    var dot = filename.lastIndexOf(\".\");\r\n    var ext = dot > -1 && filename.substring(dot + 1, filename.length);\r\n    if (ext) return CodeMirror.findModeByExtension(ext);\r\n  };\r\n\r\n  CodeMirror.findModeByName = function(name) {\r\n    name = name.toLowerCase();\r\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n      var info = CodeMirror.modeInfo[i];\r\n      if (info.name.toLowerCase() == name) return info;\r\n      if (info.alias) for (var j = 0; j < info.alias.length; j++)\r\n        if (info.alias[j].toLowerCase() == name) return info;\r\n    }\r\n  };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/mode/meta.js\n// module id = 1079\n// module chunks = 18","exports = module.exports = require(\"../../css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".CodeMirror{color:#000}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-ruler{border-left:1px solid #ccc;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-invalidchar,.cm-s-default .cm-error{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important;-webkit-user-select:none;-moz-user-select:none;user-select:none}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:none;font-variant-ligatures:none}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}.CodeMirror-focused div.CodeMirror-cursors,div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected,.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background:#ffa;background:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:\\\"\\\"}span.CodeMirror-selectedtext{background:0 0}.CodeMirror{height:auto;border:1px solid #ddd;border-bottom-left-radius:4px;border-bottom-right-radius:4px;padding:10px;font:inherit;z-index:1}.CodeMirror,.CodeMirror-scroll{min-height:300px}.CodeMirror-fullscreen{background:#fff;position:fixed!important;top:50px;left:0;right:0;bottom:0;height:auto;z-index:9}.CodeMirror-sided{width:50%!important}.editor-toolbar{position:relative;opacity:.6;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;padding:0 10px;border-top:1px solid #bbb;border-left:1px solid #bbb;border-right:1px solid #bbb;border-top-left-radius:4px;border-top-right-radius:4px}.editor-toolbar:after,.editor-toolbar:before{display:block;content:\\\" \\\";height:1px}.editor-toolbar:before{margin-bottom:8px}.editor-toolbar:after{margin-top:8px}.editor-toolbar:hover,.editor-wrapper input.title:focus,.editor-wrapper input.title:hover{opacity:.8}.editor-toolbar.fullscreen{width:100%;height:50px;overflow-x:auto;overflow-y:hidden;white-space:nowrap;padding-top:10px;padding-bottom:10px;box-sizing:border-box;background:#fff;border:0;position:fixed;top:0;left:0;opacity:1;z-index:9}.editor-toolbar.fullscreen:before{width:20px;height:50px;background:-moz-linear-gradient(left,#fff 0,hsla(0,0%,100%,0) 100%);background:-webkit-gradient(linear,left top,right top,color-stop(0,#fff),color-stop(100%,hsla(0,0%,100%,0)));background:-webkit-linear-gradient(left,#fff,hsla(0,0%,100%,0));background:-o-linear-gradient(left,#fff 0,hsla(0,0%,100%,0) 100%);background:-ms-linear-gradient(left,#fff 0,hsla(0,0%,100%,0) 100%);background:linear-gradient(90deg,#fff 0,hsla(0,0%,100%,0));position:fixed;top:0;left:0;margin:0;padding:0}.editor-toolbar.fullscreen:after{width:20px;height:50px;background:-moz-linear-gradient(left,hsla(0,0%,100%,0) 0,#fff 100%);background:-webkit-gradient(linear,left top,right top,color-stop(0,hsla(0,0%,100%,0)),color-stop(100%,#fff));background:-webkit-linear-gradient(left,hsla(0,0%,100%,0),#fff);background:-o-linear-gradient(left,hsla(0,0%,100%,0) 0,#fff 100%);background:-ms-linear-gradient(left,hsla(0,0%,100%,0) 0,#fff 100%);background:linear-gradient(90deg,hsla(0,0%,100%,0) 0,#fff);position:fixed;top:0;right:0;margin:0;padding:0}.editor-toolbar a{display:inline-block;text-align:center;text-decoration:none!important;color:#2c3e50!important;width:30px;height:30px;margin:0;border:1px solid transparent;border-radius:3px;cursor:pointer}.editor-toolbar a.active,.editor-toolbar a:hover{background:#fcfcfc;border-color:#95a5a6}.editor-toolbar a:before{line-height:30px}.editor-toolbar i.separator{display:inline-block;width:0;border-left:1px solid #d9d9d9;border-right:1px solid #fff;color:transparent;text-indent:-10px;margin:0 6px}.editor-toolbar a.fa-header-x:after{font-family:Arial,Helvetica Neue,Helvetica,sans-serif;font-size:65%;vertical-align:text-bottom;position:relative;top:2px}.editor-toolbar a.fa-header-1:after{content:\\\"1\\\"}.editor-toolbar a.fa-header-2:after{content:\\\"2\\\"}.editor-toolbar a.fa-header-3:after{content:\\\"3\\\"}.editor-toolbar a.fa-header-bigger:after{content:\\\"\\\\25B2\\\"}.editor-toolbar a.fa-header-smaller:after{content:\\\"\\\\25BC\\\"}.editor-toolbar.disabled-for-preview a:not(.no-disable){pointer-events:none;background:#fff;border-color:transparent;text-shadow:inherit}@media only screen and (max-width:700px){.editor-toolbar a.no-mobile{display:none}}.editor-statusbar{padding:8px 10px;font-size:12px;color:#959694;text-align:right}.editor-statusbar span{display:inline-block;min-width:4em;margin-left:1em}.editor-preview,.editor-preview-side{padding:10px;background:#fafafa;overflow:auto;display:none;box-sizing:border-box}.editor-statusbar .lines:before{content:\\\"lines: \\\"}.editor-statusbar .words:before{content:\\\"words: \\\"}.editor-statusbar .characters:before{content:\\\"characters: \\\"}.editor-preview{position:absolute;width:100%;height:100%;top:0;left:0;z-index:7}.editor-preview-side{position:fixed;bottom:0;width:50%;top:50px;right:0;z-index:9;border:1px solid #ddd}.editor-preview-active,.editor-preview-active-side{display:block}.editor-preview-side>p,.editor-preview>p{margin-top:0}.editor-preview-side pre,.editor-preview pre{background:#eee;margin-bottom:10px}.editor-preview-side table td,.editor-preview-side table th,.editor-preview table td,.editor-preview table th{border:1px solid #ddd;padding:5px}.CodeMirror .CodeMirror-code .cm-tag{color:#63a35c}.CodeMirror .CodeMirror-code .cm-attribute{color:#795da3}.CodeMirror .CodeMirror-code .cm-string{color:#183691}.CodeMirror .CodeMirror-selected{background:#d9d9d9}.CodeMirror .CodeMirror-code .cm-header-1{font-size:200%;line-height:200%}.CodeMirror .CodeMirror-code .cm-header-2{font-size:160%;line-height:160%}.CodeMirror .CodeMirror-code .cm-header-3{font-size:125%;line-height:125%}.CodeMirror .CodeMirror-code .cm-header-4{font-size:110%;line-height:110%}.CodeMirror .CodeMirror-code .cm-comment{background:rgba(0,0,0,.05);border-radius:2px}.CodeMirror .CodeMirror-code .cm-link{color:#7f8c8d}.CodeMirror .CodeMirror-code .cm-url{color:#aab2b3}.CodeMirror .CodeMirror-code .cm-strikethrough{text-decoration:line-through}.CodeMirror .CodeMirror-placeholder{opacity:.5}.CodeMirror .cm-spell-error:not(.cm-url):not(.cm-comment):not(.cm-tag):not(.cm-word){background:rgba(255,0,0,.15)}\", \"\", {\"version\":3,\"sources\":[\"C:/Users/admin/feeling_admin2/node_modules/simplemde/dist/simplemde.min.css\"],\"names\":[],\"mappings\":\"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\",\"file\":\"simplemde.min.css\",\"sourcesContent\":[\"/**\\r\\n * simplemde v1.11.2\\r\\n * Copyright Next Step Webs, Inc.\\r\\n * @link https://github.com/NextStepWebs/simplemde-markdown-editor\\r\\n * @license MIT\\r\\n */\\r\\n.CodeMirror{color:#000}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-ruler{border-left:1px solid #ccc;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-invalidchar,.cm-s-default .cm-error{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important;-webkit-user-select:none;-moz-user-select:none;user-select:none}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:none;font-variant-ligatures:none}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}.CodeMirror-focused div.CodeMirror-cursors,div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected,.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background:#ffa;background:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}.CodeMirror{height:auto;min-height:300px;border:1px solid #ddd;border-bottom-left-radius:4px;border-bottom-right-radius:4px;padding:10px;font:inherit;z-index:1}.CodeMirror-scroll{min-height:300px}.CodeMirror-fullscreen{background:#fff;position:fixed!important;top:50px;left:0;right:0;bottom:0;height:auto;z-index:9}.CodeMirror-sided{width:50%!important}.editor-toolbar{position:relative;opacity:.6;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;padding:0 10px;border-top:1px solid #bbb;border-left:1px solid #bbb;border-right:1px solid #bbb;border-top-left-radius:4px;border-top-right-radius:4px}.editor-toolbar:after,.editor-toolbar:before{display:block;content:' ';height:1px}.editor-toolbar:before{margin-bottom:8px}.editor-toolbar:after{margin-top:8px}.editor-toolbar:hover,.editor-wrapper input.title:focus,.editor-wrapper input.title:hover{opacity:.8}.editor-toolbar.fullscreen{width:100%;height:50px;overflow-x:auto;overflow-y:hidden;white-space:nowrap;padding-top:10px;padding-bottom:10px;box-sizing:border-box;background:#fff;border:0;position:fixed;top:0;left:0;opacity:1;z-index:9}.editor-toolbar.fullscreen::before{width:20px;height:50px;background:-moz-linear-gradient(left,rgba(255,255,255,1) 0,rgba(255,255,255,0) 100%);background:-webkit-gradient(linear,left top,right top,color-stop(0,rgba(255,255,255,1)),color-stop(100%,rgba(255,255,255,0)));background:-webkit-linear-gradient(left,rgba(255,255,255,1) 0,rgba(255,255,255,0) 100%);background:-o-linear-gradient(left,rgba(255,255,255,1) 0,rgba(255,255,255,0) 100%);background:-ms-linear-gradient(left,rgba(255,255,255,1) 0,rgba(255,255,255,0) 100%);background:linear-gradient(to right,rgba(255,255,255,1) 0,rgba(255,255,255,0) 100%);position:fixed;top:0;left:0;margin:0;padding:0}.editor-toolbar.fullscreen::after{width:20px;height:50px;background:-moz-linear-gradient(left,rgba(255,255,255,0) 0,rgba(255,255,255,1) 100%);background:-webkit-gradient(linear,left top,right top,color-stop(0,rgba(255,255,255,0)),color-stop(100%,rgba(255,255,255,1)));background:-webkit-linear-gradient(left,rgba(255,255,255,0) 0,rgba(255,255,255,1) 100%);background:-o-linear-gradient(left,rgba(255,255,255,0) 0,rgba(255,255,255,1) 100%);background:-ms-linear-gradient(left,rgba(255,255,255,0) 0,rgba(255,255,255,1) 100%);background:linear-gradient(to right,rgba(255,255,255,0) 0,rgba(255,255,255,1) 100%);position:fixed;top:0;right:0;margin:0;padding:0}.editor-toolbar a{display:inline-block;text-align:center;text-decoration:none!important;color:#2c3e50!important;width:30px;height:30px;margin:0;border:1px solid transparent;border-radius:3px;cursor:pointer}.editor-toolbar a.active,.editor-toolbar a:hover{background:#fcfcfc;border-color:#95a5a6}.editor-toolbar a:before{line-height:30px}.editor-toolbar i.separator{display:inline-block;width:0;border-left:1px solid #d9d9d9;border-right:1px solid #fff;color:transparent;text-indent:-10px;margin:0 6px}.editor-toolbar a.fa-header-x:after{font-family:Arial,\\\"Helvetica Neue\\\",Helvetica,sans-serif;font-size:65%;vertical-align:text-bottom;position:relative;top:2px}.editor-toolbar a.fa-header-1:after{content:\\\"1\\\"}.editor-toolbar a.fa-header-2:after{content:\\\"2\\\"}.editor-toolbar a.fa-header-3:after{content:\\\"3\\\"}.editor-toolbar a.fa-header-bigger:after{content:\\\"▲\\\"}.editor-toolbar a.fa-header-smaller:after{content:\\\"▼\\\"}.editor-toolbar.disabled-for-preview a:not(.no-disable){pointer-events:none;background:#fff;border-color:transparent;text-shadow:inherit}@media only screen and (max-width:700px){.editor-toolbar a.no-mobile{display:none}}.editor-statusbar{padding:8px 10px;font-size:12px;color:#959694;text-align:right}.editor-statusbar span{display:inline-block;min-width:4em;margin-left:1em}.editor-preview,.editor-preview-side{padding:10px;background:#fafafa;overflow:auto;display:none;box-sizing:border-box}.editor-statusbar .lines:before{content:'lines: '}.editor-statusbar .words:before{content:'words: '}.editor-statusbar .characters:before{content:'characters: '}.editor-preview{position:absolute;width:100%;height:100%;top:0;left:0;z-index:7}.editor-preview-side{position:fixed;bottom:0;width:50%;top:50px;right:0;z-index:9;border:1px solid #ddd}.editor-preview-active,.editor-preview-active-side{display:block}.editor-preview-side>p,.editor-preview>p{margin-top:0}.editor-preview pre,.editor-preview-side pre{background:#eee;margin-bottom:10px}.editor-preview table td,.editor-preview table th,.editor-preview-side table td,.editor-preview-side table th{border:1px solid #ddd;padding:5px}.CodeMirror .CodeMirror-code .cm-tag{color:#63a35c}.CodeMirror .CodeMirror-code .cm-attribute{color:#795da3}.CodeMirror .CodeMirror-code .cm-string{color:#183691}.CodeMirror .CodeMirror-selected{background:#d9d9d9}.CodeMirror .CodeMirror-code .cm-header-1{font-size:200%;line-height:200%}.CodeMirror .CodeMirror-code .cm-header-2{font-size:160%;line-height:160%}.CodeMirror .CodeMirror-code .cm-header-3{font-size:125%;line-height:125%}.CodeMirror .CodeMirror-code .cm-header-4{font-size:110%;line-height:110%}.CodeMirror .CodeMirror-code .cm-comment{background:rgba(0,0,0,.05);border-radius:2px}.CodeMirror .CodeMirror-code .cm-link{color:#7f8c8d}.CodeMirror .CodeMirror-code .cm-url{color:#aab2b3}.CodeMirror .CodeMirror-code .cm-strikethrough{text-decoration:line-through}.CodeMirror .CodeMirror-placeholder{opacity:.5}.CodeMirror .cm-spell-error:not(.cm-url):not(.cm-comment):not(.cm-tag):not(.cm-word){background:rgba(255,0,0,.15)}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/simplemde/dist/simplemde.min.css\n// module id = 1084\n// module chunks = 18","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".simplemde-container .CodeMirror,.simplemde-container .CodeMirror-scroll{min-height:150px}.simplemde-container .CodeMirror-code{padding-bottom:40px}.simplemde-container .editor-statusbar{display:none}.simplemde-container .CodeMirror .CodeMirror-code .cm-link{color:#1482f0}.simplemde-container .CodeMirror .CodeMirror-code .cm-string.cm-url{color:#2d3b4d;font-weight:700}.simplemde-container .CodeMirror .CodeMirror-code .cm-formatting-link-string.cm-url{padding:0 2px;font-weight:700;color:#e61e1e}\", \"\", {\"version\":3,\"sources\":[\"C:/Users/admin/feeling_admin2/src/components/MdEditor/index.vue\"],\"names\":[],\"mappings\":\"AAKA,yEACE,gBAAkB,CACnB,AACD,sCACE,mBAAqB,CACtB,AACD,uCACE,YAAc,CACf,AACD,2DACE,aAAe,CAChB,AACD,oEACE,cAAe,AACf,eAAkB,CACnB,AACD,oFACE,cAAe,AACf,gBAAkB,AAClB,aAAe,CAChB\",\"file\":\"index.vue\",\"sourcesContent\":[\"\\n.simplemde-container .CodeMirror {\\r\\n  /*height: 150px;*/\\r\\n  min-height: 150px;\\n}\\n.simplemde-container .CodeMirror-scroll {\\r\\n  min-height: 150px;\\n}\\n.simplemde-container .CodeMirror-code {\\r\\n  padding-bottom: 40px;\\n}\\n.simplemde-container .editor-statusbar {\\r\\n  display: none;\\n}\\n.simplemde-container .CodeMirror .CodeMirror-code .cm-link {\\r\\n  color: #1482F0;\\n}\\n.simplemde-container .CodeMirror .CodeMirror-code .cm-string.cm-url {\\r\\n  color: #2d3b4d;\\r\\n  font-weight: bold;\\n}\\n.simplemde-container .CodeMirror .CodeMirror-code .cm-formatting-link-string.cm-url {\\r\\n  padding: 0 2px;\\r\\n  font-weight: bold;\\r\\n  color: #E61E1E;\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-48a3e0da\",\"scoped\":false,\"hasInlineConfig\":false}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/MdEditor/index.vue\n// module id = 1123\n// module chunks = 18","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../css-loader/index.js??ref--4-2!./simplemde.min.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../vue-style-loader/lib/addStylesClient.js\")(\"0cac9a3e\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/simplemde/dist/simplemde.min.css\n// module id = 1180\n// module chunks = 18","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-48a3e0da\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./index.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"b04691d0\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-48a3e0da\",\"scoped\":false,\"hasInlineConfig\":false}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/MdEditor/index.vue\n// module id = 1219\n// module chunks = 18","/**\r\n * marked - a markdown parser\r\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\r\n * https://github.com/chjj/marked\r\n */\r\n\r\n;(function() {\r\n\r\n/**\r\n * Block-Level Grammar\r\n */\r\n\r\nvar block = {\r\n  newline: /^\\n+/,\r\n  code: /^( {4}[^\\n]+\\n*)+/,\r\n  fences: noop,\r\n  hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\r\n  heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\r\n  nptable: noop,\r\n  lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\r\n  blockquote: /^( *>[^\\n]+(\\n(?!def)[^\\n]+)*\\n*)+/,\r\n  list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\r\n  html: /^ *(?:comment *(?:\\n|\\s*$)|closed *(?:\\n{2,}|\\s*$)|closing *(?:\\n{2,}|\\s*$))/,\r\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\r\n  table: noop,\r\n  paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\r\n  text: /^[^\\n]+/\r\n};\r\n\r\nblock.bullet = /(?:[*+-]|\\d+\\.)/;\r\nblock.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\r\nblock.item = replace(block.item, 'gm')\r\n  (/bull/g, block.bullet)\r\n  ();\r\n\r\nblock.list = replace(block.list)\r\n  (/bull/g, block.bullet)\r\n  ('hr', '\\\\n+(?=\\\\1?(?:[-*_] *){3,}(?:\\\\n+|$))')\r\n  ('def', '\\\\n+(?=' + block.def.source + ')')\r\n  ();\r\n\r\nblock.blockquote = replace(block.blockquote)\r\n  ('def', block.def)\r\n  ();\r\n\r\nblock._tag = '(?!(?:'\r\n  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'\r\n  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'\r\n  + '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|[^\\\\w\\\\s@]*@)\\\\b';\r\n\r\nblock.html = replace(block.html)\r\n  ('comment', /<!--[\\s\\S]*?-->/)\r\n  ('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\r\n  ('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\r\n  (/tag/g, block._tag)\r\n  ();\r\n\r\nblock.paragraph = replace(block.paragraph)\r\n  ('hr', block.hr)\r\n  ('heading', block.heading)\r\n  ('lheading', block.lheading)\r\n  ('blockquote', block.blockquote)\r\n  ('tag', '<' + block._tag)\r\n  ('def', block.def)\r\n  ();\r\n\r\n/**\r\n * Normal Block Grammar\r\n */\r\n\r\nblock.normal = merge({}, block);\r\n\r\n/**\r\n * GFM Block Grammar\r\n */\r\n\r\nblock.gfm = merge({}, block.normal, {\r\n  fences: /^ *(`{3,}|~{3,})[ \\.]*(\\S+)? *\\n([\\s\\S]*?)\\s*\\1 *(?:\\n+|$)/,\r\n  paragraph: /^/,\r\n  heading: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/\r\n});\r\n\r\nblock.gfm.paragraph = replace(block.paragraph)\r\n  ('(?!', '(?!'\r\n    + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|'\r\n    + block.list.source.replace('\\\\1', '\\\\3') + '|')\r\n  ();\r\n\r\n/**\r\n * GFM + Tables Block Grammar\r\n */\r\n\r\nblock.tables = merge({}, block.gfm, {\r\n  nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\r\n  table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/\r\n});\r\n\r\n/**\r\n * Block Lexer\r\n */\r\n\r\nfunction Lexer(options) {\r\n  this.tokens = [];\r\n  this.tokens.links = {};\r\n  this.options = options || marked.defaults;\r\n  this.rules = block.normal;\r\n\r\n  if (this.options.gfm) {\r\n    if (this.options.tables) {\r\n      this.rules = block.tables;\r\n    } else {\r\n      this.rules = block.gfm;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Expose Block Rules\r\n */\r\n\r\nLexer.rules = block;\r\n\r\n/**\r\n * Static Lex Method\r\n */\r\n\r\nLexer.lex = function(src, options) {\r\n  var lexer = new Lexer(options);\r\n  return lexer.lex(src);\r\n};\r\n\r\n/**\r\n * Preprocessing\r\n */\r\n\r\nLexer.prototype.lex = function(src) {\r\n  src = src\r\n    .replace(/\\r\\n|\\r/g, '\\n')\r\n    .replace(/\\t/g, '    ')\r\n    .replace(/\\u00a0/g, ' ')\r\n    .replace(/\\u2424/g, '\\n');\r\n\r\n  return this.token(src, true);\r\n};\r\n\r\n/**\r\n * Lexing\r\n */\r\n\r\nLexer.prototype.token = function(src, top, bq) {\r\n  var src = src.replace(/^ +$/gm, '')\r\n    , next\r\n    , loose\r\n    , cap\r\n    , bull\r\n    , b\r\n    , item\r\n    , space\r\n    , i\r\n    , l;\r\n\r\n  while (src) {\r\n    // newline\r\n    if (cap = this.rules.newline.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      if (cap[0].length > 1) {\r\n        this.tokens.push({\r\n          type: 'space'\r\n        });\r\n      }\r\n    }\r\n\r\n    // code\r\n    if (cap = this.rules.code.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      cap = cap[0].replace(/^ {4}/gm, '');\r\n      this.tokens.push({\r\n        type: 'code',\r\n        text: !this.options.pedantic\r\n          ? cap.replace(/\\n+$/, '')\r\n          : cap\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // fences (gfm)\r\n    if (cap = this.rules.fences.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'code',\r\n        lang: cap[2],\r\n        text: cap[3] || ''\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // heading\r\n    if (cap = this.rules.heading.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'heading',\r\n        depth: cap[1].length,\r\n        text: cap[2]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // table no leading pipe (gfm)\r\n    if (top && (cap = this.rules.nptable.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n\r\n      item = {\r\n        type: 'table',\r\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\r\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\r\n        cells: cap[3].replace(/\\n$/, '').split('\\n')\r\n      };\r\n\r\n      for (i = 0; i < item.align.length; i++) {\r\n        if (/^ *-+: *$/.test(item.align[i])) {\r\n          item.align[i] = 'right';\r\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\r\n          item.align[i] = 'center';\r\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\r\n          item.align[i] = 'left';\r\n        } else {\r\n          item.align[i] = null;\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < item.cells.length; i++) {\r\n        item.cells[i] = item.cells[i].split(/ *\\| */);\r\n      }\r\n\r\n      this.tokens.push(item);\r\n\r\n      continue;\r\n    }\r\n\r\n    // lheading\r\n    if (cap = this.rules.lheading.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'heading',\r\n        depth: cap[2] === '=' ? 1 : 2,\r\n        text: cap[1]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // hr\r\n    if (cap = this.rules.hr.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'hr'\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // blockquote\r\n    if (cap = this.rules.blockquote.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n\r\n      this.tokens.push({\r\n        type: 'blockquote_start'\r\n      });\r\n\r\n      cap = cap[0].replace(/^ *> ?/gm, '');\r\n\r\n      // Pass `top` to keep the current\r\n      // \"toplevel\" state. This is exactly\r\n      // how markdown.pl works.\r\n      this.token(cap, top, true);\r\n\r\n      this.tokens.push({\r\n        type: 'blockquote_end'\r\n      });\r\n\r\n      continue;\r\n    }\r\n\r\n    // list\r\n    if (cap = this.rules.list.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      bull = cap[2];\r\n\r\n      this.tokens.push({\r\n        type: 'list_start',\r\n        ordered: bull.length > 1\r\n      });\r\n\r\n      // Get each top-level item.\r\n      cap = cap[0].match(this.rules.item);\r\n\r\n      next = false;\r\n      l = cap.length;\r\n      i = 0;\r\n\r\n      for (; i < l; i++) {\r\n        item = cap[i];\r\n\r\n        // Remove the list item's bullet\r\n        // so it is seen as the next token.\r\n        space = item.length;\r\n        item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\r\n\r\n        // Outdent whatever the\r\n        // list item contains. Hacky.\r\n        if (~item.indexOf('\\n ')) {\r\n          space -= item.length;\r\n          item = !this.options.pedantic\r\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\r\n            : item.replace(/^ {1,4}/gm, '');\r\n        }\r\n\r\n        // Determine whether the next list item belongs here.\r\n        // Backpedal if it does not belong in this list.\r\n        if (this.options.smartLists && i !== l - 1) {\r\n          b = block.bullet.exec(cap[i + 1])[0];\r\n          if (bull !== b && !(bull.length > 1 && b.length > 1)) {\r\n            src = cap.slice(i + 1).join('\\n') + src;\r\n            i = l - 1;\r\n          }\r\n        }\r\n\r\n        // Determine whether item is loose or not.\r\n        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\r\n        // for discount behavior.\r\n        loose = next || /\\n\\n(?!\\s*$)/.test(item);\r\n        if (i !== l - 1) {\r\n          next = item.charAt(item.length - 1) === '\\n';\r\n          if (!loose) loose = next;\r\n        }\r\n\r\n        this.tokens.push({\r\n          type: loose\r\n            ? 'loose_item_start'\r\n            : 'list_item_start'\r\n        });\r\n\r\n        // Recurse.\r\n        this.token(item, false, bq);\r\n\r\n        this.tokens.push({\r\n          type: 'list_item_end'\r\n        });\r\n      }\r\n\r\n      this.tokens.push({\r\n        type: 'list_end'\r\n      });\r\n\r\n      continue;\r\n    }\r\n\r\n    // html\r\n    if (cap = this.rules.html.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: this.options.sanitize\r\n          ? 'paragraph'\r\n          : 'html',\r\n        pre: !this.options.sanitizer\r\n          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\r\n        text: cap[0]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // def\r\n    if ((!bq && top) && (cap = this.rules.def.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.links[cap[1].toLowerCase()] = {\r\n        href: cap[2],\r\n        title: cap[3]\r\n      };\r\n      continue;\r\n    }\r\n\r\n    // table (gfm)\r\n    if (top && (cap = this.rules.table.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n\r\n      item = {\r\n        type: 'table',\r\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\r\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\r\n        cells: cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n')\r\n      };\r\n\r\n      for (i = 0; i < item.align.length; i++) {\r\n        if (/^ *-+: *$/.test(item.align[i])) {\r\n          item.align[i] = 'right';\r\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\r\n          item.align[i] = 'center';\r\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\r\n          item.align[i] = 'left';\r\n        } else {\r\n          item.align[i] = null;\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < item.cells.length; i++) {\r\n        item.cells[i] = item.cells[i]\r\n          .replace(/^ *\\| *| *\\| *$/g, '')\r\n          .split(/ *\\| */);\r\n      }\r\n\r\n      this.tokens.push(item);\r\n\r\n      continue;\r\n    }\r\n\r\n    // top-level paragraph\r\n    if (top && (cap = this.rules.paragraph.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'paragraph',\r\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\r\n          ? cap[1].slice(0, -1)\r\n          : cap[1]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // text\r\n    if (cap = this.rules.text.exec(src)) {\r\n      // Top-level should never reach here.\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'text',\r\n        text: cap[0]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    if (src) {\r\n      throw new\r\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\r\n    }\r\n  }\r\n\r\n  return this.tokens;\r\n};\r\n\r\n/**\r\n * Inline-Level Grammar\r\n */\r\n\r\nvar inline = {\r\n  escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\r\n  autolink: /^<([^ >]+(@|:\\/)[^ >]+)>/,\r\n  url: noop,\r\n  tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/,\r\n  link: /^!?\\[(inside)\\]\\(href\\)/,\r\n  reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\r\n  nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\r\n  strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\r\n  em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\r\n  code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\r\n  br: /^ {2,}\\n(?!\\s*$)/,\r\n  del: noop,\r\n  text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/\r\n};\r\n\r\ninline._inside = /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/;\r\ninline._href = /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/;\r\n\r\ninline.link = replace(inline.link)\r\n  ('inside', inline._inside)\r\n  ('href', inline._href)\r\n  ();\r\n\r\ninline.reflink = replace(inline.reflink)\r\n  ('inside', inline._inside)\r\n  ();\r\n\r\n/**\r\n * Normal Inline Grammar\r\n */\r\n\r\ninline.normal = merge({}, inline);\r\n\r\n/**\r\n * Pedantic Inline Grammar\r\n */\r\n\r\ninline.pedantic = merge({}, inline.normal, {\r\n  strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\r\n  em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/\r\n});\r\n\r\n/**\r\n * GFM Inline Grammar\r\n */\r\n\r\ninline.gfm = merge({}, inline.normal, {\r\n  escape: replace(inline.escape)('])', '~|])')(),\r\n  url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\r\n  del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\r\n  text: replace(inline.text)\r\n    (']|', '~]|')\r\n    ('|', '|https?://|')\r\n    ()\r\n});\r\n\r\n/**\r\n * GFM + Line Breaks Inline Grammar\r\n */\r\n\r\ninline.breaks = merge({}, inline.gfm, {\r\n  br: replace(inline.br)('{2,}', '*')(),\r\n  text: replace(inline.gfm.text)('{2,}', '*')()\r\n});\r\n\r\n/**\r\n * Inline Lexer & Compiler\r\n */\r\n\r\nfunction InlineLexer(links, options) {\r\n  this.options = options || marked.defaults;\r\n  this.links = links;\r\n  this.rules = inline.normal;\r\n  this.renderer = this.options.renderer || new Renderer;\r\n  this.renderer.options = this.options;\r\n\r\n  if (!this.links) {\r\n    throw new\r\n      Error('Tokens array requires a `links` property.');\r\n  }\r\n\r\n  if (this.options.gfm) {\r\n    if (this.options.breaks) {\r\n      this.rules = inline.breaks;\r\n    } else {\r\n      this.rules = inline.gfm;\r\n    }\r\n  } else if (this.options.pedantic) {\r\n    this.rules = inline.pedantic;\r\n  }\r\n}\r\n\r\n/**\r\n * Expose Inline Rules\r\n */\r\n\r\nInlineLexer.rules = inline;\r\n\r\n/**\r\n * Static Lexing/Compiling Method\r\n */\r\n\r\nInlineLexer.output = function(src, links, options) {\r\n  var inline = new InlineLexer(links, options);\r\n  return inline.output(src);\r\n};\r\n\r\n/**\r\n * Lexing/Compiling\r\n */\r\n\r\nInlineLexer.prototype.output = function(src) {\r\n  var out = ''\r\n    , link\r\n    , text\r\n    , href\r\n    , cap;\r\n\r\n  while (src) {\r\n    // escape\r\n    if (cap = this.rules.escape.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += cap[1];\r\n      continue;\r\n    }\r\n\r\n    // autolink\r\n    if (cap = this.rules.autolink.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      if (cap[2] === '@') {\r\n        text = cap[1].charAt(6) === ':'\r\n          ? this.mangle(cap[1].substring(7))\r\n          : this.mangle(cap[1]);\r\n        href = this.mangle('mailto:') + text;\r\n      } else {\r\n        text = escape(cap[1]);\r\n        href = text;\r\n      }\r\n      out += this.renderer.link(href, null, text);\r\n      continue;\r\n    }\r\n\r\n    // url (gfm)\r\n    if (!this.inLink && (cap = this.rules.url.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n      text = escape(cap[1]);\r\n      href = text;\r\n      out += this.renderer.link(href, null, text);\r\n      continue;\r\n    }\r\n\r\n    // tag\r\n    if (cap = this.rules.tag.exec(src)) {\r\n      if (!this.inLink && /^<a /i.test(cap[0])) {\r\n        this.inLink = true;\r\n      } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\r\n        this.inLink = false;\r\n      }\r\n      src = src.substring(cap[0].length);\r\n      out += this.options.sanitize\r\n        ? this.options.sanitizer\r\n          ? this.options.sanitizer(cap[0])\r\n          : escape(cap[0])\r\n        : cap[0]\r\n      continue;\r\n    }\r\n\r\n    // link\r\n    if (cap = this.rules.link.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.inLink = true;\r\n      out += this.outputLink(cap, {\r\n        href: cap[2],\r\n        title: cap[3]\r\n      });\r\n      this.inLink = false;\r\n      continue;\r\n    }\r\n\r\n    // reflink, nolink\r\n    if ((cap = this.rules.reflink.exec(src))\r\n        || (cap = this.rules.nolink.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n      link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\r\n      link = this.links[link.toLowerCase()];\r\n      if (!link || !link.href) {\r\n        out += cap[0].charAt(0);\r\n        src = cap[0].substring(1) + src;\r\n        continue;\r\n      }\r\n      this.inLink = true;\r\n      out += this.outputLink(cap, link);\r\n      this.inLink = false;\r\n      continue;\r\n    }\r\n\r\n    // strong\r\n    if (cap = this.rules.strong.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.strong(this.output(cap[2] || cap[1]));\r\n      continue;\r\n    }\r\n\r\n    // em\r\n    if (cap = this.rules.em.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.em(this.output(cap[2] || cap[1]));\r\n      continue;\r\n    }\r\n\r\n    // code\r\n    if (cap = this.rules.code.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.codespan(escape(cap[2], true));\r\n      continue;\r\n    }\r\n\r\n    // br\r\n    if (cap = this.rules.br.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.br();\r\n      continue;\r\n    }\r\n\r\n    // del (gfm)\r\n    if (cap = this.rules.del.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.del(this.output(cap[1]));\r\n      continue;\r\n    }\r\n\r\n    // text\r\n    if (cap = this.rules.text.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.text(escape(this.smartypants(cap[0])));\r\n      continue;\r\n    }\r\n\r\n    if (src) {\r\n      throw new\r\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\r\n    }\r\n  }\r\n\r\n  return out;\r\n};\r\n\r\n/**\r\n * Compile Link\r\n */\r\n\r\nInlineLexer.prototype.outputLink = function(cap, link) {\r\n  var href = escape(link.href)\r\n    , title = link.title ? escape(link.title) : null;\r\n\r\n  return cap[0].charAt(0) !== '!'\r\n    ? this.renderer.link(href, title, this.output(cap[1]))\r\n    : this.renderer.image(href, title, escape(cap[1]));\r\n};\r\n\r\n/**\r\n * Smartypants Transformations\r\n */\r\n\r\nInlineLexer.prototype.smartypants = function(text) {\r\n  if (!this.options.smartypants) return text;\r\n  return text\r\n    // em-dashes\r\n    .replace(/---/g, '\\u2014')\r\n    // en-dashes\r\n    .replace(/--/g, '\\u2013')\r\n    // opening singles\r\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\r\n    // closing singles & apostrophes\r\n    .replace(/'/g, '\\u2019')\r\n    // opening doubles\r\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\r\n    // closing doubles\r\n    .replace(/\"/g, '\\u201d')\r\n    // ellipses\r\n    .replace(/\\.{3}/g, '\\u2026');\r\n};\r\n\r\n/**\r\n * Mangle Links\r\n */\r\n\r\nInlineLexer.prototype.mangle = function(text) {\r\n  if (!this.options.mangle) return text;\r\n  var out = ''\r\n    , l = text.length\r\n    , i = 0\r\n    , ch;\r\n\r\n  for (; i < l; i++) {\r\n    ch = text.charCodeAt(i);\r\n    if (Math.random() > 0.5) {\r\n      ch = 'x' + ch.toString(16);\r\n    }\r\n    out += '&#' + ch + ';';\r\n  }\r\n\r\n  return out;\r\n};\r\n\r\n/**\r\n * Renderer\r\n */\r\n\r\nfunction Renderer(options) {\r\n  this.options = options || {};\r\n}\r\n\r\nRenderer.prototype.code = function(code, lang, escaped) {\r\n  if (this.options.highlight) {\r\n    var out = this.options.highlight(code, lang);\r\n    if (out != null && out !== code) {\r\n      escaped = true;\r\n      code = out;\r\n    }\r\n  }\r\n\r\n  if (!lang) {\r\n    return '<pre><code>'\r\n      + (escaped ? code : escape(code, true))\r\n      + '\\n</code></pre>';\r\n  }\r\n\r\n  return '<pre><code class=\"'\r\n    + this.options.langPrefix\r\n    + escape(lang, true)\r\n    + '\">'\r\n    + (escaped ? code : escape(code, true))\r\n    + '\\n</code></pre>\\n';\r\n};\r\n\r\nRenderer.prototype.blockquote = function(quote) {\r\n  return '<blockquote>\\n' + quote + '</blockquote>\\n';\r\n};\r\n\r\nRenderer.prototype.html = function(html) {\r\n  return html;\r\n};\r\n\r\nRenderer.prototype.heading = function(text, level, raw) {\r\n  return '<h'\r\n    + level\r\n    + ' id=\"'\r\n    + this.options.headerPrefix\r\n    + raw.toLowerCase().replace(/[^\\w]+/g, '-')\r\n    + '\">'\r\n    + text\r\n    + '</h'\r\n    + level\r\n    + '>\\n';\r\n};\r\n\r\nRenderer.prototype.hr = function() {\r\n  return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\r\n};\r\n\r\nRenderer.prototype.list = function(body, ordered) {\r\n  var type = ordered ? 'ol' : 'ul';\r\n  return '<' + type + '>\\n' + body + '</' + type + '>\\n';\r\n};\r\n\r\nRenderer.prototype.listitem = function(text) {\r\n  return '<li>' + text + '</li>\\n';\r\n};\r\n\r\nRenderer.prototype.paragraph = function(text) {\r\n  return '<p>' + text + '</p>\\n';\r\n};\r\n\r\nRenderer.prototype.table = function(header, body) {\r\n  return '<table>\\n'\r\n    + '<thead>\\n'\r\n    + header\r\n    + '</thead>\\n'\r\n    + '<tbody>\\n'\r\n    + body\r\n    + '</tbody>\\n'\r\n    + '</table>\\n';\r\n};\r\n\r\nRenderer.prototype.tablerow = function(content) {\r\n  return '<tr>\\n' + content + '</tr>\\n';\r\n};\r\n\r\nRenderer.prototype.tablecell = function(content, flags) {\r\n  var type = flags.header ? 'th' : 'td';\r\n  var tag = flags.align\r\n    ? '<' + type + ' style=\"text-align:' + flags.align + '\">'\r\n    : '<' + type + '>';\r\n  return tag + content + '</' + type + '>\\n';\r\n};\r\n\r\n// span level renderer\r\nRenderer.prototype.strong = function(text) {\r\n  return '<strong>' + text + '</strong>';\r\n};\r\n\r\nRenderer.prototype.em = function(text) {\r\n  return '<em>' + text + '</em>';\r\n};\r\n\r\nRenderer.prototype.codespan = function(text) {\r\n  return '<code>' + text + '</code>';\r\n};\r\n\r\nRenderer.prototype.br = function() {\r\n  return this.options.xhtml ? '<br/>' : '<br>';\r\n};\r\n\r\nRenderer.prototype.del = function(text) {\r\n  return '<del>' + text + '</del>';\r\n};\r\n\r\nRenderer.prototype.link = function(href, title, text) {\r\n  if (this.options.sanitize) {\r\n    try {\r\n      var prot = decodeURIComponent(unescape(href))\r\n        .replace(/[^\\w:]/g, '')\r\n        .toLowerCase();\r\n    } catch (e) {\r\n      return '';\r\n    }\r\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {\r\n      return '';\r\n    }\r\n  }\r\n  var out = '<a href=\"' + href + '\"';\r\n  if (title) {\r\n    out += ' title=\"' + title + '\"';\r\n  }\r\n  out += '>' + text + '</a>';\r\n  return out;\r\n};\r\n\r\nRenderer.prototype.image = function(href, title, text) {\r\n  var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\r\n  if (title) {\r\n    out += ' title=\"' + title + '\"';\r\n  }\r\n  out += this.options.xhtml ? '/>' : '>';\r\n  return out;\r\n};\r\n\r\nRenderer.prototype.text = function(text) {\r\n  return text;\r\n};\r\n\r\n/**\r\n * Parsing & Compiling\r\n */\r\n\r\nfunction Parser(options) {\r\n  this.tokens = [];\r\n  this.token = null;\r\n  this.options = options || marked.defaults;\r\n  this.options.renderer = this.options.renderer || new Renderer;\r\n  this.renderer = this.options.renderer;\r\n  this.renderer.options = this.options;\r\n}\r\n\r\n/**\r\n * Static Parse Method\r\n */\r\n\r\nParser.parse = function(src, options, renderer) {\r\n  var parser = new Parser(options, renderer);\r\n  return parser.parse(src);\r\n};\r\n\r\n/**\r\n * Parse Loop\r\n */\r\n\r\nParser.prototype.parse = function(src) {\r\n  this.inline = new InlineLexer(src.links, this.options, this.renderer);\r\n  this.tokens = src.reverse();\r\n\r\n  var out = '';\r\n  while (this.next()) {\r\n    out += this.tok();\r\n  }\r\n\r\n  return out;\r\n};\r\n\r\n/**\r\n * Next Token\r\n */\r\n\r\nParser.prototype.next = function() {\r\n  return this.token = this.tokens.pop();\r\n};\r\n\r\n/**\r\n * Preview Next Token\r\n */\r\n\r\nParser.prototype.peek = function() {\r\n  return this.tokens[this.tokens.length - 1] || 0;\r\n};\r\n\r\n/**\r\n * Parse Text Tokens\r\n */\r\n\r\nParser.prototype.parseText = function() {\r\n  var body = this.token.text;\r\n\r\n  while (this.peek().type === 'text') {\r\n    body += '\\n' + this.next().text;\r\n  }\r\n\r\n  return this.inline.output(body);\r\n};\r\n\r\n/**\r\n * Parse Current Token\r\n */\r\n\r\nParser.prototype.tok = function() {\r\n  switch (this.token.type) {\r\n    case 'space': {\r\n      return '';\r\n    }\r\n    case 'hr': {\r\n      return this.renderer.hr();\r\n    }\r\n    case 'heading': {\r\n      return this.renderer.heading(\r\n        this.inline.output(this.token.text),\r\n        this.token.depth,\r\n        this.token.text);\r\n    }\r\n    case 'code': {\r\n      return this.renderer.code(this.token.text,\r\n        this.token.lang,\r\n        this.token.escaped);\r\n    }\r\n    case 'table': {\r\n      var header = ''\r\n        , body = ''\r\n        , i\r\n        , row\r\n        , cell\r\n        , flags\r\n        , j;\r\n\r\n      // header\r\n      cell = '';\r\n      for (i = 0; i < this.token.header.length; i++) {\r\n        flags = { header: true, align: this.token.align[i] };\r\n        cell += this.renderer.tablecell(\r\n          this.inline.output(this.token.header[i]),\r\n          { header: true, align: this.token.align[i] }\r\n        );\r\n      }\r\n      header += this.renderer.tablerow(cell);\r\n\r\n      for (i = 0; i < this.token.cells.length; i++) {\r\n        row = this.token.cells[i];\r\n\r\n        cell = '';\r\n        for (j = 0; j < row.length; j++) {\r\n          cell += this.renderer.tablecell(\r\n            this.inline.output(row[j]),\r\n            { header: false, align: this.token.align[j] }\r\n          );\r\n        }\r\n\r\n        body += this.renderer.tablerow(cell);\r\n      }\r\n      return this.renderer.table(header, body);\r\n    }\r\n    case 'blockquote_start': {\r\n      var body = '';\r\n\r\n      while (this.next().type !== 'blockquote_end') {\r\n        body += this.tok();\r\n      }\r\n\r\n      return this.renderer.blockquote(body);\r\n    }\r\n    case 'list_start': {\r\n      var body = ''\r\n        , ordered = this.token.ordered;\r\n\r\n      while (this.next().type !== 'list_end') {\r\n        body += this.tok();\r\n      }\r\n\r\n      return this.renderer.list(body, ordered);\r\n    }\r\n    case 'list_item_start': {\r\n      var body = '';\r\n\r\n      while (this.next().type !== 'list_item_end') {\r\n        body += this.token.type === 'text'\r\n          ? this.parseText()\r\n          : this.tok();\r\n      }\r\n\r\n      return this.renderer.listitem(body);\r\n    }\r\n    case 'loose_item_start': {\r\n      var body = '';\r\n\r\n      while (this.next().type !== 'list_item_end') {\r\n        body += this.tok();\r\n      }\r\n\r\n      return this.renderer.listitem(body);\r\n    }\r\n    case 'html': {\r\n      var html = !this.token.pre && !this.options.pedantic\r\n        ? this.inline.output(this.token.text)\r\n        : this.token.text;\r\n      return this.renderer.html(html);\r\n    }\r\n    case 'paragraph': {\r\n      return this.renderer.paragraph(this.inline.output(this.token.text));\r\n    }\r\n    case 'text': {\r\n      return this.renderer.paragraph(this.parseText());\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Helpers\r\n */\r\n\r\nfunction escape(html, encode) {\r\n  return html\r\n    .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\"/g, '&quot;')\r\n    .replace(/'/g, '&#39;');\r\n}\r\n\r\nfunction unescape(html) {\r\n\t// explicitly match decimal, hex, and named HTML entities \r\n  return html.replace(/&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/g, function(_, n) {\r\n    n = n.toLowerCase();\r\n    if (n === 'colon') return ':';\r\n    if (n.charAt(0) === '#') {\r\n      return n.charAt(1) === 'x'\r\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\r\n        : String.fromCharCode(+n.substring(1));\r\n    }\r\n    return '';\r\n  });\r\n}\r\n\r\nfunction replace(regex, opt) {\r\n  regex = regex.source;\r\n  opt = opt || '';\r\n  return function self(name, val) {\r\n    if (!name) return new RegExp(regex, opt);\r\n    val = val.source || val;\r\n    val = val.replace(/(^|[^\\[])\\^/g, '$1');\r\n    regex = regex.replace(name, val);\r\n    return self;\r\n  };\r\n}\r\n\r\nfunction noop() {}\r\nnoop.exec = noop;\r\n\r\nfunction merge(obj) {\r\n  var i = 1\r\n    , target\r\n    , key;\r\n\r\n  for (; i < arguments.length; i++) {\r\n    target = arguments[i];\r\n    for (key in target) {\r\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\r\n        obj[key] = target[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\n\r\n/**\r\n * Marked\r\n */\r\n\r\nfunction marked(src, opt, callback) {\r\n  if (callback || typeof opt === 'function') {\r\n    if (!callback) {\r\n      callback = opt;\r\n      opt = null;\r\n    }\r\n\r\n    opt = merge({}, marked.defaults, opt || {});\r\n\r\n    var highlight = opt.highlight\r\n      , tokens\r\n      , pending\r\n      , i = 0;\r\n\r\n    try {\r\n      tokens = Lexer.lex(src, opt)\r\n    } catch (e) {\r\n      return callback(e);\r\n    }\r\n\r\n    pending = tokens.length;\r\n\r\n    var done = function(err) {\r\n      if (err) {\r\n        opt.highlight = highlight;\r\n        return callback(err);\r\n      }\r\n\r\n      var out;\r\n\r\n      try {\r\n        out = Parser.parse(tokens, opt);\r\n      } catch (e) {\r\n        err = e;\r\n      }\r\n\r\n      opt.highlight = highlight;\r\n\r\n      return err\r\n        ? callback(err)\r\n        : callback(null, out);\r\n    };\r\n\r\n    if (!highlight || highlight.length < 3) {\r\n      return done();\r\n    }\r\n\r\n    delete opt.highlight;\r\n\r\n    if (!pending) return done();\r\n\r\n    for (; i < tokens.length; i++) {\r\n      (function(token) {\r\n        if (token.type !== 'code') {\r\n          return --pending || done();\r\n        }\r\n        return highlight(token.text, token.lang, function(err, code) {\r\n          if (err) return done(err);\r\n          if (code == null || code === token.text) {\r\n            return --pending || done();\r\n          }\r\n          token.text = code;\r\n          token.escaped = true;\r\n          --pending || done();\r\n        });\r\n      })(tokens[i]);\r\n    }\r\n\r\n    return;\r\n  }\r\n  try {\r\n    if (opt) opt = merge({}, marked.defaults, opt);\r\n    return Parser.parse(Lexer.lex(src, opt), opt);\r\n  } catch (e) {\r\n    e.message += '\\nPlease report this to https://github.com/chjj/marked.';\r\n    if ((opt || marked.defaults).silent) {\r\n      return '<p>An error occured:</p><pre>'\r\n        + escape(e.message + '', true)\r\n        + '</pre>';\r\n    }\r\n    throw e;\r\n  }\r\n}\r\n\r\n/**\r\n * Options\r\n */\r\n\r\nmarked.options =\r\nmarked.setOptions = function(opt) {\r\n  merge(marked.defaults, opt);\r\n  return marked;\r\n};\r\n\r\nmarked.defaults = {\r\n  gfm: true,\r\n  tables: true,\r\n  breaks: false,\r\n  pedantic: false,\r\n  sanitize: false,\r\n  sanitizer: null,\r\n  mangle: true,\r\n  smartLists: false,\r\n  silent: false,\r\n  highlight: null,\r\n  langPrefix: 'lang-',\r\n  smartypants: false,\r\n  headerPrefix: '',\r\n  renderer: new Renderer,\r\n  xhtml: false\r\n};\r\n\r\n/**\r\n * Expose\r\n */\r\n\r\nmarked.Parser = Parser;\r\nmarked.parser = Parser.parse;\r\n\r\nmarked.Renderer = Renderer;\r\n\r\nmarked.Lexer = Lexer;\r\nmarked.lexer = Lexer.lex;\r\n\r\nmarked.InlineLexer = InlineLexer;\r\nmarked.inlineLexer = InlineLexer.output;\r\n\r\nmarked.parse = marked;\r\n\r\nif (typeof module !== 'undefined' && typeof exports === 'object') {\r\n  module.exports = marked;\r\n} else if (typeof define === 'function' && define.amd) {\r\n  define(function() { return marked; });\r\n} else {\r\n  this.marked = marked;\r\n}\r\n\r\n}).call(function() {\r\n  return this || (typeof window !== 'undefined' ? window : global);\r\n}());\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/marked/lib/marked.js\n// module id = 1271\n// module chunks = 18","// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\nvar CodeMirror = require(\"codemirror\");\r\n\r\nCodeMirror.commands.tabAndIndentMarkdownList = function (cm) {\r\n\tvar ranges = cm.listSelections();\r\n\tvar pos = ranges[0].head;\r\n\tvar eolState = cm.getStateAfter(pos.line);\r\n\tvar inList = eolState.list !== false;\r\n\r\n\tif (inList) {\r\n\t\tcm.execCommand(\"indentMore\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (cm.options.indentWithTabs) {\r\n\t\tcm.execCommand(\"insertTab\");\r\n\t}\r\n\telse {\r\n\t\tvar spaces = Array(cm.options.tabSize + 1).join(\" \");\r\n\t\tcm.replaceSelection(spaces);\r\n\t}\r\n};\r\n\r\nCodeMirror.commands.shiftTabAndUnindentMarkdownList = function (cm) {\r\n\tvar ranges = cm.listSelections();\r\n\tvar pos = ranges[0].head;\r\n\tvar eolState = cm.getStateAfter(pos.line);\r\n\tvar inList = eolState.list !== false;\r\n\r\n\tif (inList) {\r\n\t\tcm.execCommand(\"indentLess\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (cm.options.indentWithTabs) {\r\n\t\tcm.execCommand(\"insertTab\");\r\n\t}\r\n\telse {\r\n\t\tvar spaces = Array(cm.options.tabSize + 1).join(\" \");\r\n\t\tcm.replaceSelection(spaces);\r\n\t}\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/simplemde/src/js/codemirror/tablist.js\n// module id = 1281\n// module chunks = 18","/*global require,module*/\r\n\"use strict\";\r\nvar CodeMirror = require(\"codemirror\");\r\nrequire(\"codemirror/addon/edit/continuelist.js\");\r\nrequire(\"./codemirror/tablist\");\r\nrequire(\"codemirror/addon/display/fullscreen.js\");\r\nrequire(\"codemirror/mode/markdown/markdown.js\");\r\nrequire(\"codemirror/addon/mode/overlay.js\");\r\nrequire(\"codemirror/addon/display/placeholder.js\");\r\nrequire(\"codemirror/addon/selection/mark-selection.js\");\r\nrequire(\"codemirror/mode/gfm/gfm.js\");\r\nrequire(\"codemirror/mode/xml/xml.js\");\r\nvar CodeMirrorSpellChecker = require(\"codemirror-spell-checker\");\r\nvar marked = require(\"marked\");\r\n\r\n\r\n// Some variables\r\nvar isMac = /Mac/.test(navigator.platform);\r\n\r\n// Mapping of actions that can be bound to keyboard shortcuts or toolbar buttons\r\nvar bindings = {\r\n\t\"toggleBold\": toggleBold,\r\n\t\"toggleItalic\": toggleItalic,\r\n\t\"drawLink\": drawLink,\r\n\t\"toggleHeadingSmaller\": toggleHeadingSmaller,\r\n\t\"toggleHeadingBigger\": toggleHeadingBigger,\r\n\t\"drawImage\": drawImage,\r\n\t\"toggleBlockquote\": toggleBlockquote,\r\n\t\"toggleOrderedList\": toggleOrderedList,\r\n\t\"toggleUnorderedList\": toggleUnorderedList,\r\n\t\"toggleCodeBlock\": toggleCodeBlock,\r\n\t\"togglePreview\": togglePreview,\r\n\t\"toggleStrikethrough\": toggleStrikethrough,\r\n\t\"toggleHeading1\": toggleHeading1,\r\n\t\"toggleHeading2\": toggleHeading2,\r\n\t\"toggleHeading3\": toggleHeading3,\r\n\t\"cleanBlock\": cleanBlock,\r\n\t\"drawTable\": drawTable,\r\n\t\"drawHorizontalRule\": drawHorizontalRule,\r\n\t\"undo\": undo,\r\n\t\"redo\": redo,\r\n\t\"toggleSideBySide\": toggleSideBySide,\r\n\t\"toggleFullScreen\": toggleFullScreen\r\n};\r\n\r\nvar shortcuts = {\r\n\t\"toggleBold\": \"Cmd-B\",\r\n\t\"toggleItalic\": \"Cmd-I\",\r\n\t\"drawLink\": \"Cmd-K\",\r\n\t\"toggleHeadingSmaller\": \"Cmd-H\",\r\n\t\"toggleHeadingBigger\": \"Shift-Cmd-H\",\r\n\t\"cleanBlock\": \"Cmd-E\",\r\n\t\"drawImage\": \"Cmd-Alt-I\",\r\n\t\"toggleBlockquote\": \"Cmd-'\",\r\n\t\"toggleOrderedList\": \"Cmd-Alt-L\",\r\n\t\"toggleUnorderedList\": \"Cmd-L\",\r\n\t\"toggleCodeBlock\": \"Cmd-Alt-C\",\r\n\t\"togglePreview\": \"Cmd-P\",\r\n\t\"toggleSideBySide\": \"F9\",\r\n\t\"toggleFullScreen\": \"F11\"\r\n};\r\n\r\nvar getBindingName = function(f) {\r\n\tfor(var key in bindings) {\r\n\t\tif(bindings[key] === f) {\r\n\t\t\treturn key;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nvar isMobile = function() {\r\n\tvar check = false;\r\n\t(function(a) {\r\n\t\tif(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4))) check = true;\r\n\t})(navigator.userAgent || navigator.vendor || window.opera);\r\n\treturn check;\r\n};\r\n\r\n\r\n/**\r\n * Fix shortcut. Mac use Command, others use Ctrl.\r\n */\r\nfunction fixShortcut(name) {\r\n\tif(isMac) {\r\n\t\tname = name.replace(\"Ctrl\", \"Cmd\");\r\n\t} else {\r\n\t\tname = name.replace(\"Cmd\", \"Ctrl\");\r\n\t}\r\n\treturn name;\r\n}\r\n\r\n\r\n/**\r\n * Create icon element for toolbar.\r\n */\r\nfunction createIcon(options, enableTooltips, shortcuts) {\r\n\toptions = options || {};\r\n\tvar el = document.createElement(\"a\");\r\n\tenableTooltips = (enableTooltips == undefined) ? true : enableTooltips;\r\n\r\n\tif(options.title && enableTooltips) {\r\n\t\tel.title = createTootlip(options.title, options.action, shortcuts);\r\n\r\n\t\tif(isMac) {\r\n\t\t\tel.title = el.title.replace(\"Ctrl\", \"⌘\");\r\n\t\t\tel.title = el.title.replace(\"Alt\", \"⌥\");\r\n\t\t}\r\n\t}\r\n\r\n\tel.tabIndex = -1;\r\n\tel.className = options.className;\r\n\treturn el;\r\n}\r\n\r\nfunction createSep() {\r\n\tvar el = document.createElement(\"i\");\r\n\tel.className = \"separator\";\r\n\tel.innerHTML = \"|\";\r\n\treturn el;\r\n}\r\n\r\nfunction createTootlip(title, action, shortcuts) {\r\n\tvar actionName;\r\n\tvar tooltip = title;\r\n\r\n\tif(action) {\r\n\t\tactionName = getBindingName(action);\r\n\t\tif(shortcuts[actionName]) {\r\n\t\t\ttooltip += \" (\" + fixShortcut(shortcuts[actionName]) + \")\";\r\n\t\t}\r\n\t}\r\n\r\n\treturn tooltip;\r\n}\r\n\r\n/**\r\n * The state of CodeMirror at the given position.\r\n */\r\nfunction getState(cm, pos) {\r\n\tpos = pos || cm.getCursor(\"start\");\r\n\tvar stat = cm.getTokenAt(pos);\r\n\tif(!stat.type) return {};\r\n\r\n\tvar types = stat.type.split(\" \");\r\n\r\n\tvar ret = {},\r\n\t\tdata, text;\r\n\tfor(var i = 0; i < types.length; i++) {\r\n\t\tdata = types[i];\r\n\t\tif(data === \"strong\") {\r\n\t\t\tret.bold = true;\r\n\t\t} else if(data === \"variable-2\") {\r\n\t\t\ttext = cm.getLine(pos.line);\r\n\t\t\tif(/^\\s*\\d+\\.\\s/.test(text)) {\r\n\t\t\t\tret[\"ordered-list\"] = true;\r\n\t\t\t} else {\r\n\t\t\t\tret[\"unordered-list\"] = true;\r\n\t\t\t}\r\n\t\t} else if(data === \"atom\") {\r\n\t\t\tret.quote = true;\r\n\t\t} else if(data === \"em\") {\r\n\t\t\tret.italic = true;\r\n\t\t} else if(data === \"quote\") {\r\n\t\t\tret.quote = true;\r\n\t\t} else if(data === \"strikethrough\") {\r\n\t\t\tret.strikethrough = true;\r\n\t\t} else if(data === \"comment\") {\r\n\t\t\tret.code = true;\r\n\t\t} else if(data === \"link\") {\r\n\t\t\tret.link = true;\r\n\t\t} else if(data === \"tag\") {\r\n\t\t\tret.image = true;\r\n\t\t} else if(data.match(/^header(\\-[1-6])?$/)) {\r\n\t\t\tret[data.replace(\"header\", \"heading\")] = true;\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n\r\n// Saved overflow setting\r\nvar saved_overflow = \"\";\r\n\r\n/**\r\n * Toggle full screen of the editor.\r\n */\r\nfunction toggleFullScreen(editor) {\r\n\t// Set fullscreen\r\n\tvar cm = editor.codemirror;\r\n\tcm.setOption(\"fullScreen\", !cm.getOption(\"fullScreen\"));\r\n\r\n\r\n\t// Prevent scrolling on body during fullscreen active\r\n\tif(cm.getOption(\"fullScreen\")) {\r\n\t\tsaved_overflow = document.body.style.overflow;\r\n\t\tdocument.body.style.overflow = \"hidden\";\r\n\t} else {\r\n\t\tdocument.body.style.overflow = saved_overflow;\r\n\t}\r\n\r\n\r\n\t// Update toolbar class\r\n\tvar wrap = cm.getWrapperElement();\r\n\r\n\tif(!/fullscreen/.test(wrap.previousSibling.className)) {\r\n\t\twrap.previousSibling.className += \" fullscreen\";\r\n\t} else {\r\n\t\twrap.previousSibling.className = wrap.previousSibling.className.replace(/\\s*fullscreen\\b/, \"\");\r\n\t}\r\n\r\n\r\n\t// Update toolbar button\r\n\tvar toolbarButton = editor.toolbarElements.fullscreen;\r\n\r\n\tif(!/active/.test(toolbarButton.className)) {\r\n\t\ttoolbarButton.className += \" active\";\r\n\t} else {\r\n\t\ttoolbarButton.className = toolbarButton.className.replace(/\\s*active\\s*/g, \"\");\r\n\t}\r\n\r\n\r\n\t// Hide side by side if needed\r\n\tvar sidebyside = cm.getWrapperElement().nextSibling;\r\n\tif(/editor-preview-active-side/.test(sidebyside.className))\r\n\t\ttoggleSideBySide(editor);\r\n}\r\n\r\n\r\n/**\r\n * Action for toggling bold.\r\n */\r\nfunction toggleBold(editor) {\r\n\t_toggleBlock(editor, \"bold\", editor.options.blockStyles.bold);\r\n}\r\n\r\n\r\n/**\r\n * Action for toggling italic.\r\n */\r\nfunction toggleItalic(editor) {\r\n\t_toggleBlock(editor, \"italic\", editor.options.blockStyles.italic);\r\n}\r\n\r\n\r\n/**\r\n * Action for toggling strikethrough.\r\n */\r\nfunction toggleStrikethrough(editor) {\r\n\t_toggleBlock(editor, \"strikethrough\", \"~~\");\r\n}\r\n\r\n/**\r\n * Action for toggling code block.\r\n */\r\nfunction toggleCodeBlock(editor) {\r\n\tvar fenceCharsToInsert = editor.options.blockStyles.code;\r\n\r\n\tfunction fencing_line(line) {\r\n\t\t/* return true, if this is a ``` or ~~~ line */\r\n\t\tif(typeof line !== \"object\") {\r\n\t\t\tthrow \"fencing_line() takes a 'line' object (not a line number, or line text).  Got: \" + typeof line + \": \" + line;\r\n\t\t}\r\n\t\treturn line.styles && line.styles[2] && line.styles[2].indexOf(\"formatting-code-block\") !== -1;\r\n\t}\r\n\r\n\tfunction token_state(token) {\r\n\t\t// base goes an extra level deep when mode backdrops are used, e.g. spellchecker on\r\n\t\treturn token.state.base.base || token.state.base;\r\n\t}\r\n\r\n\tfunction code_type(cm, line_num, line, firstTok, lastTok) {\r\n\t\t/*\r\n\t\t * Return \"single\", \"indented\", \"fenced\" or false\r\n\t\t *\r\n\t\t * cm and line_num are required.  Others are optional for efficiency\r\n\t\t *   To check in the middle of a line, pass in firstTok yourself.\r\n\t\t */\r\n\t\tline = line || cm.getLineHandle(line_num);\r\n\t\tfirstTok = firstTok || cm.getTokenAt({\r\n\t\t\tline: line_num,\r\n\t\t\tch: 1\r\n\t\t});\r\n\t\tlastTok = lastTok || (!!line.text && cm.getTokenAt({\r\n\t\t\tline: line_num,\r\n\t\t\tch: line.text.length - 1\r\n\t\t}));\r\n\t\tvar types = firstTok.type ? firstTok.type.split(\" \") : [];\r\n\t\tif(lastTok && token_state(lastTok).indentedCode) {\r\n\t\t\t// have to check last char, since first chars of first line aren\"t marked as indented\r\n\t\t\treturn \"indented\";\r\n\t\t} else if(types.indexOf(\"comment\") === -1) {\r\n\t\t\t// has to be after \"indented\" check, since first chars of first indented line aren\"t marked as such\r\n\t\t\treturn false;\r\n\t\t} else if(token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line)) {\r\n\t\t\treturn \"fenced\";\r\n\t\t} else {\r\n\t\t\treturn \"single\";\r\n\t\t}\r\n\t}\r\n\r\n\tfunction insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert) {\r\n\t\tvar start_line_sel = cur_start.line + 1,\r\n\t\t\tend_line_sel = cur_end.line + 1,\r\n\t\t\tsel_multi = cur_start.line !== cur_end.line,\r\n\t\t\trepl_start = fenceCharsToInsert + \"\\n\",\r\n\t\t\trepl_end = \"\\n\" + fenceCharsToInsert;\r\n\t\tif(sel_multi) {\r\n\t\t\tend_line_sel++;\r\n\t\t}\r\n\t\t// handle last char including \\n or not\r\n\t\tif(sel_multi && cur_end.ch === 0) {\r\n\t\t\trepl_end = fenceCharsToInsert + \"\\n\";\r\n\t\t\tend_line_sel--;\r\n\t\t}\r\n\t\t_replaceSelection(cm, false, [repl_start, repl_end]);\r\n\t\tcm.setSelection({\r\n\t\t\tline: start_line_sel,\r\n\t\t\tch: 0\r\n\t\t}, {\r\n\t\t\tline: end_line_sel,\r\n\t\t\tch: 0\r\n\t\t});\r\n\t}\r\n\r\n\tvar cm = editor.codemirror,\r\n\t\tcur_start = cm.getCursor(\"start\"),\r\n\t\tcur_end = cm.getCursor(\"end\"),\r\n\t\ttok = cm.getTokenAt({\r\n\t\t\tline: cur_start.line,\r\n\t\t\tch: cur_start.ch || 1\r\n\t\t}), // avoid ch 0 which is a cursor pos but not token\r\n\t\tline = cm.getLineHandle(cur_start.line),\r\n\t\tis_code = code_type(cm, cur_start.line, line, tok);\r\n\tvar block_start, block_end, lineCount;\r\n\r\n\tif(is_code === \"single\") {\r\n\t\t// similar to some SimpleMDE _toggleBlock logic\r\n\t\tvar start = line.text.slice(0, cur_start.ch).replace(\"`\", \"\"),\r\n\t\t\tend = line.text.slice(cur_start.ch).replace(\"`\", \"\");\r\n\t\tcm.replaceRange(start + end, {\r\n\t\t\tline: cur_start.line,\r\n\t\t\tch: 0\r\n\t\t}, {\r\n\t\t\tline: cur_start.line,\r\n\t\t\tch: 99999999999999\r\n\t\t});\r\n\t\tcur_start.ch--;\r\n\t\tif(cur_start !== cur_end) {\r\n\t\t\tcur_end.ch--;\r\n\t\t}\r\n\t\tcm.setSelection(cur_start, cur_end);\r\n\t\tcm.focus();\r\n\t} else if(is_code === \"fenced\") {\r\n\t\tif(cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {\r\n\t\t\t// use selection\r\n\r\n\t\t\t// find the fenced line so we know what type it is (tilde, backticks, number of them)\r\n\t\t\tfor(block_start = cur_start.line; block_start >= 0; block_start--) {\r\n\t\t\t\tline = cm.getLineHandle(block_start);\r\n\t\t\t\tif(fencing_line(line)) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar fencedTok = cm.getTokenAt({\r\n\t\t\t\tline: block_start,\r\n\t\t\t\tch: 1\r\n\t\t\t});\r\n\t\t\tvar fence_chars = token_state(fencedTok).fencedChars;\r\n\t\t\tvar start_text, start_line;\r\n\t\t\tvar end_text, end_line;\r\n\t\t\t// check for selection going up against fenced lines, in which case we don't want to add more fencing\r\n\t\t\tif(fencing_line(cm.getLineHandle(cur_start.line))) {\r\n\t\t\t\tstart_text = \"\";\r\n\t\t\t\tstart_line = cur_start.line;\r\n\t\t\t} else if(fencing_line(cm.getLineHandle(cur_start.line - 1))) {\r\n\t\t\t\tstart_text = \"\";\r\n\t\t\t\tstart_line = cur_start.line - 1;\r\n\t\t\t} else {\r\n\t\t\t\tstart_text = fence_chars + \"\\n\";\r\n\t\t\t\tstart_line = cur_start.line;\r\n\t\t\t}\r\n\t\t\tif(fencing_line(cm.getLineHandle(cur_end.line))) {\r\n\t\t\t\tend_text = \"\";\r\n\t\t\t\tend_line = cur_end.line;\r\n\t\t\t\tif(cur_end.ch === 0) {\r\n\t\t\t\t\tend_line += 1;\r\n\t\t\t\t}\r\n\t\t\t} else if(cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {\r\n\t\t\t\tend_text = \"\";\r\n\t\t\t\tend_line = cur_end.line + 1;\r\n\t\t\t} else {\r\n\t\t\t\tend_text = fence_chars + \"\\n\";\r\n\t\t\t\tend_line = cur_end.line + 1;\r\n\t\t\t}\r\n\t\t\tif(cur_end.ch === 0) {\r\n\t\t\t\t// full last line selected, putting cursor at beginning of next\r\n\t\t\t\tend_line -= 1;\r\n\t\t\t}\r\n\t\t\tcm.operation(function() {\r\n\t\t\t\t// end line first, so that line numbers don't change\r\n\t\t\t\tcm.replaceRange(end_text, {\r\n\t\t\t\t\tline: end_line,\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t}, {\r\n\t\t\t\t\tline: end_line + (end_text ? 0 : 1),\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t});\r\n\t\t\t\tcm.replaceRange(start_text, {\r\n\t\t\t\t\tline: start_line,\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t}, {\r\n\t\t\t\t\tline: start_line + (start_text ? 0 : 1),\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t\tcm.setSelection({\r\n\t\t\t\tline: start_line + (start_text ? 1 : 0),\r\n\t\t\t\tch: 0\r\n\t\t\t}, {\r\n\t\t\t\tline: end_line + (start_text ? 1 : -1),\r\n\t\t\t\tch: 0\r\n\t\t\t});\r\n\t\t\tcm.focus();\r\n\t\t} else {\r\n\t\t\t// no selection, search for ends of this fenced block\r\n\t\t\tvar search_from = cur_start.line;\r\n\t\t\tif(fencing_line(cm.getLineHandle(cur_start.line))) { // gets a little tricky if cursor is right on a fenced line\r\n\t\t\t\tif(code_type(cm, cur_start.line + 1) === \"fenced\") {\r\n\t\t\t\t\tblock_start = cur_start.line;\r\n\t\t\t\t\tsearch_from = cur_start.line + 1; // for searching for \"end\"\r\n\t\t\t\t} else {\r\n\t\t\t\t\tblock_end = cur_start.line;\r\n\t\t\t\t\tsearch_from = cur_start.line - 1; // for searching for \"start\"\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(block_start === undefined) {\r\n\t\t\t\tfor(block_start = search_from; block_start >= 0; block_start--) {\r\n\t\t\t\t\tline = cm.getLineHandle(block_start);\r\n\t\t\t\t\tif(fencing_line(line)) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(block_end === undefined) {\r\n\t\t\t\tlineCount = cm.lineCount();\r\n\t\t\t\tfor(block_end = search_from; block_end < lineCount; block_end++) {\r\n\t\t\t\t\tline = cm.getLineHandle(block_end);\r\n\t\t\t\t\tif(fencing_line(line)) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcm.operation(function() {\r\n\t\t\t\tcm.replaceRange(\"\", {\r\n\t\t\t\t\tline: block_start,\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t}, {\r\n\t\t\t\t\tline: block_start + 1,\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t});\r\n\t\t\t\tcm.replaceRange(\"\", {\r\n\t\t\t\t\tline: block_end - 1,\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t}, {\r\n\t\t\t\t\tline: block_end,\r\n\t\t\t\t\tch: 0\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t\tcm.focus();\r\n\t\t}\r\n\t} else if(is_code === \"indented\") {\r\n\t\tif(cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {\r\n\t\t\t// use selection\r\n\t\t\tblock_start = cur_start.line;\r\n\t\t\tblock_end = cur_end.line;\r\n\t\t\tif(cur_end.ch === 0) {\r\n\t\t\t\tblock_end--;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// no selection, search for ends of this indented block\r\n\t\t\tfor(block_start = cur_start.line; block_start >= 0; block_start--) {\r\n\t\t\t\tline = cm.getLineHandle(block_start);\r\n\t\t\t\tif(line.text.match(/^\\s*$/)) {\r\n\t\t\t\t\t// empty or all whitespace - keep going\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif(code_type(cm, block_start, line) !== \"indented\") {\r\n\t\t\t\t\t\tblock_start += 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlineCount = cm.lineCount();\r\n\t\t\tfor(block_end = cur_start.line; block_end < lineCount; block_end++) {\r\n\t\t\t\tline = cm.getLineHandle(block_end);\r\n\t\t\t\tif(line.text.match(/^\\s*$/)) {\r\n\t\t\t\t\t// empty or all whitespace - keep going\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif(code_type(cm, block_end, line) !== \"indented\") {\r\n\t\t\t\t\t\tblock_end -= 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// if we are going to un-indent based on a selected set of lines, and the next line is indented too, we need to\r\n\t\t// insert a blank line so that the next line(s) continue to be indented code\r\n\t\tvar next_line = cm.getLineHandle(block_end + 1),\r\n\t\t\tnext_line_last_tok = next_line && cm.getTokenAt({\r\n\t\t\t\tline: block_end + 1,\r\n\t\t\t\tch: next_line.text.length - 1\r\n\t\t\t}),\r\n\t\t\tnext_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;\r\n\t\tif(next_line_indented) {\r\n\t\t\tcm.replaceRange(\"\\n\", {\r\n\t\t\t\tline: block_end + 1,\r\n\t\t\t\tch: 0\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfor(var i = block_start; i <= block_end; i++) {\r\n\t\t\tcm.indentLine(i, \"subtract\"); // TODO: this doesn't get tracked in the history, so can't be undone :(\r\n\t\t}\r\n\t\tcm.focus();\r\n\t} else {\r\n\t\t// insert code formatting\r\n\t\tvar no_sel_and_starting_of_line = (cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0);\r\n\t\tvar sel_multi = cur_start.line !== cur_end.line;\r\n\t\tif(no_sel_and_starting_of_line || sel_multi) {\r\n\t\t\tinsertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);\r\n\t\t} else {\r\n\t\t\t_replaceSelection(cm, false, [\"`\", \"`\"]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Action for toggling blockquote.\r\n */\r\nfunction toggleBlockquote(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleLine(cm, \"quote\");\r\n}\r\n\r\n/**\r\n * Action for toggling heading size: normal -> h1 -> h2 -> h3 -> h4 -> h5 -> h6 -> normal\r\n */\r\nfunction toggleHeadingSmaller(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleHeading(cm, \"smaller\");\r\n}\r\n\r\n/**\r\n * Action for toggling heading size: normal -> h6 -> h5 -> h4 -> h3 -> h2 -> h1 -> normal\r\n */\r\nfunction toggleHeadingBigger(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleHeading(cm, \"bigger\");\r\n}\r\n\r\n/**\r\n * Action for toggling heading size 1\r\n */\r\nfunction toggleHeading1(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleHeading(cm, undefined, 1);\r\n}\r\n\r\n/**\r\n * Action for toggling heading size 2\r\n */\r\nfunction toggleHeading2(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleHeading(cm, undefined, 2);\r\n}\r\n\r\n/**\r\n * Action for toggling heading size 3\r\n */\r\nfunction toggleHeading3(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleHeading(cm, undefined, 3);\r\n}\r\n\r\n\r\n/**\r\n * Action for toggling ul.\r\n */\r\nfunction toggleUnorderedList(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleLine(cm, \"unordered-list\");\r\n}\r\n\r\n\r\n/**\r\n * Action for toggling ol.\r\n */\r\nfunction toggleOrderedList(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_toggleLine(cm, \"ordered-list\");\r\n}\r\n\r\n/**\r\n * Action for clean block (remove headline, list, blockquote code, markers)\r\n */\r\nfunction cleanBlock(editor) {\r\n\tvar cm = editor.codemirror;\r\n\t_cleanBlock(cm);\r\n}\r\n\r\n/**\r\n * Action for drawing a link.\r\n */\r\nfunction drawLink(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tvar stat = getState(cm);\r\n\tvar options = editor.options;\r\n\tvar url = \"http://\";\r\n\tif(options.promptURLs) {\r\n\t\turl = prompt(options.promptTexts.link);\r\n\t\tif(!url) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t_replaceSelection(cm, stat.link, options.insertTexts.link, url);\r\n}\r\n\r\n/**\r\n * Action for drawing an img.\r\n */\r\nfunction drawImage(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tvar stat = getState(cm);\r\n\tvar options = editor.options;\r\n\tvar url = \"http://\";\r\n\tif(options.promptURLs) {\r\n\t\turl = prompt(options.promptTexts.image);\r\n\t\tif(!url) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t_replaceSelection(cm, stat.image, options.insertTexts.image, url);\r\n}\r\n\r\n/**\r\n * Action for drawing a table.\r\n */\r\nfunction drawTable(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tvar stat = getState(cm);\r\n\tvar options = editor.options;\r\n\t_replaceSelection(cm, stat.table, options.insertTexts.table);\r\n}\r\n\r\n/**\r\n * Action for drawing a horizontal rule.\r\n */\r\nfunction drawHorizontalRule(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tvar stat = getState(cm);\r\n\tvar options = editor.options;\r\n\t_replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);\r\n}\r\n\r\n\r\n/**\r\n * Undo action.\r\n */\r\nfunction undo(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tcm.undo();\r\n\tcm.focus();\r\n}\r\n\r\n\r\n/**\r\n * Redo action.\r\n */\r\nfunction redo(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tcm.redo();\r\n\tcm.focus();\r\n}\r\n\r\n\r\n/**\r\n * Toggle side by side preview\r\n */\r\nfunction toggleSideBySide(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tvar wrapper = cm.getWrapperElement();\r\n\tvar preview = wrapper.nextSibling;\r\n\tvar toolbarButton = editor.toolbarElements[\"side-by-side\"];\r\n\tvar useSideBySideListener = false;\r\n\tif(/editor-preview-active-side/.test(preview.className)) {\r\n\t\tpreview.className = preview.className.replace(\r\n\t\t\t/\\s*editor-preview-active-side\\s*/g, \"\"\r\n\t\t);\r\n\t\ttoolbarButton.className = toolbarButton.className.replace(/\\s*active\\s*/g, \"\");\r\n\t\twrapper.className = wrapper.className.replace(/\\s*CodeMirror-sided\\s*/g, \" \");\r\n\t} else {\r\n\t\t// When the preview button is clicked for the first time,\r\n\t\t// give some time for the transition from editor.css to fire and the view to slide from right to left,\r\n\t\t// instead of just appearing.\r\n\t\tsetTimeout(function() {\r\n\t\t\tif(!cm.getOption(\"fullScreen\"))\r\n\t\t\t\ttoggleFullScreen(editor);\r\n\t\t\tpreview.className += \" editor-preview-active-side\";\r\n\t\t}, 1);\r\n\t\ttoolbarButton.className += \" active\";\r\n\t\twrapper.className += \" CodeMirror-sided\";\r\n\t\tuseSideBySideListener = true;\r\n\t}\r\n\r\n\t// Hide normal preview if active\r\n\tvar previewNormal = wrapper.lastChild;\r\n\tif(/editor-preview-active/.test(previewNormal.className)) {\r\n\t\tpreviewNormal.className = previewNormal.className.replace(\r\n\t\t\t/\\s*editor-preview-active\\s*/g, \"\"\r\n\t\t);\r\n\t\tvar toolbar = editor.toolbarElements.preview;\r\n\t\tvar toolbar_div = wrapper.previousSibling;\r\n\t\ttoolbar.className = toolbar.className.replace(/\\s*active\\s*/g, \"\");\r\n\t\ttoolbar_div.className = toolbar_div.className.replace(/\\s*disabled-for-preview*/g, \"\");\r\n\t}\r\n\r\n\tvar sideBySideRenderingFunction = function() {\r\n\t\tpreview.innerHTML = editor.options.previewRender(editor.value(), preview);\r\n\t};\r\n\r\n\tif(!cm.sideBySideRenderingFunction) {\r\n\t\tcm.sideBySideRenderingFunction = sideBySideRenderingFunction;\r\n\t}\r\n\r\n\tif(useSideBySideListener) {\r\n\t\tpreview.innerHTML = editor.options.previewRender(editor.value(), preview);\r\n\t\tcm.on(\"update\", cm.sideBySideRenderingFunction);\r\n\t} else {\r\n\t\tcm.off(\"update\", cm.sideBySideRenderingFunction);\r\n\t}\r\n\r\n\t// Refresh to fix selection being off (#309)\r\n\tcm.refresh();\r\n}\r\n\r\n\r\n/**\r\n * Preview action.\r\n */\r\nfunction togglePreview(editor) {\r\n\tvar cm = editor.codemirror;\r\n\tvar wrapper = cm.getWrapperElement();\r\n\tvar toolbar_div = wrapper.previousSibling;\r\n\tvar toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;\r\n\tvar preview = wrapper.lastChild;\r\n\tif(!preview || !/editor-preview/.test(preview.className)) {\r\n\t\tpreview = document.createElement(\"div\");\r\n\t\tpreview.className = \"editor-preview\";\r\n\t\twrapper.appendChild(preview);\r\n\t}\r\n\tif(/editor-preview-active/.test(preview.className)) {\r\n\t\tpreview.className = preview.className.replace(\r\n\t\t\t/\\s*editor-preview-active\\s*/g, \"\"\r\n\t\t);\r\n\t\tif(toolbar) {\r\n\t\t\ttoolbar.className = toolbar.className.replace(/\\s*active\\s*/g, \"\");\r\n\t\t\ttoolbar_div.className = toolbar_div.className.replace(/\\s*disabled-for-preview*/g, \"\");\r\n\t\t}\r\n\t} else {\r\n\t\t// When the preview button is clicked for the first time,\r\n\t\t// give some time for the transition from editor.css to fire and the view to slide from right to left,\r\n\t\t// instead of just appearing.\r\n\t\tsetTimeout(function() {\r\n\t\t\tpreview.className += \" editor-preview-active\";\r\n\t\t}, 1);\r\n\t\tif(toolbar) {\r\n\t\t\ttoolbar.className += \" active\";\r\n\t\t\ttoolbar_div.className += \" disabled-for-preview\";\r\n\t\t}\r\n\t}\r\n\tpreview.innerHTML = editor.options.previewRender(editor.value(), preview);\r\n\r\n\t// Turn off side by side if needed\r\n\tvar sidebyside = cm.getWrapperElement().nextSibling;\r\n\tif(/editor-preview-active-side/.test(sidebyside.className))\r\n\t\ttoggleSideBySide(editor);\r\n}\r\n\r\nfunction _replaceSelection(cm, active, startEnd, url) {\r\n\tif(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))\r\n\t\treturn;\r\n\r\n\tvar text;\r\n\tvar start = startEnd[0];\r\n\tvar end = startEnd[1];\r\n\tvar startPoint = cm.getCursor(\"start\");\r\n\tvar endPoint = cm.getCursor(\"end\");\r\n\tif(url) {\r\n\t\tend = end.replace(\"#url#\", url);\r\n\t}\r\n\tif(active) {\r\n\t\ttext = cm.getLine(startPoint.line);\r\n\t\tstart = text.slice(0, startPoint.ch);\r\n\t\tend = text.slice(startPoint.ch);\r\n\t\tcm.replaceRange(start + end, {\r\n\t\t\tline: startPoint.line,\r\n\t\t\tch: 0\r\n\t\t});\r\n\t} else {\r\n\t\ttext = cm.getSelection();\r\n\t\tcm.replaceSelection(start + text + end);\r\n\r\n\t\tstartPoint.ch += start.length;\r\n\t\tif(startPoint !== endPoint) {\r\n\t\t\tendPoint.ch += start.length;\r\n\t\t}\r\n\t}\r\n\tcm.setSelection(startPoint, endPoint);\r\n\tcm.focus();\r\n}\r\n\r\n\r\nfunction _toggleHeading(cm, direction, size) {\r\n\tif(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))\r\n\t\treturn;\r\n\r\n\tvar startPoint = cm.getCursor(\"start\");\r\n\tvar endPoint = cm.getCursor(\"end\");\r\n\tfor(var i = startPoint.line; i <= endPoint.line; i++) {\r\n\t\t(function(i) {\r\n\t\t\tvar text = cm.getLine(i);\r\n\t\t\tvar currHeadingLevel = text.search(/[^#]/);\r\n\r\n\t\t\tif(direction !== undefined) {\r\n\t\t\t\tif(currHeadingLevel <= 0) {\r\n\t\t\t\t\tif(direction == \"bigger\") {\r\n\t\t\t\t\t\ttext = \"###### \" + text;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttext = \"# \" + text;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(currHeadingLevel == 6 && direction == \"smaller\") {\r\n\t\t\t\t\ttext = text.substr(7);\r\n\t\t\t\t} else if(currHeadingLevel == 1 && direction == \"bigger\") {\r\n\t\t\t\t\ttext = text.substr(2);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif(direction == \"bigger\") {\r\n\t\t\t\t\t\ttext = text.substr(1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttext = \"#\" + text;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif(size == 1) {\r\n\t\t\t\t\tif(currHeadingLevel <= 0) {\r\n\t\t\t\t\t\ttext = \"# \" + text;\r\n\t\t\t\t\t} else if(currHeadingLevel == size) {\r\n\t\t\t\t\t\ttext = text.substr(currHeadingLevel + 1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttext = \"# \" + text.substr(currHeadingLevel + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(size == 2) {\r\n\t\t\t\t\tif(currHeadingLevel <= 0) {\r\n\t\t\t\t\t\ttext = \"## \" + text;\r\n\t\t\t\t\t} else if(currHeadingLevel == size) {\r\n\t\t\t\t\t\ttext = text.substr(currHeadingLevel + 1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttext = \"## \" + text.substr(currHeadingLevel + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif(currHeadingLevel <= 0) {\r\n\t\t\t\t\t\ttext = \"### \" + text;\r\n\t\t\t\t\t} else if(currHeadingLevel == size) {\r\n\t\t\t\t\t\ttext = text.substr(currHeadingLevel + 1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttext = \"### \" + text.substr(currHeadingLevel + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tcm.replaceRange(text, {\r\n\t\t\t\tline: i,\r\n\t\t\t\tch: 0\r\n\t\t\t}, {\r\n\t\t\t\tline: i,\r\n\t\t\t\tch: 99999999999999\r\n\t\t\t});\r\n\t\t})(i);\r\n\t}\r\n\tcm.focus();\r\n}\r\n\r\n\r\nfunction _toggleLine(cm, name) {\r\n\tif(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))\r\n\t\treturn;\r\n\r\n\tvar stat = getState(cm);\r\n\tvar startPoint = cm.getCursor(\"start\");\r\n\tvar endPoint = cm.getCursor(\"end\");\r\n\tvar repl = {\r\n\t\t\"quote\": /^(\\s*)\\>\\s+/,\r\n\t\t\"unordered-list\": /^(\\s*)(\\*|\\-|\\+)\\s+/,\r\n\t\t\"ordered-list\": /^(\\s*)\\d+\\.\\s+/\r\n\t};\r\n\tvar map = {\r\n\t\t\"quote\": \"> \",\r\n\t\t\"unordered-list\": \"* \",\r\n\t\t\"ordered-list\": \"1. \"\r\n\t};\r\n\tfor(var i = startPoint.line; i <= endPoint.line; i++) {\r\n\t\t(function(i) {\r\n\t\t\tvar text = cm.getLine(i);\r\n\t\t\tif(stat[name]) {\r\n\t\t\t\ttext = text.replace(repl[name], \"$1\");\r\n\t\t\t} else {\r\n\t\t\t\ttext = map[name] + text;\r\n\t\t\t}\r\n\t\t\tcm.replaceRange(text, {\r\n\t\t\t\tline: i,\r\n\t\t\t\tch: 0\r\n\t\t\t}, {\r\n\t\t\t\tline: i,\r\n\t\t\t\tch: 99999999999999\r\n\t\t\t});\r\n\t\t})(i);\r\n\t}\r\n\tcm.focus();\r\n}\r\n\r\nfunction _toggleBlock(editor, type, start_chars, end_chars) {\r\n\tif(/editor-preview-active/.test(editor.codemirror.getWrapperElement().lastChild.className))\r\n\t\treturn;\r\n\r\n\tend_chars = (typeof end_chars === \"undefined\") ? start_chars : end_chars;\r\n\tvar cm = editor.codemirror;\r\n\tvar stat = getState(cm);\r\n\r\n\tvar text;\r\n\tvar start = start_chars;\r\n\tvar end = end_chars;\r\n\r\n\tvar startPoint = cm.getCursor(\"start\");\r\n\tvar endPoint = cm.getCursor(\"end\");\r\n\r\n\tif(stat[type]) {\r\n\t\ttext = cm.getLine(startPoint.line);\r\n\t\tstart = text.slice(0, startPoint.ch);\r\n\t\tend = text.slice(startPoint.ch);\r\n\t\tif(type == \"bold\") {\r\n\t\t\tstart = start.replace(/(\\*\\*|__)(?![\\s\\S]*(\\*\\*|__))/, \"\");\r\n\t\t\tend = end.replace(/(\\*\\*|__)/, \"\");\r\n\t\t} else if(type == \"italic\") {\r\n\t\t\tstart = start.replace(/(\\*|_)(?![\\s\\S]*(\\*|_))/, \"\");\r\n\t\t\tend = end.replace(/(\\*|_)/, \"\");\r\n\t\t} else if(type == \"strikethrough\") {\r\n\t\t\tstart = start.replace(/(\\*\\*|~~)(?![\\s\\S]*(\\*\\*|~~))/, \"\");\r\n\t\t\tend = end.replace(/(\\*\\*|~~)/, \"\");\r\n\t\t}\r\n\t\tcm.replaceRange(start + end, {\r\n\t\t\tline: startPoint.line,\r\n\t\t\tch: 0\r\n\t\t}, {\r\n\t\t\tline: startPoint.line,\r\n\t\t\tch: 99999999999999\r\n\t\t});\r\n\r\n\t\tif(type == \"bold\" || type == \"strikethrough\") {\r\n\t\t\tstartPoint.ch -= 2;\r\n\t\t\tif(startPoint !== endPoint) {\r\n\t\t\t\tendPoint.ch -= 2;\r\n\t\t\t}\r\n\t\t} else if(type == \"italic\") {\r\n\t\t\tstartPoint.ch -= 1;\r\n\t\t\tif(startPoint !== endPoint) {\r\n\t\t\t\tendPoint.ch -= 1;\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\ttext = cm.getSelection();\r\n\t\tif(type == \"bold\") {\r\n\t\t\ttext = text.split(\"**\").join(\"\");\r\n\t\t\ttext = text.split(\"__\").join(\"\");\r\n\t\t} else if(type == \"italic\") {\r\n\t\t\ttext = text.split(\"*\").join(\"\");\r\n\t\t\ttext = text.split(\"_\").join(\"\");\r\n\t\t} else if(type == \"strikethrough\") {\r\n\t\t\ttext = text.split(\"~~\").join(\"\");\r\n\t\t}\r\n\t\tcm.replaceSelection(start + text + end);\r\n\r\n\t\tstartPoint.ch += start_chars.length;\r\n\t\tendPoint.ch = startPoint.ch + text.length;\r\n\t}\r\n\r\n\tcm.setSelection(startPoint, endPoint);\r\n\tcm.focus();\r\n}\r\n\r\nfunction _cleanBlock(cm) {\r\n\tif(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))\r\n\t\treturn;\r\n\r\n\tvar startPoint = cm.getCursor(\"start\");\r\n\tvar endPoint = cm.getCursor(\"end\");\r\n\tvar text;\r\n\r\n\tfor(var line = startPoint.line; line <= endPoint.line; line++) {\r\n\t\ttext = cm.getLine(line);\r\n\t\ttext = text.replace(/^[ ]*([# ]+|\\*|\\-|[> ]+|[0-9]+(.|\\)))[ ]*/, \"\");\r\n\r\n\t\tcm.replaceRange(text, {\r\n\t\t\tline: line,\r\n\t\t\tch: 0\r\n\t\t}, {\r\n\t\t\tline: line,\r\n\t\t\tch: 99999999999999\r\n\t\t});\r\n\t}\r\n}\r\n\r\n// Merge the properties of one object into another.\r\nfunction _mergeProperties(target, source) {\r\n\tfor(var property in source) {\r\n\t\tif(source.hasOwnProperty(property)) {\r\n\t\t\tif(source[property] instanceof Array) {\r\n\t\t\t\ttarget[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);\r\n\t\t\t} else if(\r\n\t\t\t\tsource[property] !== null &&\r\n\t\t\t\ttypeof source[property] === \"object\" &&\r\n\t\t\t\tsource[property].constructor === Object\r\n\t\t\t) {\r\n\t\t\t\ttarget[property] = _mergeProperties(target[property] || {}, source[property]);\r\n\t\t\t} else {\r\n\t\t\t\ttarget[property] = source[property];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn target;\r\n}\r\n\r\n// Merge an arbitrary number of objects into one.\r\nfunction extend(target) {\r\n\tfor(var i = 1; i < arguments.length; i++) {\r\n\t\ttarget = _mergeProperties(target, arguments[i]);\r\n\t}\r\n\r\n\treturn target;\r\n}\r\n\r\n/* The right word count in respect for CJK. */\r\nfunction wordCount(data) {\r\n\tvar pattern = /[a-zA-Z0-9_\\u0392-\\u03c9\\u0410-\\u04F9]+|[\\u4E00-\\u9FFF\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af]+/g;\r\n\tvar m = data.match(pattern);\r\n\tvar count = 0;\r\n\tif(m === null) return count;\r\n\tfor(var i = 0; i < m.length; i++) {\r\n\t\tif(m[i].charCodeAt(0) >= 0x4E00) {\r\n\t\t\tcount += m[i].length;\r\n\t\t} else {\r\n\t\t\tcount += 1;\r\n\t\t}\r\n\t}\r\n\treturn count;\r\n}\r\n\r\nvar toolbarBuiltInButtons = {\r\n\t\"bold\": {\r\n\t\tname: \"bold\",\r\n\t\taction: toggleBold,\r\n\t\tclassName: \"fa fa-bold\",\r\n\t\ttitle: \"Bold\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"italic\": {\r\n\t\tname: \"italic\",\r\n\t\taction: toggleItalic,\r\n\t\tclassName: \"fa fa-italic\",\r\n\t\ttitle: \"Italic\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"strikethrough\": {\r\n\t\tname: \"strikethrough\",\r\n\t\taction: toggleStrikethrough,\r\n\t\tclassName: \"fa fa-strikethrough\",\r\n\t\ttitle: \"Strikethrough\"\r\n\t},\r\n\t\"heading\": {\r\n\t\tname: \"heading\",\r\n\t\taction: toggleHeadingSmaller,\r\n\t\tclassName: \"fa fa-header\",\r\n\t\ttitle: \"Heading\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"heading-smaller\": {\r\n\t\tname: \"heading-smaller\",\r\n\t\taction: toggleHeadingSmaller,\r\n\t\tclassName: \"fa fa-header fa-header-x fa-header-smaller\",\r\n\t\ttitle: \"Smaller Heading\"\r\n\t},\r\n\t\"heading-bigger\": {\r\n\t\tname: \"heading-bigger\",\r\n\t\taction: toggleHeadingBigger,\r\n\t\tclassName: \"fa fa-header fa-header-x fa-header-bigger\",\r\n\t\ttitle: \"Bigger Heading\"\r\n\t},\r\n\t\"heading-1\": {\r\n\t\tname: \"heading-1\",\r\n\t\taction: toggleHeading1,\r\n\t\tclassName: \"fa fa-header fa-header-x fa-header-1\",\r\n\t\ttitle: \"Big Heading\"\r\n\t},\r\n\t\"heading-2\": {\r\n\t\tname: \"heading-2\",\r\n\t\taction: toggleHeading2,\r\n\t\tclassName: \"fa fa-header fa-header-x fa-header-2\",\r\n\t\ttitle: \"Medium Heading\"\r\n\t},\r\n\t\"heading-3\": {\r\n\t\tname: \"heading-3\",\r\n\t\taction: toggleHeading3,\r\n\t\tclassName: \"fa fa-header fa-header-x fa-header-3\",\r\n\t\ttitle: \"Small Heading\"\r\n\t},\r\n\t\"separator-1\": {\r\n\t\tname: \"separator-1\"\r\n\t},\r\n\t\"code\": {\r\n\t\tname: \"code\",\r\n\t\taction: toggleCodeBlock,\r\n\t\tclassName: \"fa fa-code\",\r\n\t\ttitle: \"Code\"\r\n\t},\r\n\t\"quote\": {\r\n\t\tname: \"quote\",\r\n\t\taction: toggleBlockquote,\r\n\t\tclassName: \"fa fa-quote-left\",\r\n\t\ttitle: \"Quote\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"unordered-list\": {\r\n\t\tname: \"unordered-list\",\r\n\t\taction: toggleUnorderedList,\r\n\t\tclassName: \"fa fa-list-ul\",\r\n\t\ttitle: \"Generic List\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"ordered-list\": {\r\n\t\tname: \"ordered-list\",\r\n\t\taction: toggleOrderedList,\r\n\t\tclassName: \"fa fa-list-ol\",\r\n\t\ttitle: \"Numbered List\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"clean-block\": {\r\n\t\tname: \"clean-block\",\r\n\t\taction: cleanBlock,\r\n\t\tclassName: \"fa fa-eraser fa-clean-block\",\r\n\t\ttitle: \"Clean block\"\r\n\t},\r\n\t\"separator-2\": {\r\n\t\tname: \"separator-2\"\r\n\t},\r\n\t\"link\": {\r\n\t\tname: \"link\",\r\n\t\taction: drawLink,\r\n\t\tclassName: \"fa fa-link\",\r\n\t\ttitle: \"Create Link\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"image\": {\r\n\t\tname: \"image\",\r\n\t\taction: drawImage,\r\n\t\tclassName: \"fa fa-picture-o\",\r\n\t\ttitle: \"Insert Image\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"table\": {\r\n\t\tname: \"table\",\r\n\t\taction: drawTable,\r\n\t\tclassName: \"fa fa-table\",\r\n\t\ttitle: \"Insert Table\"\r\n\t},\r\n\t\"horizontal-rule\": {\r\n\t\tname: \"horizontal-rule\",\r\n\t\taction: drawHorizontalRule,\r\n\t\tclassName: \"fa fa-minus\",\r\n\t\ttitle: \"Insert Horizontal Line\"\r\n\t},\r\n\t\"separator-3\": {\r\n\t\tname: \"separator-3\"\r\n\t},\r\n\t\"preview\": {\r\n\t\tname: \"preview\",\r\n\t\taction: togglePreview,\r\n\t\tclassName: \"fa fa-eye no-disable\",\r\n\t\ttitle: \"Toggle Preview\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"side-by-side\": {\r\n\t\tname: \"side-by-side\",\r\n\t\taction: toggleSideBySide,\r\n\t\tclassName: \"fa fa-columns no-disable no-mobile\",\r\n\t\ttitle: \"Toggle Side by Side\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"fullscreen\": {\r\n\t\tname: \"fullscreen\",\r\n\t\taction: toggleFullScreen,\r\n\t\tclassName: \"fa fa-arrows-alt no-disable no-mobile\",\r\n\t\ttitle: \"Toggle Fullscreen\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"separator-4\": {\r\n\t\tname: \"separator-4\"\r\n\t},\r\n\t\"guide\": {\r\n\t\tname: \"guide\",\r\n\t\taction: \"https://simplemde.com/markdown-guide\",\r\n\t\tclassName: \"fa fa-question-circle\",\r\n\t\ttitle: \"Markdown Guide\",\r\n\t\tdefault: true\r\n\t},\r\n\t\"separator-5\": {\r\n\t\tname: \"separator-5\"\r\n\t},\r\n\t\"undo\": {\r\n\t\tname: \"undo\",\r\n\t\taction: undo,\r\n\t\tclassName: \"fa fa-undo no-disable\",\r\n\t\ttitle: \"Undo\"\r\n\t},\r\n\t\"redo\": {\r\n\t\tname: \"redo\",\r\n\t\taction: redo,\r\n\t\tclassName: \"fa fa-repeat no-disable\",\r\n\t\ttitle: \"Redo\"\r\n\t}\r\n};\r\n\r\nvar insertTexts = {\r\n\tlink: [\"[\", \"](#url#)\"],\r\n\timage: [\"![](\", \"#url#)\"],\r\n\ttable: [\"\", \"\\n\\n| Column 1 | Column 2 | Column 3 |\\n| -------- | -------- | -------- |\\n| Text     | Text     | Text     |\\n\\n\"],\r\n\thorizontalRule: [\"\", \"\\n\\n-----\\n\\n\"]\r\n};\r\n\r\nvar promptTexts = {\r\n\tlink: \"URL for the link:\",\r\n\timage: \"URL of the image:\"\r\n};\r\n\r\nvar blockStyles = {\r\n\t\"bold\": \"**\",\r\n\t\"code\": \"```\",\r\n\t\"italic\": \"*\"\r\n};\r\n\r\n/**\r\n * Interface of SimpleMDE.\r\n */\r\nfunction SimpleMDE(options) {\r\n\t// Handle options parameter\r\n\toptions = options || {};\r\n\r\n\r\n\t// Used later to refer to it\"s parent\r\n\toptions.parent = this;\r\n\r\n\r\n\t// Check if Font Awesome needs to be auto downloaded\r\n\tvar autoDownloadFA = true;\r\n\r\n\tif(options.autoDownloadFontAwesome === false) {\r\n\t\tautoDownloadFA = false;\r\n\t}\r\n\r\n\tif(options.autoDownloadFontAwesome !== true) {\r\n\t\tvar styleSheets = document.styleSheets;\r\n\t\tfor(var i = 0; i < styleSheets.length; i++) {\r\n\t\t\tif(!styleSheets[i].href)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tif(styleSheets[i].href.indexOf(\"//maxcdn.bootstrapcdn.com/font-awesome/\") > -1) {\r\n\t\t\t\tautoDownloadFA = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif(autoDownloadFA) {\r\n\t\tvar link = document.createElement(\"link\");\r\n\t\tlink.rel = \"stylesheet\";\r\n\t\tlink.href = \"https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css\";\r\n\t\tdocument.getElementsByTagName(\"head\")[0].appendChild(link);\r\n\t}\r\n\r\n\r\n\t// Find the textarea to use\r\n\tif(options.element) {\r\n\t\tthis.element = options.element;\r\n\t} else if(options.element === null) {\r\n\t\t// This means that the element option was specified, but no element was found\r\n\t\tconsole.log(\"SimpleMDE: Error. No element was found.\");\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\t// Handle toolbar\r\n\tif(options.toolbar === undefined) {\r\n\t\t// Initialize\r\n\t\toptions.toolbar = [];\r\n\r\n\r\n\t\t// Loop over the built in buttons, to get the preferred order\r\n\t\tfor(var key in toolbarBuiltInButtons) {\r\n\t\t\tif(toolbarBuiltInButtons.hasOwnProperty(key)) {\r\n\t\t\t\tif(key.indexOf(\"separator-\") != -1) {\r\n\t\t\t\t\toptions.toolbar.push(\"|\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(toolbarBuiltInButtons[key].default === true || (options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1)) {\r\n\t\t\t\t\toptions.toolbar.push(key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Handle status bar\r\n\tif(!options.hasOwnProperty(\"status\")) {\r\n\t\toptions.status = [\"autosave\", \"lines\", \"words\", \"cursor\"];\r\n\t}\r\n\r\n\r\n\t// Add default preview rendering function\r\n\tif(!options.previewRender) {\r\n\t\toptions.previewRender = function(plainText) {\r\n\t\t\t// Note: \"this\" refers to the options object\r\n\t\t\treturn this.parent.markdown(plainText);\r\n\t\t};\r\n\t}\r\n\r\n\r\n\t// Set default options for parsing config\r\n\toptions.parsingConfig = extend({\r\n\t\thighlightFormatting: true // needed for toggleCodeBlock to detect types of code\r\n\t}, options.parsingConfig || {});\r\n\r\n\r\n\t// Merging the insertTexts, with the given options\r\n\toptions.insertTexts = extend({}, insertTexts, options.insertTexts || {});\r\n\r\n\r\n\t// Merging the promptTexts, with the given options\r\n\toptions.promptTexts = promptTexts;\r\n\r\n\r\n\t// Merging the blockStyles, with the given options\r\n\toptions.blockStyles = extend({}, blockStyles, options.blockStyles || {});\r\n\r\n\r\n\t// Merging the shortcuts, with the given options\r\n\toptions.shortcuts = extend({}, shortcuts, options.shortcuts || {});\r\n\r\n\r\n\t// Change unique_id to uniqueId for backwards compatibility\r\n\tif(options.autosave != undefined && options.autosave.unique_id != undefined && options.autosave.unique_id != \"\")\r\n\t\toptions.autosave.uniqueId = options.autosave.unique_id;\r\n\r\n\r\n\t// Update this options\r\n\tthis.options = options;\r\n\r\n\r\n\t// Auto render\r\n\tthis.render();\r\n\r\n\r\n\t// The codemirror component is only available after rendering\r\n\t// so, the setter for the initialValue can only run after\r\n\t// the element has been rendered\r\n\tif(options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {\r\n\t\tthis.value(options.initialValue);\r\n\t}\r\n}\r\n\r\n/**\r\n * Default markdown render.\r\n */\r\nSimpleMDE.prototype.markdown = function(text) {\r\n\tif(marked) {\r\n\t\t// Initialize\r\n\t\tvar markedOptions = {};\r\n\r\n\r\n\t\t// Update options\r\n\t\tif(this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {\r\n\t\t\tmarkedOptions.breaks = false;\r\n\t\t} else {\r\n\t\t\tmarkedOptions.breaks = true;\r\n\t\t}\r\n\r\n\t\tif(this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true && window.hljs) {\r\n\t\t\tmarkedOptions.highlight = function(code) {\r\n\t\t\t\treturn window.hljs.highlightAuto(code).value;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\r\n\t\t// Set options\r\n\t\tmarked.setOptions(markedOptions);\r\n\r\n\r\n\t\t// Return\r\n\t\treturn marked(text);\r\n\t}\r\n};\r\n\r\n/**\r\n * Render editor to the given element.\r\n */\r\nSimpleMDE.prototype.render = function(el) {\r\n\tif(!el) {\r\n\t\tel = this.element || document.getElementsByTagName(\"textarea\")[0];\r\n\t}\r\n\r\n\tif(this._rendered && this._rendered === el) {\r\n\t\t// Already rendered.\r\n\t\treturn;\r\n\t}\r\n\r\n\tthis.element = el;\r\n\tvar options = this.options;\r\n\r\n\tvar self = this;\r\n\tvar keyMaps = {};\r\n\r\n\tfor(var key in options.shortcuts) {\r\n\t\t// null stands for \"do not bind this command\"\r\n\t\tif(options.shortcuts[key] !== null && bindings[key] !== null) {\r\n\t\t\t(function(key) {\r\n\t\t\t\tkeyMaps[fixShortcut(options.shortcuts[key])] = function() {\r\n\t\t\t\t\tbindings[key](self);\r\n\t\t\t\t};\r\n\t\t\t})(key);\r\n\t\t}\r\n\t}\r\n\r\n\tkeyMaps[\"Enter\"] = \"newlineAndIndentContinueMarkdownList\";\r\n\tkeyMaps[\"Tab\"] = \"tabAndIndentMarkdownList\";\r\n\tkeyMaps[\"Shift-Tab\"] = \"shiftTabAndUnindentMarkdownList\";\r\n\tkeyMaps[\"Esc\"] = function(cm) {\r\n\t\tif(cm.getOption(\"fullScreen\")) toggleFullScreen(self);\r\n\t};\r\n\r\n\tdocument.addEventListener(\"keydown\", function(e) {\r\n\t\te = e || window.event;\r\n\r\n\t\tif(e.keyCode == 27) {\r\n\t\t\tif(self.codemirror.getOption(\"fullScreen\")) toggleFullScreen(self);\r\n\t\t}\r\n\t}, false);\r\n\r\n\tvar mode, backdrop;\r\n\tif(options.spellChecker !== false) {\r\n\t\tmode = \"spell-checker\";\r\n\t\tbackdrop = options.parsingConfig;\r\n\t\tbackdrop.name = \"gfm\";\r\n\t\tbackdrop.gitHubSpice = false;\r\n\r\n\t\tCodeMirrorSpellChecker({\r\n\t\t\tcodeMirrorInstance: CodeMirror\r\n\t\t});\r\n\t} else {\r\n\t\tmode = options.parsingConfig;\r\n\t\tmode.name = \"gfm\";\r\n\t\tmode.gitHubSpice = false;\r\n\t}\r\n\r\n\tthis.codemirror = CodeMirror.fromTextArea(el, {\r\n\t\tmode: mode,\r\n\t\tbackdrop: backdrop,\r\n\t\ttheme: \"paper\",\r\n\t\ttabSize: (options.tabSize != undefined) ? options.tabSize : 2,\r\n\t\tindentUnit: (options.tabSize != undefined) ? options.tabSize : 2,\r\n\t\tindentWithTabs: (options.indentWithTabs === false) ? false : true,\r\n\t\tlineNumbers: false,\r\n\t\tautofocus: (options.autofocus === true) ? true : false,\r\n\t\textraKeys: keyMaps,\r\n\t\tlineWrapping: (options.lineWrapping === false) ? false : true,\r\n\t\tallowDropFileTypes: [\"text/plain\"],\r\n\t\tplaceholder: options.placeholder || el.getAttribute(\"placeholder\") || \"\",\r\n\t\tstyleSelectedText: (options.styleSelectedText != undefined) ? options.styleSelectedText : true\r\n\t});\r\n\r\n\tif(options.forceSync === true) {\r\n\t\tvar cm = this.codemirror;\r\n\t\tcm.on(\"change\", function() {\r\n\t\t\tcm.save();\r\n\t\t});\r\n\t}\r\n\r\n\tthis.gui = {};\r\n\r\n\tif(options.toolbar !== false) {\r\n\t\tthis.gui.toolbar = this.createToolbar();\r\n\t}\r\n\tif(options.status !== false) {\r\n\t\tthis.gui.statusbar = this.createStatusbar();\r\n\t}\r\n\tif(options.autosave != undefined && options.autosave.enabled === true) {\r\n\t\tthis.autosave();\r\n\t}\r\n\r\n\tthis.gui.sideBySide = this.createSideBySide();\r\n\r\n\tthis._rendered = this.element;\r\n\r\n\r\n\t// Fixes CodeMirror bug (#344)\r\n\tvar temp_cm = this.codemirror;\r\n\tsetTimeout(function() {\r\n\t\ttemp_cm.refresh();\r\n\t}.bind(temp_cm), 0);\r\n};\r\n\r\n// Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem throw QuotaExceededError. We're going to detect this and set a variable accordingly.\r\nfunction isLocalStorageAvailable() {\r\n\tif(typeof localStorage === \"object\") {\r\n\t\ttry {\r\n\t\t\tlocalStorage.setItem(\"smde_localStorage\", 1);\r\n\t\t\tlocalStorage.removeItem(\"smde_localStorage\");\r\n\t\t} catch(e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t} else {\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nSimpleMDE.prototype.autosave = function() {\r\n\tif(isLocalStorageAvailable()) {\r\n\t\tvar simplemde = this;\r\n\r\n\t\tif(this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == \"\") {\r\n\t\t\tconsole.log(\"SimpleMDE: You must set a uniqueId to use the autosave feature\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif(simplemde.element.form != null && simplemde.element.form != undefined) {\r\n\t\t\tsimplemde.element.form.addEventListener(\"submit\", function() {\r\n\t\t\t\tlocalStorage.removeItem(\"smde_\" + simplemde.options.autosave.uniqueId);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif(this.options.autosave.loaded !== true) {\r\n\t\t\tif(typeof localStorage.getItem(\"smde_\" + this.options.autosave.uniqueId) == \"string\" && localStorage.getItem(\"smde_\" + this.options.autosave.uniqueId) != \"\") {\r\n\t\t\t\tthis.codemirror.setValue(localStorage.getItem(\"smde_\" + this.options.autosave.uniqueId));\r\n\t\t\t\tthis.options.autosave.foundSavedValue = true;\r\n\t\t\t}\r\n\r\n\t\t\tthis.options.autosave.loaded = true;\r\n\t\t}\r\n\r\n\t\tlocalStorage.setItem(\"smde_\" + this.options.autosave.uniqueId, simplemde.value());\r\n\r\n\t\tvar el = document.getElementById(\"autosaved\");\r\n\t\tif(el != null && el != undefined && el != \"\") {\r\n\t\t\tvar d = new Date();\r\n\t\t\tvar hh = d.getHours();\r\n\t\t\tvar m = d.getMinutes();\r\n\t\t\tvar dd = \"am\";\r\n\t\t\tvar h = hh;\r\n\t\t\tif(h >= 12) {\r\n\t\t\t\th = hh - 12;\r\n\t\t\t\tdd = \"pm\";\r\n\t\t\t}\r\n\t\t\tif(h == 0) {\r\n\t\t\t\th = 12;\r\n\t\t\t}\r\n\t\t\tm = m < 10 ? \"0\" + m : m;\r\n\r\n\t\t\tel.innerHTML = \"Autosaved: \" + h + \":\" + m + \" \" + dd;\r\n\t\t}\r\n\r\n\t\tthis.autosaveTimeoutId = setTimeout(function() {\r\n\t\t\tsimplemde.autosave();\r\n\t\t}, this.options.autosave.delay || 10000);\r\n\t} else {\r\n\t\tconsole.log(\"SimpleMDE: localStorage not available, cannot autosave\");\r\n\t}\r\n};\r\n\r\nSimpleMDE.prototype.clearAutosavedValue = function() {\r\n\tif(isLocalStorageAvailable()) {\r\n\t\tif(this.options.autosave == undefined || this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == \"\") {\r\n\t\t\tconsole.log(\"SimpleMDE: You must set a uniqueId to clear the autosave value\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlocalStorage.removeItem(\"smde_\" + this.options.autosave.uniqueId);\r\n\t} else {\r\n\t\tconsole.log(\"SimpleMDE: localStorage not available, cannot autosave\");\r\n\t}\r\n};\r\n\r\nSimpleMDE.prototype.createSideBySide = function() {\r\n\tvar cm = this.codemirror;\r\n\tvar wrapper = cm.getWrapperElement();\r\n\tvar preview = wrapper.nextSibling;\r\n\r\n\tif(!preview || !/editor-preview-side/.test(preview.className)) {\r\n\t\tpreview = document.createElement(\"div\");\r\n\t\tpreview.className = \"editor-preview-side\";\r\n\t\twrapper.parentNode.insertBefore(preview, wrapper.nextSibling);\r\n\t}\r\n\r\n\t// Syncs scroll  editor -> preview\r\n\tvar cScroll = false;\r\n\tvar pScroll = false;\r\n\tcm.on(\"scroll\", function(v) {\r\n\t\tif(cScroll) {\r\n\t\t\tcScroll = false;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tpScroll = true;\r\n\t\tvar height = v.getScrollInfo().height - v.getScrollInfo().clientHeight;\r\n\t\tvar ratio = parseFloat(v.getScrollInfo().top) / height;\r\n\t\tvar move = (preview.scrollHeight - preview.clientHeight) * ratio;\r\n\t\tpreview.scrollTop = move;\r\n\t});\r\n\r\n\t// Syncs scroll  preview -> editor\r\n\tpreview.onscroll = function() {\r\n\t\tif(pScroll) {\r\n\t\t\tpScroll = false;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcScroll = true;\r\n\t\tvar height = preview.scrollHeight - preview.clientHeight;\r\n\t\tvar ratio = parseFloat(preview.scrollTop) / height;\r\n\t\tvar move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;\r\n\t\tcm.scrollTo(0, move);\r\n\t};\r\n\treturn preview;\r\n};\r\n\r\nSimpleMDE.prototype.createToolbar = function(items) {\r\n\titems = items || this.options.toolbar;\r\n\r\n\tif(!items || items.length === 0) {\r\n\t\treturn;\r\n\t}\r\n\tvar i;\r\n\tfor(i = 0; i < items.length; i++) {\r\n\t\tif(toolbarBuiltInButtons[items[i]] != undefined) {\r\n\t\t\titems[i] = toolbarBuiltInButtons[items[i]];\r\n\t\t}\r\n\t}\r\n\r\n\tvar bar = document.createElement(\"div\");\r\n\tbar.className = \"editor-toolbar\";\r\n\r\n\tvar self = this;\r\n\r\n\tvar toolbarData = {};\r\n\tself.toolbar = items;\r\n\r\n\tfor(i = 0; i < items.length; i++) {\r\n\t\tif(items[i].name == \"guide\" && self.options.toolbarGuideIcon === false)\r\n\t\t\tcontinue;\r\n\r\n\t\tif(self.options.hideIcons && self.options.hideIcons.indexOf(items[i].name) != -1)\r\n\t\t\tcontinue;\r\n\r\n\t\t// Fullscreen does not work well on mobile devices (even tablets)\r\n\t\t// In the future, hopefully this can be resolved\r\n\t\tif((items[i].name == \"fullscreen\" || items[i].name == \"side-by-side\") && isMobile())\r\n\t\t\tcontinue;\r\n\r\n\r\n\t\t// Don't include trailing separators\r\n\t\tif(items[i] === \"|\") {\r\n\t\t\tvar nonSeparatorIconsFollow = false;\r\n\r\n\t\t\tfor(var x = (i + 1); x < items.length; x++) {\r\n\t\t\t\tif(items[x] !== \"|\" && (!self.options.hideIcons || self.options.hideIcons.indexOf(items[x].name) == -1)) {\r\n\t\t\t\t\tnonSeparatorIconsFollow = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(!nonSeparatorIconsFollow)\r\n\t\t\t\tcontinue;\r\n\t\t}\r\n\r\n\r\n\t\t// Create the icon and append to the toolbar\r\n\t\t(function(item) {\r\n\t\t\tvar el;\r\n\t\t\tif(item === \"|\") {\r\n\t\t\t\tel = createSep();\r\n\t\t\t} else {\r\n\t\t\t\tel = createIcon(item, self.options.toolbarTips, self.options.shortcuts);\r\n\t\t\t}\r\n\r\n\t\t\t// bind events, special for info\r\n\t\t\tif(item.action) {\r\n\t\t\t\tif(typeof item.action === \"function\") {\r\n\t\t\t\t\tel.onclick = function(e) {\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t\titem.action(self);\r\n\t\t\t\t\t};\r\n\t\t\t\t} else if(typeof item.action === \"string\") {\r\n\t\t\t\t\tel.href = item.action;\r\n\t\t\t\t\tel.target = \"_blank\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttoolbarData[item.name || item] = el;\r\n\t\t\tbar.appendChild(el);\r\n\t\t})(items[i]);\r\n\t}\r\n\r\n\tself.toolbarElements = toolbarData;\r\n\r\n\tvar cm = this.codemirror;\r\n\tcm.on(\"cursorActivity\", function() {\r\n\t\tvar stat = getState(cm);\r\n\r\n\t\tfor(var key in toolbarData) {\r\n\t\t\t(function(key) {\r\n\t\t\t\tvar el = toolbarData[key];\r\n\t\t\t\tif(stat[key]) {\r\n\t\t\t\t\tel.className += \" active\";\r\n\t\t\t\t} else if(key != \"fullscreen\" && key != \"side-by-side\") {\r\n\t\t\t\t\tel.className = el.className.replace(/\\s*active\\s*/g, \"\");\r\n\t\t\t\t}\r\n\t\t\t})(key);\r\n\t\t}\r\n\t});\r\n\r\n\tvar cmWrapper = cm.getWrapperElement();\r\n\tcmWrapper.parentNode.insertBefore(bar, cmWrapper);\r\n\treturn bar;\r\n};\r\n\r\nSimpleMDE.prototype.createStatusbar = function(status) {\r\n\t// Initialize\r\n\tstatus = status || this.options.status;\r\n\tvar options = this.options;\r\n\tvar cm = this.codemirror;\r\n\r\n\r\n\t// Make sure the status variable is valid\r\n\tif(!status || status.length === 0)\r\n\t\treturn;\r\n\r\n\r\n\t// Set up the built-in items\r\n\tvar items = [];\r\n\tvar i, onUpdate, defaultValue;\r\n\r\n\tfor(i = 0; i < status.length; i++) {\r\n\t\t// Reset some values\r\n\t\tonUpdate = undefined;\r\n\t\tdefaultValue = undefined;\r\n\r\n\r\n\t\t// Handle if custom or not\r\n\t\tif(typeof status[i] === \"object\") {\r\n\t\t\titems.push({\r\n\t\t\t\tclassName: status[i].className,\r\n\t\t\t\tdefaultValue: status[i].defaultValue,\r\n\t\t\t\tonUpdate: status[i].onUpdate\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tvar name = status[i];\r\n\r\n\t\t\tif(name === \"words\") {\r\n\t\t\t\tdefaultValue = function(el) {\r\n\t\t\t\t\tel.innerHTML = wordCount(cm.getValue());\r\n\t\t\t\t};\r\n\t\t\t\tonUpdate = function(el) {\r\n\t\t\t\t\tel.innerHTML = wordCount(cm.getValue());\r\n\t\t\t\t};\r\n\t\t\t} else if(name === \"lines\") {\r\n\t\t\t\tdefaultValue = function(el) {\r\n\t\t\t\t\tel.innerHTML = cm.lineCount();\r\n\t\t\t\t};\r\n\t\t\t\tonUpdate = function(el) {\r\n\t\t\t\t\tel.innerHTML = cm.lineCount();\r\n\t\t\t\t};\r\n\t\t\t} else if(name === \"cursor\") {\r\n\t\t\t\tdefaultValue = function(el) {\r\n\t\t\t\t\tel.innerHTML = \"0:0\";\r\n\t\t\t\t};\r\n\t\t\t\tonUpdate = function(el) {\r\n\t\t\t\t\tvar pos = cm.getCursor();\r\n\t\t\t\t\tel.innerHTML = pos.line + \":\" + pos.ch;\r\n\t\t\t\t};\r\n\t\t\t} else if(name === \"autosave\") {\r\n\t\t\t\tdefaultValue = function(el) {\r\n\t\t\t\t\tif(options.autosave != undefined && options.autosave.enabled === true) {\r\n\t\t\t\t\t\tel.setAttribute(\"id\", \"autosaved\");\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\titems.push({\r\n\t\t\t\tclassName: name,\r\n\t\t\t\tdefaultValue: defaultValue,\r\n\t\t\t\tonUpdate: onUpdate\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Create element for the status bar\r\n\tvar bar = document.createElement(\"div\");\r\n\tbar.className = \"editor-statusbar\";\r\n\r\n\r\n\t// Create a new span for each item\r\n\tfor(i = 0; i < items.length; i++) {\r\n\t\t// Store in temporary variable\r\n\t\tvar item = items[i];\r\n\r\n\r\n\t\t// Create span element\r\n\t\tvar el = document.createElement(\"span\");\r\n\t\tel.className = item.className;\r\n\r\n\r\n\t\t// Ensure the defaultValue is a function\r\n\t\tif(typeof item.defaultValue === \"function\") {\r\n\t\t\titem.defaultValue(el);\r\n\t\t}\r\n\r\n\r\n\t\t// Ensure the onUpdate is a function\r\n\t\tif(typeof item.onUpdate === \"function\") {\r\n\t\t\t// Create a closure around the span of the current action, then execute the onUpdate handler\r\n\t\t\tthis.codemirror.on(\"update\", (function(el, item) {\r\n\t\t\t\treturn function() {\r\n\t\t\t\t\titem.onUpdate(el);\r\n\t\t\t\t};\r\n\t\t\t}(el, item)));\r\n\t\t}\r\n\r\n\r\n\t\t// Append the item to the status bar\r\n\t\tbar.appendChild(el);\r\n\t}\r\n\r\n\r\n\t// Insert the status bar into the DOM\r\n\tvar cmWrapper = this.codemirror.getWrapperElement();\r\n\tcmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);\r\n\treturn bar;\r\n};\r\n\r\n/**\r\n * Get or set the text content.\r\n */\r\nSimpleMDE.prototype.value = function(val) {\r\n\tif(val === undefined) {\r\n\t\treturn this.codemirror.getValue();\r\n\t} else {\r\n\t\tthis.codemirror.getDoc().setValue(val);\r\n\t\treturn this;\r\n\t}\r\n};\r\n\r\n\r\n/**\r\n * Bind static methods for exports.\r\n */\r\nSimpleMDE.toggleBold = toggleBold;\r\nSimpleMDE.toggleItalic = toggleItalic;\r\nSimpleMDE.toggleStrikethrough = toggleStrikethrough;\r\nSimpleMDE.toggleBlockquote = toggleBlockquote;\r\nSimpleMDE.toggleHeadingSmaller = toggleHeadingSmaller;\r\nSimpleMDE.toggleHeadingBigger = toggleHeadingBigger;\r\nSimpleMDE.toggleHeading1 = toggleHeading1;\r\nSimpleMDE.toggleHeading2 = toggleHeading2;\r\nSimpleMDE.toggleHeading3 = toggleHeading3;\r\nSimpleMDE.toggleCodeBlock = toggleCodeBlock;\r\nSimpleMDE.toggleUnorderedList = toggleUnorderedList;\r\nSimpleMDE.toggleOrderedList = toggleOrderedList;\r\nSimpleMDE.cleanBlock = cleanBlock;\r\nSimpleMDE.drawLink = drawLink;\r\nSimpleMDE.drawImage = drawImage;\r\nSimpleMDE.drawTable = drawTable;\r\nSimpleMDE.drawHorizontalRule = drawHorizontalRule;\r\nSimpleMDE.undo = undo;\r\nSimpleMDE.redo = redo;\r\nSimpleMDE.togglePreview = togglePreview;\r\nSimpleMDE.toggleSideBySide = toggleSideBySide;\r\nSimpleMDE.toggleFullScreen = toggleFullScreen;\r\n\r\n/**\r\n * Bind instance methods for exports.\r\n */\r\nSimpleMDE.prototype.toggleBold = function() {\r\n\ttoggleBold(this);\r\n};\r\nSimpleMDE.prototype.toggleItalic = function() {\r\n\ttoggleItalic(this);\r\n};\r\nSimpleMDE.prototype.toggleStrikethrough = function() {\r\n\ttoggleStrikethrough(this);\r\n};\r\nSimpleMDE.prototype.toggleBlockquote = function() {\r\n\ttoggleBlockquote(this);\r\n};\r\nSimpleMDE.prototype.toggleHeadingSmaller = function() {\r\n\ttoggleHeadingSmaller(this);\r\n};\r\nSimpleMDE.prototype.toggleHeadingBigger = function() {\r\n\ttoggleHeadingBigger(this);\r\n};\r\nSimpleMDE.prototype.toggleHeading1 = function() {\r\n\ttoggleHeading1(this);\r\n};\r\nSimpleMDE.prototype.toggleHeading2 = function() {\r\n\ttoggleHeading2(this);\r\n};\r\nSimpleMDE.prototype.toggleHeading3 = function() {\r\n\ttoggleHeading3(this);\r\n};\r\nSimpleMDE.prototype.toggleCodeBlock = function() {\r\n\ttoggleCodeBlock(this);\r\n};\r\nSimpleMDE.prototype.toggleUnorderedList = function() {\r\n\ttoggleUnorderedList(this);\r\n};\r\nSimpleMDE.prototype.toggleOrderedList = function() {\r\n\ttoggleOrderedList(this);\r\n};\r\nSimpleMDE.prototype.cleanBlock = function() {\r\n\tcleanBlock(this);\r\n};\r\nSimpleMDE.prototype.drawLink = function() {\r\n\tdrawLink(this);\r\n};\r\nSimpleMDE.prototype.drawImage = function() {\r\n\tdrawImage(this);\r\n};\r\nSimpleMDE.prototype.drawTable = function() {\r\n\tdrawTable(this);\r\n};\r\nSimpleMDE.prototype.drawHorizontalRule = function() {\r\n\tdrawHorizontalRule(this);\r\n};\r\nSimpleMDE.prototype.undo = function() {\r\n\tundo(this);\r\n};\r\nSimpleMDE.prototype.redo = function() {\r\n\tredo(this);\r\n};\r\nSimpleMDE.prototype.togglePreview = function() {\r\n\ttogglePreview(this);\r\n};\r\nSimpleMDE.prototype.toggleSideBySide = function() {\r\n\ttoggleSideBySide(this);\r\n};\r\nSimpleMDE.prototype.toggleFullScreen = function() {\r\n\ttoggleFullScreen(this);\r\n};\r\n\r\nSimpleMDE.prototype.isPreviewActive = function() {\r\n\tvar cm = this.codemirror;\r\n\tvar wrapper = cm.getWrapperElement();\r\n\tvar preview = wrapper.lastChild;\r\n\r\n\treturn /editor-preview-active/.test(preview.className);\r\n};\r\n\r\nSimpleMDE.prototype.isSideBySideActive = function() {\r\n\tvar cm = this.codemirror;\r\n\tvar wrapper = cm.getWrapperElement();\r\n\tvar preview = wrapper.nextSibling;\r\n\r\n\treturn /editor-preview-active-side/.test(preview.className);\r\n};\r\n\r\nSimpleMDE.prototype.isFullscreenActive = function() {\r\n\tvar cm = this.codemirror;\r\n\r\n\treturn cm.getOption(\"fullScreen\");\r\n};\r\n\r\nSimpleMDE.prototype.getState = function() {\r\n\tvar cm = this.codemirror;\r\n\r\n\treturn getState(cm);\r\n};\r\n\r\nSimpleMDE.prototype.toTextArea = function() {\r\n\tvar cm = this.codemirror;\r\n\tvar wrapper = cm.getWrapperElement();\r\n\r\n\tif(wrapper.parentNode) {\r\n\t\tif(this.gui.toolbar) {\r\n\t\t\twrapper.parentNode.removeChild(this.gui.toolbar);\r\n\t\t}\r\n\t\tif(this.gui.statusbar) {\r\n\t\t\twrapper.parentNode.removeChild(this.gui.statusbar);\r\n\t\t}\r\n\t\tif(this.gui.sideBySide) {\r\n\t\t\twrapper.parentNode.removeChild(this.gui.sideBySide);\r\n\t\t}\r\n\t}\r\n\r\n\tcm.toTextArea();\r\n\r\n\tif(this.autosaveTimeoutId) {\r\n\t\tclearTimeout(this.autosaveTimeoutId);\r\n\t\tthis.autosaveTimeoutId = undefined;\r\n\t\tthis.clearAutosavedValue();\r\n\t}\r\n};\r\n\r\nmodule.exports = SimpleMDE;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/simplemde/src/js/simplemde.js\n// module id = 1282\n// module chunks = 18","/* globals chrome: false */\r\n/* globals __dirname: false */\r\n/* globals require: false */\r\n/* globals Buffer: false */\r\n/* globals module: false */\r\n\r\n/**\r\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style \r\n * dictionaries.\r\n */\r\n\r\nvar Typo;\r\n\r\n(function () {\r\n\"use strict\";\r\n\r\n/**\r\n * Typo constructor.\r\n *\r\n * @param {String} [dictionary] The locale code of the dictionary being used. e.g.,\r\n *                              \"en_US\". This is only used to auto-load dictionaries.\r\n * @param {String} [affData]    The data from the dictionary's .aff file. If omitted\r\n *                              and Typo.js is being used in a Chrome extension, the .aff\r\n *                              file will be loaded automatically from\r\n *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff\r\n *                              In other environments, it will be loaded from\r\n *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff\r\n * @param {String} [wordsData]  The data from the dictionary's .dic file. If omitted\r\n *                              and Typo.js is being used in a Chrome extension, the .dic\r\n *                              file will be loaded automatically from\r\n *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic\r\n *                              In other environments, it will be loaded from\r\n *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic\r\n * @param {Object} [settings]   Constructor settings. Available properties are:\r\n *                              {String} [dictionaryPath]: path to load dictionary from in non-chrome\r\n *                              environment.\r\n *                              {Object} [flags]: flag information.\r\n *                              {Boolean} [asyncLoad]: If true, affData and wordsData will be loaded\r\n *                              asynchronously.\r\n *                              {Function} [loadedCallback]: Called when both affData and wordsData\r\n *                              have been loaded. Only used if asyncLoad is set to true. The parameter\r\n *                              is the instantiated Typo object.\r\n *\r\n * @returns {Typo} A Typo object.\r\n */\r\n\r\nTypo = function (dictionary, affData, wordsData, settings) {\r\n\tsettings = settings || {};\r\n\r\n\tthis.dictionary = null;\r\n\t\r\n\tthis.rules = {};\r\n\tthis.dictionaryTable = {};\r\n\t\r\n\tthis.compoundRules = [];\r\n\tthis.compoundRuleCodes = {};\r\n\t\r\n\tthis.replacementTable = [];\r\n\t\r\n\tthis.flags = settings.flags || {}; \r\n\t\r\n\tthis.memoized = {};\r\n\r\n\tthis.loaded = false;\r\n\t\r\n\tvar self = this;\r\n\t\r\n\tvar path;\r\n\t\r\n\t// Loop-control variables.\r\n\tvar i, j, _len, _jlen;\r\n\t\r\n\tif (dictionary) {\r\n\t\tself.dictionary = dictionary;\r\n\t\t\r\n\t\t// If the data is preloaded, just setup the Typo object.\r\n\t\tif (affData && wordsData) {\r\n\t\t\tsetup();\r\n\t\t}\r\n\t\t// Loading data for Chrome extentions.\r\n\t\telse if (typeof window !== 'undefined' && 'chrome' in window && 'extension' in window.chrome && 'getURL' in window.chrome.extension) {\r\n\t\t\tif (settings.dictionaryPath) {\r\n\t\t\t\tpath = settings.dictionaryPath;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tpath = \"typo/dictionaries\";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!affData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\"), setAffData);\r\n\t\t\tif (!wordsData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\"), setWordsData);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (settings.dictionaryPath) {\r\n\t\t\t\tpath = settings.dictionaryPath;\r\n\t\t\t}\r\n\t\t\telse if (typeof __dirname !== 'undefined') {\r\n\t\t\t\tpath = __dirname + '/dictionaries';\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tpath = './dictionaries';\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!affData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\", setAffData);\r\n\t\t\tif (!wordsData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\", setWordsData);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction readDataFile(url, setFunc) {\r\n\t\tvar response = self._readFile(url, null, settings.asyncLoad);\r\n\t\t\r\n\t\tif (settings.asyncLoad) {\r\n\t\t\tresponse.then(function(data) {\r\n\t\t\t\tsetFunc(data);\r\n\t\t\t});\r\n\t\t}\r\n\t\telse {\r\n\t\t\tsetFunc(response);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setAffData(data) {\r\n\t\taffData = data;\r\n\r\n\t\tif (wordsData) {\r\n\t\t\tsetup();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setWordsData(data) {\r\n\t\twordsData = data;\r\n\r\n\t\tif (affData) {\r\n\t\t\tsetup();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setup() {\r\n\t\tself.rules = self._parseAFF(affData);\r\n\t\t\r\n\t\t// Save the rule codes that are used in compound rules.\r\n\t\tself.compoundRuleCodes = {};\r\n\t\t\r\n\t\tfor (i = 0, _len = self.compoundRules.length; i < _len; i++) {\r\n\t\t\tvar rule = self.compoundRules[i];\r\n\t\t\t\r\n\t\t\tfor (j = 0, _jlen = rule.length; j < _jlen; j++) {\r\n\t\t\t\tself.compoundRuleCodes[rule[j]] = [];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\r\n\t\t// will do the work of saving the list of words that are compound-only.\r\n\t\tif (\"ONLYINCOMPOUND\" in self.flags) {\r\n\t\t\tself.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];\r\n\t\t}\r\n\t\t\r\n\t\tself.dictionaryTable = self._parseDIC(wordsData);\r\n\t\t\r\n\t\t// Get rid of any codes from the compound rule codes that are never used \r\n\t\t// (or that were special regex characters).  Not especially necessary... \r\n\t\tfor (i in self.compoundRuleCodes) {\r\n\t\t\tif (self.compoundRuleCodes[i].length === 0) {\r\n\t\t\t\tdelete self.compoundRuleCodes[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Build the full regular expressions for each compound rule.\r\n\t\t// I have a feeling (but no confirmation yet) that this method of \r\n\t\t// testing for compound words is probably slow.\r\n\t\tfor (i = 0, _len = self.compoundRules.length; i < _len; i++) {\r\n\t\t\tvar ruleText = self.compoundRules[i];\r\n\t\t\t\r\n\t\t\tvar expressionText = \"\";\r\n\t\t\t\r\n\t\t\tfor (j = 0, _jlen = ruleText.length; j < _jlen; j++) {\r\n\t\t\t\tvar character = ruleText[j];\r\n\t\t\t\t\r\n\t\t\t\tif (character in self.compoundRuleCodes) {\r\n\t\t\t\t\texpressionText += \"(\" + self.compoundRuleCodes[character].join(\"|\") + \")\";\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\texpressionText += character;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tself.compoundRules[i] = new RegExp(expressionText, \"i\");\r\n\t\t}\r\n\t\t\r\n\t\tself.loaded = true;\r\n\t\t\r\n\t\tif (settings.asyncLoad && settings.loadedCallback) {\r\n\t\t\tsettings.loadedCallback(self);\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn this;\r\n};\r\n\r\nTypo.prototype = {\r\n\t/**\r\n\t * Loads a Typo instance from a hash of all of the Typo properties.\r\n\t *\r\n\t * @param object obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\r\n\t */\r\n\t\r\n\tload : function (obj) {\r\n\t\tfor (var i in obj) {\r\n\t\t\tif (obj.hasOwnProperty(i)) {\r\n\t\t\t\tthis[i] = obj[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn this;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Read the contents of a file.\r\n\t * \r\n\t * @param {String} path The path (relative) to the file.\r\n\t * @param {String} [charset=\"ISO8859-1\"] The expected charset of the file\r\n\t * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\r\n\t *        files are read synchronously.\r\n\t * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is\r\n\t *          always returned.\r\n\t */\r\n\t\r\n\t_readFile : function (path, charset, async) {\r\n\t\tcharset = charset || \"utf8\";\r\n\t\t\r\n\t\tif (typeof XMLHttpRequest !== 'undefined') {\r\n\t\t\tvar promise;\r\n\t\t\tvar req = new XMLHttpRequest();\r\n\t\t\treq.open(\"GET\", path, async);\r\n\t\t\t\r\n\t\t\tif (async) {\r\n\t\t\t\tpromise = new Promise(function(resolve, reject) {\r\n\t\t\t\t\treq.onload = function() {\r\n\t\t\t\t\t\tif (req.status === 200) {\r\n\t\t\t\t\t\t\tresolve(req.responseText);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\treject(req.statusText);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\treq.onerror = function() {\r\n\t\t\t\t\t\treject(req.statusText);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\r\n\t\t\tif (req.overrideMimeType)\r\n\t\t\t\treq.overrideMimeType(\"text/plain; charset=\" + charset);\r\n\t\t\r\n\t\t\treq.send(null);\r\n\t\t\t\r\n\t\t\treturn async ? promise : req.responseText;\r\n\t\t}\r\n\t\telse if (typeof require !== 'undefined') {\r\n\t\t\t// Node.js\r\n\t\t\tvar fs = require(\"fs\");\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tif (fs.existsSync(path)) {\r\n\t\t\t\t\tvar stats = fs.statSync(path);\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar fileDescriptor = fs.openSync(path, 'r');\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar buffer = new Buffer(stats.size);\r\n\t\t\t\t\t\r\n\t\t\t\t\tfs.readSync(fileDescriptor, buffer, 0, buffer.length, null);\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn buffer.toString(charset, 0, buffer.length);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconsole.log(\"Path \" + path + \" does not exist.\");\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\tconsole.log(e);\r\n\t\t\t\treturn '';\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t\r\n\t/**\r\n\t * Parse the rules out from a .aff file.\r\n\t *\r\n\t * @param {String} data The contents of the affix file.\r\n\t * @returns object The rules from the file.\r\n\t */\r\n\t\r\n\t_parseAFF : function (data) {\r\n\t\tvar rules = {};\r\n\t\t\r\n\t\tvar line, subline, numEntries, lineParts;\r\n\t\tvar i, j, _len, _jlen;\r\n\t\t\r\n\t\t// Remove comment lines\r\n\t\tdata = this._removeAffixComments(data);\r\n\t\t\r\n\t\tvar lines = data.split(\"\\n\");\r\n\t\t\r\n\t\tfor (i = 0, _len = lines.length; i < _len; i++) {\r\n\t\t\tline = lines[i];\r\n\t\t\t\r\n\t\t\tvar definitionParts = line.split(/\\s+/);\r\n\t\t\t\r\n\t\t\tvar ruleType = definitionParts[0];\r\n\t\t\t\r\n\t\t\tif (ruleType == \"PFX\" || ruleType == \"SFX\") {\r\n\t\t\t\tvar ruleCode = definitionParts[1];\r\n\t\t\t\tvar combineable = definitionParts[2];\r\n\t\t\t\tnumEntries = parseInt(definitionParts[3], 10);\r\n\t\t\t\t\r\n\t\t\t\tvar entries = [];\r\n\t\t\t\t\r\n\t\t\t\tfor (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\r\n\t\t\t\t\tsubline = lines[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\tlineParts = subline.split(/\\s+/);\r\n\t\t\t\t\tvar charactersToRemove = lineParts[2];\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar additionParts = lineParts[3].split(\"/\");\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar charactersToAdd = additionParts[0];\r\n\t\t\t\t\tif (charactersToAdd === \"0\") charactersToAdd = \"\";\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar continuationClasses = this.parseRuleCodes(additionParts[1]);\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar regexToMatch = lineParts[4];\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar entry = {};\r\n\t\t\t\t\tentry.add = charactersToAdd;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (continuationClasses.length > 0) entry.continuationClasses = continuationClasses;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (regexToMatch !== \".\") {\r\n\t\t\t\t\t\tif (ruleType === \"SFX\") {\r\n\t\t\t\t\t\t\tentry.match = new RegExp(regexToMatch + \"$\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tentry.match = new RegExp(\"^\" + regexToMatch);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (charactersToRemove != \"0\") {\r\n\t\t\t\t\t\tif (ruleType === \"SFX\") {\r\n\t\t\t\t\t\t\tentry.remove = new RegExp(charactersToRemove  + \"$\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tentry.remove = charactersToRemove;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tentries.push(entry);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\trules[ruleCode] = { \"type\" : ruleType, \"combineable\" : (combineable == \"Y\"), \"entries\" : entries };\r\n\t\t\t\t\r\n\t\t\t\ti += numEntries;\r\n\t\t\t}\r\n\t\t\telse if (ruleType === \"COMPOUNDRULE\") {\r\n\t\t\t\tnumEntries = parseInt(definitionParts[1], 10);\r\n\t\t\t\t\r\n\t\t\t\tfor (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\r\n\t\t\t\t\tline = lines[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\tlineParts = line.split(/\\s+/);\r\n\t\t\t\t\tthis.compoundRules.push(lineParts[1]);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ti += numEntries;\r\n\t\t\t}\r\n\t\t\telse if (ruleType === \"REP\") {\r\n\t\t\t\tlineParts = line.split(/\\s+/);\r\n\t\t\t\t\r\n\t\t\t\tif (lineParts.length === 3) {\r\n\t\t\t\t\tthis.replacementTable.push([ lineParts[1], lineParts[2] ]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// ONLYINCOMPOUND\r\n\t\t\t\t// COMPOUNDMIN\r\n\t\t\t\t// FLAG\r\n\t\t\t\t// KEEPCASE\r\n\t\t\t\t// NEEDAFFIX\r\n\t\t\t\t\r\n\t\t\t\tthis.flags[ruleType] = definitionParts[1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn rules;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Removes comment lines and then cleans up blank lines and trailing whitespace.\r\n\t *\r\n\t * @param {String} data The data from an affix file.\r\n\t * @return {String} The cleaned-up data.\r\n\t */\r\n\t\r\n\t_removeAffixComments : function (data) {\r\n\t\t// Remove comments\r\n\t\t// This used to remove any string starting with '#' up to the end of the line,\r\n\t\t// but some COMPOUNDRULE definitions include '#' as part of the rule.\r\n\t\t// I haven't seen any affix files that use comments on the same line as real data,\r\n\t\t// so I don't think this will break anything.\r\n\t\tdata = data.replace(/^\\s*#.*$/mg, \"\");\r\n\t\t\r\n\t\t// Trim each line\r\n\t\tdata = data.replace(/^\\s\\s*/m, '').replace(/\\s\\s*$/m, '');\r\n\t\t\r\n\t\t// Remove blank lines.\r\n\t\tdata = data.replace(/\\n{2,}/g, \"\\n\");\r\n\t\t\r\n\t\t// Trim the entire string\r\n\t\tdata = data.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\r\n\t\t\r\n\t\treturn data;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Parses the words out from the .dic file.\r\n\t *\r\n\t * @param {String} data The data from the dictionary file.\r\n\t * @returns object The lookup table containing all of the words and\r\n\t *                 word forms from the dictionary.\r\n\t */\r\n\t\r\n\t_parseDIC : function (data) {\r\n\t\tdata = this._removeDicComments(data);\r\n\t\t\r\n\t\tvar lines = data.split(\"\\n\");\r\n\t\tvar dictionaryTable = {};\r\n\t\t\r\n\t\tfunction addWord(word, rules) {\r\n\t\t\t// Some dictionaries will list the same word multiple times with different rule sets.\r\n\t\t\tif (!dictionaryTable.hasOwnProperty(word)) {\r\n\t\t\t\tdictionaryTable[word] = null;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (rules.length > 0) {\r\n\t\t\t\tif (dictionaryTable[word] === null) {\r\n\t\t\t\t\tdictionaryTable[word] = [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdictionaryTable[word].push(rules);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// The first line is the number of words in the dictionary.\r\n\t\tfor (var i = 1, _len = lines.length; i < _len; i++) {\r\n\t\t\tvar line = lines[i];\r\n\t\t\t\r\n\t\t\tvar parts = line.split(\"/\", 2);\r\n\t\t\t\r\n\t\t\tvar word = parts[0];\r\n\r\n\t\t\t// Now for each affix rule, generate that form of the word.\r\n\t\t\tif (parts.length > 1) {\r\n\t\t\t\tvar ruleCodesArray = this.parseRuleCodes(parts[1]);\r\n\t\t\t\t\r\n\t\t\t\t// Save the ruleCodes for compound word situations.\r\n\t\t\t\tif (!(\"NEEDAFFIX\" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {\r\n\t\t\t\t\taddWord(word, ruleCodesArray);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfor (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {\r\n\t\t\t\t\tvar code = ruleCodesArray[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar rule = this.rules[code];\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (rule) {\r\n\t\t\t\t\t\tvar newWords = this._applyRule(word, rule);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfor (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {\r\n\t\t\t\t\t\t\tvar newWord = newWords[ii];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\taddWord(newWord, []);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (rule.combineable) {\r\n\t\t\t\t\t\t\t\tfor (var k = j + 1; k < _jlen; k++) {\r\n\t\t\t\t\t\t\t\t\tvar combineCode = ruleCodesArray[k];\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tvar combineRule = this.rules[combineCode];\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif (combineRule) {\r\n\t\t\t\t\t\t\t\t\t\tif (combineRule.combineable && (rule.type != combineRule.type)) {\r\n\t\t\t\t\t\t\t\t\t\t\tvar otherNewWords = this._applyRule(newWord, combineRule);\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\tfor (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvar otherNewWord = otherNewWords[iii];\r\n\t\t\t\t\t\t\t\t\t\t\t\taddWord(otherNewWord, []);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (code in this.compoundRuleCodes) {\r\n\t\t\t\t\t\tthis.compoundRuleCodes[code].push(word);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\taddWord(word.trim(), []);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn dictionaryTable;\r\n\t},\r\n\t\r\n\t\r\n\t/**\r\n\t * Removes comment lines and then cleans up blank lines and trailing whitespace.\r\n\t *\r\n\t * @param {String} data The data from a .dic file.\r\n\t * @return {String} The cleaned-up data.\r\n\t */\r\n\t\r\n\t_removeDicComments : function (data) {\r\n\t\t// I can't find any official documentation on it, but at least the de_DE\r\n\t\t// dictionary uses tab-indented lines as comments.\r\n\t\t\r\n\t\t// Remove comments\r\n\t\tdata = data.replace(/^\\t.*$/mg, \"\");\r\n\t\t\r\n\t\treturn data;\r\n\t},\r\n\t\r\n\tparseRuleCodes : function (textCodes) {\r\n\t\tif (!textCodes) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\t\telse if (!(\"FLAG\" in this.flags)) {\r\n\t\t\treturn textCodes.split(\"\");\r\n\t\t}\r\n\t\telse if (this.flags.FLAG === \"long\") {\r\n\t\t\tvar flags = [];\r\n\t\t\t\r\n\t\t\tfor (var i = 0, _len = textCodes.length; i < _len; i += 2) {\r\n\t\t\t\tflags.push(textCodes.substr(i, 2));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn flags;\r\n\t\t}\r\n\t\telse if (this.flags.FLAG === \"num\") {\r\n\t\t\treturn textCodes.split(\",\");\r\n\t\t}\r\n\t},\r\n\t\r\n\t/**\r\n\t * Applies an affix rule to a word.\r\n\t *\r\n\t * @param {String} word The base word.\r\n\t * @param {Object} rule The affix rule.\r\n\t * @returns {String[]} The new words generated by the rule.\r\n\t */\r\n\t\r\n\t_applyRule : function (word, rule) {\r\n\t\tvar entries = rule.entries;\r\n\t\tvar newWords = [];\r\n\t\t\r\n\t\tfor (var i = 0, _len = entries.length; i < _len; i++) {\r\n\t\t\tvar entry = entries[i];\r\n\t\t\t\r\n\t\t\tif (!entry.match || word.match(entry.match)) {\r\n\t\t\t\tvar newWord = word;\r\n\t\t\t\t\r\n\t\t\t\tif (entry.remove) {\r\n\t\t\t\t\tnewWord = newWord.replace(entry.remove, \"\");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (rule.type === \"SFX\") {\r\n\t\t\t\t\tnewWord = newWord + entry.add;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tnewWord = entry.add + newWord;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tnewWords.push(newWord);\r\n\t\t\t\t\r\n\t\t\t\tif (\"continuationClasses\" in entry) {\r\n\t\t\t\t\tfor (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {\r\n\t\t\t\t\t\tvar continuationRule = this.rules[entry.continuationClasses[j]];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (continuationRule) {\r\n\t\t\t\t\t\t\tnewWords = newWords.concat(this._applyRule(newWord, continuationRule));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// This shouldn't happen, but it does, at least in the de_DE dictionary.\r\n\t\t\t\t\t\t\t// I think the author mistakenly supplied lower-case rule codes instead \r\n\t\t\t\t\t\t\t// of upper-case.\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t*/\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn newWords;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Checks whether a word or a capitalization variant exists in the current dictionary.\r\n\t * The word is trimmed and several variations of capitalizations are checked.\r\n\t * If you want to check a word without any changes made to it, call checkExact()\r\n\t *\r\n\t * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\r\n\t *\r\n\t * @param {String} aWord The word to check.\r\n\t * @returns {Boolean}\r\n\t */\r\n\t\r\n\tcheck : function (aWord) {\r\n\t\tif (!this.loaded) {\r\n\t\t\tthrow \"Dictionary not loaded.\";\r\n\t\t}\r\n\t\t\r\n\t\t// Remove leading and trailing whitespace\r\n\t\tvar trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\r\n\t\t\r\n\t\tif (this.checkExact(trimmedWord)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t// The exact word is not in the dictionary.\r\n\t\tif (trimmedWord.toUpperCase() === trimmedWord) {\r\n\t\t\t// The word was supplied in all uppercase.\r\n\t\t\t// Check for a capitalized form of the word.\r\n\t\t\tvar capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\r\n\t\t\t\r\n\t\t\tif (this.hasFlag(capitalizedWord, \"KEEPCASE\")) {\r\n\t\t\t\t// Capitalization variants are not allowed for this word.\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (this.checkExact(capitalizedWord)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar lowercaseWord = trimmedWord.toLowerCase();\r\n\t\t\r\n\t\tif (lowercaseWord !== trimmedWord) {\r\n\t\t\tif (this.hasFlag(lowercaseWord, \"KEEPCASE\")) {\r\n\t\t\t\t// Capitalization variants are not allowed for this word.\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Check for a lowercase form\r\n\t\t\tif (this.checkExact(lowercaseWord)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Checks whether a word exists in the current dictionary.\r\n\t *\r\n\t * @param {String} word The word to check.\r\n\t * @returns {Boolean}\r\n\t */\r\n\t\r\n\tcheckExact : function (word) {\r\n\t\tif (!this.loaded) {\r\n\t\t\tthrow \"Dictionary not loaded.\";\r\n\t\t}\r\n\r\n\t\tvar ruleCodes = this.dictionaryTable[word];\r\n\t\t\r\n\t\tvar i, _len;\r\n\t\t\r\n\t\tif (typeof ruleCodes === 'undefined') {\r\n\t\t\t// Check if this might be a compound word.\r\n\t\t\tif (\"COMPOUNDMIN\" in this.flags && word.length >= this.flags.COMPOUNDMIN) {\r\n\t\t\t\tfor (i = 0, _len = this.compoundRules.length; i < _len; i++) {\r\n\t\t\t\t\tif (word.match(this.compoundRules[i])) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (ruleCodes === null) {\r\n\t\t\t// a null (but not undefined) value for an entry in the dictionary table\r\n\t\t\t// means that the word is in the dictionary but has no flags.\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.\r\n\t\t\tfor (i = 0, _len = ruleCodes.length; i < _len; i++) {\r\n\t\t\t\tif (!this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCodes[i])) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Looks up whether a given word is flagged with a given flag.\r\n\t *\r\n\t * @param {String} word The word in question.\r\n\t * @param {String} flag The flag in question.\r\n\t * @return {Boolean}\r\n\t */\r\n\t \r\n\thasFlag : function (word, flag, wordFlags) {\r\n\t\tif (!this.loaded) {\r\n\t\t\tthrow \"Dictionary not loaded.\";\r\n\t\t}\r\n\r\n\t\tif (flag in this.flags) {\r\n\t\t\tif (typeof wordFlags === 'undefined') {\r\n\t\t\t\twordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Returns a list of suggestions for a misspelled word.\r\n\t *\r\n\t * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\r\n\t * This suggestor is primitive, but it works.\r\n\t *\r\n\t * @param {String} word The misspelling.\r\n\t * @param {Number} [limit=5] The maximum number of suggestions to return.\r\n\t * @returns {String[]} The array of suggestions.\r\n\t */\r\n\t\r\n\talphabet : \"\",\r\n\t\r\n\tsuggest : function (word, limit) {\r\n\t\tif (!this.loaded) {\r\n\t\t\tthrow \"Dictionary not loaded.\";\r\n\t\t}\r\n\r\n\t\tlimit = limit || 5;\r\n\r\n\t\tif (this.memoized.hasOwnProperty(word)) {\r\n\t\t\tvar memoizedLimit = this.memoized[word]['limit'];\r\n\r\n\t\t\t// Only return the cached list if it's big enough or if there weren't enough suggestions\r\n\t\t\t// to fill a smaller limit.\r\n\t\t\tif (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\r\n\t\t\t\treturn this.memoized[word]['suggestions'].slice(0, limit);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (this.check(word)) return [];\r\n\t\t\r\n\t\t// Check the replacement table.\r\n\t\tfor (var i = 0, _len = this.replacementTable.length; i < _len; i++) {\r\n\t\t\tvar replacementEntry = this.replacementTable[i];\r\n\t\t\t\r\n\t\t\tif (word.indexOf(replacementEntry[0]) !== -1) {\r\n\t\t\t\tvar correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\r\n\t\t\t\t\r\n\t\t\t\tif (this.check(correctedWord)) {\r\n\t\t\t\t\treturn [ correctedWord ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar self = this;\r\n\t\tself.alphabet = \"abcdefghijklmnopqrstuvwxyz\";\r\n\t\t\r\n\t\t/*\r\n\t\tif (!self.alphabet) {\r\n\t\t\t// Use the alphabet as implicitly defined by the words in the dictionary.\r\n\t\t\tvar alphaHash = {};\r\n\t\t\t\r\n\t\t\tfor (var i in self.dictionaryTable) {\r\n\t\t\t\tfor (var j = 0, _len = i.length; j < _len; j++) {\r\n\t\t\t\t\talphaHash[i[j]] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (var i in alphaHash) {\r\n\t\t\t\tself.alphabet += i;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar alphaArray = self.alphabet.split(\"\");\r\n\t\t\talphaArray.sort();\r\n\t\t\tself.alphabet = alphaArray.join(\"\");\r\n\t\t}\r\n\t\t*/\r\n\t\t\r\n\t\tfunction edits1(words) {\r\n\t\t\tvar rv = [];\r\n\t\t\t\r\n\t\t\tvar ii, i, j, _iilen, _len, _jlen;\r\n\t\t\t\r\n\t\t\tfor (ii = 0, _iilen = words.length; ii < _iilen; ii++) {\r\n\t\t\t\tvar word = words[ii];\r\n\t\t\t\t\r\n\t\t\t\tfor (i = 0, _len = word.length + 1; i < _len; i++) {\r\n\t\t\t\t\tvar s = [ word.substring(0, i), word.substring(i) ];\r\n\t\t\t\t\r\n\t\t\t\t\tif (s[1]) {\r\n\t\t\t\t\t\trv.push(s[0] + s[1].substring(1));\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Eliminate transpositions of identical letters\r\n\t\t\t\t\tif (s[1].length > 1 && s[1][1] !== s[1][0]) {\r\n\t\t\t\t\t\trv.push(s[0] + s[1][1] + s[1][0] + s[1].substring(2));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (s[1]) {\r\n\t\t\t\t\t\tfor (j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {\r\n\t\t\t\t\t\t\t// Eliminate replacement of a letter by itself\r\n\t\t\t\t\t\t\tif (self.alphabet[j] != s[1].substring(0,1)){\r\n\t\t\t\t\t\t\t\trv.push(s[0] + self.alphabet[j] + s[1].substring(1));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (s[1]) {\r\n\t\t\t\t\t\tfor (j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {\r\n\t\t\t\t\t\t\trv.push(s[0] + self.alphabet[j] + s[1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn rv;\r\n\t\t}\r\n\t\t\r\n\t\tfunction known(words) {\r\n\t\t\tvar rv = [];\r\n\t\t\t\r\n\t\t\tfor (var i = 0, _len = words.length; i < _len; i++) {\r\n\t\t\t\tif (self.check(words[i])) {\r\n\t\t\t\t\trv.push(words[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn rv;\r\n\t\t}\r\n\t\t\r\n\t\tfunction correct(word) {\r\n\t\t\t// Get the edit-distance-1 and edit-distance-2 forms of this word.\r\n\t\t\tvar ed1 = edits1([word]);\r\n\t\t\tvar ed2 = edits1(ed1);\r\n\t\t\t\r\n\t\t\tvar corrections = known(ed1.concat(ed2));\r\n\t\t\t\r\n\t\t\tvar i, _len;\r\n\t\t\t\r\n\t\t\t// Sort the edits based on how many different ways they were created.\r\n\t\t\tvar weighted_corrections = {};\r\n\t\t\t\r\n\t\t\tfor (i = 0, _len = corrections.length; i < _len; i++) {\r\n\t\t\t\tif (!(corrections[i] in weighted_corrections)) {\r\n\t\t\t\t\tweighted_corrections[corrections[i]] = 1;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tweighted_corrections[corrections[i]] += 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar sorted_corrections = [];\r\n\t\t\t\r\n\t\t\tfor (i in weighted_corrections) {\r\n\t\t\t\tif (weighted_corrections.hasOwnProperty(i)) {\r\n\t\t\t\t\tsorted_corrections.push([ i, weighted_corrections[i] ]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfunction sorter(a, b) {\r\n\t\t\t\tif (a[1] < b[1]) {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsorted_corrections.sort(sorter).reverse();\r\n\t\t\t\r\n\t\t\tvar rv = [];\r\n\r\n\t\t\tvar capitalization_scheme = \"lowercase\";\r\n\t\t\t\r\n\t\t\tif (word.toUpperCase() === word) {\r\n\t\t\t\tcapitalization_scheme = \"uppercase\";\r\n\t\t\t}\r\n\t\t\telse if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {\r\n\t\t\t\tcapitalization_scheme = \"capitalized\";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (i = 0, _len = Math.min(limit, sorted_corrections.length); i < _len; i++) {\r\n\t\t\t\tif (\"uppercase\" === capitalization_scheme) {\r\n\t\t\t\t\tsorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();\r\n\t\t\t\t}\r\n\t\t\t\telse if (\"capitalized\" === capitalization_scheme) {\r\n\t\t\t\t\tsorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (!self.hasFlag(sorted_corrections[i][0], \"NOSUGGEST\")) {\r\n\t\t\t\t\trv.push(sorted_corrections[i][0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn rv;\r\n\t\t}\r\n\t\t\r\n\t\tthis.memoized[word] = {\r\n\t\t\t'suggestions': correct(word),\r\n\t\t\t'limit': limit\r\n\t\t};\r\n\r\n\t\treturn this.memoized[word]['suggestions'];\r\n\t}\r\n};\r\n})();\r\n\r\n// Support for use as a node.js module.\r\nif (typeof module !== 'undefined') {\r\n\tmodule.exports = Typo;\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/typo-js/typo.js\n// module id = 1284\n// module chunks = 18","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-48a3e0da\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./index.vue\")\n}\nvar Component = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./index.vue\"),\n  /* template */\n  require(\"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-48a3e0da\\\"}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./index.vue\"),\n  /* styles */\n  injectStyle,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/MdEditor/index.vue\n// module id = 1295\n// module chunks = 18","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"simplemde-container\",\n    style: ({\n      height: _vm.height + 'px',\n      zIndex: _vm.zIndex\n    })\n  }, [_c('textarea', {\n    attrs: {\n      \"id\": _vm.id\n    }\n  })])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-48a3e0da\"}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/MdEditor/index.vue\n// module id = 1358\n// module chunks = 18","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"components-container\"\n  }, [_vm._m(0), _vm._v(\" \"), _c('div', {\n    staticClass: \"editor-container\"\n  }, [_c('md-editor', {\n    ref: \"contentEditor\",\n    attrs: {\n      \"id\": \"contentEditor\",\n      \"height\": 300,\n      \"zIndex\": 20\n    },\n    model: {\n      value: (_vm.content),\n      callback: function($$v) {\n        _vm.content = $$v\n      },\n      expression: \"content\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-button', {\n    staticStyle: {\n      \"margin-top\": \"80px\"\n    },\n    attrs: {\n      \"type\": \"primary\"\n    },\n    on: {\n      \"click\": _vm.markdown2Html\n    }\n  }, [_vm._v(\"转为HTML\"), _c('i', {\n    staticClass: \"el-icon-document el-icon--right\"\n  })]), _vm._v(\" \"), _c('div', {\n    domProps: {\n      \"innerHTML\": _vm._s(_vm.html)\n    }\n  })], 1)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('code', [_vm._v(\"Markdown 我们这里选用了 \"), _c('a', {\n    attrs: {\n      \"href\": \"https://github.com/sparksuite/simplemde-markdown-editor\",\n      \"target\": \"_blank\"\n    }\n  }, [_vm._v(\"simplemde-markdown-editor\")]), _vm._v(\" ，简单的用vue封装了一下\"), _c('a', {\n    attrs: {\n      \"target\": \"_blank\",\n      \"href\": \"https://segmentfault.com/a/1190000009762198#articleHeader14\"\n    }\n  }, [_vm._v(\" 相关文章 \")])])\n}]}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-8b20223e\"}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/views/components/markdown.vue\n// module id = 1398\n// module chunks = 18","var Component = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./markdown.vue\"),\n  /* template */\n  require(\"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-8b20223e\\\"}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./markdown.vue\"),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/components/markdown.vue\n// module id = 761\n// module chunks = 18","// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// This is CodeMirror (http://codemirror.net), a code editor\r\n// implemented in JavaScript on top of the browser's DOM.\r\n//\r\n// You can find some technical background for some of the code below\r\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\r\n\r\n(function (global, factory) {\r\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n\ttypeof define === 'function' && define.amd ? define(factory) :\r\n\t(global.CodeMirror = factory());\r\n}(this, (function () { 'use strict';\r\n\r\n// Kludges for bugs and behavior differences that can't be feature\r\n// detected are enabled based on userAgent etc sniffing.\r\nvar userAgent = navigator.userAgent;\r\nvar platform = navigator.platform;\r\n\r\nvar gecko = /gecko\\/\\d/i.test(userAgent);\r\nvar ie_upto10 = /MSIE \\d/.test(userAgent);\r\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\r\nvar edge = /Edge\\/(\\d+)/.exec(userAgent);\r\nvar ie = ie_upto10 || ie_11up || edge;\r\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\r\nvar webkit = !edge && /WebKit\\//.test(userAgent);\r\nvar qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\r\nvar chrome = !edge && /Chrome\\//.test(userAgent);\r\nvar presto = /Opera\\//.test(userAgent);\r\nvar safari = /Apple Computer/.test(navigator.vendor);\r\nvar mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\r\nvar phantom = /PhantomJS/.test(userAgent);\r\n\r\nvar ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\r\nvar android = /Android/.test(userAgent);\r\n// This is woefully incomplete. Suggestions for alternative methods welcome.\r\nvar mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\r\nvar mac = ios || /Mac/.test(platform);\r\nvar chromeOS = /\\bCrOS\\b/.test(userAgent);\r\nvar windows = /win/i.test(platform);\r\n\r\nvar presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\r\nif (presto_version) { presto_version = Number(presto_version[1]); }\r\nif (presto_version && presto_version >= 15) { presto = false; webkit = true; }\r\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\r\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\r\nvar captureRightClick = gecko || (ie && ie_version >= 9);\r\n\r\nfunction classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\r\n\r\nvar rmClass = function(node, cls) {\r\n  var current = node.className;\r\n  var match = classTest(cls).exec(current);\r\n  if (match) {\r\n    var after = current.slice(match.index + match[0].length);\r\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\r\n  }\r\n};\r\n\r\nfunction removeChildren(e) {\r\n  for (var count = e.childNodes.length; count > 0; --count)\r\n    { e.removeChild(e.firstChild); }\r\n  return e\r\n}\r\n\r\nfunction removeChildrenAndAdd(parent, e) {\r\n  return removeChildren(parent).appendChild(e)\r\n}\r\n\r\nfunction elt(tag, content, className, style) {\r\n  var e = document.createElement(tag);\r\n  if (className) { e.className = className; }\r\n  if (style) { e.style.cssText = style; }\r\n  if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\r\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\r\n  return e\r\n}\r\n// wrapper for elt, which removes the elt from the accessibility tree\r\nfunction eltP(tag, content, className, style) {\r\n  var e = elt(tag, content, className, style);\r\n  e.setAttribute(\"role\", \"presentation\");\r\n  return e\r\n}\r\n\r\nvar range;\r\nif (document.createRange) { range = function(node, start, end, endNode) {\r\n  var r = document.createRange();\r\n  r.setEnd(endNode || node, end);\r\n  r.setStart(node, start);\r\n  return r\r\n}; }\r\nelse { range = function(node, start, end) {\r\n  var r = document.body.createTextRange();\r\n  try { r.moveToElementText(node.parentNode); }\r\n  catch(e) { return r }\r\n  r.collapse(true);\r\n  r.moveEnd(\"character\", end);\r\n  r.moveStart(\"character\", start);\r\n  return r\r\n}; }\r\n\r\nfunction contains(parent, child) {\r\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\r\n    { child = child.parentNode; }\r\n  if (parent.contains)\r\n    { return parent.contains(child) }\r\n  do {\r\n    if (child.nodeType == 11) { child = child.host; }\r\n    if (child == parent) { return true }\r\n  } while (child = child.parentNode)\r\n}\r\n\r\nfunction activeElt() {\r\n  // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\r\n  // IE < 10 will throw when accessed while the page is loading or in an iframe.\r\n  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\r\n  var activeElement;\r\n  try {\r\n    activeElement = document.activeElement;\r\n  } catch(e) {\r\n    activeElement = document.body || null;\r\n  }\r\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\r\n    { activeElement = activeElement.shadowRoot.activeElement; }\r\n  return activeElement\r\n}\r\n\r\nfunction addClass(node, cls) {\r\n  var current = node.className;\r\n  if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\r\n}\r\nfunction joinClasses(a, b) {\r\n  var as = a.split(\" \");\r\n  for (var i = 0; i < as.length; i++)\r\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\r\n  return b\r\n}\r\n\r\nvar selectInput = function(node) { node.select(); };\r\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\r\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\r\nelse if (ie) // Suppress mysterious IE10 errors\r\n  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\r\n\r\nfunction bind(f) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  return function(){return f.apply(null, args)}\r\n}\r\n\r\nfunction copyObj(obj, target, overwrite) {\r\n  if (!target) { target = {}; }\r\n  for (var prop in obj)\r\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\r\n      { target[prop] = obj[prop]; } }\r\n  return target\r\n}\r\n\r\n// Counts the column offset in a string, taking tabs into account.\r\n// Used mostly to find indentation.\r\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\r\n  if (end == null) {\r\n    end = string.search(/[^\\s\\u00a0]/);\r\n    if (end == -1) { end = string.length; }\r\n  }\r\n  for (var i = startIndex || 0, n = startValue || 0;;) {\r\n    var nextTab = string.indexOf(\"\\t\", i);\r\n    if (nextTab < 0 || nextTab >= end)\r\n      { return n + (end - i) }\r\n    n += nextTab - i;\r\n    n += tabSize - (n % tabSize);\r\n    i = nextTab + 1;\r\n  }\r\n}\r\n\r\nvar Delayed = function() {this.id = null;};\r\nDelayed.prototype.set = function (ms, f) {\r\n  clearTimeout(this.id);\r\n  this.id = setTimeout(f, ms);\r\n};\r\n\r\nfunction indexOf(array, elt) {\r\n  for (var i = 0; i < array.length; ++i)\r\n    { if (array[i] == elt) { return i } }\r\n  return -1\r\n}\r\n\r\n// Number of pixels added to scroller and sizer to hide scrollbar\r\nvar scrollerGap = 30;\r\n\r\n// Returned or thrown by various protocols to signal 'I'm not\r\n// handling this'.\r\nvar Pass = {toString: function(){return \"CodeMirror.Pass\"}};\r\n\r\n// Reused option objects for setSelection & friends\r\nvar sel_dontScroll = {scroll: false};\r\nvar sel_mouse = {origin: \"*mouse\"};\r\nvar sel_move = {origin: \"+move\"};\r\n\r\n// The inverse of countColumn -- find the offset that corresponds to\r\n// a particular column.\r\nfunction findColumn(string, goal, tabSize) {\r\n  for (var pos = 0, col = 0;;) {\r\n    var nextTab = string.indexOf(\"\\t\", pos);\r\n    if (nextTab == -1) { nextTab = string.length; }\r\n    var skipped = nextTab - pos;\r\n    if (nextTab == string.length || col + skipped >= goal)\r\n      { return pos + Math.min(skipped, goal - col) }\r\n    col += nextTab - pos;\r\n    col += tabSize - (col % tabSize);\r\n    pos = nextTab + 1;\r\n    if (col >= goal) { return pos }\r\n  }\r\n}\r\n\r\nvar spaceStrs = [\"\"];\r\nfunction spaceStr(n) {\r\n  while (spaceStrs.length <= n)\r\n    { spaceStrs.push(lst(spaceStrs) + \" \"); }\r\n  return spaceStrs[n]\r\n}\r\n\r\nfunction lst(arr) { return arr[arr.length-1] }\r\n\r\nfunction map(array, f) {\r\n  var out = [];\r\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\r\n  return out\r\n}\r\n\r\nfunction insertSorted(array, value, score) {\r\n  var pos = 0, priority = score(value);\r\n  while (pos < array.length && score(array[pos]) <= priority) { pos++; }\r\n  array.splice(pos, 0, value);\r\n}\r\n\r\nfunction nothing() {}\r\n\r\nfunction createObj(base, props) {\r\n  var inst;\r\n  if (Object.create) {\r\n    inst = Object.create(base);\r\n  } else {\r\n    nothing.prototype = base;\r\n    inst = new nothing();\r\n  }\r\n  if (props) { copyObj(props, inst); }\r\n  return inst\r\n}\r\n\r\nvar nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\r\nfunction isWordCharBasic(ch) {\r\n  return /\\w/.test(ch) || ch > \"\\x80\" &&\r\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\r\n}\r\nfunction isWordChar(ch, helper) {\r\n  if (!helper) { return isWordCharBasic(ch) }\r\n  if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\r\n  return helper.test(ch)\r\n}\r\n\r\nfunction isEmpty(obj) {\r\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\r\n  return true\r\n}\r\n\r\n// Extending unicode characters. A series of a non-extending char +\r\n// any number of extending chars is treated as a single unit as far\r\n// as editing and measuring is concerned. This is not fully correct,\r\n// since some scripts/fonts/browsers also treat other configurations\r\n// of code points as a group.\r\nvar extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\r\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\r\n\r\n// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\r\nfunction skipExtendingChars(str, pos, dir) {\r\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\r\n  return pos\r\n}\r\n\r\n// Returns the value from the range [`from`; `to`] that satisfies\r\n// `pred` and is closest to `from`. Assumes that at least `to` satisfies `pred`.\r\nfunction findFirst(pred, from, to) {\r\n  for (;;) {\r\n    if (Math.abs(from - to) <= 1) { return pred(from) ? from : to }\r\n    var mid = Math.floor((from + to) / 2);\r\n    if (pred(mid)) { to = mid; }\r\n    else { from = mid; }\r\n  }\r\n}\r\n\r\n// The display handles the DOM integration, both for input reading\r\n// and content drawing. It holds references to DOM nodes and\r\n// display-related state.\r\n\r\nfunction Display(place, doc, input) {\r\n  var d = this;\r\n  this.input = input;\r\n\r\n  // Covers bottom-right square when both scrollbars are present.\r\n  d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\r\n  d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\r\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\r\n  // and h scrollbar is present.\r\n  d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\r\n  d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\r\n  // Will contain the actual code, positioned to cover the viewport.\r\n  d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\r\n  // Elements are added to these to represent selection and cursors.\r\n  d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\r\n  d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\r\n  // A visibility: hidden element used to find the size of things.\r\n  d.measure = elt(\"div\", null, \"CodeMirror-measure\");\r\n  // When lines outside of the viewport are measured, they are drawn in this.\r\n  d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\r\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\r\n  d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\r\n                    null, \"position: relative; outline: none\");\r\n  var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\r\n  // Moved around its parent to cover visible view.\r\n  d.mover = elt(\"div\", [lines], null, \"position: relative\");\r\n  // Set to the height of the document, allowing scrolling.\r\n  d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\r\n  d.sizerWidth = null;\r\n  // Behavior of elts with overflow: auto and padding is\r\n  // inconsistent across browsers. This is used to ensure the\r\n  // scrollable area is big enough.\r\n  d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\r\n  // Will contain the gutters, if any.\r\n  d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\r\n  d.lineGutter = null;\r\n  // Actual scrollable element.\r\n  d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\r\n  d.scroller.setAttribute(\"tabIndex\", \"-1\");\r\n  // The element in which the editor lives.\r\n  d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\r\n\r\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\r\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\r\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\r\n\r\n  if (place) {\r\n    if (place.appendChild) { place.appendChild(d.wrapper); }\r\n    else { place(d.wrapper); }\r\n  }\r\n\r\n  // Current rendered range (may be bigger than the view window).\r\n  d.viewFrom = d.viewTo = doc.first;\r\n  d.reportedViewFrom = d.reportedViewTo = doc.first;\r\n  // Information about the rendered lines.\r\n  d.view = [];\r\n  d.renderedView = null;\r\n  // Holds info about a single rendered line when it was rendered\r\n  // for measurement, while not in view.\r\n  d.externalMeasured = null;\r\n  // Empty space (in pixels) above the view\r\n  d.viewOffset = 0;\r\n  d.lastWrapHeight = d.lastWrapWidth = 0;\r\n  d.updateLineNumbers = null;\r\n\r\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0;\r\n  d.scrollbarsClipped = false;\r\n\r\n  // Used to only resize the line number gutter when necessary (when\r\n  // the amount of lines crosses a boundary that makes its width change)\r\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\r\n  // Set to true when a non-horizontal-scrolling line widget is\r\n  // added. As an optimization, line widget aligning is skipped when\r\n  // this is false.\r\n  d.alignWidgets = false;\r\n\r\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\r\n\r\n  // Tracks the maximum line length so that the horizontal scrollbar\r\n  // can be kept static when scrolling.\r\n  d.maxLine = null;\r\n  d.maxLineLength = 0;\r\n  d.maxLineChanged = false;\r\n\r\n  // Used for measuring wheel scrolling granularity\r\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\r\n\r\n  // True when shift is held down.\r\n  d.shift = false;\r\n\r\n  // Used to track whether anything happened since the context menu\r\n  // was opened.\r\n  d.selForContextMenu = null;\r\n\r\n  d.activeTouch = null;\r\n\r\n  input.init(d);\r\n}\r\n\r\n// Find the line object corresponding to the given line number.\r\nfunction getLine(doc, n) {\r\n  n -= doc.first;\r\n  if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\r\n  var chunk = doc;\r\n  while (!chunk.lines) {\r\n    for (var i = 0;; ++i) {\r\n      var child = chunk.children[i], sz = child.chunkSize();\r\n      if (n < sz) { chunk = child; break }\r\n      n -= sz;\r\n    }\r\n  }\r\n  return chunk.lines[n]\r\n}\r\n\r\n// Get the part of a document between two positions, as an array of\r\n// strings.\r\nfunction getBetween(doc, start, end) {\r\n  var out = [], n = start.line;\r\n  doc.iter(start.line, end.line + 1, function (line) {\r\n    var text = line.text;\r\n    if (n == end.line) { text = text.slice(0, end.ch); }\r\n    if (n == start.line) { text = text.slice(start.ch); }\r\n    out.push(text);\r\n    ++n;\r\n  });\r\n  return out\r\n}\r\n// Get the lines between from and to, as array of strings.\r\nfunction getLines(doc, from, to) {\r\n  var out = [];\r\n  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\r\n  return out\r\n}\r\n\r\n// Update the height of a line, propagating the height change\r\n// upwards to parent nodes.\r\nfunction updateLineHeight(line, height) {\r\n  var diff = height - line.height;\r\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\r\n}\r\n\r\n// Given a line object, find its line number by walking up through\r\n// its parent links.\r\nfunction lineNo(line) {\r\n  if (line.parent == null) { return null }\r\n  var cur = line.parent, no = indexOf(cur.lines, line);\r\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\r\n    for (var i = 0;; ++i) {\r\n      if (chunk.children[i] == cur) { break }\r\n      no += chunk.children[i].chunkSize();\r\n    }\r\n  }\r\n  return no + cur.first\r\n}\r\n\r\n// Find the line at the given vertical position, using the height\r\n// information in the document tree.\r\nfunction lineAtHeight(chunk, h) {\r\n  var n = chunk.first;\r\n  outer: do {\r\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\r\n      var child = chunk.children[i$1], ch = child.height;\r\n      if (h < ch) { chunk = child; continue outer }\r\n      h -= ch;\r\n      n += child.chunkSize();\r\n    }\r\n    return n\r\n  } while (!chunk.lines)\r\n  var i = 0;\r\n  for (; i < chunk.lines.length; ++i) {\r\n    var line = chunk.lines[i], lh = line.height;\r\n    if (h < lh) { break }\r\n    h -= lh;\r\n  }\r\n  return n + i\r\n}\r\n\r\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\r\n\r\nfunction lineNumberFor(options, i) {\r\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\r\n}\r\n\r\n// A Pos instance represents a position within the text.\r\nfunction Pos(line, ch, sticky) {\r\n  if ( sticky === void 0 ) sticky = null;\r\n\r\n  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\r\n  this.line = line;\r\n  this.ch = ch;\r\n  this.sticky = sticky;\r\n}\r\n\r\n// Compare two positions, return 0 if they are the same, a negative\r\n// number when a is less, and a positive number otherwise.\r\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\r\n\r\nfunction equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\r\n\r\nfunction copyPos(x) {return Pos(x.line, x.ch)}\r\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\r\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\r\n\r\n// Most of the external API clips given positions to make sure they\r\n// actually exist within the document.\r\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\r\nfunction clipPos(doc, pos) {\r\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\r\n  var last = doc.first + doc.size - 1;\r\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\r\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\r\n}\r\nfunction clipToLen(pos, linelen) {\r\n  var ch = pos.ch;\r\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\r\n  else if (ch < 0) { return Pos(pos.line, 0) }\r\n  else { return pos }\r\n}\r\nfunction clipPosArray(doc, array) {\r\n  var out = [];\r\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\r\n  return out\r\n}\r\n\r\n// Optimize some code when these features are not used.\r\nvar sawReadOnlySpans = false;\r\nvar sawCollapsedSpans = false;\r\n\r\nfunction seeReadOnlySpans() {\r\n  sawReadOnlySpans = true;\r\n}\r\n\r\nfunction seeCollapsedSpans() {\r\n  sawCollapsedSpans = true;\r\n}\r\n\r\n// TEXTMARKER SPANS\r\n\r\nfunction MarkedSpan(marker, from, to) {\r\n  this.marker = marker;\r\n  this.from = from; this.to = to;\r\n}\r\n\r\n// Search an array of spans for a span matching the given marker.\r\nfunction getMarkedSpanFor(spans, marker) {\r\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\r\n    var span = spans[i];\r\n    if (span.marker == marker) { return span }\r\n  } }\r\n}\r\n// Remove a span from an array, returning undefined if no spans are\r\n// left (we don't store arrays for lines without spans).\r\nfunction removeMarkedSpan(spans, span) {\r\n  var r;\r\n  for (var i = 0; i < spans.length; ++i)\r\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\r\n  return r\r\n}\r\n// Add a span to a line.\r\nfunction addMarkedSpan(line, span) {\r\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\r\n  span.marker.attachLine(line);\r\n}\r\n\r\n// Used for the algorithm that adjusts markers for a change in the\r\n// document. These functions cut an array of spans at a given\r\n// character position, returning an array of remaining chunks (or\r\n// undefined if nothing remains).\r\nfunction markedSpansBefore(old, startCh, isInsert) {\r\n  var nw;\r\n  if (old) { for (var i = 0; i < old.length; ++i) {\r\n    var span = old[i], marker = span.marker;\r\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\r\n    if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\r\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\r\n    }\r\n  } }\r\n  return nw\r\n}\r\nfunction markedSpansAfter(old, endCh, isInsert) {\r\n  var nw;\r\n  if (old) { for (var i = 0; i < old.length; ++i) {\r\n    var span = old[i], marker = span.marker;\r\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\r\n    if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\r\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\r\n                                            span.to == null ? null : span.to - endCh));\r\n    }\r\n  } }\r\n  return nw\r\n}\r\n\r\n// Given a change object, compute the new set of marker spans that\r\n// cover the line in which the change took place. Removes spans\r\n// entirely within the change, reconnects spans belonging to the\r\n// same marker that appear on both sides of the change, and cuts off\r\n// spans partially within the change. Returns an array of span\r\n// arrays with one element for each line in (after) the change.\r\nfunction stretchSpansOverChange(doc, change) {\r\n  if (change.full) { return null }\r\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\r\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\r\n  if (!oldFirst && !oldLast) { return null }\r\n\r\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\r\n  // Get the spans that 'stick out' on both sides\r\n  var first = markedSpansBefore(oldFirst, startCh, isInsert);\r\n  var last = markedSpansAfter(oldLast, endCh, isInsert);\r\n\r\n  // Next, merge those two ends\r\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\r\n  if (first) {\r\n    // Fix up .to properties of first\r\n    for (var i = 0; i < first.length; ++i) {\r\n      var span = first[i];\r\n      if (span.to == null) {\r\n        var found = getMarkedSpanFor(last, span.marker);\r\n        if (!found) { span.to = startCh; }\r\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\r\n      }\r\n    }\r\n  }\r\n  if (last) {\r\n    // Fix up .from in last (or move them into first in case of sameLine)\r\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\r\n      var span$1 = last[i$1];\r\n      if (span$1.to != null) { span$1.to += offset; }\r\n      if (span$1.from == null) {\r\n        var found$1 = getMarkedSpanFor(first, span$1.marker);\r\n        if (!found$1) {\r\n          span$1.from = offset;\r\n          if (sameLine) { (first || (first = [])).push(span$1); }\r\n        }\r\n      } else {\r\n        span$1.from += offset;\r\n        if (sameLine) { (first || (first = [])).push(span$1); }\r\n      }\r\n    }\r\n  }\r\n  // Make sure we didn't create any zero-length spans\r\n  if (first) { first = clearEmptySpans(first); }\r\n  if (last && last != first) { last = clearEmptySpans(last); }\r\n\r\n  var newMarkers = [first];\r\n  if (!sameLine) {\r\n    // Fill gap with whole-line-spans\r\n    var gap = change.text.length - 2, gapMarkers;\r\n    if (gap > 0 && first)\r\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\r\n        { if (first[i$2].to == null)\r\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\r\n    for (var i$3 = 0; i$3 < gap; ++i$3)\r\n      { newMarkers.push(gapMarkers); }\r\n    newMarkers.push(last);\r\n  }\r\n  return newMarkers\r\n}\r\n\r\n// Remove spans that are empty and don't have a clearWhenEmpty\r\n// option of false.\r\nfunction clearEmptySpans(spans) {\r\n  for (var i = 0; i < spans.length; ++i) {\r\n    var span = spans[i];\r\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\r\n      { spans.splice(i--, 1); }\r\n  }\r\n  if (!spans.length) { return null }\r\n  return spans\r\n}\r\n\r\n// Used to 'clip' out readOnly ranges when making a change.\r\nfunction removeReadOnlyRanges(doc, from, to) {\r\n  var markers = null;\r\n  doc.iter(from.line, to.line + 1, function (line) {\r\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\r\n      var mark = line.markedSpans[i].marker;\r\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\r\n        { (markers || (markers = [])).push(mark); }\r\n    } }\r\n  });\r\n  if (!markers) { return null }\r\n  var parts = [{from: from, to: to}];\r\n  for (var i = 0; i < markers.length; ++i) {\r\n    var mk = markers[i], m = mk.find(0);\r\n    for (var j = 0; j < parts.length; ++j) {\r\n      var p = parts[j];\r\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\r\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\r\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\r\n        { newParts.push({from: p.from, to: m.from}); }\r\n      if (dto > 0 || !mk.inclusiveRight && !dto)\r\n        { newParts.push({from: m.to, to: p.to}); }\r\n      parts.splice.apply(parts, newParts);\r\n      j += newParts.length - 3;\r\n    }\r\n  }\r\n  return parts\r\n}\r\n\r\n// Connect or disconnect spans from a line.\r\nfunction detachMarkedSpans(line) {\r\n  var spans = line.markedSpans;\r\n  if (!spans) { return }\r\n  for (var i = 0; i < spans.length; ++i)\r\n    { spans[i].marker.detachLine(line); }\r\n  line.markedSpans = null;\r\n}\r\nfunction attachMarkedSpans(line, spans) {\r\n  if (!spans) { return }\r\n  for (var i = 0; i < spans.length; ++i)\r\n    { spans[i].marker.attachLine(line); }\r\n  line.markedSpans = spans;\r\n}\r\n\r\n// Helpers used when computing which overlapping collapsed span\r\n// counts as the larger one.\r\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\r\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\r\n\r\n// Returns a number indicating which of two overlapping collapsed\r\n// spans is larger (and thus includes the other). Falls back to\r\n// comparing ids when the spans cover exactly the same range.\r\nfunction compareCollapsedMarkers(a, b) {\r\n  var lenDiff = a.lines.length - b.lines.length;\r\n  if (lenDiff != 0) { return lenDiff }\r\n  var aPos = a.find(), bPos = b.find();\r\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\r\n  if (fromCmp) { return -fromCmp }\r\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\r\n  if (toCmp) { return toCmp }\r\n  return b.id - a.id\r\n}\r\n\r\n// Find out whether a line ends or starts in a collapsed span. If\r\n// so, return the marker for that span.\r\nfunction collapsedSpanAtSide(line, start) {\r\n  var sps = sawCollapsedSpans && line.markedSpans, found;\r\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\r\n    sp = sps[i];\r\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\r\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\r\n      { found = sp.marker; }\r\n  } }\r\n  return found\r\n}\r\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\r\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\r\n\r\n// Test whether there exists a collapsed span that partially\r\n// overlaps (covers the start or end, but not both) of a new span.\r\n// Such overlap is not allowed.\r\nfunction conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\r\n  var line = getLine(doc, lineNo$$1);\r\n  var sps = sawCollapsedSpans && line.markedSpans;\r\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\r\n    var sp = sps[i];\r\n    if (!sp.marker.collapsed) { continue }\r\n    var found = sp.marker.find(0);\r\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\r\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\r\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\r\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\r\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\r\n      { return true }\r\n  } }\r\n}\r\n\r\n// A visual line is a line as drawn on the screen. Folding, for\r\n// example, can cause multiple logical lines to appear on the same\r\n// visual line. This finds the start of the visual line that the\r\n// given line is part of (usually that is the line itself).\r\nfunction visualLine(line) {\r\n  var merged;\r\n  while (merged = collapsedSpanAtStart(line))\r\n    { line = merged.find(-1, true).line; }\r\n  return line\r\n}\r\n\r\nfunction visualLineEnd(line) {\r\n  var merged;\r\n  while (merged = collapsedSpanAtEnd(line))\r\n    { line = merged.find(1, true).line; }\r\n  return line\r\n}\r\n\r\n// Returns an array of logical lines that continue the visual line\r\n// started by the argument, or undefined if there are no such lines.\r\nfunction visualLineContinued(line) {\r\n  var merged, lines;\r\n  while (merged = collapsedSpanAtEnd(line)) {\r\n    line = merged.find(1, true).line\r\n    ;(lines || (lines = [])).push(line);\r\n  }\r\n  return lines\r\n}\r\n\r\n// Get the line number of the start of the visual line that the\r\n// given line number is part of.\r\nfunction visualLineNo(doc, lineN) {\r\n  var line = getLine(doc, lineN), vis = visualLine(line);\r\n  if (line == vis) { return lineN }\r\n  return lineNo(vis)\r\n}\r\n\r\n// Get the line number of the start of the next visual line after\r\n// the given line.\r\nfunction visualLineEndNo(doc, lineN) {\r\n  if (lineN > doc.lastLine()) { return lineN }\r\n  var line = getLine(doc, lineN), merged;\r\n  if (!lineIsHidden(doc, line)) { return lineN }\r\n  while (merged = collapsedSpanAtEnd(line))\r\n    { line = merged.find(1, true).line; }\r\n  return lineNo(line) + 1\r\n}\r\n\r\n// Compute whether a line is hidden. Lines count as hidden when they\r\n// are part of a visual line that starts with another line, or when\r\n// they are entirely covered by collapsed, non-widget span.\r\nfunction lineIsHidden(doc, line) {\r\n  var sps = sawCollapsedSpans && line.markedSpans;\r\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\r\n    sp = sps[i];\r\n    if (!sp.marker.collapsed) { continue }\r\n    if (sp.from == null) { return true }\r\n    if (sp.marker.widgetNode) { continue }\r\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\r\n      { return true }\r\n  } }\r\n}\r\nfunction lineIsHiddenInner(doc, line, span) {\r\n  if (span.to == null) {\r\n    var end = span.marker.find(1, true);\r\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\r\n  }\r\n  if (span.marker.inclusiveRight && span.to == line.text.length)\r\n    { return true }\r\n  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\r\n    sp = line.markedSpans[i];\r\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\r\n        (sp.to == null || sp.to != span.from) &&\r\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\r\n        lineIsHiddenInner(doc, line, sp)) { return true }\r\n  }\r\n}\r\n\r\n// Find the height above the given line.\r\nfunction heightAtLine(lineObj) {\r\n  lineObj = visualLine(lineObj);\r\n\r\n  var h = 0, chunk = lineObj.parent;\r\n  for (var i = 0; i < chunk.lines.length; ++i) {\r\n    var line = chunk.lines[i];\r\n    if (line == lineObj) { break }\r\n    else { h += line.height; }\r\n  }\r\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\r\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\r\n      var cur = p.children[i$1];\r\n      if (cur == chunk) { break }\r\n      else { h += cur.height; }\r\n    }\r\n  }\r\n  return h\r\n}\r\n\r\n// Compute the character length of a line, taking into account\r\n// collapsed ranges (see markText) that might hide parts, and join\r\n// other lines onto it.\r\nfunction lineLength(line) {\r\n  if (line.height == 0) { return 0 }\r\n  var len = line.text.length, merged, cur = line;\r\n  while (merged = collapsedSpanAtStart(cur)) {\r\n    var found = merged.find(0, true);\r\n    cur = found.from.line;\r\n    len += found.from.ch - found.to.ch;\r\n  }\r\n  cur = line;\r\n  while (merged = collapsedSpanAtEnd(cur)) {\r\n    var found$1 = merged.find(0, true);\r\n    len -= cur.text.length - found$1.from.ch;\r\n    cur = found$1.to.line;\r\n    len += cur.text.length - found$1.to.ch;\r\n  }\r\n  return len\r\n}\r\n\r\n// Find the longest line in the document.\r\nfunction findMaxLine(cm) {\r\n  var d = cm.display, doc = cm.doc;\r\n  d.maxLine = getLine(doc, doc.first);\r\n  d.maxLineLength = lineLength(d.maxLine);\r\n  d.maxLineChanged = true;\r\n  doc.iter(function (line) {\r\n    var len = lineLength(line);\r\n    if (len > d.maxLineLength) {\r\n      d.maxLineLength = len;\r\n      d.maxLine = line;\r\n    }\r\n  });\r\n}\r\n\r\n// BIDI HELPERS\r\n\r\nfunction iterateBidiSections(order, from, to, f) {\r\n  if (!order) { return f(from, to, \"ltr\") }\r\n  var found = false;\r\n  for (var i = 0; i < order.length; ++i) {\r\n    var part = order[i];\r\n    if (part.from < to && part.to > from || from == to && part.to == from) {\r\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\r\n      found = true;\r\n    }\r\n  }\r\n  if (!found) { f(from, to, \"ltr\"); }\r\n}\r\n\r\nvar bidiOther = null;\r\nfunction getBidiPartAt(order, ch, sticky) {\r\n  var found;\r\n  bidiOther = null;\r\n  for (var i = 0; i < order.length; ++i) {\r\n    var cur = order[i];\r\n    if (cur.from < ch && cur.to > ch) { return i }\r\n    if (cur.to == ch) {\r\n      if (cur.from != cur.to && sticky == \"before\") { found = i; }\r\n      else { bidiOther = i; }\r\n    }\r\n    if (cur.from == ch) {\r\n      if (cur.from != cur.to && sticky != \"before\") { found = i; }\r\n      else { bidiOther = i; }\r\n    }\r\n  }\r\n  return found != null ? found : bidiOther\r\n}\r\n\r\n// Bidirectional ordering algorithm\r\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\r\n// that this (partially) implements.\r\n\r\n// One-char codes used for character types:\r\n// L (L):   Left-to-Right\r\n// R (R):   Right-to-Left\r\n// r (AL):  Right-to-Left Arabic\r\n// 1 (EN):  European Number\r\n// + (ES):  European Number Separator\r\n// % (ET):  European Number Terminator\r\n// n (AN):  Arabic Number\r\n// , (CS):  Common Number Separator\r\n// m (NSM): Non-Spacing Mark\r\n// b (BN):  Boundary Neutral\r\n// s (B):   Paragraph Separator\r\n// t (S):   Segment Separator\r\n// w (WS):  Whitespace\r\n// N (ON):  Other Neutrals\r\n\r\n// Returns null if characters are ordered as they appear\r\n// (left-to-right), or an array of sections ({from, to, level}\r\n// objects) in the order in which they occur visually.\r\nvar bidiOrdering = (function() {\r\n  // Character types for codepoints 0 to 0xff\r\n  var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\r\n  // Character types for codepoints 0x600 to 0x6f9\r\n  var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\r\n  function charType(code) {\r\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\r\n    else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\r\n    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\r\n    else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\r\n    else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\r\n    else if (code == 0x200c) { return \"b\" }\r\n    else { return \"L\" }\r\n  }\r\n\r\n  var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\r\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\r\n\r\n  function BidiSpan(level, from, to) {\r\n    this.level = level;\r\n    this.from = from; this.to = to;\r\n  }\r\n\r\n  return function(str, direction) {\r\n    var outerType = direction == \"ltr\" ? \"L\" : \"R\";\r\n\r\n    if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\r\n    var len = str.length, types = [];\r\n    for (var i = 0; i < len; ++i)\r\n      { types.push(charType(str.charCodeAt(i))); }\r\n\r\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\r\n    // change the type of the NSM to the type of the previous\r\n    // character. If the NSM is at the start of the level run, it will\r\n    // get the type of sor.\r\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\r\n      var type = types[i$1];\r\n      if (type == \"m\") { types[i$1] = prev; }\r\n      else { prev = type; }\r\n    }\r\n\r\n    // W2. Search backwards from each instance of a European number\r\n    // until the first strong type (R, L, AL, or sor) is found. If an\r\n    // AL is found, change the type of the European number to Arabic\r\n    // number.\r\n    // W3. Change all ALs to R.\r\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\r\n      var type$1 = types[i$2];\r\n      if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\r\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\r\n    }\r\n\r\n    // W4. A single European separator between two European numbers\r\n    // changes to a European number. A single common separator between\r\n    // two numbers of the same type changes to that type.\r\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\r\n      var type$2 = types[i$3];\r\n      if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\r\n      else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\r\n               (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\r\n      prev$1 = type$2;\r\n    }\r\n\r\n    // W5. A sequence of European terminators adjacent to European\r\n    // numbers changes to all European numbers.\r\n    // W6. Otherwise, separators and terminators change to Other\r\n    // Neutral.\r\n    for (var i$4 = 0; i$4 < len; ++i$4) {\r\n      var type$3 = types[i$4];\r\n      if (type$3 == \",\") { types[i$4] = \"N\"; }\r\n      else if (type$3 == \"%\") {\r\n        var end = (void 0);\r\n        for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\r\n        var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\r\n        for (var j = i$4; j < end; ++j) { types[j] = replace; }\r\n        i$4 = end - 1;\r\n      }\r\n    }\r\n\r\n    // W7. Search backwards from each instance of a European number\r\n    // until the first strong type (R, L, or sor) is found. If an L is\r\n    // found, then change the type of the European number to L.\r\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\r\n      var type$4 = types[i$5];\r\n      if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\r\n      else if (isStrong.test(type$4)) { cur$1 = type$4; }\r\n    }\r\n\r\n    // N1. A sequence of neutrals takes the direction of the\r\n    // surrounding strong text if the text on both sides has the same\r\n    // direction. European and Arabic numbers act as if they were R in\r\n    // terms of their influence on neutrals. Start-of-level-run (sor)\r\n    // and end-of-level-run (eor) are used at level run boundaries.\r\n    // N2. Any remaining neutrals take the embedding direction.\r\n    for (var i$6 = 0; i$6 < len; ++i$6) {\r\n      if (isNeutral.test(types[i$6])) {\r\n        var end$1 = (void 0);\r\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\r\n        var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\r\n        var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\r\n        var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\r\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\r\n        i$6 = end$1 - 1;\r\n      }\r\n    }\r\n\r\n    // Here we depart from the documented algorithm, in order to avoid\r\n    // building up an actual levels array. Since there are only three\r\n    // levels (0, 1, 2) in an implementation that doesn't take\r\n    // explicit embedding into account, we can build up the order on\r\n    // the fly, without following the level-based algorithm.\r\n    var order = [], m;\r\n    for (var i$7 = 0; i$7 < len;) {\r\n      if (countsAsLeft.test(types[i$7])) {\r\n        var start = i$7;\r\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\r\n        order.push(new BidiSpan(0, start, i$7));\r\n      } else {\r\n        var pos = i$7, at = order.length;\r\n        for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\r\n        for (var j$2 = pos; j$2 < i$7;) {\r\n          if (countsAsNum.test(types[j$2])) {\r\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\r\n            var nstart = j$2;\r\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\r\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\r\n            pos = j$2;\r\n          } else { ++j$2; }\r\n        }\r\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\r\n      }\r\n    }\r\n    if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\r\n      order[0].from = m[0].length;\r\n      order.unshift(new BidiSpan(0, 0, m[0].length));\r\n    }\r\n    if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\r\n      lst(order).to -= m[0].length;\r\n      order.push(new BidiSpan(0, len - m[0].length, len));\r\n    }\r\n\r\n    return direction == \"rtl\" ? order.reverse() : order\r\n  }\r\n})();\r\n\r\n// Get the bidi ordering for the given line (and cache it). Returns\r\n// false for lines that are fully left-to-right, and an array of\r\n// BidiSpan objects otherwise.\r\nfunction getOrder(line, direction) {\r\n  var order = line.order;\r\n  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\r\n  return order\r\n}\r\n\r\nfunction moveCharLogically(line, ch, dir) {\r\n  var target = skipExtendingChars(line.text, ch + dir, dir);\r\n  return target < 0 || target > line.text.length ? null : target\r\n}\r\n\r\nfunction moveLogically(line, start, dir) {\r\n  var ch = moveCharLogically(line, start.ch, dir);\r\n  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\r\n}\r\n\r\nfunction endOfLine(visually, cm, lineObj, lineNo, dir) {\r\n  if (visually) {\r\n    var order = getOrder(lineObj, cm.doc.direction);\r\n    if (order) {\r\n      var part = dir < 0 ? lst(order) : order[0];\r\n      var moveInStorageOrder = (dir < 0) == (part.level == 1);\r\n      var sticky = moveInStorageOrder ? \"after\" : \"before\";\r\n      var ch;\r\n      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\r\n      // it could be that the last bidi part is not on the last visual line,\r\n      // since visual lines contain content order-consecutive chunks.\r\n      // Thus, in rtl, we are looking for the first (content-order) character\r\n      // in the rtl chunk that is on the last line (that is, the same line\r\n      // as the last (content-order) character).\r\n      if (part.level > 0) {\r\n        var prep = prepareMeasureForLine(cm, lineObj);\r\n        ch = dir < 0 ? lineObj.text.length - 1 : 0;\r\n        var targetTop = measureCharPrepared(cm, prep, ch).top;\r\n        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\r\n        if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\r\n      } else { ch = dir < 0 ? part.to : part.from; }\r\n      return new Pos(lineNo, ch, sticky)\r\n    }\r\n  }\r\n  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\r\n}\r\n\r\nfunction moveVisually(cm, line, start, dir) {\r\n  var bidi = getOrder(line, cm.doc.direction);\r\n  if (!bidi) { return moveLogically(line, start, dir) }\r\n  if (start.ch >= line.text.length) {\r\n    start.ch = line.text.length;\r\n    start.sticky = \"before\";\r\n  } else if (start.ch <= 0) {\r\n    start.ch = 0;\r\n    start.sticky = \"after\";\r\n  }\r\n  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\r\n  if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\r\n    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\r\n    // nothing interesting happens.\r\n    return moveLogically(line, start, dir)\r\n  }\r\n\r\n  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\r\n  var prep;\r\n  var getWrappedLineExtent = function (ch) {\r\n    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\r\n    prep = prep || prepareMeasureForLine(cm, line);\r\n    return wrappedLineExtentChar(cm, line, prep, ch)\r\n  };\r\n  var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\r\n\r\n  if (cm.doc.direction == \"rtl\" || part.level == 1) {\r\n    var moveInStorageOrder = (part.level == 1) == (dir < 0);\r\n    var ch = mv(start, moveInStorageOrder ? 1 : -1);\r\n    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\r\n      // Case 2: We move within an rtl part or in an rtl editor on the same visual line\r\n      var sticky = moveInStorageOrder ? \"before\" : \"after\";\r\n      return new Pos(start.line, ch, sticky)\r\n    }\r\n  }\r\n\r\n  // Case 3: Could not move within this bidi part in this visual line, so leave\r\n  // the current bidi part\r\n\r\n  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\r\n    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\r\n      ? new Pos(start.line, mv(ch, 1), \"before\")\r\n      : new Pos(start.line, ch, \"after\"); };\r\n\r\n    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\r\n      var part = bidi[partPos];\r\n      var moveInStorageOrder = (dir > 0) == (part.level != 1);\r\n      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\r\n      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\r\n      ch = moveInStorageOrder ? part.from : mv(part.to, -1);\r\n      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\r\n    }\r\n  };\r\n\r\n  // Case 3a: Look for other bidi parts on the same visual line\r\n  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\r\n  if (res) { return res }\r\n\r\n  // Case 3b: Look for other bidi parts on the next visual line\r\n  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\r\n  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\r\n    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\r\n    if (res) { return res }\r\n  }\r\n\r\n  // Case 4: Nowhere to move\r\n  return null\r\n}\r\n\r\n// EVENT HANDLING\r\n\r\n// Lightweight event framework. on/off also work on DOM nodes,\r\n// registering native DOM handlers.\r\n\r\nvar noHandlers = [];\r\n\r\nvar on = function(emitter, type, f) {\r\n  if (emitter.addEventListener) {\r\n    emitter.addEventListener(type, f, false);\r\n  } else if (emitter.attachEvent) {\r\n    emitter.attachEvent(\"on\" + type, f);\r\n  } else {\r\n    var map$$1 = emitter._handlers || (emitter._handlers = {});\r\n    map$$1[type] = (map$$1[type] || noHandlers).concat(f);\r\n  }\r\n};\r\n\r\nfunction getHandlers(emitter, type) {\r\n  return emitter._handlers && emitter._handlers[type] || noHandlers\r\n}\r\n\r\nfunction off(emitter, type, f) {\r\n  if (emitter.removeEventListener) {\r\n    emitter.removeEventListener(type, f, false);\r\n  } else if (emitter.detachEvent) {\r\n    emitter.detachEvent(\"on\" + type, f);\r\n  } else {\r\n    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\r\n    if (arr) {\r\n      var index = indexOf(arr, f);\r\n      if (index > -1)\r\n        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\r\n    }\r\n  }\r\n}\r\n\r\nfunction signal(emitter, type /*, values...*/) {\r\n  var handlers = getHandlers(emitter, type);\r\n  if (!handlers.length) { return }\r\n  var args = Array.prototype.slice.call(arguments, 2);\r\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\r\n}\r\n\r\n// The DOM events that CodeMirror handles can be overridden by\r\n// registering a (non-DOM) handler on the editor for the event name,\r\n// and preventDefault-ing the event in that handler.\r\nfunction signalDOMEvent(cm, e, override) {\r\n  if (typeof e == \"string\")\r\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\r\n  signal(cm, override || e.type, cm, e);\r\n  return e_defaultPrevented(e) || e.codemirrorIgnore\r\n}\r\n\r\nfunction signalCursorActivity(cm) {\r\n  var arr = cm._handlers && cm._handlers.cursorActivity;\r\n  if (!arr) { return }\r\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\r\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\r\n    { set.push(arr[i]); } }\r\n}\r\n\r\nfunction hasHandler(emitter, type) {\r\n  return getHandlers(emitter, type).length > 0\r\n}\r\n\r\n// Add on and off methods to a constructor's prototype, to make\r\n// registering events on such objects more convenient.\r\nfunction eventMixin(ctor) {\r\n  ctor.prototype.on = function(type, f) {on(this, type, f);};\r\n  ctor.prototype.off = function(type, f) {off(this, type, f);};\r\n}\r\n\r\n// Due to the fact that we still support jurassic IE versions, some\r\n// compatibility wrappers are needed.\r\n\r\nfunction e_preventDefault(e) {\r\n  if (e.preventDefault) { e.preventDefault(); }\r\n  else { e.returnValue = false; }\r\n}\r\nfunction e_stopPropagation(e) {\r\n  if (e.stopPropagation) { e.stopPropagation(); }\r\n  else { e.cancelBubble = true; }\r\n}\r\nfunction e_defaultPrevented(e) {\r\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\r\n}\r\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\r\n\r\nfunction e_target(e) {return e.target || e.srcElement}\r\nfunction e_button(e) {\r\n  var b = e.which;\r\n  if (b == null) {\r\n    if (e.button & 1) { b = 1; }\r\n    else if (e.button & 2) { b = 3; }\r\n    else if (e.button & 4) { b = 2; }\r\n  }\r\n  if (mac && e.ctrlKey && b == 1) { b = 3; }\r\n  return b\r\n}\r\n\r\n// Detect drag-and-drop\r\nvar dragAndDrop = function() {\r\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\r\n  // couldn't get it to work yet.\r\n  if (ie && ie_version < 9) { return false }\r\n  var div = elt('div');\r\n  return \"draggable\" in div || \"dragDrop\" in div\r\n}();\r\n\r\nvar zwspSupported;\r\nfunction zeroWidthElement(measure) {\r\n  if (zwspSupported == null) {\r\n    var test = elt(\"span\", \"\\u200b\");\r\n    removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\r\n    if (measure.firstChild.offsetHeight != 0)\r\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\r\n  }\r\n  var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\r\n    elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\r\n  node.setAttribute(\"cm-text\", \"\");\r\n  return node\r\n}\r\n\r\n// Feature-detect IE's crummy client rect reporting for bidi text\r\nvar badBidiRects;\r\nfunction hasBadBidiRects(measure) {\r\n  if (badBidiRects != null) { return badBidiRects }\r\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\r\n  var r0 = range(txt, 0, 1).getBoundingClientRect();\r\n  var r1 = range(txt, 1, 2).getBoundingClientRect();\r\n  removeChildren(measure);\r\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\r\n  return badBidiRects = (r1.right - r0.right < 3)\r\n}\r\n\r\n// See if \"\".split is the broken IE version, if so, provide an\r\n// alternative way to split lines.\r\nvar splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\r\n  var pos = 0, result = [], l = string.length;\r\n  while (pos <= l) {\r\n    var nl = string.indexOf(\"\\n\", pos);\r\n    if (nl == -1) { nl = string.length; }\r\n    var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\r\n    var rt = line.indexOf(\"\\r\");\r\n    if (rt != -1) {\r\n      result.push(line.slice(0, rt));\r\n      pos += rt + 1;\r\n    } else {\r\n      result.push(line);\r\n      pos = nl + 1;\r\n    }\r\n  }\r\n  return result\r\n} : function (string) { return string.split(/\\r\\n?|\\n/); };\r\n\r\nvar hasSelection = window.getSelection ? function (te) {\r\n  try { return te.selectionStart != te.selectionEnd }\r\n  catch(e) { return false }\r\n} : function (te) {\r\n  var range$$1;\r\n  try {range$$1 = te.ownerDocument.selection.createRange();}\r\n  catch(e) {}\r\n  if (!range$$1 || range$$1.parentElement() != te) { return false }\r\n  return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\r\n};\r\n\r\nvar hasCopyEvent = (function () {\r\n  var e = elt(\"div\");\r\n  if (\"oncopy\" in e) { return true }\r\n  e.setAttribute(\"oncopy\", \"return;\");\r\n  return typeof e.oncopy == \"function\"\r\n})();\r\n\r\nvar badZoomedRects = null;\r\nfunction hasBadZoomedRects(measure) {\r\n  if (badZoomedRects != null) { return badZoomedRects }\r\n  var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\r\n  var normal = node.getBoundingClientRect();\r\n  var fromRange = range(node, 0, 1).getBoundingClientRect();\r\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\r\n}\r\n\r\n// Known modes, by name and by MIME\r\nvar modes = {};\r\nvar mimeModes = {};\r\n\r\n// Extra arguments are stored as the mode's dependencies, which is\r\n// used by (legacy) mechanisms like loadmode.js to automatically\r\n// load a mode. (Preferred mechanism is the require/define calls.)\r\nfunction defineMode(name, mode) {\r\n  if (arguments.length > 2)\r\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\r\n  modes[name] = mode;\r\n}\r\n\r\nfunction defineMIME(mime, spec) {\r\n  mimeModes[mime] = spec;\r\n}\r\n\r\n// Given a MIME type, a {name, ...options} config object, or a name\r\n// string, return a mode config object.\r\nfunction resolveMode(spec) {\r\n  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\r\n    spec = mimeModes[spec];\r\n  } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\r\n    var found = mimeModes[spec.name];\r\n    if (typeof found == \"string\") { found = {name: found}; }\r\n    spec = createObj(found, spec);\r\n    spec.name = found.name;\r\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\r\n    return resolveMode(\"application/xml\")\r\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\r\n    return resolveMode(\"application/json\")\r\n  }\r\n  if (typeof spec == \"string\") { return {name: spec} }\r\n  else { return spec || {name: \"null\"} }\r\n}\r\n\r\n// Given a mode spec (anything that resolveMode accepts), find and\r\n// initialize an actual mode object.\r\nfunction getMode(options, spec) {\r\n  spec = resolveMode(spec);\r\n  var mfactory = modes[spec.name];\r\n  if (!mfactory) { return getMode(options, \"text/plain\") }\r\n  var modeObj = mfactory(options, spec);\r\n  if (modeExtensions.hasOwnProperty(spec.name)) {\r\n    var exts = modeExtensions[spec.name];\r\n    for (var prop in exts) {\r\n      if (!exts.hasOwnProperty(prop)) { continue }\r\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\r\n      modeObj[prop] = exts[prop];\r\n    }\r\n  }\r\n  modeObj.name = spec.name;\r\n  if (spec.helperType) { modeObj.helperType = spec.helperType; }\r\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\r\n    { modeObj[prop$1] = spec.modeProps[prop$1]; } }\r\n\r\n  return modeObj\r\n}\r\n\r\n// This can be used to attach properties to mode objects from\r\n// outside the actual mode definition.\r\nvar modeExtensions = {};\r\nfunction extendMode(mode, properties) {\r\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\r\n  copyObj(properties, exts);\r\n}\r\n\r\nfunction copyState(mode, state) {\r\n  if (state === true) { return state }\r\n  if (mode.copyState) { return mode.copyState(state) }\r\n  var nstate = {};\r\n  for (var n in state) {\r\n    var val = state[n];\r\n    if (val instanceof Array) { val = val.concat([]); }\r\n    nstate[n] = val;\r\n  }\r\n  return nstate\r\n}\r\n\r\n// Given a mode and a state (for that mode), find the inner mode and\r\n// state at the position that the state refers to.\r\nfunction innerMode(mode, state) {\r\n  var info;\r\n  while (mode.innerMode) {\r\n    info = mode.innerMode(state);\r\n    if (!info || info.mode == mode) { break }\r\n    state = info.state;\r\n    mode = info.mode;\r\n  }\r\n  return info || {mode: mode, state: state}\r\n}\r\n\r\nfunction startState(mode, a1, a2) {\r\n  return mode.startState ? mode.startState(a1, a2) : true\r\n}\r\n\r\n// STRING STREAM\r\n\r\n// Fed to the mode parsers, provides helper functions to make\r\n// parsers more succinct.\r\n\r\nvar StringStream = function(string, tabSize) {\r\n  this.pos = this.start = 0;\r\n  this.string = string;\r\n  this.tabSize = tabSize || 8;\r\n  this.lastColumnPos = this.lastColumnValue = 0;\r\n  this.lineStart = 0;\r\n};\r\n\r\nStringStream.prototype.eol = function () {return this.pos >= this.string.length};\r\nStringStream.prototype.sol = function () {return this.pos == this.lineStart};\r\nStringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\r\nStringStream.prototype.next = function () {\r\n  if (this.pos < this.string.length)\r\n    { return this.string.charAt(this.pos++) }\r\n};\r\nStringStream.prototype.eat = function (match) {\r\n  var ch = this.string.charAt(this.pos);\r\n  var ok;\r\n  if (typeof match == \"string\") { ok = ch == match; }\r\n  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\r\n  if (ok) {++this.pos; return ch}\r\n};\r\nStringStream.prototype.eatWhile = function (match) {\r\n  var start = this.pos;\r\n  while (this.eat(match)){}\r\n  return this.pos > start\r\n};\r\nStringStream.prototype.eatSpace = function () {\r\n    var this$1 = this;\r\n\r\n  var start = this.pos;\r\n  while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\r\n  return this.pos > start\r\n};\r\nStringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\r\nStringStream.prototype.skipTo = function (ch) {\r\n  var found = this.string.indexOf(ch, this.pos);\r\n  if (found > -1) {this.pos = found; return true}\r\n};\r\nStringStream.prototype.backUp = function (n) {this.pos -= n;};\r\nStringStream.prototype.column = function () {\r\n  if (this.lastColumnPos < this.start) {\r\n    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\r\n    this.lastColumnPos = this.start;\r\n  }\r\n  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\r\n};\r\nStringStream.prototype.indentation = function () {\r\n  return countColumn(this.string, null, this.tabSize) -\r\n    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\r\n};\r\nStringStream.prototype.match = function (pattern, consume, caseInsensitive) {\r\n  if (typeof pattern == \"string\") {\r\n    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\r\n    var substr = this.string.substr(this.pos, pattern.length);\r\n    if (cased(substr) == cased(pattern)) {\r\n      if (consume !== false) { this.pos += pattern.length; }\r\n      return true\r\n    }\r\n  } else {\r\n    var match = this.string.slice(this.pos).match(pattern);\r\n    if (match && match.index > 0) { return null }\r\n    if (match && consume !== false) { this.pos += match[0].length; }\r\n    return match\r\n  }\r\n};\r\nStringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\r\nStringStream.prototype.hideFirstChars = function (n, inner) {\r\n  this.lineStart += n;\r\n  try { return inner() }\r\n  finally { this.lineStart -= n; }\r\n};\r\n\r\n// Compute a style array (an array starting with a mode generation\r\n// -- for invalidation -- followed by pairs of end positions and\r\n// style strings), which is used to highlight the tokens on the\r\n// line.\r\nfunction highlightLine(cm, line, state, forceToEnd) {\r\n  // A styles array always starts with a number identifying the\r\n  // mode/overlays that it is based on (for easy invalidation).\r\n  var st = [cm.state.modeGen], lineClasses = {};\r\n  // Compute the base array of styles\r\n  runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },\r\n    lineClasses, forceToEnd);\r\n\r\n  // Run overlays, adjust style array.\r\n  var loop = function ( o ) {\r\n    var overlay = cm.state.overlays[o], i = 1, at = 0;\r\n    runMode(cm, line.text, overlay.mode, true, function (end, style) {\r\n      var start = i;\r\n      // Ensure there's a token end at the current position, and that i points at it\r\n      while (at < end) {\r\n        var i_end = st[i];\r\n        if (i_end > end)\r\n          { st.splice(i, 1, end, st[i+1], i_end); }\r\n        i += 2;\r\n        at = Math.min(end, i_end);\r\n      }\r\n      if (!style) { return }\r\n      if (overlay.opaque) {\r\n        st.splice(start, i - start, end, \"overlay \" + style);\r\n        i = start + 2;\r\n      } else {\r\n        for (; start < i; start += 2) {\r\n          var cur = st[start+1];\r\n          st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\r\n        }\r\n      }\r\n    }, lineClasses);\r\n  };\r\n\r\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\r\n\r\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\r\n}\r\n\r\nfunction getLineStyles(cm, line, updateFrontier) {\r\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\r\n    var state = getStateBefore(cm, lineNo(line));\r\n    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\r\n    line.stateAfter = state;\r\n    line.styles = result.styles;\r\n    if (result.classes) { line.styleClasses = result.classes; }\r\n    else if (line.styleClasses) { line.styleClasses = null; }\r\n    if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++; }\r\n  }\r\n  return line.styles\r\n}\r\n\r\nfunction getStateBefore(cm, n, precise) {\r\n  var doc = cm.doc, display = cm.display;\r\n  if (!doc.mode.startState) { return true }\r\n  var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\r\n  if (!state) { state = startState(doc.mode); }\r\n  else { state = copyState(doc.mode, state); }\r\n  doc.iter(pos, n, function (line) {\r\n    processLine(cm, line.text, state);\r\n    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\r\n    line.stateAfter = save ? copyState(doc.mode, state) : null;\r\n    ++pos;\r\n  });\r\n  if (precise) { doc.frontier = pos; }\r\n  return state\r\n}\r\n\r\n// Lightweight form of highlight -- proceed over this line and\r\n// update state, but don't save a style array. Used for lines that\r\n// aren't currently visible.\r\nfunction processLine(cm, text, state, startAt) {\r\n  var mode = cm.doc.mode;\r\n  var stream = new StringStream(text, cm.options.tabSize);\r\n  stream.start = stream.pos = startAt || 0;\r\n  if (text == \"\") { callBlankLine(mode, state); }\r\n  while (!stream.eol()) {\r\n    readToken(mode, stream, state);\r\n    stream.start = stream.pos;\r\n  }\r\n}\r\n\r\nfunction callBlankLine(mode, state) {\r\n  if (mode.blankLine) { return mode.blankLine(state) }\r\n  if (!mode.innerMode) { return }\r\n  var inner = innerMode(mode, state);\r\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\r\n}\r\n\r\nfunction readToken(mode, stream, state, inner) {\r\n  for (var i = 0; i < 10; i++) {\r\n    if (inner) { inner[0] = innerMode(mode, state).mode; }\r\n    var style = mode.token(stream, state);\r\n    if (stream.pos > stream.start) { return style }\r\n  }\r\n  throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\r\n}\r\n\r\n// Utility for getTokenAt and getLineTokens\r\nfunction takeToken(cm, pos, precise, asArray) {\r\n  var getObj = function (copy) { return ({\r\n    start: stream.start, end: stream.pos,\r\n    string: stream.current(),\r\n    type: style || null,\r\n    state: copy ? copyState(doc.mode, state) : state\r\n  }); };\r\n\r\n  var doc = cm.doc, mode = doc.mode, style;\r\n  pos = clipPos(doc, pos);\r\n  var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\r\n  var stream = new StringStream(line.text, cm.options.tabSize), tokens;\r\n  if (asArray) { tokens = []; }\r\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\r\n    stream.start = stream.pos;\r\n    style = readToken(mode, stream, state);\r\n    if (asArray) { tokens.push(getObj(true)); }\r\n  }\r\n  return asArray ? tokens : getObj()\r\n}\r\n\r\nfunction extractLineClasses(type, output) {\r\n  if (type) { for (;;) {\r\n    var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\r\n    if (!lineClass) { break }\r\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\r\n    var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\r\n    if (output[prop] == null)\r\n      { output[prop] = lineClass[2]; }\r\n    else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\r\n      { output[prop] += \" \" + lineClass[2]; }\r\n  } }\r\n  return type\r\n}\r\n\r\n// Run the given mode's parser over a line, calling f for each token.\r\nfunction runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\r\n  var flattenSpans = mode.flattenSpans;\r\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\r\n  var curStart = 0, curStyle = null;\r\n  var stream = new StringStream(text, cm.options.tabSize), style;\r\n  var inner = cm.options.addModeClass && [null];\r\n  if (text == \"\") { extractLineClasses(callBlankLine(mode, state), lineClasses); }\r\n  while (!stream.eol()) {\r\n    if (stream.pos > cm.options.maxHighlightLength) {\r\n      flattenSpans = false;\r\n      if (forceToEnd) { processLine(cm, text, state, stream.pos); }\r\n      stream.pos = text.length;\r\n      style = null;\r\n    } else {\r\n      style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\r\n    }\r\n    if (inner) {\r\n      var mName = inner[0].name;\r\n      if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\r\n    }\r\n    if (!flattenSpans || curStyle != style) {\r\n      while (curStart < stream.start) {\r\n        curStart = Math.min(stream.start, curStart + 5000);\r\n        f(curStart, curStyle);\r\n      }\r\n      curStyle = style;\r\n    }\r\n    stream.start = stream.pos;\r\n  }\r\n  while (curStart < stream.pos) {\r\n    // Webkit seems to refuse to render text nodes longer than 57444\r\n    // characters, and returns inaccurate measurements in nodes\r\n    // starting around 5000 chars.\r\n    var pos = Math.min(stream.pos, curStart + 5000);\r\n    f(pos, curStyle);\r\n    curStart = pos;\r\n  }\r\n}\r\n\r\n// Finds the line to start with when starting a parse. Tries to\r\n// find a line with a stateAfter, so that it can start with a\r\n// valid state. If that fails, it returns the line with the\r\n// smallest indentation, which tends to need the least context to\r\n// parse correctly.\r\nfunction findStartLine(cm, n, precise) {\r\n  var minindent, minline, doc = cm.doc;\r\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\r\n  for (var search = n; search > lim; --search) {\r\n    if (search <= doc.first) { return doc.first }\r\n    var line = getLine(doc, search - 1);\r\n    if (line.stateAfter && (!precise || search <= doc.frontier)) { return search }\r\n    var indented = countColumn(line.text, null, cm.options.tabSize);\r\n    if (minline == null || minindent > indented) {\r\n      minline = search - 1;\r\n      minindent = indented;\r\n    }\r\n  }\r\n  return minline\r\n}\r\n\r\n// LINE DATA STRUCTURE\r\n\r\n// Line objects. These hold state related to a line, including\r\n// highlighting info (the styles array).\r\nvar Line = function(text, markedSpans, estimateHeight) {\r\n  this.text = text;\r\n  attachMarkedSpans(this, markedSpans);\r\n  this.height = estimateHeight ? estimateHeight(this) : 1;\r\n};\r\n\r\nLine.prototype.lineNo = function () { return lineNo(this) };\r\neventMixin(Line);\r\n\r\n// Change the content (text, markers) of a line. Automatically\r\n// invalidates cached information and tries to re-estimate the\r\n// line's height.\r\nfunction updateLine(line, text, markedSpans, estimateHeight) {\r\n  line.text = text;\r\n  if (line.stateAfter) { line.stateAfter = null; }\r\n  if (line.styles) { line.styles = null; }\r\n  if (line.order != null) { line.order = null; }\r\n  detachMarkedSpans(line);\r\n  attachMarkedSpans(line, markedSpans);\r\n  var estHeight = estimateHeight ? estimateHeight(line) : 1;\r\n  if (estHeight != line.height) { updateLineHeight(line, estHeight); }\r\n}\r\n\r\n// Detach a line from the document tree and its markers.\r\nfunction cleanUpLine(line) {\r\n  line.parent = null;\r\n  detachMarkedSpans(line);\r\n}\r\n\r\n// Convert a style as returned by a mode (either null, or a string\r\n// containing one or more styles) to a CSS style. This is cached,\r\n// and also looks for line-wide styles.\r\nvar styleToClassCache = {};\r\nvar styleToClassCacheWithMode = {};\r\nfunction interpretTokenStyle(style, options) {\r\n  if (!style || /^\\s*$/.test(style)) { return null }\r\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\r\n  return cache[style] ||\r\n    (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\r\n}\r\n\r\n// Render the DOM representation of the text of a line. Also builds\r\n// up a 'line map', which points at the DOM nodes that represent\r\n// specific stretches of text, and is used by the measuring code.\r\n// The returned object contains the DOM node, this map, and\r\n// information about line-wide styles that were set by the mode.\r\nfunction buildLineContent(cm, lineView) {\r\n  // The padding-right forces the element to have a 'border', which\r\n  // is needed on Webkit to be able to get line-level bounding\r\n  // rectangles for it (in measureChar).\r\n  var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\r\n  var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\r\n                 col: 0, pos: 0, cm: cm,\r\n                 trailingSpace: false,\r\n                 splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\r\n  lineView.measure = {};\r\n\r\n  // Iterate over the logical lines that make up this visual line.\r\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\r\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\r\n    builder.pos = 0;\r\n    builder.addToken = buildToken;\r\n    // Optionally wire in some hacks into the token-rendering\r\n    // algorithm, to deal with browser quirks.\r\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\r\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\r\n    builder.map = [];\r\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\r\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\r\n    if (line.styleClasses) {\r\n      if (line.styleClasses.bgClass)\r\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\r\n      if (line.styleClasses.textClass)\r\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\r\n    }\r\n\r\n    // Ensure at least a single node is present, for measuring.\r\n    if (builder.map.length == 0)\r\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\r\n\r\n    // Store the map and a cache object for the current logical line\r\n    if (i == 0) {\r\n      lineView.measure.map = builder.map;\r\n      lineView.measure.cache = {};\r\n    } else {\r\n      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\r\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\r\n    }\r\n  }\r\n\r\n  // See issue #2901\r\n  if (webkit) {\r\n    var last = builder.content.lastChild;\r\n    if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\r\n      { builder.content.className = \"cm-tab-wrap-hack\"; }\r\n  }\r\n\r\n  signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\r\n  if (builder.pre.className)\r\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\r\n\r\n  return builder\r\n}\r\n\r\nfunction defaultSpecialCharPlaceholder(ch) {\r\n  var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\r\n  token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\r\n  token.setAttribute(\"aria-label\", token.title);\r\n  return token\r\n}\r\n\r\n// Build up the DOM representation for a single token, and add it to\r\n// the line map. Takes care to render special characters separately.\r\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\r\n  if (!text) { return }\r\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\r\n  var special = builder.cm.state.specialChars, mustWrap = false;\r\n  var content;\r\n  if (!special.test(text)) {\r\n    builder.col += text.length;\r\n    content = document.createTextNode(displayText);\r\n    builder.map.push(builder.pos, builder.pos + text.length, content);\r\n    if (ie && ie_version < 9) { mustWrap = true; }\r\n    builder.pos += text.length;\r\n  } else {\r\n    content = document.createDocumentFragment();\r\n    var pos = 0;\r\n    while (true) {\r\n      special.lastIndex = pos;\r\n      var m = special.exec(text);\r\n      var skipped = m ? m.index - pos : text.length - pos;\r\n      if (skipped) {\r\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\r\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\r\n        else { content.appendChild(txt); }\r\n        builder.map.push(builder.pos, builder.pos + skipped, txt);\r\n        builder.col += skipped;\r\n        builder.pos += skipped;\r\n      }\r\n      if (!m) { break }\r\n      pos += skipped + 1;\r\n      var txt$1 = (void 0);\r\n      if (m[0] == \"\\t\") {\r\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\r\n        txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\r\n        txt$1.setAttribute(\"role\", \"presentation\");\r\n        txt$1.setAttribute(\"cm-text\", \"\\t\");\r\n        builder.col += tabWidth;\r\n      } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\r\n        txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\r\n        txt$1.setAttribute(\"cm-text\", m[0]);\r\n        builder.col += 1;\r\n      } else {\r\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\r\n        txt$1.setAttribute(\"cm-text\", m[0]);\r\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\r\n        else { content.appendChild(txt$1); }\r\n        builder.col += 1;\r\n      }\r\n      builder.map.push(builder.pos, builder.pos + 1, txt$1);\r\n      builder.pos++;\r\n    }\r\n  }\r\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\r\n  if (style || startStyle || endStyle || mustWrap || css) {\r\n    var fullStyle = style || \"\";\r\n    if (startStyle) { fullStyle += startStyle; }\r\n    if (endStyle) { fullStyle += endStyle; }\r\n    var token = elt(\"span\", [content], fullStyle, css);\r\n    if (title) { token.title = title; }\r\n    return builder.content.appendChild(token)\r\n  }\r\n  builder.content.appendChild(content);\r\n}\r\n\r\nfunction splitSpaces(text, trailingBefore) {\r\n  if (text.length > 1 && !/  /.test(text)) { return text }\r\n  var spaceBefore = trailingBefore, result = \"\";\r\n  for (var i = 0; i < text.length; i++) {\r\n    var ch = text.charAt(i);\r\n    if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\r\n      { ch = \"\\u00a0\"; }\r\n    result += ch;\r\n    spaceBefore = ch == \" \";\r\n  }\r\n  return result\r\n}\r\n\r\n// Work around nonsense dimensions being reported for stretches of\r\n// right-to-left text.\r\nfunction buildTokenBadBidi(inner, order) {\r\n  return function (builder, text, style, startStyle, endStyle, title, css) {\r\n    style = style ? style + \" cm-force-border\" : \"cm-force-border\";\r\n    var start = builder.pos, end = start + text.length;\r\n    for (;;) {\r\n      // Find the part that overlaps with the start of this text\r\n      var part = (void 0);\r\n      for (var i = 0; i < order.length; i++) {\r\n        part = order[i];\r\n        if (part.to > start && part.from <= start) { break }\r\n      }\r\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\r\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\r\n      startStyle = null;\r\n      text = text.slice(part.to - start);\r\n      start = part.to;\r\n    }\r\n  }\r\n}\r\n\r\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\r\n  var widget = !ignoreWidget && marker.widgetNode;\r\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\r\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\r\n    if (!widget)\r\n      { widget = builder.content.appendChild(document.createElement(\"span\")); }\r\n    widget.setAttribute(\"cm-marker\", marker.id);\r\n  }\r\n  if (widget) {\r\n    builder.cm.display.input.setUneditable(widget);\r\n    builder.content.appendChild(widget);\r\n  }\r\n  builder.pos += size;\r\n  builder.trailingSpace = false;\r\n}\r\n\r\n// Outputs a number of spans to make up a line, taking highlighting\r\n// and marked text into account.\r\nfunction insertLineContent(line, builder, styles) {\r\n  var spans = line.markedSpans, allText = line.text, at = 0;\r\n  if (!spans) {\r\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\r\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\r\n    return\r\n  }\r\n\r\n  var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\r\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\r\n  for (;;) {\r\n    if (nextChange == pos) { // Update current marker set\r\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\r\n      collapsed = null; nextChange = Infinity;\r\n      var foundBookmarks = [], endStyles = (void 0);\r\n      for (var j = 0; j < spans.length; ++j) {\r\n        var sp = spans[j], m = sp.marker;\r\n        if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\r\n          foundBookmarks.push(m);\r\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\r\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\r\n            nextChange = sp.to;\r\n            spanEndStyle = \"\";\r\n          }\r\n          if (m.className) { spanStyle += \" \" + m.className; }\r\n          if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\r\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\r\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\r\n          if (m.title && !title) { title = m.title; }\r\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\r\n            { collapsed = sp; }\r\n        } else if (sp.from > pos && nextChange > sp.from) {\r\n          nextChange = sp.from;\r\n        }\r\n      }\r\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\r\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\r\n\r\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\r\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\r\n      if (collapsed && (collapsed.from || 0) == pos) {\r\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\r\n                           collapsed.marker, collapsed.from == null);\r\n        if (collapsed.to == null) { return }\r\n        if (collapsed.to == pos) { collapsed = false; }\r\n      }\r\n    }\r\n    if (pos >= len) { break }\r\n\r\n    var upto = Math.min(len, nextChange);\r\n    while (true) {\r\n      if (text) {\r\n        var end = pos + text.length;\r\n        if (!collapsed) {\r\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text;\r\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\r\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\r\n        }\r\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\r\n        pos = end;\r\n        spanStartStyle = \"\";\r\n      }\r\n      text = allText.slice(at, at = styles[i++]);\r\n      style = interpretTokenStyle(styles[i++], builder.cm.options);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n// These objects are used to represent the visible (currently drawn)\r\n// part of the document. A LineView may correspond to multiple\r\n// logical lines, if those are connected by collapsed ranges.\r\nfunction LineView(doc, line, lineN) {\r\n  // The starting line\r\n  this.line = line;\r\n  // Continuing lines, if any\r\n  this.rest = visualLineContinued(line);\r\n  // Number of logical lines in this visual line\r\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\r\n  this.node = this.text = null;\r\n  this.hidden = lineIsHidden(doc, line);\r\n}\r\n\r\n// Create a range of LineView objects for the given lines.\r\nfunction buildViewArray(cm, from, to) {\r\n  var array = [], nextPos;\r\n  for (var pos = from; pos < to; pos = nextPos) {\r\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\r\n    nextPos = pos + view.size;\r\n    array.push(view);\r\n  }\r\n  return array\r\n}\r\n\r\nvar operationGroup = null;\r\n\r\nfunction pushOperation(op) {\r\n  if (operationGroup) {\r\n    operationGroup.ops.push(op);\r\n  } else {\r\n    op.ownsGroup = operationGroup = {\r\n      ops: [op],\r\n      delayedCallbacks: []\r\n    };\r\n  }\r\n}\r\n\r\nfunction fireCallbacksForOps(group) {\r\n  // Calls delayed callbacks and cursorActivity handlers until no\r\n  // new ones appear\r\n  var callbacks = group.delayedCallbacks, i = 0;\r\n  do {\r\n    for (; i < callbacks.length; i++)\r\n      { callbacks[i].call(null); }\r\n    for (var j = 0; j < group.ops.length; j++) {\r\n      var op = group.ops[j];\r\n      if (op.cursorActivityHandlers)\r\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\r\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\r\n    }\r\n  } while (i < callbacks.length)\r\n}\r\n\r\nfunction finishOperation(op, endCb) {\r\n  var group = op.ownsGroup;\r\n  if (!group) { return }\r\n\r\n  try { fireCallbacksForOps(group); }\r\n  finally {\r\n    operationGroup = null;\r\n    endCb(group);\r\n  }\r\n}\r\n\r\nvar orphanDelayedCallbacks = null;\r\n\r\n// Often, we want to signal events at a point where we are in the\r\n// middle of some work, but don't want the handler to start calling\r\n// other methods on the editor, which might be in an inconsistent\r\n// state or simply not expect any other events to happen.\r\n// signalLater looks whether there are any handlers, and schedules\r\n// them to be executed when the last operation ends, or, if no\r\n// operation is active, when a timeout fires.\r\nfunction signalLater(emitter, type /*, values...*/) {\r\n  var arr = getHandlers(emitter, type);\r\n  if (!arr.length) { return }\r\n  var args = Array.prototype.slice.call(arguments, 2), list;\r\n  if (operationGroup) {\r\n    list = operationGroup.delayedCallbacks;\r\n  } else if (orphanDelayedCallbacks) {\r\n    list = orphanDelayedCallbacks;\r\n  } else {\r\n    list = orphanDelayedCallbacks = [];\r\n    setTimeout(fireOrphanDelayed, 0);\r\n  }\r\n  var loop = function ( i ) {\r\n    list.push(function () { return arr[i].apply(null, args); });\r\n  };\r\n\r\n  for (var i = 0; i < arr.length; ++i)\r\n    loop( i );\r\n}\r\n\r\nfunction fireOrphanDelayed() {\r\n  var delayed = orphanDelayedCallbacks;\r\n  orphanDelayedCallbacks = null;\r\n  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\r\n}\r\n\r\n// When an aspect of a line changes, a string is added to\r\n// lineView.changes. This updates the relevant part of the line's\r\n// DOM structure.\r\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\r\n  for (var j = 0; j < lineView.changes.length; j++) {\r\n    var type = lineView.changes[j];\r\n    if (type == \"text\") { updateLineText(cm, lineView); }\r\n    else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\r\n    else if (type == \"class\") { updateLineClasses(cm, lineView); }\r\n    else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\r\n  }\r\n  lineView.changes = null;\r\n}\r\n\r\n// Lines with gutter elements, widgets or a background class need to\r\n// be wrapped, and have the extra elements added to the wrapper div\r\nfunction ensureLineWrapped(lineView) {\r\n  if (lineView.node == lineView.text) {\r\n    lineView.node = elt(\"div\", null, null, \"position: relative\");\r\n    if (lineView.text.parentNode)\r\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\r\n    lineView.node.appendChild(lineView.text);\r\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\r\n  }\r\n  return lineView.node\r\n}\r\n\r\nfunction updateLineBackground(cm, lineView) {\r\n  var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\r\n  if (cls) { cls += \" CodeMirror-linebackground\"; }\r\n  if (lineView.background) {\r\n    if (cls) { lineView.background.className = cls; }\r\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\r\n  } else if (cls) {\r\n    var wrap = ensureLineWrapped(lineView);\r\n    lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\r\n    cm.display.input.setUneditable(lineView.background);\r\n  }\r\n}\r\n\r\n// Wrapper around buildLineContent which will reuse the structure\r\n// in display.externalMeasured when possible.\r\nfunction getLineContent(cm, lineView) {\r\n  var ext = cm.display.externalMeasured;\r\n  if (ext && ext.line == lineView.line) {\r\n    cm.display.externalMeasured = null;\r\n    lineView.measure = ext.measure;\r\n    return ext.built\r\n  }\r\n  return buildLineContent(cm, lineView)\r\n}\r\n\r\n// Redraw the line's text. Interacts with the background and text\r\n// classes because the mode may output tokens that influence these\r\n// classes.\r\nfunction updateLineText(cm, lineView) {\r\n  var cls = lineView.text.className;\r\n  var built = getLineContent(cm, lineView);\r\n  if (lineView.text == lineView.node) { lineView.node = built.pre; }\r\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text);\r\n  lineView.text = built.pre;\r\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\r\n    lineView.bgClass = built.bgClass;\r\n    lineView.textClass = built.textClass;\r\n    updateLineClasses(cm, lineView);\r\n  } else if (cls) {\r\n    lineView.text.className = cls;\r\n  }\r\n}\r\n\r\nfunction updateLineClasses(cm, lineView) {\r\n  updateLineBackground(cm, lineView);\r\n  if (lineView.line.wrapClass)\r\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\r\n  else if (lineView.node != lineView.text)\r\n    { lineView.node.className = \"\"; }\r\n  var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\r\n  lineView.text.className = textClass || \"\";\r\n}\r\n\r\nfunction updateLineGutter(cm, lineView, lineN, dims) {\r\n  if (lineView.gutter) {\r\n    lineView.node.removeChild(lineView.gutter);\r\n    lineView.gutter = null;\r\n  }\r\n  if (lineView.gutterBackground) {\r\n    lineView.node.removeChild(lineView.gutterBackground);\r\n    lineView.gutterBackground = null;\r\n  }\r\n  if (lineView.line.gutterClass) {\r\n    var wrap = ensureLineWrapped(lineView);\r\n    lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\r\n                                    (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\r\n    cm.display.input.setUneditable(lineView.gutterBackground);\r\n    wrap.insertBefore(lineView.gutterBackground, lineView.text);\r\n  }\r\n  var markers = lineView.line.gutterMarkers;\r\n  if (cm.options.lineNumbers || markers) {\r\n    var wrap$1 = ensureLineWrapped(lineView);\r\n    var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\r\n    cm.display.input.setUneditable(gutterWrap);\r\n    wrap$1.insertBefore(gutterWrap, lineView.text);\r\n    if (lineView.line.gutterClass)\r\n      { gutterWrap.className += \" \" + lineView.line.gutterClass; }\r\n    if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\r\n      { lineView.lineNumber = gutterWrap.appendChild(\r\n        elt(\"div\", lineNumberFor(cm.options, lineN),\r\n            \"CodeMirror-linenumber CodeMirror-gutter-elt\",\r\n            (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\r\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\r\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\r\n      if (found)\r\n        { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\r\n                                   (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\r\n    } }\r\n  }\r\n}\r\n\r\nfunction updateLineWidgets(cm, lineView, dims) {\r\n  if (lineView.alignable) { lineView.alignable = null; }\r\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\r\n    next = node.nextSibling;\r\n    if (node.className == \"CodeMirror-linewidget\")\r\n      { lineView.node.removeChild(node); }\r\n  }\r\n  insertLineWidgets(cm, lineView, dims);\r\n}\r\n\r\n// Build a line's DOM representation from scratch\r\nfunction buildLineElement(cm, lineView, lineN, dims) {\r\n  var built = getLineContent(cm, lineView);\r\n  lineView.text = lineView.node = built.pre;\r\n  if (built.bgClass) { lineView.bgClass = built.bgClass; }\r\n  if (built.textClass) { lineView.textClass = built.textClass; }\r\n\r\n  updateLineClasses(cm, lineView);\r\n  updateLineGutter(cm, lineView, lineN, dims);\r\n  insertLineWidgets(cm, lineView, dims);\r\n  return lineView.node\r\n}\r\n\r\n// A lineView may contain multiple logical lines (when merged by\r\n// collapsed spans). The widgets for all of them need to be drawn.\r\nfunction insertLineWidgets(cm, lineView, dims) {\r\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\r\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\r\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\r\n}\r\n\r\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\r\n  if (!line.widgets) { return }\r\n  var wrap = ensureLineWrapped(lineView);\r\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\r\n    var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\r\n    if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\r\n    positionLineWidget(widget, node, lineView, dims);\r\n    cm.display.input.setUneditable(node);\r\n    if (allowAbove && widget.above)\r\n      { wrap.insertBefore(node, lineView.gutter || lineView.text); }\r\n    else\r\n      { wrap.appendChild(node); }\r\n    signalLater(widget, \"redraw\");\r\n  }\r\n}\r\n\r\nfunction positionLineWidget(widget, node, lineView, dims) {\r\n  if (widget.noHScroll) {\r\n    (lineView.alignable || (lineView.alignable = [])).push(node);\r\n    var width = dims.wrapperWidth;\r\n    node.style.left = dims.fixedPos + \"px\";\r\n    if (!widget.coverGutter) {\r\n      width -= dims.gutterTotalWidth;\r\n      node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\r\n    }\r\n    node.style.width = width + \"px\";\r\n  }\r\n  if (widget.coverGutter) {\r\n    node.style.zIndex = 5;\r\n    node.style.position = \"relative\";\r\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\r\n  }\r\n}\r\n\r\nfunction widgetHeight(widget) {\r\n  if (widget.height != null) { return widget.height }\r\n  var cm = widget.doc.cm;\r\n  if (!cm) { return 0 }\r\n  if (!contains(document.body, widget.node)) {\r\n    var parentStyle = \"position: relative;\";\r\n    if (widget.coverGutter)\r\n      { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\r\n    if (widget.noHScroll)\r\n      { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\r\n    removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\r\n  }\r\n  return widget.height = widget.node.parentNode.offsetHeight\r\n}\r\n\r\n// Return true when the given mouse event happened in a widget\r\nfunction eventInWidget(display, e) {\r\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\r\n    if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\r\n        (n.parentNode == display.sizer && n != display.mover))\r\n      { return true }\r\n  }\r\n}\r\n\r\n// POSITION MEASUREMENT\r\n\r\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\r\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\r\nfunction paddingH(display) {\r\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\r\n  var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\r\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\r\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\r\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\r\n  return data\r\n}\r\n\r\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\r\nfunction displayWidth(cm) {\r\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\r\n}\r\nfunction displayHeight(cm) {\r\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\r\n}\r\n\r\n// Ensure the lineView.wrapping.heights array is populated. This is\r\n// an array of bottom offsets for the lines that make up a drawn\r\n// line. When lineWrapping is on, there might be more than one\r\n// height.\r\nfunction ensureLineHeights(cm, lineView, rect) {\r\n  var wrapping = cm.options.lineWrapping;\r\n  var curWidth = wrapping && displayWidth(cm);\r\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\r\n    var heights = lineView.measure.heights = [];\r\n    if (wrapping) {\r\n      lineView.measure.width = curWidth;\r\n      var rects = lineView.text.firstChild.getClientRects();\r\n      for (var i = 0; i < rects.length - 1; i++) {\r\n        var cur = rects[i], next = rects[i + 1];\r\n        if (Math.abs(cur.bottom - next.bottom) > 2)\r\n          { heights.push((cur.bottom + next.top) / 2 - rect.top); }\r\n      }\r\n    }\r\n    heights.push(rect.bottom - rect.top);\r\n  }\r\n}\r\n\r\n// Find a line map (mapping character offsets to text nodes) and a\r\n// measurement cache for the given line number. (A line view might\r\n// contain multiple lines when collapsed ranges are present.)\r\nfunction mapFromLineView(lineView, line, lineN) {\r\n  if (lineView.line == line)\r\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\r\n  for (var i = 0; i < lineView.rest.length; i++)\r\n    { if (lineView.rest[i] == line)\r\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\r\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\r\n    { if (lineNo(lineView.rest[i$1]) > lineN)\r\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\r\n}\r\n\r\n// Render a line into the hidden node display.externalMeasured. Used\r\n// when measurement is needed for a line that's not in the viewport.\r\nfunction updateExternalMeasurement(cm, line) {\r\n  line = visualLine(line);\r\n  var lineN = lineNo(line);\r\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\r\n  view.lineN = lineN;\r\n  var built = view.built = buildLineContent(cm, view);\r\n  view.text = built.pre;\r\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\r\n  return view\r\n}\r\n\r\n// Get a {top, bottom, left, right} box (in line-local coordinates)\r\n// for a given character.\r\nfunction measureChar(cm, line, ch, bias) {\r\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\r\n}\r\n\r\n// Find a line view that corresponds to the given line number.\r\nfunction findViewForLine(cm, lineN) {\r\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\r\n    { return cm.display.view[findViewIndex(cm, lineN)] }\r\n  var ext = cm.display.externalMeasured;\r\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\r\n    { return ext }\r\n}\r\n\r\n// Measurement can be split in two steps, the set-up work that\r\n// applies to the whole line, and the measurement of the actual\r\n// character. Functions like coordsChar, that need to do a lot of\r\n// measurements in a row, can thus ensure that the set-up work is\r\n// only done once.\r\nfunction prepareMeasureForLine(cm, line) {\r\n  var lineN = lineNo(line);\r\n  var view = findViewForLine(cm, lineN);\r\n  if (view && !view.text) {\r\n    view = null;\r\n  } else if (view && view.changes) {\r\n    updateLineForChanges(cm, view, lineN, getDimensions(cm));\r\n    cm.curOp.forceUpdate = true;\r\n  }\r\n  if (!view)\r\n    { view = updateExternalMeasurement(cm, line); }\r\n\r\n  var info = mapFromLineView(view, line, lineN);\r\n  return {\r\n    line: line, view: view, rect: null,\r\n    map: info.map, cache: info.cache, before: info.before,\r\n    hasHeights: false\r\n  }\r\n}\r\n\r\n// Given a prepared measurement object, measures the position of an\r\n// actual character (or fetches it from the cache).\r\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\r\n  if (prepared.before) { ch = -1; }\r\n  var key = ch + (bias || \"\"), found;\r\n  if (prepared.cache.hasOwnProperty(key)) {\r\n    found = prepared.cache[key];\r\n  } else {\r\n    if (!prepared.rect)\r\n      { prepared.rect = prepared.view.text.getBoundingClientRect(); }\r\n    if (!prepared.hasHeights) {\r\n      ensureLineHeights(cm, prepared.view, prepared.rect);\r\n      prepared.hasHeights = true;\r\n    }\r\n    found = measureCharInner(cm, prepared, ch, bias);\r\n    if (!found.bogus) { prepared.cache[key] = found; }\r\n  }\r\n  return {left: found.left, right: found.right,\r\n          top: varHeight ? found.rtop : found.top,\r\n          bottom: varHeight ? found.rbottom : found.bottom}\r\n}\r\n\r\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0};\r\n\r\nfunction nodeAndOffsetInLineMap(map$$1, ch, bias) {\r\n  var node, start, end, collapse, mStart, mEnd;\r\n  // First, search the line map for the text node corresponding to,\r\n  // or closest to, the target character.\r\n  for (var i = 0; i < map$$1.length; i += 3) {\r\n    mStart = map$$1[i];\r\n    mEnd = map$$1[i + 1];\r\n    if (ch < mStart) {\r\n      start = 0; end = 1;\r\n      collapse = \"left\";\r\n    } else if (ch < mEnd) {\r\n      start = ch - mStart;\r\n      end = start + 1;\r\n    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\r\n      end = mEnd - mStart;\r\n      start = end - 1;\r\n      if (ch >= mEnd) { collapse = \"right\"; }\r\n    }\r\n    if (start != null) {\r\n      node = map$$1[i + 2];\r\n      if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\r\n        { collapse = bias; }\r\n      if (bias == \"left\" && start == 0)\r\n        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\r\n          node = map$$1[(i -= 3) + 2];\r\n          collapse = \"left\";\r\n        } }\r\n      if (bias == \"right\" && start == mEnd - mStart)\r\n        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\r\n          node = map$$1[(i += 3) + 2];\r\n          collapse = \"right\";\r\n        } }\r\n      break\r\n    }\r\n  }\r\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\r\n}\r\n\r\nfunction getUsefulRect(rects, bias) {\r\n  var rect = nullRect;\r\n  if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\r\n    if ((rect = rects[i]).left != rect.right) { break }\r\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\r\n    if ((rect = rects[i$1]).left != rect.right) { break }\r\n  } }\r\n  return rect\r\n}\r\n\r\nfunction measureCharInner(cm, prepared, ch, bias) {\r\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\r\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\r\n\r\n  var rect;\r\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\r\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\r\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\r\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\r\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\r\n        { rect = node.parentNode.getBoundingClientRect(); }\r\n      else\r\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\r\n      if (rect.left || rect.right || start == 0) { break }\r\n      end = start;\r\n      start = start - 1;\r\n      collapse = \"right\";\r\n    }\r\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\r\n  } else { // If it is a widget, simply get the box for the whole widget.\r\n    if (start > 0) { collapse = bias = \"right\"; }\r\n    var rects;\r\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\r\n      { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\r\n    else\r\n      { rect = node.getBoundingClientRect(); }\r\n  }\r\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\r\n    var rSpan = node.parentNode.getClientRects()[0];\r\n    if (rSpan)\r\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\r\n    else\r\n      { rect = nullRect; }\r\n  }\r\n\r\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\r\n  var mid = (rtop + rbot) / 2;\r\n  var heights = prepared.view.measure.heights;\r\n  var i = 0;\r\n  for (; i < heights.length - 1; i++)\r\n    { if (mid < heights[i]) { break } }\r\n  var top = i ? heights[i - 1] : 0, bot = heights[i];\r\n  var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\r\n                right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\r\n                top: top, bottom: bot};\r\n  if (!rect.left && !rect.right) { result.bogus = true; }\r\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\r\n\r\n  return result\r\n}\r\n\r\n// Work around problem with bounding client rects on ranges being\r\n// returned incorrectly when zoomed on IE10 and below.\r\nfunction maybeUpdateRectForZooming(measure, rect) {\r\n  if (!window.screen || screen.logicalXDPI == null ||\r\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\r\n    { return rect }\r\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI;\r\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI;\r\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\r\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\r\n}\r\n\r\nfunction clearLineMeasurementCacheFor(lineView) {\r\n  if (lineView.measure) {\r\n    lineView.measure.cache = {};\r\n    lineView.measure.heights = null;\r\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\r\n      { lineView.measure.caches[i] = {}; } }\r\n  }\r\n}\r\n\r\nfunction clearLineMeasurementCache(cm) {\r\n  cm.display.externalMeasure = null;\r\n  removeChildren(cm.display.lineMeasure);\r\n  for (var i = 0; i < cm.display.view.length; i++)\r\n    { clearLineMeasurementCacheFor(cm.display.view[i]); }\r\n}\r\n\r\nfunction clearCaches(cm) {\r\n  clearLineMeasurementCache(cm);\r\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\r\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\r\n  cm.display.lineNumChars = null;\r\n}\r\n\r\nfunction pageScrollX() {\r\n  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\r\n  // which causes page_Offset and bounding client rects to use\r\n  // different reference viewports and invalidate our calculations.\r\n  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\r\n  return window.pageXOffset || (document.documentElement || document.body).scrollLeft\r\n}\r\nfunction pageScrollY() {\r\n  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\r\n  return window.pageYOffset || (document.documentElement || document.body).scrollTop\r\n}\r\n\r\n// Converts a {top, bottom, left, right} box from line-local\r\n// coordinates into another coordinate system. Context may be one of\r\n// \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\r\n// or \"page\".\r\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\r\n  if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {\r\n    var size = widgetHeight(lineObj.widgets[i]);\r\n    rect.top += size; rect.bottom += size;\r\n  } } }\r\n  if (context == \"line\") { return rect }\r\n  if (!context) { context = \"local\"; }\r\n  var yOff = heightAtLine(lineObj);\r\n  if (context == \"local\") { yOff += paddingTop(cm.display); }\r\n  else { yOff -= cm.display.viewOffset; }\r\n  if (context == \"page\" || context == \"window\") {\r\n    var lOff = cm.display.lineSpace.getBoundingClientRect();\r\n    yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\r\n    var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\r\n    rect.left += xOff; rect.right += xOff;\r\n  }\r\n  rect.top += yOff; rect.bottom += yOff;\r\n  return rect\r\n}\r\n\r\n// Coverts a box from \"div\" coords to another coordinate system.\r\n// Context may be \"window\", \"page\", \"div\", or \"local\"./null.\r\nfunction fromCoordSystem(cm, coords, context) {\r\n  if (context == \"div\") { return coords }\r\n  var left = coords.left, top = coords.top;\r\n  // First move into \"page\" coordinate system\r\n  if (context == \"page\") {\r\n    left -= pageScrollX();\r\n    top -= pageScrollY();\r\n  } else if (context == \"local\" || !context) {\r\n    var localBox = cm.display.sizer.getBoundingClientRect();\r\n    left += localBox.left;\r\n    top += localBox.top;\r\n  }\r\n\r\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\r\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\r\n}\r\n\r\nfunction charCoords(cm, pos, context, lineObj, bias) {\r\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\r\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\r\n}\r\n\r\n// Returns a box for a given cursor position, which may have an\r\n// 'other' property containing the position of the secondary cursor\r\n// on a bidi boundary.\r\n// A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\r\n// and after `char - 1` in writing order of `char - 1`\r\n// A cursor Pos(line, char, \"after\") is on the same visual line as `char`\r\n// and before `char` in writing order of `char`\r\n// Examples (upper-case letters are RTL, lower-case are LTR):\r\n//     Pos(0, 1, ...)\r\n//     before   after\r\n// ab     a|b     a|b\r\n// aB     a|B     aB|\r\n// Ab     |Ab     A|b\r\n// AB     B|A     B|A\r\n// Every position after the last character on a line is considered to stick\r\n// to the last character on the line.\r\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\r\n  lineObj = lineObj || getLine(cm.doc, pos.line);\r\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\r\n  function get(ch, right) {\r\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\r\n    if (right) { m.left = m.right; } else { m.right = m.left; }\r\n    return intoCoordSystem(cm, lineObj, m, context)\r\n  }\r\n  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\r\n  if (ch >= lineObj.text.length) {\r\n    ch = lineObj.text.length;\r\n    sticky = \"before\";\r\n  } else if (ch <= 0) {\r\n    ch = 0;\r\n    sticky = \"after\";\r\n  }\r\n  if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\r\n\r\n  function getBidi(ch, partPos, invert) {\r\n    var part = order[partPos], right = (part.level % 2) != 0;\r\n    return get(invert ? ch - 1 : ch, right != invert)\r\n  }\r\n  var partPos = getBidiPartAt(order, ch, sticky);\r\n  var other = bidiOther;\r\n  var val = getBidi(ch, partPos, sticky == \"before\");\r\n  if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\r\n  return val\r\n}\r\n\r\n// Used to cheaply estimate the coordinates for a position. Used for\r\n// intermediate scroll updates.\r\nfunction estimateCoords(cm, pos) {\r\n  var left = 0;\r\n  pos = clipPos(cm.doc, pos);\r\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\r\n  var lineObj = getLine(cm.doc, pos.line);\r\n  var top = heightAtLine(lineObj) + paddingTop(cm.display);\r\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\r\n}\r\n\r\n// Positions returned by coordsChar contain some extra information.\r\n// xRel is the relative x position of the input coordinates compared\r\n// to the found position (so xRel > 0 means the coordinates are to\r\n// the right of the character position, for example). When outside\r\n// is true, that means the coordinates lie outside the line's\r\n// vertical range.\r\nfunction PosWithInfo(line, ch, sticky, outside, xRel) {\r\n  var pos = Pos(line, ch, sticky);\r\n  pos.xRel = xRel;\r\n  if (outside) { pos.outside = true; }\r\n  return pos\r\n}\r\n\r\n// Compute the character position closest to the given coordinates.\r\n// Input must be lineSpace-local (\"div\" coordinate system).\r\nfunction coordsChar(cm, x, y) {\r\n  var doc = cm.doc;\r\n  y += cm.display.viewOffset;\r\n  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\r\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\r\n  if (lineN > last)\r\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\r\n  if (x < 0) { x = 0; }\r\n\r\n  var lineObj = getLine(doc, lineN);\r\n  for (;;) {\r\n    var found = coordsCharInner(cm, lineObj, lineN, x, y);\r\n    var merged = collapsedSpanAtEnd(lineObj);\r\n    var mergedPos = merged && merged.find(0, true);\r\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\r\n      { lineN = lineNo(lineObj = mergedPos.to.line); }\r\n    else\r\n      { return found }\r\n  }\r\n}\r\n\r\nfunction wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\r\n  var measure = function (ch) { return intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \"line\"); };\r\n  var end = lineObj.text.length;\r\n  var begin = findFirst(function (ch) { return measure(ch - 1).bottom <= y; }, end, 0);\r\n  end = findFirst(function (ch) { return measure(ch).top > y; }, begin, end);\r\n  return {begin: begin, end: end}\r\n}\r\n\r\nfunction wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\r\n  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\r\n  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\r\n}\r\n\r\nfunction coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\r\n  y -= heightAtLine(lineObj);\r\n  var begin = 0, end = lineObj.text.length;\r\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj);\r\n  var pos;\r\n  var order = getOrder(lineObj, cm.doc.direction);\r\n  if (order) {\r\n    if (cm.options.lineWrapping) {\r\n      var assign;\r\n      ((assign = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = assign.begin, end = assign.end, assign));\r\n    }\r\n    pos = new Pos(lineNo$$1, begin);\r\n    var beginLeft = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure).left;\r\n    var dir = beginLeft < x ? 1 : -1;\r\n    var prevDiff, diff = beginLeft - x, prevPos;\r\n    do {\r\n      prevDiff = diff;\r\n      prevPos = pos;\r\n      pos = moveVisually(cm, lineObj, pos, dir);\r\n      if (pos == null || pos.ch < begin || end <= (pos.sticky == \"before\" ? pos.ch - 1 : pos.ch)) {\r\n        pos = prevPos;\r\n        break\r\n      }\r\n      diff = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure).left - x;\r\n    } while ((dir < 0) != (diff < 0) && (Math.abs(diff) <= Math.abs(prevDiff)))\r\n    if (Math.abs(diff) > Math.abs(prevDiff)) {\r\n      if ((diff < 0) == (prevDiff < 0)) { throw new Error(\"Broke out of infinite loop in coordsCharInner\") }\r\n      pos = prevPos;\r\n    }\r\n  } else {\r\n    var ch = findFirst(function (ch) {\r\n      var box = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \"line\");\r\n      if (box.top > y) {\r\n        // For the cursor stickiness\r\n        end = Math.min(ch, end);\r\n        return true\r\n      }\r\n      else if (box.bottom <= y) { return false }\r\n      else if (box.left > x) { return true }\r\n      else if (box.right < x) { return false }\r\n      else { return (x - box.left < box.right - x) }\r\n    }, begin, end);\r\n    ch = skipExtendingChars(lineObj.text, ch, 1);\r\n    pos = new Pos(lineNo$$1, ch, ch == end ? \"before\" : \"after\");\r\n  }\r\n  var coords = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure);\r\n  if (y < coords.top || coords.bottom < y) { pos.outside = true; }\r\n  pos.xRel = x < coords.left ? -1 : (x > coords.right ? 1 : 0);\r\n  return pos\r\n}\r\n\r\nvar measureText;\r\n// Compute the default text height.\r\nfunction textHeight(display) {\r\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\r\n  if (measureText == null) {\r\n    measureText = elt(\"pre\");\r\n    // Measure a bunch of lines, for browsers that compute\r\n    // fractional heights.\r\n    for (var i = 0; i < 49; ++i) {\r\n      measureText.appendChild(document.createTextNode(\"x\"));\r\n      measureText.appendChild(elt(\"br\"));\r\n    }\r\n    measureText.appendChild(document.createTextNode(\"x\"));\r\n  }\r\n  removeChildrenAndAdd(display.measure, measureText);\r\n  var height = measureText.offsetHeight / 50;\r\n  if (height > 3) { display.cachedTextHeight = height; }\r\n  removeChildren(display.measure);\r\n  return height || 1\r\n}\r\n\r\n// Compute the default character width.\r\nfunction charWidth(display) {\r\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\r\n  var anchor = elt(\"span\", \"xxxxxxxxxx\");\r\n  var pre = elt(\"pre\", [anchor]);\r\n  removeChildrenAndAdd(display.measure, pre);\r\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\r\n  if (width > 2) { display.cachedCharWidth = width; }\r\n  return width || 10\r\n}\r\n\r\n// Do a bulk-read of the DOM positions and sizes needed to draw the\r\n// view, so that we don't interleave reading and writing to the DOM.\r\nfunction getDimensions(cm) {\r\n  var d = cm.display, left = {}, width = {};\r\n  var gutterLeft = d.gutters.clientLeft;\r\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\r\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\r\n    width[cm.options.gutters[i]] = n.clientWidth;\r\n  }\r\n  return {fixedPos: compensateForHScroll(d),\r\n          gutterTotalWidth: d.gutters.offsetWidth,\r\n          gutterLeft: left,\r\n          gutterWidth: width,\r\n          wrapperWidth: d.wrapper.clientWidth}\r\n}\r\n\r\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\r\n// but using getBoundingClientRect to get a sub-pixel-accurate\r\n// result.\r\nfunction compensateForHScroll(display) {\r\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\r\n}\r\n\r\n// Returns a function that estimates the height of a line, to use as\r\n// first approximation until the line becomes visible (and is thus\r\n// properly measurable).\r\nfunction estimateHeight(cm) {\r\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\r\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\r\n  return function (line) {\r\n    if (lineIsHidden(cm.doc, line)) { return 0 }\r\n\r\n    var widgetsHeight = 0;\r\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\r\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\r\n    } }\r\n\r\n    if (wrapping)\r\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\r\n    else\r\n      { return widgetsHeight + th }\r\n  }\r\n}\r\n\r\nfunction estimateLineHeights(cm) {\r\n  var doc = cm.doc, est = estimateHeight(cm);\r\n  doc.iter(function (line) {\r\n    var estHeight = est(line);\r\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\r\n  });\r\n}\r\n\r\n// Given a mouse event, find the corresponding position. If liberal\r\n// is false, it checks whether a gutter or scrollbar was clicked,\r\n// and returns null if it was. forRect is used by rectangular\r\n// selections, and tries to estimate a character position even for\r\n// coordinates beyond the right of the text.\r\nfunction posFromMouse(cm, e, liberal, forRect) {\r\n  var display = cm.display;\r\n  if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\r\n\r\n  var x, y, space = display.lineSpace.getBoundingClientRect();\r\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\r\n  try { x = e.clientX - space.left; y = e.clientY - space.top; }\r\n  catch (e) { return null }\r\n  var coords = coordsChar(cm, x, y), line;\r\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\r\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\r\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\r\n  }\r\n  return coords\r\n}\r\n\r\n// Find the view element corresponding to a given line. Return null\r\n// when the line isn't visible.\r\nfunction findViewIndex(cm, n) {\r\n  if (n >= cm.display.viewTo) { return null }\r\n  n -= cm.display.viewFrom;\r\n  if (n < 0) { return null }\r\n  var view = cm.display.view;\r\n  for (var i = 0; i < view.length; i++) {\r\n    n -= view[i].size;\r\n    if (n < 0) { return i }\r\n  }\r\n}\r\n\r\nfunction updateSelection(cm) {\r\n  cm.display.input.showSelection(cm.display.input.prepareSelection());\r\n}\r\n\r\nfunction prepareSelection(cm, primary) {\r\n  var doc = cm.doc, result = {};\r\n  var curFragment = result.cursors = document.createDocumentFragment();\r\n  var selFragment = result.selection = document.createDocumentFragment();\r\n\r\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\r\n    if (primary === false && i == doc.sel.primIndex) { continue }\r\n    var range$$1 = doc.sel.ranges[i];\r\n    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\r\n    var collapsed = range$$1.empty();\r\n    if (collapsed || cm.options.showCursorWhenSelecting)\r\n      { drawSelectionCursor(cm, range$$1.head, curFragment); }\r\n    if (!collapsed)\r\n      { drawSelectionRange(cm, range$$1, selFragment); }\r\n  }\r\n  return result\r\n}\r\n\r\n// Draws a cursor for the given range\r\nfunction drawSelectionCursor(cm, head, output) {\r\n  var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\r\n\r\n  var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\r\n  cursor.style.left = pos.left + \"px\";\r\n  cursor.style.top = pos.top + \"px\";\r\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\r\n\r\n  if (pos.other) {\r\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\r\n    var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\r\n    otherCursor.style.display = \"\";\r\n    otherCursor.style.left = pos.other.left + \"px\";\r\n    otherCursor.style.top = pos.other.top + \"px\";\r\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\r\n  }\r\n}\r\n\r\n// Draws the given range as a highlighted selection\r\nfunction drawSelectionRange(cm, range$$1, output) {\r\n  var display = cm.display, doc = cm.doc;\r\n  var fragment = document.createDocumentFragment();\r\n  var padding = paddingH(cm.display), leftSide = padding.left;\r\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\r\n\r\n  function add(left, top, width, bottom) {\r\n    if (top < 0) { top = 0; }\r\n    top = Math.round(top);\r\n    bottom = Math.round(bottom);\r\n    fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\r\n  }\r\n\r\n  function drawForLine(line, fromArg, toArg) {\r\n    var lineObj = getLine(doc, line);\r\n    var lineLen = lineObj.text.length;\r\n    var start, end;\r\n    function coords(ch, bias) {\r\n      return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\r\n    }\r\n\r\n    iterateBidiSections(getOrder(lineObj, doc.direction), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {\r\n      var leftPos = coords(from, \"left\"), rightPos, left, right;\r\n      if (from == to) {\r\n        rightPos = leftPos;\r\n        left = right = leftPos.left;\r\n      } else {\r\n        rightPos = coords(to - 1, \"right\");\r\n        if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\r\n        left = leftPos.left;\r\n        right = rightPos.right;\r\n      }\r\n      if (fromArg == null && from == 0) { left = leftSide; }\r\n      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\r\n        add(left, leftPos.top, null, leftPos.bottom);\r\n        left = leftSide;\r\n        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top); }\r\n      }\r\n      if (toArg == null && to == lineLen) { right = rightSide; }\r\n      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\r\n        { start = leftPos; }\r\n      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\r\n        { end = rightPos; }\r\n      if (left < leftSide + 1) { left = leftSide; }\r\n      add(left, rightPos.top, right - left, rightPos.bottom);\r\n    });\r\n    return {start: start, end: end}\r\n  }\r\n\r\n  var sFrom = range$$1.from(), sTo = range$$1.to();\r\n  if (sFrom.line == sTo.line) {\r\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch);\r\n  } else {\r\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\r\n    var singleVLine = visualLine(fromLine) == visualLine(toLine);\r\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\r\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\r\n    if (singleVLine) {\r\n      if (leftEnd.top < rightStart.top - 2) {\r\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\r\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\r\n      } else {\r\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\r\n      }\r\n    }\r\n    if (leftEnd.bottom < rightStart.top)\r\n      { add(leftSide, leftEnd.bottom, null, rightStart.top); }\r\n  }\r\n\r\n  output.appendChild(fragment);\r\n}\r\n\r\n// Cursor-blinking\r\nfunction restartBlink(cm) {\r\n  if (!cm.state.focused) { return }\r\n  var display = cm.display;\r\n  clearInterval(display.blinker);\r\n  var on = true;\r\n  display.cursorDiv.style.visibility = \"\";\r\n  if (cm.options.cursorBlinkRate > 0)\r\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\r\n      cm.options.cursorBlinkRate); }\r\n  else if (cm.options.cursorBlinkRate < 0)\r\n    { display.cursorDiv.style.visibility = \"hidden\"; }\r\n}\r\n\r\nfunction ensureFocus(cm) {\r\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\r\n}\r\n\r\nfunction delayBlurEvent(cm) {\r\n  cm.state.delayingBlurEvent = true;\r\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\r\n    cm.state.delayingBlurEvent = false;\r\n    onBlur(cm);\r\n  } }, 100);\r\n}\r\n\r\nfunction onFocus(cm, e) {\r\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\r\n\r\n  if (cm.options.readOnly == \"nocursor\") { return }\r\n  if (!cm.state.focused) {\r\n    signal(cm, \"focus\", cm, e);\r\n    cm.state.focused = true;\r\n    addClass(cm.display.wrapper, \"CodeMirror-focused\");\r\n    // This test prevents this from firing when a context\r\n    // menu is closed (since the input reset would kill the\r\n    // select-all detection hack)\r\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\r\n      cm.display.input.reset();\r\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\r\n    }\r\n    cm.display.input.receivedFocus();\r\n  }\r\n  restartBlink(cm);\r\n}\r\nfunction onBlur(cm, e) {\r\n  if (cm.state.delayingBlurEvent) { return }\r\n\r\n  if (cm.state.focused) {\r\n    signal(cm, \"blur\", cm, e);\r\n    cm.state.focused = false;\r\n    rmClass(cm.display.wrapper, \"CodeMirror-focused\");\r\n  }\r\n  clearInterval(cm.display.blinker);\r\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\r\n}\r\n\r\n// Read the actual heights of the rendered lines, and update their\r\n// stored heights to match.\r\nfunction updateHeightsInViewport(cm) {\r\n  var display = cm.display;\r\n  var prevBottom = display.lineDiv.offsetTop;\r\n  for (var i = 0; i < display.view.length; i++) {\r\n    var cur = display.view[i], height = (void 0);\r\n    if (cur.hidden) { continue }\r\n    if (ie && ie_version < 8) {\r\n      var bot = cur.node.offsetTop + cur.node.offsetHeight;\r\n      height = bot - prevBottom;\r\n      prevBottom = bot;\r\n    } else {\r\n      var box = cur.node.getBoundingClientRect();\r\n      height = box.bottom - box.top;\r\n    }\r\n    var diff = cur.line.height - height;\r\n    if (height < 2) { height = textHeight(display); }\r\n    if (diff > .001 || diff < -.001) {\r\n      updateLineHeight(cur.line, height);\r\n      updateWidgetHeight(cur.line);\r\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\r\n        { updateWidgetHeight(cur.rest[j]); } }\r\n    }\r\n  }\r\n}\r\n\r\n// Read and store the height of line widgets associated with the\r\n// given line.\r\nfunction updateWidgetHeight(line) {\r\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)\r\n    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight; } }\r\n}\r\n\r\n// Compute the lines that are visible in a given viewport (defaults\r\n// the the current scroll position). viewport may contain top,\r\n// height, and ensure (see op.scrollToPos) properties.\r\nfunction visibleLines(display, doc, viewport) {\r\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\r\n  top = Math.floor(top - paddingTop(display));\r\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\r\n\r\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\r\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\r\n  // forces those lines into the viewport (if possible).\r\n  if (viewport && viewport.ensure) {\r\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\r\n    if (ensureFrom < from) {\r\n      from = ensureFrom;\r\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\r\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\r\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\r\n      to = ensureTo;\r\n    }\r\n  }\r\n  return {from: from, to: Math.max(to, from + 1)}\r\n}\r\n\r\n// Re-align line numbers and gutter marks to compensate for\r\n// horizontal scrolling.\r\nfunction alignHorizontally(cm) {\r\n  var display = cm.display, view = display.view;\r\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\r\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\r\n  var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\r\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\r\n    if (cm.options.fixedGutter) {\r\n      if (view[i].gutter)\r\n        { view[i].gutter.style.left = left; }\r\n      if (view[i].gutterBackground)\r\n        { view[i].gutterBackground.style.left = left; }\r\n    }\r\n    var align = view[i].alignable;\r\n    if (align) { for (var j = 0; j < align.length; j++)\r\n      { align[j].style.left = left; } }\r\n  } }\r\n  if (cm.options.fixedGutter)\r\n    { display.gutters.style.left = (comp + gutterW) + \"px\"; }\r\n}\r\n\r\n// Used to ensure that the line number gutter is still the right\r\n// size for the current document size. Returns true when an update\r\n// is needed.\r\nfunction maybeUpdateLineNumberWidth(cm) {\r\n  if (!cm.options.lineNumbers) { return false }\r\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\r\n  if (last.length != display.lineNumChars) {\r\n    var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\r\n                                               \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\r\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\r\n    display.lineGutter.style.width = \"\";\r\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\r\n    display.lineNumWidth = display.lineNumInnerWidth + padding;\r\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\r\n    display.lineGutter.style.width = display.lineNumWidth + \"px\";\r\n    updateGutterSpace(cm);\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\n// SCROLLING THINGS INTO VIEW\r\n\r\n// If an editor sits on the top or bottom of the window, partially\r\n// scrolled out of view, this ensures that the cursor is visible.\r\nfunction maybeScrollWindow(cm, rect) {\r\n  if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\r\n\r\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\r\n  if (rect.top + box.top < 0) { doScroll = true; }\r\n  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\r\n  if (doScroll != null && !phantom) {\r\n    var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\r\n    cm.display.lineSpace.appendChild(scrollNode);\r\n    scrollNode.scrollIntoView(doScroll);\r\n    cm.display.lineSpace.removeChild(scrollNode);\r\n  }\r\n}\r\n\r\n// Scroll a given position into view (immediately), verifying that\r\n// it actually became visible (as line heights are accurately\r\n// measured, the position of something may 'drift' during drawing).\r\nfunction scrollPosIntoView(cm, pos, end, margin) {\r\n  if (margin == null) { margin = 0; }\r\n  var rect;\r\n  for (var limit = 0; limit < 5; limit++) {\r\n    var changed = false;\r\n    var coords = cursorCoords(cm, pos);\r\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\r\n    rect = {left: Math.min(coords.left, endCoords.left),\r\n            top: Math.min(coords.top, endCoords.top) - margin,\r\n            right: Math.max(coords.left, endCoords.left),\r\n            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\r\n    var scrollPos = calculateScrollPos(cm, rect);\r\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\r\n    if (scrollPos.scrollTop != null) {\r\n      updateScrollTop(cm, scrollPos.scrollTop);\r\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\r\n    }\r\n    if (scrollPos.scrollLeft != null) {\r\n      setScrollLeft(cm, scrollPos.scrollLeft);\r\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\r\n    }\r\n    if (!changed) { break }\r\n  }\r\n  return rect\r\n}\r\n\r\n// Scroll a given set of coordinates into view (immediately).\r\nfunction scrollIntoView(cm, rect) {\r\n  var scrollPos = calculateScrollPos(cm, rect);\r\n  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\r\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\r\n}\r\n\r\n// Calculate a new scroll position needed to scroll the given\r\n// rectangle into view. Returns an object with scrollTop and\r\n// scrollLeft properties. When these are undefined, the\r\n// vertical/horizontal position does not need to be adjusted.\r\nfunction calculateScrollPos(cm, rect) {\r\n  var display = cm.display, snapMargin = textHeight(cm.display);\r\n  if (rect.top < 0) { rect.top = 0; }\r\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\r\n  var screen = displayHeight(cm), result = {};\r\n  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\r\n  var docBottom = cm.doc.height + paddingVert(display);\r\n  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\r\n  if (rect.top < screentop) {\r\n    result.scrollTop = atTop ? 0 : rect.top;\r\n  } else if (rect.bottom > screentop + screen) {\r\n    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\r\n    if (newTop != screentop) { result.scrollTop = newTop; }\r\n  }\r\n\r\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\r\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\r\n  var tooWide = rect.right - rect.left > screenw;\r\n  if (tooWide) { rect.right = rect.left + screenw; }\r\n  if (rect.left < 10)\r\n    { result.scrollLeft = 0; }\r\n  else if (rect.left < screenleft)\r\n    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\r\n  else if (rect.right > screenw + screenleft - 3)\r\n    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\r\n  return result\r\n}\r\n\r\n// Store a relative adjustment to the scroll position in the current\r\n// operation (to be applied when the operation finishes).\r\nfunction addToScrollTop(cm, top) {\r\n  if (top == null) { return }\r\n  resolveScrollToPos(cm);\r\n  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\r\n}\r\n\r\n// Make sure that at the end of the operation the current cursor is\r\n// shown.\r\nfunction ensureCursorVisible(cm) {\r\n  resolveScrollToPos(cm);\r\n  var cur = cm.getCursor(), from = cur, to = cur;\r\n  if (!cm.options.lineWrapping) {\r\n    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\r\n    to = Pos(cur.line, cur.ch + 1);\r\n  }\r\n  cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin};\r\n}\r\n\r\nfunction scrollToCoords(cm, x, y) {\r\n  if (x != null || y != null) { resolveScrollToPos(cm); }\r\n  if (x != null) { cm.curOp.scrollLeft = x; }\r\n  if (y != null) { cm.curOp.scrollTop = y; }\r\n}\r\n\r\nfunction scrollToRange(cm, range$$1) {\r\n  resolveScrollToPos(cm);\r\n  cm.curOp.scrollToPos = range$$1;\r\n}\r\n\r\n// When an operation has its scrollToPos property set, and another\r\n// scroll action is applied before the end of the operation, this\r\n// 'simulates' scrolling that position into view in a cheap way, so\r\n// that the effect of intermediate scroll commands is not ignored.\r\nfunction resolveScrollToPos(cm) {\r\n  var range$$1 = cm.curOp.scrollToPos;\r\n  if (range$$1) {\r\n    cm.curOp.scrollToPos = null;\r\n    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\r\n    scrollToCoordsRange(cm, from, to, range$$1.margin);\r\n  }\r\n}\r\n\r\nfunction scrollToCoordsRange(cm, from, to, margin) {\r\n  var sPos = calculateScrollPos(cm, {\r\n    left: Math.min(from.left, to.left),\r\n    top: Math.min(from.top, to.top) - margin,\r\n    right: Math.max(from.right, to.right),\r\n    bottom: Math.max(from.bottom, to.bottom) + margin\r\n  });\r\n  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\r\n}\r\n\r\n// Sync the scrollable area and scrollbars, ensure the viewport\r\n// covers the visible area.\r\nfunction updateScrollTop(cm, val) {\r\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\r\n  if (!gecko) { updateDisplaySimple(cm, {top: val}); }\r\n  setScrollTop(cm, val, true);\r\n  if (gecko) { updateDisplaySimple(cm); }\r\n  startWorker(cm, 100);\r\n}\r\n\r\nfunction setScrollTop(cm, val, forceScroll) {\r\n  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\r\n  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\r\n  cm.doc.scrollTop = val;\r\n  cm.display.scrollbars.setScrollTop(val);\r\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\r\n}\r\n\r\n// Sync scroller and scrollbar, ensure the gutter elements are\r\n// aligned.\r\nfunction setScrollLeft(cm, val, isScroller, forceScroll) {\r\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\r\n  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\r\n  cm.doc.scrollLeft = val;\r\n  alignHorizontally(cm);\r\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\r\n  cm.display.scrollbars.setScrollLeft(val);\r\n}\r\n\r\n// SCROLLBARS\r\n\r\n// Prepare DOM reads needed to update the scrollbars. Done in one\r\n// shot to minimize update/measure roundtrips.\r\nfunction measureForScrollbars(cm) {\r\n  var d = cm.display, gutterW = d.gutters.offsetWidth;\r\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display));\r\n  return {\r\n    clientHeight: d.scroller.clientHeight,\r\n    viewHeight: d.wrapper.clientHeight,\r\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\r\n    viewWidth: d.wrapper.clientWidth,\r\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\r\n    docHeight: docH,\r\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\r\n    nativeBarWidth: d.nativeBarWidth,\r\n    gutterWidth: gutterW\r\n  }\r\n}\r\n\r\nvar NativeScrollbars = function(place, scroll, cm) {\r\n  this.cm = cm;\r\n  var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\r\n  var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\r\n  place(vert); place(horiz);\r\n\r\n  on(vert, \"scroll\", function () {\r\n    if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\r\n  });\r\n  on(horiz, \"scroll\", function () {\r\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\r\n  });\r\n\r\n  this.checkedZeroWidth = false;\r\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\r\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\r\n};\r\n\r\nNativeScrollbars.prototype.update = function (measure) {\r\n  var needsH = measure.scrollWidth > measure.clientWidth + 1;\r\n  var needsV = measure.scrollHeight > measure.clientHeight + 1;\r\n  var sWidth = measure.nativeBarWidth;\r\n\r\n  if (needsV) {\r\n    this.vert.style.display = \"block\";\r\n    this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\r\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\r\n    // A bug in IE8 can cause this value to be negative, so guard it.\r\n    this.vert.firstChild.style.height =\r\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\r\n  } else {\r\n    this.vert.style.display = \"\";\r\n    this.vert.firstChild.style.height = \"0\";\r\n  }\r\n\r\n  if (needsH) {\r\n    this.horiz.style.display = \"block\";\r\n    this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\r\n    this.horiz.style.left = measure.barLeft + \"px\";\r\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\r\n    this.horiz.firstChild.style.width =\r\n      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\r\n  } else {\r\n    this.horiz.style.display = \"\";\r\n    this.horiz.firstChild.style.width = \"0\";\r\n  }\r\n\r\n  if (!this.checkedZeroWidth && measure.clientHeight > 0) {\r\n    if (sWidth == 0) { this.zeroWidthHack(); }\r\n    this.checkedZeroWidth = true;\r\n  }\r\n\r\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\r\n};\r\n\r\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\r\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\r\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\r\n};\r\n\r\nNativeScrollbars.prototype.setScrollTop = function (pos) {\r\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\r\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\r\n};\r\n\r\nNativeScrollbars.prototype.zeroWidthHack = function () {\r\n  var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\r\n  this.horiz.style.height = this.vert.style.width = w;\r\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\r\n  this.disableHoriz = new Delayed;\r\n  this.disableVert = new Delayed;\r\n};\r\n\r\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\r\n  bar.style.pointerEvents = \"auto\";\r\n  function maybeDisable() {\r\n    // To find out whether the scrollbar is still visible, we\r\n    // check whether the element under the pixel in the bottom\r\n    // right corner of the scrollbar box is the scrollbar box\r\n    // itself (when the bar is still visible) or its filler child\r\n    // (when the bar is hidden). If it is still visible, we keep\r\n    // it enabled, if it's hidden, we disable pointer events.\r\n    var box = bar.getBoundingClientRect();\r\n    var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\r\n        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\r\n    if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\r\n    else { delay.set(1000, maybeDisable); }\r\n  }\r\n  delay.set(1000, maybeDisable);\r\n};\r\n\r\nNativeScrollbars.prototype.clear = function () {\r\n  var parent = this.horiz.parentNode;\r\n  parent.removeChild(this.horiz);\r\n  parent.removeChild(this.vert);\r\n};\r\n\r\nvar NullScrollbars = function () {};\r\n\r\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\r\nNullScrollbars.prototype.setScrollLeft = function () {};\r\nNullScrollbars.prototype.setScrollTop = function () {};\r\nNullScrollbars.prototype.clear = function () {};\r\n\r\nfunction updateScrollbars(cm, measure) {\r\n  if (!measure) { measure = measureForScrollbars(cm); }\r\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\r\n  updateScrollbarsInner(cm, measure);\r\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\r\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\r\n      { updateHeightsInViewport(cm); }\r\n    updateScrollbarsInner(cm, measureForScrollbars(cm));\r\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\r\n  }\r\n}\r\n\r\n// Re-synchronize the fake scrollbars with the actual size of the\r\n// content.\r\nfunction updateScrollbarsInner(cm, measure) {\r\n  var d = cm.display;\r\n  var sizes = d.scrollbars.update(measure);\r\n\r\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\r\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\r\n  d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\r\n\r\n  if (sizes.right && sizes.bottom) {\r\n    d.scrollbarFiller.style.display = \"block\";\r\n    d.scrollbarFiller.style.height = sizes.bottom + \"px\";\r\n    d.scrollbarFiller.style.width = sizes.right + \"px\";\r\n  } else { d.scrollbarFiller.style.display = \"\"; }\r\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\r\n    d.gutterFiller.style.display = \"block\";\r\n    d.gutterFiller.style.height = sizes.bottom + \"px\";\r\n    d.gutterFiller.style.width = measure.gutterWidth + \"px\";\r\n  } else { d.gutterFiller.style.display = \"\"; }\r\n}\r\n\r\nvar scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\r\n\r\nfunction initScrollbars(cm) {\r\n  if (cm.display.scrollbars) {\r\n    cm.display.scrollbars.clear();\r\n    if (cm.display.scrollbars.addClass)\r\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\r\n  }\r\n\r\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\r\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\r\n    // Prevent clicks in the scrollbars from killing focus\r\n    on(node, \"mousedown\", function () {\r\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\r\n    });\r\n    node.setAttribute(\"cm-not-content\", \"true\");\r\n  }, function (pos, axis) {\r\n    if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\r\n    else { updateScrollTop(cm, pos); }\r\n  }, cm);\r\n  if (cm.display.scrollbars.addClass)\r\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\r\n}\r\n\r\n// Operations are used to wrap a series of changes to the editor\r\n// state in such a way that each change won't have to update the\r\n// cursor and display (which would be awkward, slow, and\r\n// error-prone). Instead, display updates are batched and then all\r\n// combined and executed at once.\r\n\r\nvar nextOpId = 0;\r\n// Start a new operation.\r\nfunction startOperation(cm) {\r\n  cm.curOp = {\r\n    cm: cm,\r\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\r\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\r\n    forceUpdate: false,      // Used to force a redraw\r\n    updateInput: null,       // Whether to reset the input textarea\r\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\r\n    changeObjs: null,        // Accumulated changes, for firing change events\r\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\r\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\r\n    selectionChanged: false, // Whether the selection needs to be redrawn\r\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\r\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\r\n    scrollToPos: null,       // Used to scroll to a specific position\r\n    focus: false,\r\n    id: ++nextOpId           // Unique ID\r\n  };\r\n  pushOperation(cm.curOp);\r\n}\r\n\r\n// Finish an operation, updating the display and signalling delayed events\r\nfunction endOperation(cm) {\r\n  var op = cm.curOp;\r\n  finishOperation(op, function (group) {\r\n    for (var i = 0; i < group.ops.length; i++)\r\n      { group.ops[i].cm.curOp = null; }\r\n    endOperations(group);\r\n  });\r\n}\r\n\r\n// The DOM updates done when an operation finishes are batched so\r\n// that the minimum number of relayouts are required.\r\nfunction endOperations(group) {\r\n  var ops = group.ops;\r\n  for (var i = 0; i < ops.length; i++) // Read DOM\r\n    { endOperation_R1(ops[i]); }\r\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\r\n    { endOperation_W1(ops[i$1]); }\r\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\r\n    { endOperation_R2(ops[i$2]); }\r\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\r\n    { endOperation_W2(ops[i$3]); }\r\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\r\n    { endOperation_finish(ops[i$4]); }\r\n}\r\n\r\nfunction endOperation_R1(op) {\r\n  var cm = op.cm, display = cm.display;\r\n  maybeClipScrollbars(cm);\r\n  if (op.updateMaxLine) { findMaxLine(cm); }\r\n\r\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\r\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\r\n                       op.scrollToPos.to.line >= display.viewTo) ||\r\n    display.maxLineChanged && cm.options.lineWrapping;\r\n  op.update = op.mustUpdate &&\r\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\r\n}\r\n\r\nfunction endOperation_W1(op) {\r\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\r\n}\r\n\r\nfunction endOperation_R2(op) {\r\n  var cm = op.cm, display = cm.display;\r\n  if (op.updatedDisplay) { updateHeightsInViewport(cm); }\r\n\r\n  op.barMeasure = measureForScrollbars(cm);\r\n\r\n  // If the max line changed since it was last measured, measure it,\r\n  // and ensure the document's width matches it.\r\n  // updateDisplay_W2 will use these properties to do the actual resizing\r\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\r\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\r\n    cm.display.sizerWidth = op.adjustWidthTo;\r\n    op.barMeasure.scrollWidth =\r\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\r\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\r\n  }\r\n\r\n  if (op.updatedDisplay || op.selectionChanged)\r\n    { op.preparedSelection = display.input.prepareSelection(op.focus); }\r\n}\r\n\r\nfunction endOperation_W2(op) {\r\n  var cm = op.cm;\r\n\r\n  if (op.adjustWidthTo != null) {\r\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\r\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\r\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\r\n    cm.display.maxLineChanged = false;\r\n  }\r\n\r\n  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus());\r\n  if (op.preparedSelection)\r\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\r\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\r\n    { updateScrollbars(cm, op.barMeasure); }\r\n  if (op.updatedDisplay)\r\n    { setDocumentHeight(cm, op.barMeasure); }\r\n\r\n  if (op.selectionChanged) { restartBlink(cm); }\r\n\r\n  if (cm.state.focused && op.updateInput)\r\n    { cm.display.input.reset(op.typing); }\r\n  if (takeFocus) { ensureFocus(op.cm); }\r\n}\r\n\r\nfunction endOperation_finish(op) {\r\n  var cm = op.cm, display = cm.display, doc = cm.doc;\r\n\r\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\r\n\r\n  // Abort mouse wheel delta measurement, when scrolling explicitly\r\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\r\n    { display.wheelStartX = display.wheelStartY = null; }\r\n\r\n  // Propagate the scroll position to the actual DOM scroller\r\n  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\r\n\r\n  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\r\n  // If we need to scroll a specific position into view, do so.\r\n  if (op.scrollToPos) {\r\n    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\r\n                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\r\n    maybeScrollWindow(cm, rect);\r\n  }\r\n\r\n  // Fire events for markers that are hidden/unidden by editing or\r\n  // undoing\r\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\r\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\r\n    { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\r\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\r\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\r\n\r\n  if (display.wrapper.offsetHeight)\r\n    { doc.scrollTop = cm.display.scroller.scrollTop; }\r\n\r\n  // Fire change events, and delayed event handlers\r\n  if (op.changeObjs)\r\n    { signal(cm, \"changes\", cm, op.changeObjs); }\r\n  if (op.update)\r\n    { op.update.finish(); }\r\n}\r\n\r\n// Run the given function in an operation\r\nfunction runInOp(cm, f) {\r\n  if (cm.curOp) { return f() }\r\n  startOperation(cm);\r\n  try { return f() }\r\n  finally { endOperation(cm); }\r\n}\r\n// Wraps a function in an operation. Returns the wrapped function.\r\nfunction operation(cm, f) {\r\n  return function() {\r\n    if (cm.curOp) { return f.apply(cm, arguments) }\r\n    startOperation(cm);\r\n    try { return f.apply(cm, arguments) }\r\n    finally { endOperation(cm); }\r\n  }\r\n}\r\n// Used to add methods to editor and doc instances, wrapping them in\r\n// operations.\r\nfunction methodOp(f) {\r\n  return function() {\r\n    if (this.curOp) { return f.apply(this, arguments) }\r\n    startOperation(this);\r\n    try { return f.apply(this, arguments) }\r\n    finally { endOperation(this); }\r\n  }\r\n}\r\nfunction docMethodOp(f) {\r\n  return function() {\r\n    var cm = this.cm;\r\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\r\n    startOperation(cm);\r\n    try { return f.apply(this, arguments) }\r\n    finally { endOperation(cm); }\r\n  }\r\n}\r\n\r\n// Updates the display.view data structure for a given change to the\r\n// document. From and to are in pre-change coordinates. Lendiff is\r\n// the amount of lines added or subtracted by the change. This is\r\n// used for changes that span multiple lines, or change the way\r\n// lines are divided into visual lines. regLineChange (below)\r\n// registers single-line changes.\r\nfunction regChange(cm, from, to, lendiff) {\r\n  if (from == null) { from = cm.doc.first; }\r\n  if (to == null) { to = cm.doc.first + cm.doc.size; }\r\n  if (!lendiff) { lendiff = 0; }\r\n\r\n  var display = cm.display;\r\n  if (lendiff && to < display.viewTo &&\r\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\r\n    { display.updateLineNumbers = from; }\r\n\r\n  cm.curOp.viewChanged = true;\r\n\r\n  if (from >= display.viewTo) { // Change after\r\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\r\n      { resetView(cm); }\r\n  } else if (to <= display.viewFrom) { // Change before\r\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\r\n      resetView(cm);\r\n    } else {\r\n      display.viewFrom += lendiff;\r\n      display.viewTo += lendiff;\r\n    }\r\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\r\n    resetView(cm);\r\n  } else if (from <= display.viewFrom) { // Top overlap\r\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\r\n    if (cut) {\r\n      display.view = display.view.slice(cut.index);\r\n      display.viewFrom = cut.lineN;\r\n      display.viewTo += lendiff;\r\n    } else {\r\n      resetView(cm);\r\n    }\r\n  } else if (to >= display.viewTo) { // Bottom overlap\r\n    var cut$1 = viewCuttingPoint(cm, from, from, -1);\r\n    if (cut$1) {\r\n      display.view = display.view.slice(0, cut$1.index);\r\n      display.viewTo = cut$1.lineN;\r\n    } else {\r\n      resetView(cm);\r\n    }\r\n  } else { // Gap in the middle\r\n    var cutTop = viewCuttingPoint(cm, from, from, -1);\r\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\r\n    if (cutTop && cutBot) {\r\n      display.view = display.view.slice(0, cutTop.index)\r\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\r\n        .concat(display.view.slice(cutBot.index));\r\n      display.viewTo += lendiff;\r\n    } else {\r\n      resetView(cm);\r\n    }\r\n  }\r\n\r\n  var ext = display.externalMeasured;\r\n  if (ext) {\r\n    if (to < ext.lineN)\r\n      { ext.lineN += lendiff; }\r\n    else if (from < ext.lineN + ext.size)\r\n      { display.externalMeasured = null; }\r\n  }\r\n}\r\n\r\n// Register a change to a single line. Type must be one of \"text\",\r\n// \"gutter\", \"class\", \"widget\"\r\nfunction regLineChange(cm, line, type) {\r\n  cm.curOp.viewChanged = true;\r\n  var display = cm.display, ext = cm.display.externalMeasured;\r\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\r\n    { display.externalMeasured = null; }\r\n\r\n  if (line < display.viewFrom || line >= display.viewTo) { return }\r\n  var lineView = display.view[findViewIndex(cm, line)];\r\n  if (lineView.node == null) { return }\r\n  var arr = lineView.changes || (lineView.changes = []);\r\n  if (indexOf(arr, type) == -1) { arr.push(type); }\r\n}\r\n\r\n// Clear the view.\r\nfunction resetView(cm) {\r\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\r\n  cm.display.view = [];\r\n  cm.display.viewOffset = 0;\r\n}\r\n\r\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\r\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\r\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\r\n    { return {index: index, lineN: newN} }\r\n  var n = cm.display.viewFrom;\r\n  for (var i = 0; i < index; i++)\r\n    { n += view[i].size; }\r\n  if (n != oldN) {\r\n    if (dir > 0) {\r\n      if (index == view.length - 1) { return null }\r\n      diff = (n + view[index].size) - oldN;\r\n      index++;\r\n    } else {\r\n      diff = n - oldN;\r\n    }\r\n    oldN += diff; newN += diff;\r\n  }\r\n  while (visualLineNo(cm.doc, newN) != newN) {\r\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\r\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\r\n    index += dir;\r\n  }\r\n  return {index: index, lineN: newN}\r\n}\r\n\r\n// Force the view to cover a given range, adding empty view element\r\n// or clipping off existing ones as needed.\r\nfunction adjustView(cm, from, to) {\r\n  var display = cm.display, view = display.view;\r\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\r\n    display.view = buildViewArray(cm, from, to);\r\n    display.viewFrom = from;\r\n  } else {\r\n    if (display.viewFrom > from)\r\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\r\n    else if (display.viewFrom < from)\r\n      { display.view = display.view.slice(findViewIndex(cm, from)); }\r\n    display.viewFrom = from;\r\n    if (display.viewTo < to)\r\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\r\n    else if (display.viewTo > to)\r\n      { display.view = display.view.slice(0, findViewIndex(cm, to)); }\r\n  }\r\n  display.viewTo = to;\r\n}\r\n\r\n// Count the number of lines in the view whose DOM representation is\r\n// out of date (or nonexistent).\r\nfunction countDirtyView(cm) {\r\n  var view = cm.display.view, dirty = 0;\r\n  for (var i = 0; i < view.length; i++) {\r\n    var lineView = view[i];\r\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\r\n  }\r\n  return dirty\r\n}\r\n\r\n// HIGHLIGHT WORKER\r\n\r\nfunction startWorker(cm, time) {\r\n  if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\r\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\r\n}\r\n\r\nfunction highlightWorker(cm) {\r\n  var doc = cm.doc;\r\n  if (doc.frontier < doc.first) { doc.frontier = doc.first; }\r\n  if (doc.frontier >= cm.display.viewTo) { return }\r\n  var end = +new Date + cm.options.workTime;\r\n  var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\r\n  var changedLines = [];\r\n\r\n  doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\r\n    if (doc.frontier >= cm.display.viewFrom) { // Visible\r\n      var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\r\n      var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\r\n      line.styles = highlighted.styles;\r\n      var oldCls = line.styleClasses, newCls = highlighted.classes;\r\n      if (newCls) { line.styleClasses = newCls; }\r\n      else if (oldCls) { line.styleClasses = null; }\r\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\r\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\r\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\r\n      if (ischange) { changedLines.push(doc.frontier); }\r\n      line.stateAfter = tooLong ? state : copyState(doc.mode, state);\r\n    } else {\r\n      if (line.text.length <= cm.options.maxHighlightLength)\r\n        { processLine(cm, line.text, state); }\r\n      line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\r\n    }\r\n    ++doc.frontier;\r\n    if (+new Date > end) {\r\n      startWorker(cm, cm.options.workDelay);\r\n      return true\r\n    }\r\n  });\r\n  if (changedLines.length) { runInOp(cm, function () {\r\n    for (var i = 0; i < changedLines.length; i++)\r\n      { regLineChange(cm, changedLines[i], \"text\"); }\r\n  }); }\r\n}\r\n\r\n// DISPLAY DRAWING\r\n\r\nvar DisplayUpdate = function(cm, viewport, force) {\r\n  var display = cm.display;\r\n\r\n  this.viewport = viewport;\r\n  // Store some values that we'll need later (but don't want to force a relayout for)\r\n  this.visible = visibleLines(display, cm.doc, viewport);\r\n  this.editorIsHidden = !display.wrapper.offsetWidth;\r\n  this.wrapperHeight = display.wrapper.clientHeight;\r\n  this.wrapperWidth = display.wrapper.clientWidth;\r\n  this.oldDisplayWidth = displayWidth(cm);\r\n  this.force = force;\r\n  this.dims = getDimensions(cm);\r\n  this.events = [];\r\n};\r\n\r\nDisplayUpdate.prototype.signal = function (emitter, type) {\r\n  if (hasHandler(emitter, type))\r\n    { this.events.push(arguments); }\r\n};\r\nDisplayUpdate.prototype.finish = function () {\r\n    var this$1 = this;\r\n\r\n  for (var i = 0; i < this.events.length; i++)\r\n    { signal.apply(null, this$1.events[i]); }\r\n};\r\n\r\nfunction maybeClipScrollbars(cm) {\r\n  var display = cm.display;\r\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\r\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\r\n    display.heightForcer.style.height = scrollGap(cm) + \"px\";\r\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\r\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\r\n    display.scrollbarsClipped = true;\r\n  }\r\n}\r\n\r\nfunction selectionSnapshot(cm) {\r\n  if (cm.hasFocus()) { return null }\r\n  var active = activeElt();\r\n  if (!active || !contains(cm.display.lineDiv, active)) { return null }\r\n  var result = {activeElt: active};\r\n  if (window.getSelection) {\r\n    var sel = window.getSelection();\r\n    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\r\n      result.anchorNode = sel.anchorNode;\r\n      result.anchorOffset = sel.anchorOffset;\r\n      result.focusNode = sel.focusNode;\r\n      result.focusOffset = sel.focusOffset;\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\nfunction restoreSelection(snapshot) {\r\n  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\r\n  snapshot.activeElt.focus();\r\n  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\r\n    var sel = window.getSelection(), range$$1 = document.createRange();\r\n    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\r\n    range$$1.collapse(false);\r\n    sel.removeAllRanges();\r\n    sel.addRange(range$$1);\r\n    sel.extend(snapshot.focusNode, snapshot.focusOffset);\r\n  }\r\n}\r\n\r\n// Does the actual updating of the line display. Bails out\r\n// (returning false) when there is nothing to be done and forced is\r\n// false.\r\nfunction updateDisplayIfNeeded(cm, update) {\r\n  var display = cm.display, doc = cm.doc;\r\n\r\n  if (update.editorIsHidden) {\r\n    resetView(cm);\r\n    return false\r\n  }\r\n\r\n  // Bail out if the visible area is already rendered and nothing changed.\r\n  if (!update.force &&\r\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\r\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\r\n      display.renderedView == display.view && countDirtyView(cm) == 0)\r\n    { return false }\r\n\r\n  if (maybeUpdateLineNumberWidth(cm)) {\r\n    resetView(cm);\r\n    update.dims = getDimensions(cm);\r\n  }\r\n\r\n  // Compute a suitable new viewport (from & to)\r\n  var end = doc.first + doc.size;\r\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\r\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\r\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\r\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\r\n  if (sawCollapsedSpans) {\r\n    from = visualLineNo(cm.doc, from);\r\n    to = visualLineEndNo(cm.doc, to);\r\n  }\r\n\r\n  var different = from != display.viewFrom || to != display.viewTo ||\r\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\r\n  adjustView(cm, from, to);\r\n\r\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\r\n  // Position the mover div to align with the current scroll position\r\n  cm.display.mover.style.top = display.viewOffset + \"px\";\r\n\r\n  var toUpdate = countDirtyView(cm);\r\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\r\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\r\n    { return false }\r\n\r\n  // For big changes, we hide the enclosing element during the\r\n  // update, since that speeds up the operations on most browsers.\r\n  var selSnapshot = selectionSnapshot(cm);\r\n  if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\r\n  patchDisplay(cm, display.updateLineNumbers, update.dims);\r\n  if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\r\n  display.renderedView = display.view;\r\n  // There might have been a widget with a focused element that got\r\n  // hidden or updated, if so re-focus it.\r\n  restoreSelection(selSnapshot);\r\n\r\n  // Prevent selection and cursors from interfering with the scroll\r\n  // width and height.\r\n  removeChildren(display.cursorDiv);\r\n  removeChildren(display.selectionDiv);\r\n  display.gutters.style.height = display.sizer.style.minHeight = 0;\r\n\r\n  if (different) {\r\n    display.lastWrapHeight = update.wrapperHeight;\r\n    display.lastWrapWidth = update.wrapperWidth;\r\n    startWorker(cm, 400);\r\n  }\r\n\r\n  display.updateLineNumbers = null;\r\n\r\n  return true\r\n}\r\n\r\nfunction postUpdateDisplay(cm, update) {\r\n  var viewport = update.viewport;\r\n\r\n  for (var first = true;; first = false) {\r\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\r\n      // Clip forced viewport to actual scrollable area.\r\n      if (viewport && viewport.top != null)\r\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\r\n      // Updated line heights might result in the drawn area not\r\n      // actually covering the viewport. Keep looping until it does.\r\n      update.visible = visibleLines(cm.display, cm.doc, viewport);\r\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\r\n        { break }\r\n    }\r\n    if (!updateDisplayIfNeeded(cm, update)) { break }\r\n    updateHeightsInViewport(cm);\r\n    var barMeasure = measureForScrollbars(cm);\r\n    updateSelection(cm);\r\n    updateScrollbars(cm, barMeasure);\r\n    setDocumentHeight(cm, barMeasure);\r\n  }\r\n\r\n  update.signal(cm, \"update\", cm);\r\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\r\n    update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\r\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\r\n  }\r\n}\r\n\r\nfunction updateDisplaySimple(cm, viewport) {\r\n  var update = new DisplayUpdate(cm, viewport);\r\n  if (updateDisplayIfNeeded(cm, update)) {\r\n    updateHeightsInViewport(cm);\r\n    postUpdateDisplay(cm, update);\r\n    var barMeasure = measureForScrollbars(cm);\r\n    updateSelection(cm);\r\n    updateScrollbars(cm, barMeasure);\r\n    setDocumentHeight(cm, barMeasure);\r\n    update.finish();\r\n  }\r\n}\r\n\r\n// Sync the actual display DOM structure with display.view, removing\r\n// nodes for lines that are no longer in view, and creating the ones\r\n// that are not there yet, and updating the ones that are out of\r\n// date.\r\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\r\n  var display = cm.display, lineNumbers = cm.options.lineNumbers;\r\n  var container = display.lineDiv, cur = container.firstChild;\r\n\r\n  function rm(node) {\r\n    var next = node.nextSibling;\r\n    // Works around a throw-scroll bug in OS X Webkit\r\n    if (webkit && mac && cm.display.currentWheelTarget == node)\r\n      { node.style.display = \"none\"; }\r\n    else\r\n      { node.parentNode.removeChild(node); }\r\n    return next\r\n  }\r\n\r\n  var view = display.view, lineN = display.viewFrom;\r\n  // Loop over the elements in the view, syncing cur (the DOM nodes\r\n  // in display.lineDiv) with the view as we go.\r\n  for (var i = 0; i < view.length; i++) {\r\n    var lineView = view[i];\r\n    if (lineView.hidden) {\r\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\r\n      var node = buildLineElement(cm, lineView, lineN, dims);\r\n      container.insertBefore(node, cur);\r\n    } else { // Already drawn\r\n      while (cur != lineView.node) { cur = rm(cur); }\r\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\r\n        updateNumbersFrom <= lineN && lineView.lineNumber;\r\n      if (lineView.changes) {\r\n        if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\r\n        updateLineForChanges(cm, lineView, lineN, dims);\r\n      }\r\n      if (updateNumber) {\r\n        removeChildren(lineView.lineNumber);\r\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\r\n      }\r\n      cur = lineView.node.nextSibling;\r\n    }\r\n    lineN += lineView.size;\r\n  }\r\n  while (cur) { cur = rm(cur); }\r\n}\r\n\r\nfunction updateGutterSpace(cm) {\r\n  var width = cm.display.gutters.offsetWidth;\r\n  cm.display.sizer.style.marginLeft = width + \"px\";\r\n}\r\n\r\nfunction setDocumentHeight(cm, measure) {\r\n  cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\r\n  cm.display.heightForcer.style.top = measure.docHeight + \"px\";\r\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\r\n}\r\n\r\n// Rebuild the gutter elements, ensure the margin to the left of the\r\n// code matches their width.\r\nfunction updateGutters(cm) {\r\n  var gutters = cm.display.gutters, specs = cm.options.gutters;\r\n  removeChildren(gutters);\r\n  var i = 0;\r\n  for (; i < specs.length; ++i) {\r\n    var gutterClass = specs[i];\r\n    var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\r\n    if (gutterClass == \"CodeMirror-linenumbers\") {\r\n      cm.display.lineGutter = gElt;\r\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\r\n    }\r\n  }\r\n  gutters.style.display = i ? \"\" : \"none\";\r\n  updateGutterSpace(cm);\r\n}\r\n\r\n// Make sure the gutters options contains the element\r\n// \"CodeMirror-linenumbers\" when the lineNumbers option is true.\r\nfunction setGuttersForLineNumbers(options) {\r\n  var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\r\n  if (found == -1 && options.lineNumbers) {\r\n    options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\r\n  } else if (found > -1 && !options.lineNumbers) {\r\n    options.gutters = options.gutters.slice(0);\r\n    options.gutters.splice(found, 1);\r\n  }\r\n}\r\n\r\n// Since the delta values reported on mouse wheel events are\r\n// unstandardized between browsers and even browser versions, and\r\n// generally horribly unpredictable, this code starts by measuring\r\n// the scroll effect that the first few mouse wheel events have,\r\n// and, from that, detects the way it can convert deltas to pixel\r\n// offsets afterwards.\r\n//\r\n// The reason we want to know the amount a wheel event will scroll\r\n// is that it gives us a chance to update the display before the\r\n// actual scrolling happens, reducing flickering.\r\n\r\nvar wheelSamples = 0;\r\nvar wheelPixelsPerUnit = null;\r\n// Fill in a browser-detected starting value on browsers where we\r\n// know one. These don't have to be accurate -- the result of them\r\n// being wrong would just be a slight flicker on the first wheel\r\n// scroll (if it is large enough).\r\nif (ie) { wheelPixelsPerUnit = -.53; }\r\nelse if (gecko) { wheelPixelsPerUnit = 15; }\r\nelse if (chrome) { wheelPixelsPerUnit = -.7; }\r\nelse if (safari) { wheelPixelsPerUnit = -1/3; }\r\n\r\nfunction wheelEventDelta(e) {\r\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\r\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\r\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\r\n  else if (dy == null) { dy = e.wheelDelta; }\r\n  return {x: dx, y: dy}\r\n}\r\nfunction wheelEventPixels(e) {\r\n  var delta = wheelEventDelta(e);\r\n  delta.x *= wheelPixelsPerUnit;\r\n  delta.y *= wheelPixelsPerUnit;\r\n  return delta\r\n}\r\n\r\nfunction onScrollWheel(cm, e) {\r\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\r\n\r\n  var display = cm.display, scroll = display.scroller;\r\n  // Quit if there's nothing to scroll here\r\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth;\r\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight;\r\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\r\n\r\n  // Webkit browsers on OS X abort momentum scrolls when the target\r\n  // of the scroll event is removed from the scrollable element.\r\n  // This hack (see related code in patchDisplay) makes sure the\r\n  // element is kept around.\r\n  if (dy && mac && webkit) {\r\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\r\n      for (var i = 0; i < view.length; i++) {\r\n        if (view[i].node == cur) {\r\n          cm.display.currentWheelTarget = cur;\r\n          break outer\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // On some browsers, horizontal scrolling will cause redraws to\r\n  // happen before the gutter has been realigned, causing it to\r\n  // wriggle around in a most unseemly way. When we have an\r\n  // estimated pixels/delta value, we just handle horizontal\r\n  // scrolling entirely here. It'll be slightly off from native, but\r\n  // better than glitching out.\r\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\r\n    if (dy && canScrollY)\r\n      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\r\n    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\r\n    // Only prevent default scrolling if vertical scrolling is\r\n    // actually possible. Otherwise, it causes vertical scroll\r\n    // jitter on OSX trackpads when deltaX is small and deltaY\r\n    // is large (issue #3579)\r\n    if (!dy || (dy && canScrollY))\r\n      { e_preventDefault(e); }\r\n    display.wheelStartX = null; // Abort measurement, if in progress\r\n    return\r\n  }\r\n\r\n  // 'Project' the visible viewport to cover the area that is being\r\n  // scrolled into view (if we know enough to estimate it).\r\n  if (dy && wheelPixelsPerUnit != null) {\r\n    var pixels = dy * wheelPixelsPerUnit;\r\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\r\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\r\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\r\n    updateDisplaySimple(cm, {top: top, bottom: bot});\r\n  }\r\n\r\n  if (wheelSamples < 20) {\r\n    if (display.wheelStartX == null) {\r\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\r\n      display.wheelDX = dx; display.wheelDY = dy;\r\n      setTimeout(function () {\r\n        if (display.wheelStartX == null) { return }\r\n        var movedX = scroll.scrollLeft - display.wheelStartX;\r\n        var movedY = scroll.scrollTop - display.wheelStartY;\r\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\r\n          (movedX && display.wheelDX && movedX / display.wheelDX);\r\n        display.wheelStartX = display.wheelStartY = null;\r\n        if (!sample) { return }\r\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\r\n        ++wheelSamples;\r\n      }, 200);\r\n    } else {\r\n      display.wheelDX += dx; display.wheelDY += dy;\r\n    }\r\n  }\r\n}\r\n\r\n// Selection objects are immutable. A new one is created every time\r\n// the selection changes. A selection is one or more non-overlapping\r\n// (and non-touching) ranges, sorted, and an integer that indicates\r\n// which one is the primary selection (the one that's scrolled into\r\n// view, that getCursor returns, etc).\r\nvar Selection = function(ranges, primIndex) {\r\n  this.ranges = ranges;\r\n  this.primIndex = primIndex;\r\n};\r\n\r\nSelection.prototype.primary = function () { return this.ranges[this.primIndex] };\r\n\r\nSelection.prototype.equals = function (other) {\r\n    var this$1 = this;\r\n\r\n  if (other == this) { return true }\r\n  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\r\n  for (var i = 0; i < this.ranges.length; i++) {\r\n    var here = this$1.ranges[i], there = other.ranges[i];\r\n    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\r\n  }\r\n  return true\r\n};\r\n\r\nSelection.prototype.deepCopy = function () {\r\n    var this$1 = this;\r\n\r\n  var out = [];\r\n  for (var i = 0; i < this.ranges.length; i++)\r\n    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\r\n  return new Selection(out, this.primIndex)\r\n};\r\n\r\nSelection.prototype.somethingSelected = function () {\r\n    var this$1 = this;\r\n\r\n  for (var i = 0; i < this.ranges.length; i++)\r\n    { if (!this$1.ranges[i].empty()) { return true } }\r\n  return false\r\n};\r\n\r\nSelection.prototype.contains = function (pos, end) {\r\n    var this$1 = this;\r\n\r\n  if (!end) { end = pos; }\r\n  for (var i = 0; i < this.ranges.length; i++) {\r\n    var range = this$1.ranges[i];\r\n    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\r\n      { return i }\r\n  }\r\n  return -1\r\n};\r\n\r\nvar Range = function(anchor, head) {\r\n  this.anchor = anchor; this.head = head;\r\n};\r\n\r\nRange.prototype.from = function () { return minPos(this.anchor, this.head) };\r\nRange.prototype.to = function () { return maxPos(this.anchor, this.head) };\r\nRange.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\r\n\r\n// Take an unsorted, potentially overlapping set of ranges, and\r\n// build a selection out of it. 'Consumes' ranges array (modifying\r\n// it).\r\nfunction normalizeSelection(ranges, primIndex) {\r\n  var prim = ranges[primIndex];\r\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\r\n  primIndex = indexOf(ranges, prim);\r\n  for (var i = 1; i < ranges.length; i++) {\r\n    var cur = ranges[i], prev = ranges[i - 1];\r\n    if (cmp(prev.to(), cur.from()) >= 0) {\r\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\r\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\r\n      if (i <= primIndex) { --primIndex; }\r\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\r\n    }\r\n  }\r\n  return new Selection(ranges, primIndex)\r\n}\r\n\r\nfunction simpleSelection(anchor, head) {\r\n  return new Selection([new Range(anchor, head || anchor)], 0)\r\n}\r\n\r\n// Compute the position of the end of a change (its 'to' property\r\n// refers to the pre-change end).\r\nfunction changeEnd(change) {\r\n  if (!change.text) { return change.to }\r\n  return Pos(change.from.line + change.text.length - 1,\r\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\r\n}\r\n\r\n// Adjust a position to refer to the post-change position of the\r\n// same text, or the end of the change if the change covers it.\r\nfunction adjustForChange(pos, change) {\r\n  if (cmp(pos, change.from) < 0) { return pos }\r\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\r\n\r\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\r\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\r\n  return Pos(line, ch)\r\n}\r\n\r\nfunction computeSelAfterChange(doc, change) {\r\n  var out = [];\r\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\r\n    var range = doc.sel.ranges[i];\r\n    out.push(new Range(adjustForChange(range.anchor, change),\r\n                       adjustForChange(range.head, change)));\r\n  }\r\n  return normalizeSelection(out, doc.sel.primIndex)\r\n}\r\n\r\nfunction offsetPos(pos, old, nw) {\r\n  if (pos.line == old.line)\r\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\r\n  else\r\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\r\n}\r\n\r\n// Used by replaceSelections to allow moving the selection to the\r\n// start or around the replaced test. Hint may be \"start\" or \"around\".\r\nfunction computeReplacedSel(doc, changes, hint) {\r\n  var out = [];\r\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\r\n  for (var i = 0; i < changes.length; i++) {\r\n    var change = changes[i];\r\n    var from = offsetPos(change.from, oldPrev, newPrev);\r\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev);\r\n    oldPrev = change.to;\r\n    newPrev = to;\r\n    if (hint == \"around\") {\r\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\r\n      out[i] = new Range(inv ? to : from, inv ? from : to);\r\n    } else {\r\n      out[i] = new Range(from, from);\r\n    }\r\n  }\r\n  return new Selection(out, doc.sel.primIndex)\r\n}\r\n\r\n// Used to get the editor into a consistent state again when options change.\r\n\r\nfunction loadMode(cm) {\r\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\r\n  resetModeState(cm);\r\n}\r\n\r\nfunction resetModeState(cm) {\r\n  cm.doc.iter(function (line) {\r\n    if (line.stateAfter) { line.stateAfter = null; }\r\n    if (line.styles) { line.styles = null; }\r\n  });\r\n  cm.doc.frontier = cm.doc.first;\r\n  startWorker(cm, 100);\r\n  cm.state.modeGen++;\r\n  if (cm.curOp) { regChange(cm); }\r\n}\r\n\r\n// DOCUMENT DATA STRUCTURE\r\n\r\n// By default, updates that start and end at the beginning of a line\r\n// are treated specially, in order to make the association of line\r\n// widgets and marker elements with the text behave more intuitive.\r\nfunction isWholeLineUpdate(doc, change) {\r\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\r\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\r\n}\r\n\r\n// Perform a change on the document data structure.\r\nfunction updateDoc(doc, change, markedSpans, estimateHeight$$1) {\r\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\r\n  function update(line, text, spans) {\r\n    updateLine(line, text, spans, estimateHeight$$1);\r\n    signalLater(line, \"change\", line, change);\r\n  }\r\n  function linesFor(start, end) {\r\n    var result = [];\r\n    for (var i = start; i < end; ++i)\r\n      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\r\n    return result\r\n  }\r\n\r\n  var from = change.from, to = change.to, text = change.text;\r\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\r\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\r\n\r\n  // Adjust the line structure\r\n  if (change.full) {\r\n    doc.insert(0, linesFor(0, text.length));\r\n    doc.remove(text.length, doc.size - text.length);\r\n  } else if (isWholeLineUpdate(doc, change)) {\r\n    // This is a whole-line replace. Treated specially to make\r\n    // sure line objects move the way they are supposed to.\r\n    var added = linesFor(0, text.length - 1);\r\n    update(lastLine, lastLine.text, lastSpans);\r\n    if (nlines) { doc.remove(from.line, nlines); }\r\n    if (added.length) { doc.insert(from.line, added); }\r\n  } else if (firstLine == lastLine) {\r\n    if (text.length == 1) {\r\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\r\n    } else {\r\n      var added$1 = linesFor(1, text.length - 1);\r\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\r\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\r\n      doc.insert(from.line + 1, added$1);\r\n    }\r\n  } else if (text.length == 1) {\r\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\r\n    doc.remove(from.line + 1, nlines);\r\n  } else {\r\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\r\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\r\n    var added$2 = linesFor(1, text.length - 1);\r\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\r\n    doc.insert(from.line + 1, added$2);\r\n  }\r\n\r\n  signalLater(doc, \"change\", doc, change);\r\n}\r\n\r\n// Call f for all linked documents.\r\nfunction linkedDocs(doc, f, sharedHistOnly) {\r\n  function propagate(doc, skip, sharedHist) {\r\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\r\n      var rel = doc.linked[i];\r\n      if (rel.doc == skip) { continue }\r\n      var shared = sharedHist && rel.sharedHist;\r\n      if (sharedHistOnly && !shared) { continue }\r\n      f(rel.doc, shared);\r\n      propagate(rel.doc, doc, shared);\r\n    } }\r\n  }\r\n  propagate(doc, null, true);\r\n}\r\n\r\n// Attach a document to an editor.\r\nfunction attachDoc(cm, doc) {\r\n  if (doc.cm) { throw new Error(\"This document is already in use.\") }\r\n  cm.doc = doc;\r\n  doc.cm = cm;\r\n  estimateLineHeights(cm);\r\n  loadMode(cm);\r\n  setDirectionClass(cm);\r\n  if (!cm.options.lineWrapping) { findMaxLine(cm); }\r\n  cm.options.mode = doc.modeOption;\r\n  regChange(cm);\r\n}\r\n\r\nfunction setDirectionClass(cm) {\r\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\r\n}\r\n\r\nfunction directionChanged(cm) {\r\n  runInOp(cm, function () {\r\n    setDirectionClass(cm);\r\n    regChange(cm);\r\n  });\r\n}\r\n\r\nfunction History(startGen) {\r\n  // Arrays of change events and selections. Doing something adds an\r\n  // event to done and clears undo. Undoing moves events from done\r\n  // to undone, redoing moves them in the other direction.\r\n  this.done = []; this.undone = [];\r\n  this.undoDepth = Infinity;\r\n  // Used to track when changes can be merged into a single undo\r\n  // event\r\n  this.lastModTime = this.lastSelTime = 0;\r\n  this.lastOp = this.lastSelOp = null;\r\n  this.lastOrigin = this.lastSelOrigin = null;\r\n  // Used by the isClean() method\r\n  this.generation = this.maxGeneration = startGen || 1;\r\n}\r\n\r\n// Create a history change event from an updateDoc-style change\r\n// object.\r\nfunction historyChangeFromChange(doc, change) {\r\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\r\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\r\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\r\n  return histChange\r\n}\r\n\r\n// Pop all selection events off the end of a history array. Stop at\r\n// a change event.\r\nfunction clearSelectionEvents(array) {\r\n  while (array.length) {\r\n    var last = lst(array);\r\n    if (last.ranges) { array.pop(); }\r\n    else { break }\r\n  }\r\n}\r\n\r\n// Find the top change event in the history. Pop off selection\r\n// events that are in the way.\r\nfunction lastChangeEvent(hist, force) {\r\n  if (force) {\r\n    clearSelectionEvents(hist.done);\r\n    return lst(hist.done)\r\n  } else if (hist.done.length && !lst(hist.done).ranges) {\r\n    return lst(hist.done)\r\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\r\n    hist.done.pop();\r\n    return lst(hist.done)\r\n  }\r\n}\r\n\r\n// Register a change in the history. Merges changes that are within\r\n// a single operation, or are close together with an origin that\r\n// allows merging (starting with \"+\") into a single event.\r\nfunction addChangeToHistory(doc, change, selAfter, opId) {\r\n  var hist = doc.history;\r\n  hist.undone.length = 0;\r\n  var time = +new Date, cur;\r\n  var last;\r\n\r\n  if ((hist.lastOp == opId ||\r\n       hist.lastOrigin == change.origin && change.origin &&\r\n       ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\r\n        change.origin.charAt(0) == \"*\")) &&\r\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\r\n    // Merge this change into the last event\r\n    last = lst(cur.changes);\r\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\r\n      // Optimized case for simple insertion -- don't want to add\r\n      // new changesets for every character typed\r\n      last.to = changeEnd(change);\r\n    } else {\r\n      // Add new sub-event\r\n      cur.changes.push(historyChangeFromChange(doc, change));\r\n    }\r\n  } else {\r\n    // Can not be merged, start a new event.\r\n    var before = lst(hist.done);\r\n    if (!before || !before.ranges)\r\n      { pushSelectionToHistory(doc.sel, hist.done); }\r\n    cur = {changes: [historyChangeFromChange(doc, change)],\r\n           generation: hist.generation};\r\n    hist.done.push(cur);\r\n    while (hist.done.length > hist.undoDepth) {\r\n      hist.done.shift();\r\n      if (!hist.done[0].ranges) { hist.done.shift(); }\r\n    }\r\n  }\r\n  hist.done.push(selAfter);\r\n  hist.generation = ++hist.maxGeneration;\r\n  hist.lastModTime = hist.lastSelTime = time;\r\n  hist.lastOp = hist.lastSelOp = opId;\r\n  hist.lastOrigin = hist.lastSelOrigin = change.origin;\r\n\r\n  if (!last) { signal(doc, \"historyAdded\"); }\r\n}\r\n\r\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\r\n  var ch = origin.charAt(0);\r\n  return ch == \"*\" ||\r\n    ch == \"+\" &&\r\n    prev.ranges.length == sel.ranges.length &&\r\n    prev.somethingSelected() == sel.somethingSelected() &&\r\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\r\n}\r\n\r\n// Called whenever the selection changes, sets the new selection as\r\n// the pending selection in the history, and pushes the old pending\r\n// selection into the 'done' array when it was significantly\r\n// different (in number of selected ranges, emptiness, or time).\r\nfunction addSelectionToHistory(doc, sel, opId, options) {\r\n  var hist = doc.history, origin = options && options.origin;\r\n\r\n  // A new event is started when the previous origin does not match\r\n  // the current, or the origins don't allow matching. Origins\r\n  // starting with * are always merged, those starting with + are\r\n  // merged when similar and close together in time.\r\n  if (opId == hist.lastSelOp ||\r\n      (origin && hist.lastSelOrigin == origin &&\r\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\r\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\r\n    { hist.done[hist.done.length - 1] = sel; }\r\n  else\r\n    { pushSelectionToHistory(sel, hist.done); }\r\n\r\n  hist.lastSelTime = +new Date;\r\n  hist.lastSelOrigin = origin;\r\n  hist.lastSelOp = opId;\r\n  if (options && options.clearRedo !== false)\r\n    { clearSelectionEvents(hist.undone); }\r\n}\r\n\r\nfunction pushSelectionToHistory(sel, dest) {\r\n  var top = lst(dest);\r\n  if (!(top && top.ranges && top.equals(sel)))\r\n    { dest.push(sel); }\r\n}\r\n\r\n// Used to store marked span information in the history.\r\nfunction attachLocalSpans(doc, change, from, to) {\r\n  var existing = change[\"spans_\" + doc.id], n = 0;\r\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\r\n    if (line.markedSpans)\r\n      { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\r\n    ++n;\r\n  });\r\n}\r\n\r\n// When un/re-doing restores text containing marked spans, those\r\n// that have been explicitly cleared should not be restored.\r\nfunction removeClearedSpans(spans) {\r\n  if (!spans) { return null }\r\n  var out;\r\n  for (var i = 0; i < spans.length; ++i) {\r\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\r\n    else if (out) { out.push(spans[i]); }\r\n  }\r\n  return !out ? spans : out.length ? out : null\r\n}\r\n\r\n// Retrieve and filter the old marked spans stored in a change event.\r\nfunction getOldSpans(doc, change) {\r\n  var found = change[\"spans_\" + doc.id];\r\n  if (!found) { return null }\r\n  var nw = [];\r\n  for (var i = 0; i < change.text.length; ++i)\r\n    { nw.push(removeClearedSpans(found[i])); }\r\n  return nw\r\n}\r\n\r\n// Used for un/re-doing changes from the history. Combines the\r\n// result of computing the existing spans with the set of spans that\r\n// existed in the history (so that deleting around a span and then\r\n// undoing brings back the span).\r\nfunction mergeOldSpans(doc, change) {\r\n  var old = getOldSpans(doc, change);\r\n  var stretched = stretchSpansOverChange(doc, change);\r\n  if (!old) { return stretched }\r\n  if (!stretched) { return old }\r\n\r\n  for (var i = 0; i < old.length; ++i) {\r\n    var oldCur = old[i], stretchCur = stretched[i];\r\n    if (oldCur && stretchCur) {\r\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\r\n        var span = stretchCur[j];\r\n        for (var k = 0; k < oldCur.length; ++k)\r\n          { if (oldCur[k].marker == span.marker) { continue spans } }\r\n        oldCur.push(span);\r\n      }\r\n    } else if (stretchCur) {\r\n      old[i] = stretchCur;\r\n    }\r\n  }\r\n  return old\r\n}\r\n\r\n// Used both to provide a JSON-safe object in .getHistory, and, when\r\n// detaching a document, to split the history in two\r\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\r\n  var copy = [];\r\n  for (var i = 0; i < events.length; ++i) {\r\n    var event = events[i];\r\n    if (event.ranges) {\r\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\r\n      continue\r\n    }\r\n    var changes = event.changes, newChanges = [];\r\n    copy.push({changes: newChanges});\r\n    for (var j = 0; j < changes.length; ++j) {\r\n      var change = changes[j], m = (void 0);\r\n      newChanges.push({from: change.from, to: change.to, text: change.text});\r\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\r\n        if (indexOf(newGroup, Number(m[1])) > -1) {\r\n          lst(newChanges)[prop] = change[prop];\r\n          delete change[prop];\r\n        }\r\n      } } }\r\n    }\r\n  }\r\n  return copy\r\n}\r\n\r\n// The 'scroll' parameter given to many of these indicated whether\r\n// the new cursor position should be scrolled into view after\r\n// modifying the selection.\r\n\r\n// If shift is held or the extend flag is set, extends a range to\r\n// include a given position (and optionally a second position).\r\n// Otherwise, simply returns the range between the given positions.\r\n// Used for cursor motion and such.\r\nfunction extendRange(doc, range, head, other) {\r\n  if (doc.cm && doc.cm.display.shift || doc.extend) {\r\n    var anchor = range.anchor;\r\n    if (other) {\r\n      var posBefore = cmp(head, anchor) < 0;\r\n      if (posBefore != (cmp(other, anchor) < 0)) {\r\n        anchor = head;\r\n        head = other;\r\n      } else if (posBefore != (cmp(head, other) < 0)) {\r\n        head = other;\r\n      }\r\n    }\r\n    return new Range(anchor, head)\r\n  } else {\r\n    return new Range(other || head, head)\r\n  }\r\n}\r\n\r\n// Extend the primary selection range, discard the rest.\r\nfunction extendSelection(doc, head, other, options) {\r\n  setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\r\n}\r\n\r\n// Extend all selections (pos is an array of selections with length\r\n// equal the number of selections)\r\nfunction extendSelections(doc, heads, options) {\r\n  var out = [];\r\n  for (var i = 0; i < doc.sel.ranges.length; i++)\r\n    { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null); }\r\n  var newSel = normalizeSelection(out, doc.sel.primIndex);\r\n  setSelection(doc, newSel, options);\r\n}\r\n\r\n// Updates a single range in the selection.\r\nfunction replaceOneSelection(doc, i, range, options) {\r\n  var ranges = doc.sel.ranges.slice(0);\r\n  ranges[i] = range;\r\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\r\n}\r\n\r\n// Reset the selection to a single range.\r\nfunction setSimpleSelection(doc, anchor, head, options) {\r\n  setSelection(doc, simpleSelection(anchor, head), options);\r\n}\r\n\r\n// Give beforeSelectionChange handlers a change to influence a\r\n// selection update.\r\nfunction filterSelectionChange(doc, sel, options) {\r\n  var obj = {\r\n    ranges: sel.ranges,\r\n    update: function(ranges) {\r\n      var this$1 = this;\r\n\r\n      this.ranges = [];\r\n      for (var i = 0; i < ranges.length; i++)\r\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\r\n                                   clipPos(doc, ranges[i].head)); }\r\n    },\r\n    origin: options && options.origin\r\n  };\r\n  signal(doc, \"beforeSelectionChange\", doc, obj);\r\n  if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\r\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\r\n  else { return sel }\r\n}\r\n\r\nfunction setSelectionReplaceHistory(doc, sel, options) {\r\n  var done = doc.history.done, last = lst(done);\r\n  if (last && last.ranges) {\r\n    done[done.length - 1] = sel;\r\n    setSelectionNoUndo(doc, sel, options);\r\n  } else {\r\n    setSelection(doc, sel, options);\r\n  }\r\n}\r\n\r\n// Set a new selection.\r\nfunction setSelection(doc, sel, options) {\r\n  setSelectionNoUndo(doc, sel, options);\r\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\r\n}\r\n\r\nfunction setSelectionNoUndo(doc, sel, options) {\r\n  if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\r\n    { sel = filterSelectionChange(doc, sel, options); }\r\n\r\n  var bias = options && options.bias ||\r\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\r\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\r\n\r\n  if (!(options && options.scroll === false) && doc.cm)\r\n    { ensureCursorVisible(doc.cm); }\r\n}\r\n\r\nfunction setSelectionInner(doc, sel) {\r\n  if (sel.equals(doc.sel)) { return }\r\n\r\n  doc.sel = sel;\r\n\r\n  if (doc.cm) {\r\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\r\n    signalCursorActivity(doc.cm);\r\n  }\r\n  signalLater(doc, \"cursorActivity\", doc);\r\n}\r\n\r\n// Verify that the selection does not partially select any atomic\r\n// marked ranges.\r\nfunction reCheckSelection(doc) {\r\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\r\n}\r\n\r\n// Return a selection that does not partially select any atomic\r\n// ranges.\r\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\r\n  var out;\r\n  for (var i = 0; i < sel.ranges.length; i++) {\r\n    var range = sel.ranges[i];\r\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\r\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\r\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\r\n    if (out || newAnchor != range.anchor || newHead != range.head) {\r\n      if (!out) { out = sel.ranges.slice(0, i); }\r\n      out[i] = new Range(newAnchor, newHead);\r\n    }\r\n  }\r\n  return out ? normalizeSelection(out, sel.primIndex) : sel\r\n}\r\n\r\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\r\n  var line = getLine(doc, pos.line);\r\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\r\n    var sp = line.markedSpans[i], m = sp.marker;\r\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\r\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\r\n      if (mayClear) {\r\n        signal(m, \"beforeCursorEnter\");\r\n        if (m.explicitlyCleared) {\r\n          if (!line.markedSpans) { break }\r\n          else {--i; continue}\r\n        }\r\n      }\r\n      if (!m.atomic) { continue }\r\n\r\n      if (oldPos) {\r\n        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\r\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\r\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\r\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\r\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\r\n      }\r\n\r\n      var far = m.find(dir < 0 ? -1 : 1);\r\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\r\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\r\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\r\n    }\r\n  } }\r\n  return pos\r\n}\r\n\r\n// Ensure a given position is not inside an atomic range.\r\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\r\n  var dir = bias || 1;\r\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\r\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\r\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\r\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\r\n  if (!found) {\r\n    doc.cantEdit = true;\r\n    return Pos(doc.first, 0)\r\n  }\r\n  return found\r\n}\r\n\r\nfunction movePos(doc, pos, dir, line) {\r\n  if (dir < 0 && pos.ch == 0) {\r\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\r\n    else { return null }\r\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\r\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\r\n    else { return null }\r\n  } else {\r\n    return new Pos(pos.line, pos.ch + dir)\r\n  }\r\n}\r\n\r\nfunction selectAll(cm) {\r\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\r\n}\r\n\r\n// UPDATING\r\n\r\n// Allow \"beforeChange\" event handlers to influence a change\r\nfunction filterChange(doc, change, update) {\r\n  var obj = {\r\n    canceled: false,\r\n    from: change.from,\r\n    to: change.to,\r\n    text: change.text,\r\n    origin: change.origin,\r\n    cancel: function () { return obj.canceled = true; }\r\n  };\r\n  if (update) { obj.update = function (from, to, text, origin) {\r\n    if (from) { obj.from = clipPos(doc, from); }\r\n    if (to) { obj.to = clipPos(doc, to); }\r\n    if (text) { obj.text = text; }\r\n    if (origin !== undefined) { obj.origin = origin; }\r\n  }; }\r\n  signal(doc, \"beforeChange\", doc, obj);\r\n  if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\r\n\r\n  if (obj.canceled) { return null }\r\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\r\n}\r\n\r\n// Apply a change to a document, and add it to the document's\r\n// history, and propagating it to all linked documents.\r\nfunction makeChange(doc, change, ignoreReadOnly) {\r\n  if (doc.cm) {\r\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\r\n    if (doc.cm.state.suppressEdits) { return }\r\n  }\r\n\r\n  if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\r\n    change = filterChange(doc, change, true);\r\n    if (!change) { return }\r\n  }\r\n\r\n  // Possibly split or suppress the update based on the presence\r\n  // of read-only spans in its range.\r\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\r\n  if (split) {\r\n    for (var i = split.length - 1; i >= 0; --i)\r\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text}); }\r\n  } else {\r\n    makeChangeInner(doc, change);\r\n  }\r\n}\r\n\r\nfunction makeChangeInner(doc, change) {\r\n  if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\r\n  var selAfter = computeSelAfterChange(doc, change);\r\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\r\n\r\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\r\n  var rebased = [];\r\n\r\n  linkedDocs(doc, function (doc, sharedHist) {\r\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\r\n      rebaseHist(doc.history, change);\r\n      rebased.push(doc.history);\r\n    }\r\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\r\n  });\r\n}\r\n\r\n// Revert a change stored in a document's history.\r\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\r\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\r\n\r\n  var hist = doc.history, event, selAfter = doc.sel;\r\n  var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\r\n\r\n  // Verify that there is a useable event (so that ctrl-z won't\r\n  // needlessly clear selection events)\r\n  var i = 0;\r\n  for (; i < source.length; i++) {\r\n    event = source[i];\r\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\r\n      { break }\r\n  }\r\n  if (i == source.length) { return }\r\n  hist.lastOrigin = hist.lastSelOrigin = null;\r\n\r\n  for (;;) {\r\n    event = source.pop();\r\n    if (event.ranges) {\r\n      pushSelectionToHistory(event, dest);\r\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\r\n        setSelection(doc, event, {clearRedo: false});\r\n        return\r\n      }\r\n      selAfter = event;\r\n    }\r\n    else { break }\r\n  }\r\n\r\n  // Build up a reverse change object to add to the opposite history\r\n  // stack (redo when undoing, and vice versa).\r\n  var antiChanges = [];\r\n  pushSelectionToHistory(selAfter, dest);\r\n  dest.push({changes: antiChanges, generation: hist.generation});\r\n  hist.generation = event.generation || ++hist.maxGeneration;\r\n\r\n  var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\r\n\r\n  var loop = function ( i ) {\r\n    var change = event.changes[i];\r\n    change.origin = type;\r\n    if (filter && !filterChange(doc, change, false)) {\r\n      source.length = 0;\r\n      return {}\r\n    }\r\n\r\n    antiChanges.push(historyChangeFromChange(doc, change));\r\n\r\n    var after = i ? computeSelAfterChange(doc, change) : lst(source);\r\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\r\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\r\n    var rebased = [];\r\n\r\n    // Propagate to the linked documents\r\n    linkedDocs(doc, function (doc, sharedHist) {\r\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\r\n        rebaseHist(doc.history, change);\r\n        rebased.push(doc.history);\r\n      }\r\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\r\n    });\r\n  };\r\n\r\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\r\n    var returned = loop( i$1 );\r\n\r\n    if ( returned ) return returned.v;\r\n  }\r\n}\r\n\r\n// Sub-views need their line numbers shifted when text is added\r\n// above or below them in the parent document.\r\nfunction shiftDoc(doc, distance) {\r\n  if (distance == 0) { return }\r\n  doc.first += distance;\r\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\r\n    Pos(range.anchor.line + distance, range.anchor.ch),\r\n    Pos(range.head.line + distance, range.head.ch)\r\n  ); }), doc.sel.primIndex);\r\n  if (doc.cm) {\r\n    regChange(doc.cm, doc.first, doc.first - distance, distance);\r\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\r\n      { regLineChange(doc.cm, l, \"gutter\"); }\r\n  }\r\n}\r\n\r\n// More lower-level change function, handling only a single document\r\n// (not linked ones).\r\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\r\n  if (doc.cm && !doc.cm.curOp)\r\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\r\n\r\n  if (change.to.line < doc.first) {\r\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\r\n    return\r\n  }\r\n  if (change.from.line > doc.lastLine()) { return }\r\n\r\n  // Clip the change to the size of this doc\r\n  if (change.from.line < doc.first) {\r\n    var shift = change.text.length - 1 - (doc.first - change.from.line);\r\n    shiftDoc(doc, shift);\r\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\r\n              text: [lst(change.text)], origin: change.origin};\r\n  }\r\n  var last = doc.lastLine();\r\n  if (change.to.line > last) {\r\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\r\n              text: [change.text[0]], origin: change.origin};\r\n  }\r\n\r\n  change.removed = getBetween(doc, change.from, change.to);\r\n\r\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\r\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\r\n  else { updateDoc(doc, change, spans); }\r\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll);\r\n}\r\n\r\n// Handle the interaction of a change to a document with the editor\r\n// that this document is part of.\r\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\r\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\r\n\r\n  var recomputeMaxLength = false, checkWidthStart = from.line;\r\n  if (!cm.options.lineWrapping) {\r\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\r\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\r\n      if (line == display.maxLine) {\r\n        recomputeMaxLength = true;\r\n        return true\r\n      }\r\n    });\r\n  }\r\n\r\n  if (doc.sel.contains(change.from, change.to) > -1)\r\n    { signalCursorActivity(cm); }\r\n\r\n  updateDoc(doc, change, spans, estimateHeight(cm));\r\n\r\n  if (!cm.options.lineWrapping) {\r\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\r\n      var len = lineLength(line);\r\n      if (len > display.maxLineLength) {\r\n        display.maxLine = line;\r\n        display.maxLineLength = len;\r\n        display.maxLineChanged = true;\r\n        recomputeMaxLength = false;\r\n      }\r\n    });\r\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\r\n  }\r\n\r\n  // Adjust frontier, schedule worker\r\n  doc.frontier = Math.min(doc.frontier, from.line);\r\n  startWorker(cm, 400);\r\n\r\n  var lendiff = change.text.length - (to.line - from.line) - 1;\r\n  // Remember that these lines changed, for updating the display\r\n  if (change.full)\r\n    { regChange(cm); }\r\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\r\n    { regLineChange(cm, from.line, \"text\"); }\r\n  else\r\n    { regChange(cm, from.line, to.line + 1, lendiff); }\r\n\r\n  var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\r\n  if (changeHandler || changesHandler) {\r\n    var obj = {\r\n      from: from, to: to,\r\n      text: change.text,\r\n      removed: change.removed,\r\n      origin: change.origin\r\n    };\r\n    if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\r\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\r\n  }\r\n  cm.display.selForContextMenu = null;\r\n}\r\n\r\nfunction replaceRange(doc, code, from, to, origin) {\r\n  if (!to) { to = from; }\r\n  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\r\n  if (typeof code == \"string\") { code = doc.splitLines(code); }\r\n  makeChange(doc, {from: from, to: to, text: code, origin: origin});\r\n}\r\n\r\n// Rebasing/resetting history to deal with externally-sourced changes\r\n\r\nfunction rebaseHistSelSingle(pos, from, to, diff) {\r\n  if (to < pos.line) {\r\n    pos.line += diff;\r\n  } else if (from < pos.line) {\r\n    pos.line = from;\r\n    pos.ch = 0;\r\n  }\r\n}\r\n\r\n// Tries to rebase an array of history events given a change in the\r\n// document. If the change touches the same lines as the event, the\r\n// event, and everything 'behind' it, is discarded. If the change is\r\n// before the event, the event's positions are updated. Uses a\r\n// copy-on-write scheme for the positions, to avoid having to\r\n// reallocate them all on every rebase, but also avoid problems with\r\n// shared position objects being unsafely updated.\r\nfunction rebaseHistArray(array, from, to, diff) {\r\n  for (var i = 0; i < array.length; ++i) {\r\n    var sub = array[i], ok = true;\r\n    if (sub.ranges) {\r\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\r\n      for (var j = 0; j < sub.ranges.length; j++) {\r\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\r\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\r\n      }\r\n      continue\r\n    }\r\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\r\n      var cur = sub.changes[j$1];\r\n      if (to < cur.from.line) {\r\n        cur.from = Pos(cur.from.line + diff, cur.from.ch);\r\n        cur.to = Pos(cur.to.line + diff, cur.to.ch);\r\n      } else if (from <= cur.to.line) {\r\n        ok = false;\r\n        break\r\n      }\r\n    }\r\n    if (!ok) {\r\n      array.splice(0, i + 1);\r\n      i = 0;\r\n    }\r\n  }\r\n}\r\n\r\nfunction rebaseHist(hist, change) {\r\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\r\n  rebaseHistArray(hist.done, from, to, diff);\r\n  rebaseHistArray(hist.undone, from, to, diff);\r\n}\r\n\r\n// Utility for applying a change to a line by handle or number,\r\n// returning the number and optionally registering the line as\r\n// changed.\r\nfunction changeLine(doc, handle, changeType, op) {\r\n  var no = handle, line = handle;\r\n  if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\r\n  else { no = lineNo(handle); }\r\n  if (no == null) { return null }\r\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\r\n  return line\r\n}\r\n\r\n// The document is represented as a BTree consisting of leaves, with\r\n// chunk of lines in them, and branches, with up to ten leaves or\r\n// other branch nodes below them. The top node is always a branch\r\n// node, and is the document object itself (meaning it has\r\n// additional methods and properties).\r\n//\r\n// All nodes have parent links. The tree is used both to go from\r\n// line numbers to line objects, and to go from objects to numbers.\r\n// It also indexes by height, and is used to convert between height\r\n// and line object, and to find the total height of the document.\r\n//\r\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\r\n\r\nvar LeafChunk = function(lines) {\r\n  var this$1 = this;\r\n\r\n  this.lines = lines;\r\n  this.parent = null;\r\n  var height = 0;\r\n  for (var i = 0; i < lines.length; ++i) {\r\n    lines[i].parent = this$1;\r\n    height += lines[i].height;\r\n  }\r\n  this.height = height;\r\n};\r\n\r\nLeafChunk.prototype.chunkSize = function () { return this.lines.length };\r\n\r\n// Remove the n lines at offset 'at'.\r\nLeafChunk.prototype.removeInner = function (at, n) {\r\n    var this$1 = this;\r\n\r\n  for (var i = at, e = at + n; i < e; ++i) {\r\n    var line = this$1.lines[i];\r\n    this$1.height -= line.height;\r\n    cleanUpLine(line);\r\n    signalLater(line, \"delete\");\r\n  }\r\n  this.lines.splice(at, n);\r\n};\r\n\r\n// Helper used to collapse a small branch into a single leaf.\r\nLeafChunk.prototype.collapse = function (lines) {\r\n  lines.push.apply(lines, this.lines);\r\n};\r\n\r\n// Insert the given array of lines at offset 'at', count them as\r\n// having the given height.\r\nLeafChunk.prototype.insertInner = function (at, lines, height) {\r\n    var this$1 = this;\r\n\r\n  this.height += height;\r\n  this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\r\n  for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\r\n};\r\n\r\n// Used to iterate over a part of the tree.\r\nLeafChunk.prototype.iterN = function (at, n, op) {\r\n    var this$1 = this;\r\n\r\n  for (var e = at + n; at < e; ++at)\r\n    { if (op(this$1.lines[at])) { return true } }\r\n};\r\n\r\nvar BranchChunk = function(children) {\r\n  var this$1 = this;\r\n\r\n  this.children = children;\r\n  var size = 0, height = 0;\r\n  for (var i = 0; i < children.length; ++i) {\r\n    var ch = children[i];\r\n    size += ch.chunkSize(); height += ch.height;\r\n    ch.parent = this$1;\r\n  }\r\n  this.size = size;\r\n  this.height = height;\r\n  this.parent = null;\r\n};\r\n\r\nBranchChunk.prototype.chunkSize = function () { return this.size };\r\n\r\nBranchChunk.prototype.removeInner = function (at, n) {\r\n    var this$1 = this;\r\n\r\n  this.size -= n;\r\n  for (var i = 0; i < this.children.length; ++i) {\r\n    var child = this$1.children[i], sz = child.chunkSize();\r\n    if (at < sz) {\r\n      var rm = Math.min(n, sz - at), oldHeight = child.height;\r\n      child.removeInner(at, rm);\r\n      this$1.height -= oldHeight - child.height;\r\n      if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\r\n      if ((n -= rm) == 0) { break }\r\n      at = 0;\r\n    } else { at -= sz; }\r\n  }\r\n  // If the result is smaller than 25 lines, ensure that it is a\r\n  // single leaf node.\r\n  if (this.size - n < 25 &&\r\n      (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\r\n    var lines = [];\r\n    this.collapse(lines);\r\n    this.children = [new LeafChunk(lines)];\r\n    this.children[0].parent = this;\r\n  }\r\n};\r\n\r\nBranchChunk.prototype.collapse = function (lines) {\r\n    var this$1 = this;\r\n\r\n  for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\r\n};\r\n\r\nBranchChunk.prototype.insertInner = function (at, lines, height) {\r\n    var this$1 = this;\r\n\r\n  this.size += lines.length;\r\n  this.height += height;\r\n  for (var i = 0; i < this.children.length; ++i) {\r\n    var child = this$1.children[i], sz = child.chunkSize();\r\n    if (at <= sz) {\r\n      child.insertInner(at, lines, height);\r\n      if (child.lines && child.lines.length > 50) {\r\n        // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\r\n        // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\r\n        var remaining = child.lines.length % 25 + 25;\r\n        for (var pos = remaining; pos < child.lines.length;) {\r\n          var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\r\n          child.height -= leaf.height;\r\n          this$1.children.splice(++i, 0, leaf);\r\n          leaf.parent = this$1;\r\n        }\r\n        child.lines = child.lines.slice(0, remaining);\r\n        this$1.maybeSpill();\r\n      }\r\n      break\r\n    }\r\n    at -= sz;\r\n  }\r\n};\r\n\r\n// When a node has grown, check whether it should be split.\r\nBranchChunk.prototype.maybeSpill = function () {\r\n  if (this.children.length <= 10) { return }\r\n  var me = this;\r\n  do {\r\n    var spilled = me.children.splice(me.children.length - 5, 5);\r\n    var sibling = new BranchChunk(spilled);\r\n    if (!me.parent) { // Become the parent node\r\n      var copy = new BranchChunk(me.children);\r\n      copy.parent = me;\r\n      me.children = [copy, sibling];\r\n      me = copy;\r\n   } else {\r\n      me.size -= sibling.size;\r\n      me.height -= sibling.height;\r\n      var myIndex = indexOf(me.parent.children, me);\r\n      me.parent.children.splice(myIndex + 1, 0, sibling);\r\n    }\r\n    sibling.parent = me.parent;\r\n  } while (me.children.length > 10)\r\n  me.parent.maybeSpill();\r\n};\r\n\r\nBranchChunk.prototype.iterN = function (at, n, op) {\r\n    var this$1 = this;\r\n\r\n  for (var i = 0; i < this.children.length; ++i) {\r\n    var child = this$1.children[i], sz = child.chunkSize();\r\n    if (at < sz) {\r\n      var used = Math.min(n, sz - at);\r\n      if (child.iterN(at, used, op)) { return true }\r\n      if ((n -= used) == 0) { break }\r\n      at = 0;\r\n    } else { at -= sz; }\r\n  }\r\n};\r\n\r\n// Line widgets are block elements displayed above or below a line.\r\n\r\nvar LineWidget = function(doc, node, options) {\r\n  var this$1 = this;\r\n\r\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\r\n    { this$1[opt] = options[opt]; } } }\r\n  this.doc = doc;\r\n  this.node = node;\r\n};\r\n\r\nLineWidget.prototype.clear = function () {\r\n    var this$1 = this;\r\n\r\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\r\n  if (no == null || !ws) { return }\r\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\r\n  if (!ws.length) { line.widgets = null; }\r\n  var height = widgetHeight(this);\r\n  updateLineHeight(line, Math.max(0, line.height - height));\r\n  if (cm) {\r\n    runInOp(cm, function () {\r\n      adjustScrollWhenAboveVisible(cm, line, -height);\r\n      regLineChange(cm, no, \"widget\");\r\n    });\r\n    signalLater(cm, \"lineWidgetCleared\", cm, this, no);\r\n  }\r\n};\r\n\r\nLineWidget.prototype.changed = function () {\r\n    var this$1 = this;\r\n\r\n  var oldH = this.height, cm = this.doc.cm, line = this.line;\r\n  this.height = null;\r\n  var diff = widgetHeight(this) - oldH;\r\n  if (!diff) { return }\r\n  updateLineHeight(line, line.height + diff);\r\n  if (cm) {\r\n    runInOp(cm, function () {\r\n      cm.curOp.forceUpdate = true;\r\n      adjustScrollWhenAboveVisible(cm, line, diff);\r\n      signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\r\n    });\r\n  }\r\n};\r\neventMixin(LineWidget);\r\n\r\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\r\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\r\n    { addToScrollTop(cm, diff); }\r\n}\r\n\r\nfunction addLineWidget(doc, handle, node, options) {\r\n  var widget = new LineWidget(doc, node, options);\r\n  var cm = doc.cm;\r\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\r\n  changeLine(doc, handle, \"widget\", function (line) {\r\n    var widgets = line.widgets || (line.widgets = []);\r\n    if (widget.insertAt == null) { widgets.push(widget); }\r\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\r\n    widget.line = line;\r\n    if (cm && !lineIsHidden(doc, line)) {\r\n      var aboveVisible = heightAtLine(line) < doc.scrollTop;\r\n      updateLineHeight(line, line.height + widgetHeight(widget));\r\n      if (aboveVisible) { addToScrollTop(cm, widget.height); }\r\n      cm.curOp.forceUpdate = true;\r\n    }\r\n    return true\r\n  });\r\n  signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\r\n  return widget\r\n}\r\n\r\n// TEXTMARKERS\r\n\r\n// Created with markText and setBookmark methods. A TextMarker is a\r\n// handle that can be used to clear or find a marked position in the\r\n// document. Line objects hold arrays (markedSpans) containing\r\n// {from, to, marker} object pointing to such marker objects, and\r\n// indicating that such a marker is present on that line. Multiple\r\n// lines may point to the same marker when it spans across lines.\r\n// The spans will have null for their from/to properties when the\r\n// marker continues beyond the start/end of the line. Markers have\r\n// links back to the lines they currently touch.\r\n\r\n// Collapsed markers have unique ids, in order to be able to order\r\n// them, which is needed for uniquely determining an outer marker\r\n// when they overlap (they may nest, but not partially overlap).\r\nvar nextMarkerId = 0;\r\n\r\nvar TextMarker = function(doc, type) {\r\n  this.lines = [];\r\n  this.type = type;\r\n  this.doc = doc;\r\n  this.id = ++nextMarkerId;\r\n};\r\n\r\n// Clear the marker.\r\nTextMarker.prototype.clear = function () {\r\n    var this$1 = this;\r\n\r\n  if (this.explicitlyCleared) { return }\r\n  var cm = this.doc.cm, withOp = cm && !cm.curOp;\r\n  if (withOp) { startOperation(cm); }\r\n  if (hasHandler(this, \"clear\")) {\r\n    var found = this.find();\r\n    if (found) { signalLater(this, \"clear\", found.from, found.to); }\r\n  }\r\n  var min = null, max = null;\r\n  for (var i = 0; i < this.lines.length; ++i) {\r\n    var line = this$1.lines[i];\r\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\r\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\r\n    else if (cm) {\r\n      if (span.to != null) { max = lineNo(line); }\r\n      if (span.from != null) { min = lineNo(line); }\r\n    }\r\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span);\r\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\r\n      { updateLineHeight(line, textHeight(cm.display)); }\r\n  }\r\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\r\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\r\n    if (len > cm.display.maxLineLength) {\r\n      cm.display.maxLine = visual;\r\n      cm.display.maxLineLength = len;\r\n      cm.display.maxLineChanged = true;\r\n    }\r\n  } }\r\n\r\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\r\n  this.lines.length = 0;\r\n  this.explicitlyCleared = true;\r\n  if (this.atomic && this.doc.cantEdit) {\r\n    this.doc.cantEdit = false;\r\n    if (cm) { reCheckSelection(cm.doc); }\r\n  }\r\n  if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\r\n  if (withOp) { endOperation(cm); }\r\n  if (this.parent) { this.parent.clear(); }\r\n};\r\n\r\n// Find the position of the marker in the document. Returns a {from,\r\n// to} object by default. Side can be passed to get a specific side\r\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\r\n// Pos objects returned contain a line object, rather than a line\r\n// number (used to prevent looking up the same line twice).\r\nTextMarker.prototype.find = function (side, lineObj) {\r\n    var this$1 = this;\r\n\r\n  if (side == null && this.type == \"bookmark\") { side = 1; }\r\n  var from, to;\r\n  for (var i = 0; i < this.lines.length; ++i) {\r\n    var line = this$1.lines[i];\r\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\r\n    if (span.from != null) {\r\n      from = Pos(lineObj ? line : lineNo(line), span.from);\r\n      if (side == -1) { return from }\r\n    }\r\n    if (span.to != null) {\r\n      to = Pos(lineObj ? line : lineNo(line), span.to);\r\n      if (side == 1) { return to }\r\n    }\r\n  }\r\n  return from && {from: from, to: to}\r\n};\r\n\r\n// Signals that the marker's widget changed, and surrounding layout\r\n// should be recomputed.\r\nTextMarker.prototype.changed = function () {\r\n    var this$1 = this;\r\n\r\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\r\n  if (!pos || !cm) { return }\r\n  runInOp(cm, function () {\r\n    var line = pos.line, lineN = lineNo(pos.line);\r\n    var view = findViewForLine(cm, lineN);\r\n    if (view) {\r\n      clearLineMeasurementCacheFor(view);\r\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\r\n    }\r\n    cm.curOp.updateMaxLine = true;\r\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\r\n      var oldHeight = widget.height;\r\n      widget.height = null;\r\n      var dHeight = widgetHeight(widget) - oldHeight;\r\n      if (dHeight)\r\n        { updateLineHeight(line, line.height + dHeight); }\r\n    }\r\n    signalLater(cm, \"markerChanged\", cm, this$1);\r\n  });\r\n};\r\n\r\nTextMarker.prototype.attachLine = function (line) {\r\n  if (!this.lines.length && this.doc.cm) {\r\n    var op = this.doc.cm.curOp;\r\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\r\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\r\n  }\r\n  this.lines.push(line);\r\n};\r\n\r\nTextMarker.prototype.detachLine = function (line) {\r\n  this.lines.splice(indexOf(this.lines, line), 1);\r\n  if (!this.lines.length && this.doc.cm) {\r\n    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\r\n  }\r\n};\r\neventMixin(TextMarker);\r\n\r\n// Create a marker, wire it up to the right lines, and\r\nfunction markText(doc, from, to, options, type) {\r\n  // Shared markers (across linked documents) are handled separately\r\n  // (markTextShared will call out to this again, once per\r\n  // document).\r\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\r\n  // Ensure we are in an operation.\r\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\r\n\r\n  var marker = new TextMarker(doc, type), diff = cmp(from, to);\r\n  if (options) { copyObj(options, marker, false); }\r\n  // Don't connect empty markers unless clearWhenEmpty is false\r\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\r\n    { return marker }\r\n  if (marker.replacedWith) {\r\n    // Showing up as a widget implies collapsed (widget replaces text)\r\n    marker.collapsed = true;\r\n    marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\r\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\r\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\r\n  }\r\n  if (marker.collapsed) {\r\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\r\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\r\n      { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\r\n    seeCollapsedSpans();\r\n  }\r\n\r\n  if (marker.addToHistory)\r\n    { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\r\n\r\n  var curLine = from.line, cm = doc.cm, updateMaxLine;\r\n  doc.iter(curLine, to.line + 1, function (line) {\r\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\r\n      { updateMaxLine = true; }\r\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\r\n    addMarkedSpan(line, new MarkedSpan(marker,\r\n                                       curLine == from.line ? from.ch : null,\r\n                                       curLine == to.line ? to.ch : null));\r\n    ++curLine;\r\n  });\r\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\r\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\r\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\r\n  }); }\r\n\r\n  if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\r\n\r\n  if (marker.readOnly) {\r\n    seeReadOnlySpans();\r\n    if (doc.history.done.length || doc.history.undone.length)\r\n      { doc.clearHistory(); }\r\n  }\r\n  if (marker.collapsed) {\r\n    marker.id = ++nextMarkerId;\r\n    marker.atomic = true;\r\n  }\r\n  if (cm) {\r\n    // Sync editor state\r\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\r\n    if (marker.collapsed)\r\n      { regChange(cm, from.line, to.line + 1); }\r\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\r\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\r\n    if (marker.atomic) { reCheckSelection(cm.doc); }\r\n    signalLater(cm, \"markerAdded\", cm, marker);\r\n  }\r\n  return marker\r\n}\r\n\r\n// SHARED TEXTMARKERS\r\n\r\n// A shared marker spans multiple linked documents. It is\r\n// implemented as a meta-marker-object controlling multiple normal\r\n// markers.\r\nvar SharedTextMarker = function(markers, primary) {\r\n  var this$1 = this;\r\n\r\n  this.markers = markers;\r\n  this.primary = primary;\r\n  for (var i = 0; i < markers.length; ++i)\r\n    { markers[i].parent = this$1; }\r\n};\r\n\r\nSharedTextMarker.prototype.clear = function () {\r\n    var this$1 = this;\r\n\r\n  if (this.explicitlyCleared) { return }\r\n  this.explicitlyCleared = true;\r\n  for (var i = 0; i < this.markers.length; ++i)\r\n    { this$1.markers[i].clear(); }\r\n  signalLater(this, \"clear\");\r\n};\r\n\r\nSharedTextMarker.prototype.find = function (side, lineObj) {\r\n  return this.primary.find(side, lineObj)\r\n};\r\neventMixin(SharedTextMarker);\r\n\r\nfunction markTextShared(doc, from, to, options, type) {\r\n  options = copyObj(options);\r\n  options.shared = false;\r\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0];\r\n  var widget = options.widgetNode;\r\n  linkedDocs(doc, function (doc) {\r\n    if (widget) { options.widgetNode = widget.cloneNode(true); }\r\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\r\n    for (var i = 0; i < doc.linked.length; ++i)\r\n      { if (doc.linked[i].isParent) { return } }\r\n    primary = lst(markers);\r\n  });\r\n  return new SharedTextMarker(markers, primary)\r\n}\r\n\r\nfunction findSharedMarkers(doc) {\r\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\r\n}\r\n\r\nfunction copySharedMarkers(doc, markers) {\r\n  for (var i = 0; i < markers.length; i++) {\r\n    var marker = markers[i], pos = marker.find();\r\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\r\n    if (cmp(mFrom, mTo)) {\r\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\r\n      marker.markers.push(subMark);\r\n      subMark.parent = marker;\r\n    }\r\n  }\r\n}\r\n\r\nfunction detachSharedMarkers(markers) {\r\n  var loop = function ( i ) {\r\n    var marker = markers[i], linked = [marker.primary.doc];\r\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\r\n    for (var j = 0; j < marker.markers.length; j++) {\r\n      var subMarker = marker.markers[j];\r\n      if (indexOf(linked, subMarker.doc) == -1) {\r\n        subMarker.parent = null;\r\n        marker.markers.splice(j--, 1);\r\n      }\r\n    }\r\n  };\r\n\r\n  for (var i = 0; i < markers.length; i++) loop( i );\r\n}\r\n\r\nvar nextDocId = 0;\r\nvar Doc = function(text, mode, firstLine, lineSep, direction) {\r\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\r\n  if (firstLine == null) { firstLine = 0; }\r\n\r\n  BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\r\n  this.first = firstLine;\r\n  this.scrollTop = this.scrollLeft = 0;\r\n  this.cantEdit = false;\r\n  this.cleanGeneration = 1;\r\n  this.frontier = firstLine;\r\n  var start = Pos(firstLine, 0);\r\n  this.sel = simpleSelection(start);\r\n  this.history = new History(null);\r\n  this.id = ++nextDocId;\r\n  this.modeOption = mode;\r\n  this.lineSep = lineSep;\r\n  this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\r\n  this.extend = false;\r\n\r\n  if (typeof text == \"string\") { text = this.splitLines(text); }\r\n  updateDoc(this, {from: start, to: start, text: text});\r\n  setSelection(this, simpleSelection(start), sel_dontScroll);\r\n};\r\n\r\nDoc.prototype = createObj(BranchChunk.prototype, {\r\n  constructor: Doc,\r\n  // Iterate over the document. Supports two forms -- with only one\r\n  // argument, it calls that for each line in the document. With\r\n  // three, it iterates over the range given by the first two (with\r\n  // the second being non-inclusive).\r\n  iter: function(from, to, op) {\r\n    if (op) { this.iterN(from - this.first, to - from, op); }\r\n    else { this.iterN(this.first, this.first + this.size, from); }\r\n  },\r\n\r\n  // Non-public interface for adding and removing lines.\r\n  insert: function(at, lines) {\r\n    var height = 0;\r\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\r\n    this.insertInner(at - this.first, lines, height);\r\n  },\r\n  remove: function(at, n) { this.removeInner(at - this.first, n); },\r\n\r\n  // From here, the methods are part of the public interface. Most\r\n  // are also available from CodeMirror (editor) instances.\r\n\r\n  getValue: function(lineSep) {\r\n    var lines = getLines(this, this.first, this.first + this.size);\r\n    if (lineSep === false) { return lines }\r\n    return lines.join(lineSep || this.lineSeparator())\r\n  },\r\n  setValue: docMethodOp(function(code) {\r\n    var top = Pos(this.first, 0), last = this.first + this.size - 1;\r\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\r\n                      text: this.splitLines(code), origin: \"setValue\", full: true}, true);\r\n    if (this.cm) { scrollToCoords(this.cm, 0, 0); }\r\n    setSelection(this, simpleSelection(top), sel_dontScroll);\r\n  }),\r\n  replaceRange: function(code, from, to, origin) {\r\n    from = clipPos(this, from);\r\n    to = to ? clipPos(this, to) : from;\r\n    replaceRange(this, code, from, to, origin);\r\n  },\r\n  getRange: function(from, to, lineSep) {\r\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\r\n    if (lineSep === false) { return lines }\r\n    return lines.join(lineSep || this.lineSeparator())\r\n  },\r\n\r\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\r\n\r\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\r\n  getLineNumber: function(line) {return lineNo(line)},\r\n\r\n  getLineHandleVisualStart: function(line) {\r\n    if (typeof line == \"number\") { line = getLine(this, line); }\r\n    return visualLine(line)\r\n  },\r\n\r\n  lineCount: function() {return this.size},\r\n  firstLine: function() {return this.first},\r\n  lastLine: function() {return this.first + this.size - 1},\r\n\r\n  clipPos: function(pos) {return clipPos(this, pos)},\r\n\r\n  getCursor: function(start) {\r\n    var range$$1 = this.sel.primary(), pos;\r\n    if (start == null || start == \"head\") { pos = range$$1.head; }\r\n    else if (start == \"anchor\") { pos = range$$1.anchor; }\r\n    else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\r\n    else { pos = range$$1.from(); }\r\n    return pos\r\n  },\r\n  listSelections: function() { return this.sel.ranges },\r\n  somethingSelected: function() {return this.sel.somethingSelected()},\r\n\r\n  setCursor: docMethodOp(function(line, ch, options) {\r\n    setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\r\n  }),\r\n  setSelection: docMethodOp(function(anchor, head, options) {\r\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\r\n  }),\r\n  extendSelection: docMethodOp(function(head, other, options) {\r\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\r\n  }),\r\n  extendSelections: docMethodOp(function(heads, options) {\r\n    extendSelections(this, clipPosArray(this, heads), options);\r\n  }),\r\n  extendSelectionsBy: docMethodOp(function(f, options) {\r\n    var heads = map(this.sel.ranges, f);\r\n    extendSelections(this, clipPosArray(this, heads), options);\r\n  }),\r\n  setSelections: docMethodOp(function(ranges, primary, options) {\r\n    var this$1 = this;\r\n\r\n    if (!ranges.length) { return }\r\n    var out = [];\r\n    for (var i = 0; i < ranges.length; i++)\r\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\r\n                         clipPos(this$1, ranges[i].head)); }\r\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\r\n    setSelection(this, normalizeSelection(out, primary), options);\r\n  }),\r\n  addSelection: docMethodOp(function(anchor, head, options) {\r\n    var ranges = this.sel.ranges.slice(0);\r\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\r\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\r\n  }),\r\n\r\n  getSelection: function(lineSep) {\r\n    var this$1 = this;\r\n\r\n    var ranges = this.sel.ranges, lines;\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\r\n      lines = lines ? lines.concat(sel) : sel;\r\n    }\r\n    if (lineSep === false) { return lines }\r\n    else { return lines.join(lineSep || this.lineSeparator()) }\r\n  },\r\n  getSelections: function(lineSep) {\r\n    var this$1 = this;\r\n\r\n    var parts = [], ranges = this.sel.ranges;\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\r\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\r\n      parts[i] = sel;\r\n    }\r\n    return parts\r\n  },\r\n  replaceSelection: function(code, collapse, origin) {\r\n    var dup = [];\r\n    for (var i = 0; i < this.sel.ranges.length; i++)\r\n      { dup[i] = code; }\r\n    this.replaceSelections(dup, collapse, origin || \"+input\");\r\n  },\r\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\r\n    var this$1 = this;\r\n\r\n    var changes = [], sel = this.sel;\r\n    for (var i = 0; i < sel.ranges.length; i++) {\r\n      var range$$1 = sel.ranges[i];\r\n      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\r\n    }\r\n    var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\r\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\r\n      { makeChange(this$1, changes[i$1]); }\r\n    if (newSel) { setSelectionReplaceHistory(this, newSel); }\r\n    else if (this.cm) { ensureCursorVisible(this.cm); }\r\n  }),\r\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\r\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\r\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\r\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\r\n\r\n  setExtending: function(val) {this.extend = val;},\r\n  getExtending: function() {return this.extend},\r\n\r\n  historySize: function() {\r\n    var hist = this.history, done = 0, undone = 0;\r\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\r\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\r\n    return {undo: done, redo: undone}\r\n  },\r\n  clearHistory: function() {this.history = new History(this.history.maxGeneration);},\r\n\r\n  markClean: function() {\r\n    this.cleanGeneration = this.changeGeneration(true);\r\n  },\r\n  changeGeneration: function(forceSplit) {\r\n    if (forceSplit)\r\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\r\n    return this.history.generation\r\n  },\r\n  isClean: function (gen) {\r\n    return this.history.generation == (gen || this.cleanGeneration)\r\n  },\r\n\r\n  getHistory: function() {\r\n    return {done: copyHistoryArray(this.history.done),\r\n            undone: copyHistoryArray(this.history.undone)}\r\n  },\r\n  setHistory: function(histData) {\r\n    var hist = this.history = new History(this.history.maxGeneration);\r\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true);\r\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\r\n  },\r\n\r\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\r\n    return changeLine(this, line, \"gutter\", function (line) {\r\n      var markers = line.gutterMarkers || (line.gutterMarkers = {});\r\n      markers[gutterID] = value;\r\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\r\n      return true\r\n    })\r\n  }),\r\n\r\n  clearGutter: docMethodOp(function(gutterID) {\r\n    var this$1 = this;\r\n\r\n    this.iter(function (line) {\r\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\r\n        changeLine(this$1, line, \"gutter\", function () {\r\n          line.gutterMarkers[gutterID] = null;\r\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\r\n          return true\r\n        });\r\n      }\r\n    });\r\n  }),\r\n\r\n  lineInfo: function(line) {\r\n    var n;\r\n    if (typeof line == \"number\") {\r\n      if (!isLine(this, line)) { return null }\r\n      n = line;\r\n      line = getLine(this, line);\r\n      if (!line) { return null }\r\n    } else {\r\n      n = lineNo(line);\r\n      if (n == null) { return null }\r\n    }\r\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\r\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\r\n            widgets: line.widgets}\r\n  },\r\n\r\n  addLineClass: docMethodOp(function(handle, where, cls) {\r\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\r\n      var prop = where == \"text\" ? \"textClass\"\r\n               : where == \"background\" ? \"bgClass\"\r\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\r\n      if (!line[prop]) { line[prop] = cls; }\r\n      else if (classTest(cls).test(line[prop])) { return false }\r\n      else { line[prop] += \" \" + cls; }\r\n      return true\r\n    })\r\n  }),\r\n  removeLineClass: docMethodOp(function(handle, where, cls) {\r\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\r\n      var prop = where == \"text\" ? \"textClass\"\r\n               : where == \"background\" ? \"bgClass\"\r\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\r\n      var cur = line[prop];\r\n      if (!cur) { return false }\r\n      else if (cls == null) { line[prop] = null; }\r\n      else {\r\n        var found = cur.match(classTest(cls));\r\n        if (!found) { return false }\r\n        var end = found.index + found[0].length;\r\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\r\n      }\r\n      return true\r\n    })\r\n  }),\r\n\r\n  addLineWidget: docMethodOp(function(handle, node, options) {\r\n    return addLineWidget(this, handle, node, options)\r\n  }),\r\n  removeLineWidget: function(widget) { widget.clear(); },\r\n\r\n  markText: function(from, to, options) {\r\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\r\n  },\r\n  setBookmark: function(pos, options) {\r\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\r\n                    insertLeft: options && options.insertLeft,\r\n                    clearWhenEmpty: false, shared: options && options.shared,\r\n                    handleMouseEvents: options && options.handleMouseEvents};\r\n    pos = clipPos(this, pos);\r\n    return markText(this, pos, pos, realOpts, \"bookmark\")\r\n  },\r\n  findMarksAt: function(pos) {\r\n    pos = clipPos(this, pos);\r\n    var markers = [], spans = getLine(this, pos.line).markedSpans;\r\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\r\n      var span = spans[i];\r\n      if ((span.from == null || span.from <= pos.ch) &&\r\n          (span.to == null || span.to >= pos.ch))\r\n        { markers.push(span.marker.parent || span.marker); }\r\n    } }\r\n    return markers\r\n  },\r\n  findMarks: function(from, to, filter) {\r\n    from = clipPos(this, from); to = clipPos(this, to);\r\n    var found = [], lineNo$$1 = from.line;\r\n    this.iter(from.line, to.line + 1, function (line) {\r\n      var spans = line.markedSpans;\r\n      if (spans) { for (var i = 0; i < spans.length; i++) {\r\n        var span = spans[i];\r\n        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\r\n              span.from == null && lineNo$$1 != from.line ||\r\n              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\r\n            (!filter || filter(span.marker)))\r\n          { found.push(span.marker.parent || span.marker); }\r\n      } }\r\n      ++lineNo$$1;\r\n    });\r\n    return found\r\n  },\r\n  getAllMarks: function() {\r\n    var markers = [];\r\n    this.iter(function (line) {\r\n      var sps = line.markedSpans;\r\n      if (sps) { for (var i = 0; i < sps.length; ++i)\r\n        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\r\n    });\r\n    return markers\r\n  },\r\n\r\n  posFromIndex: function(off) {\r\n    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\r\n    this.iter(function (line) {\r\n      var sz = line.text.length + sepSize;\r\n      if (sz > off) { ch = off; return true }\r\n      off -= sz;\r\n      ++lineNo$$1;\r\n    });\r\n    return clipPos(this, Pos(lineNo$$1, ch))\r\n  },\r\n  indexFromPos: function (coords) {\r\n    coords = clipPos(this, coords);\r\n    var index = coords.ch;\r\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\r\n    var sepSize = this.lineSeparator().length;\r\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\r\n      index += line.text.length + sepSize;\r\n    });\r\n    return index\r\n  },\r\n\r\n  copy: function(copyHistory) {\r\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\r\n                      this.modeOption, this.first, this.lineSep, this.direction);\r\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\r\n    doc.sel = this.sel;\r\n    doc.extend = false;\r\n    if (copyHistory) {\r\n      doc.history.undoDepth = this.history.undoDepth;\r\n      doc.setHistory(this.getHistory());\r\n    }\r\n    return doc\r\n  },\r\n\r\n  linkedDoc: function(options) {\r\n    if (!options) { options = {}; }\r\n    var from = this.first, to = this.first + this.size;\r\n    if (options.from != null && options.from > from) { from = options.from; }\r\n    if (options.to != null && options.to < to) { to = options.to; }\r\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\r\n    if (options.sharedHist) { copy.history = this.history\r\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\r\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\r\n    copySharedMarkers(copy, findSharedMarkers(this));\r\n    return copy\r\n  },\r\n  unlinkDoc: function(other) {\r\n    var this$1 = this;\r\n\r\n    if (other instanceof CodeMirror$1) { other = other.doc; }\r\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\r\n      var link = this$1.linked[i];\r\n      if (link.doc != other) { continue }\r\n      this$1.linked.splice(i, 1);\r\n      other.unlinkDoc(this$1);\r\n      detachSharedMarkers(findSharedMarkers(this$1));\r\n      break\r\n    } }\r\n    // If the histories were shared, split them again\r\n    if (other.history == this.history) {\r\n      var splitIds = [other.id];\r\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\r\n      other.history = new History(null);\r\n      other.history.done = copyHistoryArray(this.history.done, splitIds);\r\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds);\r\n    }\r\n  },\r\n  iterLinkedDocs: function(f) {linkedDocs(this, f);},\r\n\r\n  getMode: function() {return this.mode},\r\n  getEditor: function() {return this.cm},\r\n\r\n  splitLines: function(str) {\r\n    if (this.lineSep) { return str.split(this.lineSep) }\r\n    return splitLinesAuto(str)\r\n  },\r\n  lineSeparator: function() { return this.lineSep || \"\\n\" },\r\n\r\n  setDirection: docMethodOp(function (dir) {\r\n    if (dir != \"rtl\") { dir = \"ltr\"; }\r\n    if (dir == this.direction) { return }\r\n    this.direction = dir;\r\n    this.iter(function (line) { return line.order = null; });\r\n    if (this.cm) { directionChanged(this.cm); }\r\n  })\r\n});\r\n\r\n// Public alias.\r\nDoc.prototype.eachLine = Doc.prototype.iter;\r\n\r\n// Kludge to work around strange IE behavior where it'll sometimes\r\n// re-fire a series of drag-related events right after the drop (#1551)\r\nvar lastDrop = 0;\r\n\r\nfunction onDrop(e) {\r\n  var cm = this;\r\n  clearDragCursor(cm);\r\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\r\n    { return }\r\n  e_preventDefault(e);\r\n  if (ie) { lastDrop = +new Date; }\r\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\r\n  if (!pos || cm.isReadOnly()) { return }\r\n  // Might be a file drop, in which case we simply extract the text\r\n  // and insert it.\r\n  if (files && files.length && window.FileReader && window.File) {\r\n    var n = files.length, text = Array(n), read = 0;\r\n    var loadFile = function (file, i) {\r\n      if (cm.options.allowDropFileTypes &&\r\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\r\n        { return }\r\n\r\n      var reader = new FileReader;\r\n      reader.onload = operation(cm, function () {\r\n        var content = reader.result;\r\n        if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\r\n        text[i] = content;\r\n        if (++read == n) {\r\n          pos = clipPos(cm.doc, pos);\r\n          var change = {from: pos, to: pos,\r\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\r\n                        origin: \"paste\"};\r\n          makeChange(cm.doc, change);\r\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\r\n        }\r\n      });\r\n      reader.readAsText(file);\r\n    };\r\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\r\n  } else { // Normal drop\r\n    // Don't do a replace if the drop happened inside of the selected text.\r\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\r\n      cm.state.draggingText(e);\r\n      // Ensure the editor is re-focused\r\n      setTimeout(function () { return cm.display.input.focus(); }, 20);\r\n      return\r\n    }\r\n    try {\r\n      var text$1 = e.dataTransfer.getData(\"Text\");\r\n      if (text$1) {\r\n        var selected;\r\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\r\n          { selected = cm.listSelections(); }\r\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\r\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\r\n          { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\r\n        cm.replaceSelection(text$1, \"around\", \"paste\");\r\n        cm.display.input.focus();\r\n      }\r\n    }\r\n    catch(e){}\r\n  }\r\n}\r\n\r\nfunction onDragStart(cm, e) {\r\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\r\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\r\n\r\n  e.dataTransfer.setData(\"Text\", cm.getSelection());\r\n  e.dataTransfer.effectAllowed = \"copyMove\";\r\n\r\n  // Use dummy image instead of default browsers image.\r\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\r\n  if (e.dataTransfer.setDragImage && !safari) {\r\n    var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\r\n    img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\r\n    if (presto) {\r\n      img.width = img.height = 1;\r\n      cm.display.wrapper.appendChild(img);\r\n      // Force a relayout, or Opera won't use our image for some obscure reason\r\n      img._top = img.offsetTop;\r\n    }\r\n    e.dataTransfer.setDragImage(img, 0, 0);\r\n    if (presto) { img.parentNode.removeChild(img); }\r\n  }\r\n}\r\n\r\nfunction onDragOver(cm, e) {\r\n  var pos = posFromMouse(cm, e);\r\n  if (!pos) { return }\r\n  var frag = document.createDocumentFragment();\r\n  drawSelectionCursor(cm, pos, frag);\r\n  if (!cm.display.dragCursor) {\r\n    cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\r\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\r\n  }\r\n  removeChildrenAndAdd(cm.display.dragCursor, frag);\r\n}\r\n\r\nfunction clearDragCursor(cm) {\r\n  if (cm.display.dragCursor) {\r\n    cm.display.lineSpace.removeChild(cm.display.dragCursor);\r\n    cm.display.dragCursor = null;\r\n  }\r\n}\r\n\r\n// These must be handled carefully, because naively registering a\r\n// handler for each editor will cause the editors to never be\r\n// garbage collected.\r\n\r\nfunction forEachCodeMirror(f) {\r\n  if (!document.body.getElementsByClassName) { return }\r\n  var byClass = document.body.getElementsByClassName(\"CodeMirror\");\r\n  for (var i = 0; i < byClass.length; i++) {\r\n    var cm = byClass[i].CodeMirror;\r\n    if (cm) { f(cm); }\r\n  }\r\n}\r\n\r\nvar globalsRegistered = false;\r\nfunction ensureGlobalHandlers() {\r\n  if (globalsRegistered) { return }\r\n  registerGlobalHandlers();\r\n  globalsRegistered = true;\r\n}\r\nfunction registerGlobalHandlers() {\r\n  // When the window resizes, we need to refresh active editors.\r\n  var resizeTimer;\r\n  on(window, \"resize\", function () {\r\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\r\n      resizeTimer = null;\r\n      forEachCodeMirror(onResize);\r\n    }, 100); }\r\n  });\r\n  // When the window loses focus, we want to show the editor as blurred\r\n  on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\r\n}\r\n// Called when the window resizes\r\nfunction onResize(cm) {\r\n  var d = cm.display;\r\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\r\n    { return }\r\n  // Might be a text scaling operation, clear size caches.\r\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\r\n  d.scrollbarsClipped = false;\r\n  cm.setSize();\r\n}\r\n\r\nvar keyNames = {\r\n  3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\r\n  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\r\n  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\r\n  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\r\n  106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\r\n  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\r\n  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\r\n  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\r\n};\r\n\r\n// Number keys\r\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\r\n// Alphabetic keys\r\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\r\n// Function keys\r\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\r\n\r\nvar keyMap = {};\r\n\r\nkeyMap.basic = {\r\n  \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\r\n  \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\r\n  \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\r\n  \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\r\n  \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\r\n  \"Esc\": \"singleSelection\"\r\n};\r\n// Note that the save and find-related commands aren't defined by\r\n// default. User code or addons can define them. Unknown commands\r\n// are simply ignored.\r\nkeyMap.pcDefault = {\r\n  \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\r\n  \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\r\n  \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\r\n  \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\r\n  \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\r\n  \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\r\n  \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\r\n  fallthrough: \"basic\"\r\n};\r\n// Very basic readline/emacs-style bindings, which are standard on Mac.\r\nkeyMap.emacsy = {\r\n  \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\r\n  \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\r\n  \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\r\n  \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\r\n  \"Ctrl-O\": \"openLine\"\r\n};\r\nkeyMap.macDefault = {\r\n  \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\r\n  \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\r\n  \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\r\n  \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\r\n  \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\r\n  \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\r\n  \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\r\n  fallthrough: [\"basic\", \"emacsy\"]\r\n};\r\nkeyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\r\n\r\n// KEYMAP DISPATCH\r\n\r\nfunction normalizeKeyName(name) {\r\n  var parts = name.split(/-(?!$)/);\r\n  name = parts[parts.length - 1];\r\n  var alt, ctrl, shift, cmd;\r\n  for (var i = 0; i < parts.length - 1; i++) {\r\n    var mod = parts[i];\r\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\r\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\r\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\r\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\r\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\r\n  }\r\n  if (alt) { name = \"Alt-\" + name; }\r\n  if (ctrl) { name = \"Ctrl-\" + name; }\r\n  if (cmd) { name = \"Cmd-\" + name; }\r\n  if (shift) { name = \"Shift-\" + name; }\r\n  return name\r\n}\r\n\r\n// This is a kludge to keep keymaps mostly working as raw objects\r\n// (backwards compatibility) while at the same time support features\r\n// like normalization and multi-stroke key bindings. It compiles a\r\n// new normalized keymap, and then updates the old object to reflect\r\n// this.\r\nfunction normalizeKeyMap(keymap) {\r\n  var copy = {};\r\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\r\n    var value = keymap[keyname];\r\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\r\n    if (value == \"...\") { delete keymap[keyname]; continue }\r\n\r\n    var keys = map(keyname.split(\" \"), normalizeKeyName);\r\n    for (var i = 0; i < keys.length; i++) {\r\n      var val = (void 0), name = (void 0);\r\n      if (i == keys.length - 1) {\r\n        name = keys.join(\" \");\r\n        val = value;\r\n      } else {\r\n        name = keys.slice(0, i + 1).join(\" \");\r\n        val = \"...\";\r\n      }\r\n      var prev = copy[name];\r\n      if (!prev) { copy[name] = val; }\r\n      else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\r\n    }\r\n    delete keymap[keyname];\r\n  } }\r\n  for (var prop in copy) { keymap[prop] = copy[prop]; }\r\n  return keymap\r\n}\r\n\r\nfunction lookupKey(key, map$$1, handle, context) {\r\n  map$$1 = getKeyMap(map$$1);\r\n  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\r\n  if (found === false) { return \"nothing\" }\r\n  if (found === \"...\") { return \"multi\" }\r\n  if (found != null && handle(found)) { return \"handled\" }\r\n\r\n  if (map$$1.fallthrough) {\r\n    if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\r\n      { return lookupKey(key, map$$1.fallthrough, handle, context) }\r\n    for (var i = 0; i < map$$1.fallthrough.length; i++) {\r\n      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\r\n      if (result) { return result }\r\n    }\r\n  }\r\n}\r\n\r\n// Modifier key presses don't count as 'real' key presses for the\r\n// purpose of keymap fallthrough.\r\nfunction isModifierKey(value) {\r\n  var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\r\n  return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\r\n}\r\n\r\n// Look up the name of a key as indicated by an event object.\r\nfunction keyName(event, noShift) {\r\n  if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\r\n  var base = keyNames[event.keyCode], name = base;\r\n  if (name == null || event.altGraphKey) { return false }\r\n  if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\r\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\r\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\r\n  if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\r\n  return name\r\n}\r\n\r\nfunction getKeyMap(val) {\r\n  return typeof val == \"string\" ? keyMap[val] : val\r\n}\r\n\r\n// Helper for deleting text near the selection(s), used to implement\r\n// backspace, delete, and similar functionality.\r\nfunction deleteNearSelection(cm, compute) {\r\n  var ranges = cm.doc.sel.ranges, kill = [];\r\n  // Build up a set of ranges to kill first, merging overlapping\r\n  // ranges.\r\n  for (var i = 0; i < ranges.length; i++) {\r\n    var toKill = compute(ranges[i]);\r\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\r\n      var replaced = kill.pop();\r\n      if (cmp(replaced.from, toKill.from) < 0) {\r\n        toKill.from = replaced.from;\r\n        break\r\n      }\r\n    }\r\n    kill.push(toKill);\r\n  }\r\n  // Next, remove those actual ranges.\r\n  runInOp(cm, function () {\r\n    for (var i = kill.length - 1; i >= 0; i--)\r\n      { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\r\n    ensureCursorVisible(cm);\r\n  });\r\n}\r\n\r\n// Commands are parameter-less actions that can be performed on an\r\n// editor, mostly used for keybindings.\r\nvar commands = {\r\n  selectAll: selectAll,\r\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\r\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\r\n    if (range.empty()) {\r\n      var len = getLine(cm.doc, range.head.line).text.length;\r\n      if (range.head.ch == len && range.head.line < cm.lastLine())\r\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\r\n      else\r\n        { return {from: range.head, to: Pos(range.head.line, len)} }\r\n    } else {\r\n      return {from: range.from(), to: range.to()}\r\n    }\r\n  }); },\r\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\r\n    from: Pos(range.from().line, 0),\r\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\r\n  }); }); },\r\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\r\n    from: Pos(range.from().line, 0), to: range.from()\r\n  }); }); },\r\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\r\n    var top = cm.charCoords(range.head, \"div\").top + 5;\r\n    var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\r\n    return {from: leftPos, to: range.from()}\r\n  }); },\r\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\r\n    var top = cm.charCoords(range.head, \"div\").top + 5;\r\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\r\n    return {from: range.from(), to: rightPos }\r\n  }); },\r\n  undo: function (cm) { return cm.undo(); },\r\n  redo: function (cm) { return cm.redo(); },\r\n  undoSelection: function (cm) { return cm.undoSelection(); },\r\n  redoSelection: function (cm) { return cm.redoSelection(); },\r\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\r\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\r\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\r\n    {origin: \"+move\", bias: 1}\r\n  ); },\r\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\r\n    {origin: \"+move\", bias: 1}\r\n  ); },\r\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\r\n    {origin: \"+move\", bias: -1}\r\n  ); },\r\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\r\n    var top = cm.charCoords(range.head, \"div\").top + 5;\r\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\r\n  }, sel_move); },\r\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\r\n    var top = cm.charCoords(range.head, \"div\").top + 5;\r\n    return cm.coordsChar({left: 0, top: top}, \"div\")\r\n  }, sel_move); },\r\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\r\n    var top = cm.charCoords(range.head, \"div\").top + 5;\r\n    var pos = cm.coordsChar({left: 0, top: top}, \"div\");\r\n    if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\r\n    return pos\r\n  }, sel_move); },\r\n  goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\r\n  goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\r\n  goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\r\n  goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\r\n  goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\r\n  goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\r\n  goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\r\n  goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\r\n  goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\r\n  goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\r\n  goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\r\n  goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\r\n  delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\r\n  delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\r\n  delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\r\n  delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\r\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\r\n  delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\r\n  indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\r\n  indentMore: function (cm) { return cm.indentSelection(\"add\"); },\r\n  indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\r\n  insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\r\n  insertSoftTab: function (cm) {\r\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var pos = ranges[i].from();\r\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\r\n      spaces.push(spaceStr(tabSize - col % tabSize));\r\n    }\r\n    cm.replaceSelections(spaces);\r\n  },\r\n  defaultTab: function (cm) {\r\n    if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\r\n    else { cm.execCommand(\"insertTab\"); }\r\n  },\r\n  // Swap the two chars left and right of each selection's head.\r\n  // Move cursor behind the two swapped characters afterwards.\r\n  //\r\n  // Doesn't consider line feeds a character.\r\n  // Doesn't scan more than one line above to find a character.\r\n  // Doesn't do anything on an empty line.\r\n  // Doesn't do anything with non-empty selections.\r\n  transposeChars: function (cm) { return runInOp(cm, function () {\r\n    var ranges = cm.listSelections(), newSel = [];\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      if (!ranges[i].empty()) { continue }\r\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\r\n      if (line) {\r\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\r\n        if (cur.ch > 0) {\r\n          cur = new Pos(cur.line, cur.ch + 1);\r\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\r\n                          Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\r\n        } else if (cur.line > cm.doc.first) {\r\n          var prev = getLine(cm.doc, cur.line - 1).text;\r\n          if (prev) {\r\n            cur = new Pos(cur.line, 1);\r\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\r\n                            prev.charAt(prev.length - 1),\r\n                            Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\r\n          }\r\n        }\r\n      }\r\n      newSel.push(new Range(cur, cur));\r\n    }\r\n    cm.setSelections(newSel);\r\n  }); },\r\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\r\n    var sels = cm.listSelections();\r\n    for (var i = sels.length - 1; i >= 0; i--)\r\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\r\n    sels = cm.listSelections();\r\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\r\n      { cm.indentLine(sels[i$1].from().line, null, true); }\r\n    ensureCursorVisible(cm);\r\n  }); },\r\n  openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\r\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\r\n};\r\n\r\n\r\nfunction lineStart(cm, lineN) {\r\n  var line = getLine(cm.doc, lineN);\r\n  var visual = visualLine(line);\r\n  if (visual != line) { lineN = lineNo(visual); }\r\n  return endOfLine(true, cm, visual, lineN, 1)\r\n}\r\nfunction lineEnd(cm, lineN) {\r\n  var line = getLine(cm.doc, lineN);\r\n  var visual = visualLineEnd(line);\r\n  if (visual != line) { lineN = lineNo(visual); }\r\n  return endOfLine(true, cm, line, lineN, -1)\r\n}\r\nfunction lineStartSmart(cm, pos) {\r\n  var start = lineStart(cm, pos.line);\r\n  var line = getLine(cm.doc, start.line);\r\n  var order = getOrder(line, cm.doc.direction);\r\n  if (!order || order[0].level == 0) {\r\n    var firstNonWS = Math.max(0, line.text.search(/\\S/));\r\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\r\n    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\r\n  }\r\n  return start\r\n}\r\n\r\n// Run a handler that was bound to a key.\r\nfunction doHandleBinding(cm, bound, dropShift) {\r\n  if (typeof bound == \"string\") {\r\n    bound = commands[bound];\r\n    if (!bound) { return false }\r\n  }\r\n  // Ensure previous input has been read, so that the handler sees a\r\n  // consistent view of the document\r\n  cm.display.input.ensurePolled();\r\n  var prevShift = cm.display.shift, done = false;\r\n  try {\r\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\r\n    if (dropShift) { cm.display.shift = false; }\r\n    done = bound(cm) != Pass;\r\n  } finally {\r\n    cm.display.shift = prevShift;\r\n    cm.state.suppressEdits = false;\r\n  }\r\n  return done\r\n}\r\n\r\nfunction lookupKeyForEditor(cm, name, handle) {\r\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\r\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\r\n    if (result) { return result }\r\n  }\r\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\r\n    || lookupKey(name, cm.options.keyMap, handle, cm)\r\n}\r\n\r\nvar stopSeq = new Delayed;\r\nfunction dispatchKey(cm, name, e, handle) {\r\n  var seq = cm.state.keySeq;\r\n  if (seq) {\r\n    if (isModifierKey(name)) { return \"handled\" }\r\n    stopSeq.set(50, function () {\r\n      if (cm.state.keySeq == seq) {\r\n        cm.state.keySeq = null;\r\n        cm.display.input.reset();\r\n      }\r\n    });\r\n    name = seq + \" \" + name;\r\n  }\r\n  var result = lookupKeyForEditor(cm, name, handle);\r\n\r\n  if (result == \"multi\")\r\n    { cm.state.keySeq = name; }\r\n  if (result == \"handled\")\r\n    { signalLater(cm, \"keyHandled\", cm, name, e); }\r\n\r\n  if (result == \"handled\" || result == \"multi\") {\r\n    e_preventDefault(e);\r\n    restartBlink(cm);\r\n  }\r\n\r\n  if (seq && !result && /\\'$/.test(name)) {\r\n    e_preventDefault(e);\r\n    return true\r\n  }\r\n  return !!result\r\n}\r\n\r\n// Handle a key from the keydown event.\r\nfunction handleKeyBinding(cm, e) {\r\n  var name = keyName(e, true);\r\n  if (!name) { return false }\r\n\r\n  if (e.shiftKey && !cm.state.keySeq) {\r\n    // First try to resolve full name (including 'Shift-'). Failing\r\n    // that, see if there is a cursor-motion command (starting with\r\n    // 'go') bound to the keyname without 'Shift-'.\r\n    return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\r\n        || dispatchKey(cm, name, e, function (b) {\r\n             if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\r\n               { return doHandleBinding(cm, b) }\r\n           })\r\n  } else {\r\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\r\n  }\r\n}\r\n\r\n// Handle a key from the keypress event\r\nfunction handleCharBinding(cm, e, ch) {\r\n  return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\r\n}\r\n\r\nvar lastStoppedKey = null;\r\nfunction onKeyDown(e) {\r\n  var cm = this;\r\n  cm.curOp.focus = activeElt();\r\n  if (signalDOMEvent(cm, e)) { return }\r\n  // IE does strange things with escape.\r\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\r\n  var code = e.keyCode;\r\n  cm.display.shift = code == 16 || e.shiftKey;\r\n  var handled = handleKeyBinding(cm, e);\r\n  if (presto) {\r\n    lastStoppedKey = handled ? code : null;\r\n    // Opera has no cut event... we try to at least catch the key combo\r\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\r\n      { cm.replaceSelection(\"\", null, \"cut\"); }\r\n  }\r\n\r\n  // Turn mouse into crosshair when Alt is held on Mac.\r\n  if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\r\n    { showCrossHair(cm); }\r\n}\r\n\r\nfunction showCrossHair(cm) {\r\n  var lineDiv = cm.display.lineDiv;\r\n  addClass(lineDiv, \"CodeMirror-crosshair\");\r\n\r\n  function up(e) {\r\n    if (e.keyCode == 18 || !e.altKey) {\r\n      rmClass(lineDiv, \"CodeMirror-crosshair\");\r\n      off(document, \"keyup\", up);\r\n      off(document, \"mouseover\", up);\r\n    }\r\n  }\r\n  on(document, \"keyup\", up);\r\n  on(document, \"mouseover\", up);\r\n}\r\n\r\nfunction onKeyUp(e) {\r\n  if (e.keyCode == 16) { this.doc.sel.shift = false; }\r\n  signalDOMEvent(this, e);\r\n}\r\n\r\nfunction onKeyPress(e) {\r\n  var cm = this;\r\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\r\n  var keyCode = e.keyCode, charCode = e.charCode;\r\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\r\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\r\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\r\n  // Some browsers fire keypress events for backspace\r\n  if (ch == \"\\x08\") { return }\r\n  if (handleCharBinding(cm, e, ch)) { return }\r\n  cm.display.input.onKeyPress(e);\r\n}\r\n\r\n// A mouse down can be a single click, double click, triple click,\r\n// start of selection drag, start of text drag, new cursor\r\n// (ctrl-click), rectangle drag (alt-drag), or xwin\r\n// middle-click-paste. Or it might be a click on something we should\r\n// not interfere with, such as a scrollbar or widget.\r\nfunction onMouseDown(e) {\r\n  var cm = this, display = cm.display;\r\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\r\n  display.input.ensurePolled();\r\n  display.shift = e.shiftKey;\r\n\r\n  if (eventInWidget(display, e)) {\r\n    if (!webkit) {\r\n      // Briefly turn off draggability, to allow widgets to do\r\n      // normal dragging things.\r\n      display.scroller.draggable = false;\r\n      setTimeout(function () { return display.scroller.draggable = true; }, 100);\r\n    }\r\n    return\r\n  }\r\n  if (clickInGutter(cm, e)) { return }\r\n  var start = posFromMouse(cm, e);\r\n  window.focus();\r\n\r\n  switch (e_button(e)) {\r\n  case 1:\r\n    // #3261: make sure, that we're not starting a second selection\r\n    if (cm.state.selectingText)\r\n      { cm.state.selectingText(e); }\r\n    else if (start)\r\n      { leftButtonDown(cm, e, start); }\r\n    else if (e_target(e) == display.scroller)\r\n      { e_preventDefault(e); }\r\n    break\r\n  case 2:\r\n    if (webkit) { cm.state.lastMiddleDown = +new Date; }\r\n    if (start) { extendSelection(cm.doc, start); }\r\n    setTimeout(function () { return display.input.focus(); }, 20);\r\n    e_preventDefault(e);\r\n    break\r\n  case 3:\r\n    if (captureRightClick) { onContextMenu(cm, e); }\r\n    else { delayBlurEvent(cm); }\r\n    break\r\n  }\r\n}\r\n\r\nvar lastClick;\r\nvar lastDoubleClick;\r\nfunction leftButtonDown(cm, e, start) {\r\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\r\n  else { cm.curOp.focus = activeElt(); }\r\n\r\n  var now = +new Date, type;\r\n  if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\r\n    type = \"triple\";\r\n  } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\r\n    type = \"double\";\r\n    lastDoubleClick = {time: now, pos: start};\r\n  } else {\r\n    type = \"single\";\r\n    lastClick = {time: now, pos: start};\r\n  }\r\n\r\n  var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\r\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\r\n      type == \"single\" && (contained = sel.contains(start)) > -1 &&\r\n      (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\r\n      (cmp(contained.to(), start) > 0 || start.xRel < 0))\r\n    { leftButtonStartDrag(cm, e, start, modifier); }\r\n  else\r\n    { leftButtonSelect(cm, e, start, type, modifier); }\r\n}\r\n\r\n// Start a text drag. When it ends, see if any dragging actually\r\n// happen, and treat as a click if it didn't.\r\nfunction leftButtonStartDrag(cm, e, start, modifier) {\r\n  var display = cm.display, moved = false;\r\n  var dragEnd = operation(cm, function (e) {\r\n    if (webkit) { display.scroller.draggable = false; }\r\n    cm.state.draggingText = false;\r\n    off(document, \"mouseup\", dragEnd);\r\n    off(document, \"mousemove\", mouseMove);\r\n    off(display.scroller, \"dragstart\", dragStart);\r\n    off(display.scroller, \"drop\", dragEnd);\r\n    if (!moved) {\r\n      e_preventDefault(e);\r\n      if (!modifier)\r\n        { extendSelection(cm.doc, start); }\r\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\r\n      if (webkit || ie && ie_version == 9)\r\n        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }\r\n      else\r\n        { display.input.focus(); }\r\n    }\r\n  });\r\n  var mouseMove = function(e2) {\r\n    moved = moved || Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) >= 10;\r\n  };\r\n  var dragStart = function () { return moved = true; };\r\n  // Let the drag handler handle this.\r\n  if (webkit) { display.scroller.draggable = true; }\r\n  cm.state.draggingText = dragEnd;\r\n  dragEnd.copy = mac ? e.altKey : e.ctrlKey;\r\n  // IE's approach to draggable\r\n  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\r\n  on(document, \"mouseup\", dragEnd);\r\n  on(document, \"mousemove\", mouseMove);\r\n  on(display.scroller, \"dragstart\", dragStart);\r\n  on(display.scroller, \"drop\", dragEnd);\r\n\r\n  delayBlurEvent(cm);\r\n  setTimeout(function () { return display.input.focus(); }, 20);\r\n}\r\n\r\n// Normal selection, as opposed to text dragging.\r\nfunction leftButtonSelect(cm, e, start, type, addNew) {\r\n  var display = cm.display, doc = cm.doc;\r\n  e_preventDefault(e);\r\n\r\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\r\n  if (addNew && !e.shiftKey) {\r\n    ourIndex = doc.sel.contains(start);\r\n    if (ourIndex > -1)\r\n      { ourRange = ranges[ourIndex]; }\r\n    else\r\n      { ourRange = new Range(start, start); }\r\n  } else {\r\n    ourRange = doc.sel.primary();\r\n    ourIndex = doc.sel.primIndex;\r\n  }\r\n\r\n  if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {\r\n    type = \"rect\";\r\n    if (!addNew) { ourRange = new Range(start, start); }\r\n    start = posFromMouse(cm, e, true, true);\r\n    ourIndex = -1;\r\n  } else if (type == \"double\") {\r\n    var word = cm.findWordAt(start);\r\n    if (cm.display.shift || doc.extend)\r\n      { ourRange = extendRange(doc, ourRange, word.anchor, word.head); }\r\n    else\r\n      { ourRange = word; }\r\n  } else if (type == \"triple\") {\r\n    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\r\n    if (cm.display.shift || doc.extend)\r\n      { ourRange = extendRange(doc, ourRange, line.anchor, line.head); }\r\n    else\r\n      { ourRange = line; }\r\n  } else {\r\n    ourRange = extendRange(doc, ourRange, start);\r\n  }\r\n\r\n  if (!addNew) {\r\n    ourIndex = 0;\r\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse);\r\n    startSel = doc.sel;\r\n  } else if (ourIndex == -1) {\r\n    ourIndex = ranges.length;\r\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\r\n                 {scroll: false, origin: \"*mouse\"});\r\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\r\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\r\n                 {scroll: false, origin: \"*mouse\"});\r\n    startSel = doc.sel;\r\n  } else {\r\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\r\n  }\r\n\r\n  var lastPos = start;\r\n  function extendTo(pos) {\r\n    if (cmp(lastPos, pos) == 0) { return }\r\n    lastPos = pos;\r\n\r\n    if (type == \"rect\") {\r\n      var ranges = [], tabSize = cm.options.tabSize;\r\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\r\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\r\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\r\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\r\n           line <= end; line++) {\r\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\r\n        if (left == right)\r\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\r\n        else if (text.length > leftPos)\r\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\r\n      }\r\n      if (!ranges.length) { ranges.push(new Range(start, start)); }\r\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\r\n                   {origin: \"*mouse\", scroll: false});\r\n      cm.scrollIntoView(pos);\r\n    } else {\r\n      var oldRange = ourRange;\r\n      var anchor = oldRange.anchor, head = pos;\r\n      if (type != \"single\") {\r\n        var range$$1;\r\n        if (type == \"double\")\r\n          { range$$1 = cm.findWordAt(pos); }\r\n        else\r\n          { range$$1 = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))); }\r\n        if (cmp(range$$1.anchor, anchor) > 0) {\r\n          head = range$$1.head;\r\n          anchor = minPos(oldRange.from(), range$$1.anchor);\r\n        } else {\r\n          head = range$$1.anchor;\r\n          anchor = maxPos(oldRange.to(), range$$1.head);\r\n        }\r\n      }\r\n      var ranges$1 = startSel.ranges.slice(0);\r\n      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head);\r\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);\r\n    }\r\n  }\r\n\r\n  var editorSize = display.wrapper.getBoundingClientRect();\r\n  // Used to ensure timeout re-tries don't fire when another extend\r\n  // happened in the meantime (clearTimeout isn't reliable -- at\r\n  // least on Chrome, the timeouts still happen even when cleared,\r\n  // if the clear happens after their scheduled firing time).\r\n  var counter = 0;\r\n\r\n  function extend(e) {\r\n    var curCount = ++counter;\r\n    var cur = posFromMouse(cm, e, true, type == \"rect\");\r\n    if (!cur) { return }\r\n    if (cmp(cur, lastPos) != 0) {\r\n      cm.curOp.focus = activeElt();\r\n      extendTo(cur);\r\n      var visible = visibleLines(display, doc);\r\n      if (cur.line >= visible.to || cur.line < visible.from)\r\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\r\n    } else {\r\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\r\n      if (outside) { setTimeout(operation(cm, function () {\r\n        if (counter != curCount) { return }\r\n        display.scroller.scrollTop += outside;\r\n        extend(e);\r\n      }), 50); }\r\n    }\r\n  }\r\n\r\n  function done(e) {\r\n    cm.state.selectingText = false;\r\n    counter = Infinity;\r\n    e_preventDefault(e);\r\n    display.input.focus();\r\n    off(document, \"mousemove\", move);\r\n    off(document, \"mouseup\", up);\r\n    doc.history.lastSelOrigin = null;\r\n  }\r\n\r\n  var move = operation(cm, function (e) {\r\n    if (!e_button(e)) { done(e); }\r\n    else { extend(e); }\r\n  });\r\n  var up = operation(cm, done);\r\n  cm.state.selectingText = up;\r\n  on(document, \"mousemove\", move);\r\n  on(document, \"mouseup\", up);\r\n}\r\n\r\n\r\n// Determines whether an event happened in the gutter, and fires the\r\n// handlers for the corresponding event.\r\nfunction gutterEvent(cm, e, type, prevent) {\r\n  var mX, mY;\r\n  try { mX = e.clientX; mY = e.clientY; }\r\n  catch(e) { return false }\r\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\r\n  if (prevent) { e_preventDefault(e); }\r\n\r\n  var display = cm.display;\r\n  var lineBox = display.lineDiv.getBoundingClientRect();\r\n\r\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\r\n  mY -= lineBox.top - display.viewOffset;\r\n\r\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\r\n    var g = display.gutters.childNodes[i];\r\n    if (g && g.getBoundingClientRect().right >= mX) {\r\n      var line = lineAtHeight(cm.doc, mY);\r\n      var gutter = cm.options.gutters[i];\r\n      signal(cm, type, cm, line, gutter, e);\r\n      return e_defaultPrevented(e)\r\n    }\r\n  }\r\n}\r\n\r\nfunction clickInGutter(cm, e) {\r\n  return gutterEvent(cm, e, \"gutterClick\", true)\r\n}\r\n\r\n// CONTEXT MENU HANDLING\r\n\r\n// To make the context menu work, we need to briefly unhide the\r\n// textarea (making it as unobtrusive as possible) to let the\r\n// right-click take effect on it.\r\nfunction onContextMenu(cm, e) {\r\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\r\n  if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\r\n  cm.display.input.onContextMenu(e);\r\n}\r\n\r\nfunction contextMenuInGutter(cm, e) {\r\n  if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\r\n  return gutterEvent(cm, e, \"gutterContextMenu\", false)\r\n}\r\n\r\nfunction themeChanged(cm) {\r\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\r\n    cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\r\n  clearCaches(cm);\r\n}\r\n\r\nvar Init = {toString: function(){return \"CodeMirror.Init\"}};\r\n\r\nvar defaults = {};\r\nvar optionHandlers = {};\r\n\r\nfunction defineOptions(CodeMirror) {\r\n  var optionHandlers = CodeMirror.optionHandlers;\r\n\r\n  function option(name, deflt, handle, notOnInit) {\r\n    CodeMirror.defaults[name] = deflt;\r\n    if (handle) { optionHandlers[name] =\r\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\r\n  }\r\n\r\n  CodeMirror.defineOption = option;\r\n\r\n  // Passed to option handlers when there is no old value.\r\n  CodeMirror.Init = Init;\r\n\r\n  // These two are, on init, called from the constructor because they\r\n  // have to be initialized before the editor can start at all.\r\n  option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\r\n  option(\"mode\", null, function (cm, val) {\r\n    cm.doc.modeOption = val;\r\n    loadMode(cm);\r\n  }, true);\r\n\r\n  option(\"indentUnit\", 2, loadMode, true);\r\n  option(\"indentWithTabs\", false);\r\n  option(\"smartIndent\", true);\r\n  option(\"tabSize\", 4, function (cm) {\r\n    resetModeState(cm);\r\n    clearCaches(cm);\r\n    regChange(cm);\r\n  }, true);\r\n  option(\"lineSeparator\", null, function (cm, val) {\r\n    cm.doc.lineSep = val;\r\n    if (!val) { return }\r\n    var newBreaks = [], lineNo = cm.doc.first;\r\n    cm.doc.iter(function (line) {\r\n      for (var pos = 0;;) {\r\n        var found = line.text.indexOf(val, pos);\r\n        if (found == -1) { break }\r\n        pos = found + val.length;\r\n        newBreaks.push(Pos(lineNo, found));\r\n      }\r\n      lineNo++;\r\n    });\r\n    for (var i = newBreaks.length - 1; i >= 0; i--)\r\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\r\n  });\r\n  option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\r\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\r\n    if (old != Init) { cm.refresh(); }\r\n  });\r\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\r\n  option(\"electricChars\", true);\r\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\r\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\r\n  }, true);\r\n  option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\r\n  option(\"rtlMoveVisually\", !windows);\r\n  option(\"wholeLineUpdateBefore\", true);\r\n\r\n  option(\"theme\", \"default\", function (cm) {\r\n    themeChanged(cm);\r\n    guttersChanged(cm);\r\n  }, true);\r\n  option(\"keyMap\", \"default\", function (cm, val, old) {\r\n    var next = getKeyMap(val);\r\n    var prev = old != Init && getKeyMap(old);\r\n    if (prev && prev.detach) { prev.detach(cm, next); }\r\n    if (next.attach) { next.attach(cm, prev || null); }\r\n  });\r\n  option(\"extraKeys\", null);\r\n\r\n  option(\"lineWrapping\", false, wrappingChanged, true);\r\n  option(\"gutters\", [], function (cm) {\r\n    setGuttersForLineNumbers(cm.options);\r\n    guttersChanged(cm);\r\n  }, true);\r\n  option(\"fixedGutter\", true, function (cm, val) {\r\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\r\n    cm.refresh();\r\n  }, true);\r\n  option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\r\n  option(\"scrollbarStyle\", \"native\", function (cm) {\r\n    initScrollbars(cm);\r\n    updateScrollbars(cm);\r\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\r\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\r\n  }, true);\r\n  option(\"lineNumbers\", false, function (cm) {\r\n    setGuttersForLineNumbers(cm.options);\r\n    guttersChanged(cm);\r\n  }, true);\r\n  option(\"firstLineNumber\", 1, guttersChanged, true);\r\n  option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\r\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\r\n\r\n  option(\"resetSelectionOnContextMenu\", true);\r\n  option(\"lineWiseCopyCut\", true);\r\n\r\n  option(\"readOnly\", false, function (cm, val) {\r\n    if (val == \"nocursor\") {\r\n      onBlur(cm);\r\n      cm.display.input.blur();\r\n      cm.display.disabled = true;\r\n    } else {\r\n      cm.display.disabled = false;\r\n    }\r\n    cm.display.input.readOnlyChanged(val);\r\n  });\r\n  option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\r\n  option(\"dragDrop\", true, dragDropChanged);\r\n  option(\"allowDropFileTypes\", null);\r\n\r\n  option(\"cursorBlinkRate\", 530);\r\n  option(\"cursorScrollMargin\", 0);\r\n  option(\"cursorHeight\", 1, updateSelection, true);\r\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\r\n  option(\"workTime\", 100);\r\n  option(\"workDelay\", 100);\r\n  option(\"flattenSpans\", true, resetModeState, true);\r\n  option(\"addModeClass\", false, resetModeState, true);\r\n  option(\"pollInterval\", 100);\r\n  option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\r\n  option(\"historyEventDelay\", 1250);\r\n  option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\r\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\r\n  option(\"moveInputWithCursor\", true, function (cm, val) {\r\n    if (!val) { cm.display.input.resetPosition(); }\r\n  });\r\n\r\n  option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\r\n  option(\"autofocus\", null);\r\n  option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\r\n}\r\n\r\nfunction guttersChanged(cm) {\r\n  updateGutters(cm);\r\n  regChange(cm);\r\n  alignHorizontally(cm);\r\n}\r\n\r\nfunction dragDropChanged(cm, value, old) {\r\n  var wasOn = old && old != Init;\r\n  if (!value != !wasOn) {\r\n    var funcs = cm.display.dragFunctions;\r\n    var toggle = value ? on : off;\r\n    toggle(cm.display.scroller, \"dragstart\", funcs.start);\r\n    toggle(cm.display.scroller, \"dragenter\", funcs.enter);\r\n    toggle(cm.display.scroller, \"dragover\", funcs.over);\r\n    toggle(cm.display.scroller, \"dragleave\", funcs.leave);\r\n    toggle(cm.display.scroller, \"drop\", funcs.drop);\r\n  }\r\n}\r\n\r\nfunction wrappingChanged(cm) {\r\n  if (cm.options.lineWrapping) {\r\n    addClass(cm.display.wrapper, \"CodeMirror-wrap\");\r\n    cm.display.sizer.style.minWidth = \"\";\r\n    cm.display.sizerWidth = null;\r\n  } else {\r\n    rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\r\n    findMaxLine(cm);\r\n  }\r\n  estimateLineHeights(cm);\r\n  regChange(cm);\r\n  clearCaches(cm);\r\n  setTimeout(function () { return updateScrollbars(cm); }, 100);\r\n}\r\n\r\n// A CodeMirror instance represents an editor. This is the object\r\n// that user code is usually dealing with.\r\n\r\nfunction CodeMirror$1(place, options) {\r\n  var this$1 = this;\r\n\r\n  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }\r\n\r\n  this.options = options = options ? copyObj(options) : {};\r\n  // Determine effective options based on given values and defaults.\r\n  copyObj(defaults, options, false);\r\n  setGuttersForLineNumbers(options);\r\n\r\n  var doc = options.value;\r\n  if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\r\n  this.doc = doc;\r\n\r\n  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);\r\n  var display = this.display = new Display(place, doc, input);\r\n  display.wrapper.CodeMirror = this;\r\n  updateGutters(this);\r\n  themeChanged(this);\r\n  if (options.lineWrapping)\r\n    { this.display.wrapper.className += \" CodeMirror-wrap\"; }\r\n  initScrollbars(this);\r\n\r\n  this.state = {\r\n    keyMaps: [],  // stores maps added by addKeyMap\r\n    overlays: [], // highlighting overlays, as added by addOverlay\r\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\r\n    overwrite: false,\r\n    delayingBlurEvent: false,\r\n    focused: false,\r\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\r\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\r\n    selectingText: false,\r\n    draggingText: false,\r\n    highlight: new Delayed(), // stores highlight worker timeout\r\n    keySeq: null,  // Unfinished key sequence\r\n    specialChars: null\r\n  };\r\n\r\n  if (options.autofocus && !mobile) { display.input.focus(); }\r\n\r\n  // Override magic textarea content restore that IE sometimes does\r\n  // on our hidden textarea on reload\r\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\r\n\r\n  registerEventHandlers(this);\r\n  ensureGlobalHandlers();\r\n\r\n  startOperation(this);\r\n  this.curOp.forceUpdate = true;\r\n  attachDoc(this, doc);\r\n\r\n  if ((options.autofocus && !mobile) || this.hasFocus())\r\n    { setTimeout(bind(onFocus, this), 20); }\r\n  else\r\n    { onBlur(this); }\r\n\r\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\r\n    { optionHandlers[opt](this$1, options[opt], Init); } }\r\n  maybeUpdateLineNumberWidth(this);\r\n  if (options.finishInit) { options.finishInit(this); }\r\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\r\n  endOperation(this);\r\n  // Suppress optimizelegibility in Webkit, since it breaks text\r\n  // measuring on line wrapping boundaries.\r\n  if (webkit && options.lineWrapping &&\r\n      getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\r\n    { display.lineDiv.style.textRendering = \"auto\"; }\r\n}\r\n\r\n// The default configuration options.\r\nCodeMirror$1.defaults = defaults;\r\n// Functions to run when options are changed.\r\nCodeMirror$1.optionHandlers = optionHandlers;\r\n\r\n// Attach the necessary event handlers when initializing the editor\r\nfunction registerEventHandlers(cm) {\r\n  var d = cm.display;\r\n  on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\r\n  // Older IE's will not fire a second mousedown for a double click\r\n  if (ie && ie_version < 11)\r\n    { on(d.scroller, \"dblclick\", operation(cm, function (e) {\r\n      if (signalDOMEvent(cm, e)) { return }\r\n      var pos = posFromMouse(cm, e);\r\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\r\n      e_preventDefault(e);\r\n      var word = cm.findWordAt(pos);\r\n      extendSelection(cm.doc, word.anchor, word.head);\r\n    })); }\r\n  else\r\n    { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\r\n  // Some browsers fire contextmenu *after* opening the menu, at\r\n  // which point we can't mess with it anymore. Context menu is\r\n  // handled in onMouseDown for these browsers.\r\n  if (!captureRightClick) { on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); }); }\r\n\r\n  // Used to suppress mouse event handling when a touch happens\r\n  var touchFinished, prevTouch = {end: 0};\r\n  function finishTouch() {\r\n    if (d.activeTouch) {\r\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\r\n      prevTouch = d.activeTouch;\r\n      prevTouch.end = +new Date;\r\n    }\r\n  }\r\n  function isMouseLikeTouchEvent(e) {\r\n    if (e.touches.length != 1) { return false }\r\n    var touch = e.touches[0];\r\n    return touch.radiusX <= 1 && touch.radiusY <= 1\r\n  }\r\n  function farAway(touch, other) {\r\n    if (other.left == null) { return true }\r\n    var dx = other.left - touch.left, dy = other.top - touch.top;\r\n    return dx * dx + dy * dy > 20 * 20\r\n  }\r\n  on(d.scroller, \"touchstart\", function (e) {\r\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\r\n      d.input.ensurePolled();\r\n      clearTimeout(touchFinished);\r\n      var now = +new Date;\r\n      d.activeTouch = {start: now, moved: false,\r\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null};\r\n      if (e.touches.length == 1) {\r\n        d.activeTouch.left = e.touches[0].pageX;\r\n        d.activeTouch.top = e.touches[0].pageY;\r\n      }\r\n    }\r\n  });\r\n  on(d.scroller, \"touchmove\", function () {\r\n    if (d.activeTouch) { d.activeTouch.moved = true; }\r\n  });\r\n  on(d.scroller, \"touchend\", function (e) {\r\n    var touch = d.activeTouch;\r\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\r\n        !touch.moved && new Date - touch.start < 300) {\r\n      var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\r\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\r\n        { range = new Range(pos, pos); }\r\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\r\n        { range = cm.findWordAt(pos); }\r\n      else // Triple tap\r\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\r\n      cm.setSelection(range.anchor, range.head);\r\n      cm.focus();\r\n      e_preventDefault(e);\r\n    }\r\n    finishTouch();\r\n  });\r\n  on(d.scroller, \"touchcancel\", finishTouch);\r\n\r\n  // Sync scrolling between fake scrollbars and real scrollable\r\n  // area, ensure viewport is updated when scrolling.\r\n  on(d.scroller, \"scroll\", function () {\r\n    if (d.scroller.clientHeight) {\r\n      updateScrollTop(cm, d.scroller.scrollTop);\r\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\r\n      signal(cm, \"scroll\", cm);\r\n    }\r\n  });\r\n\r\n  // Listen to wheel events in order to try and update the viewport on time.\r\n  on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\r\n  on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\r\n\r\n  // Prevent wrapper from ever scrolling\r\n  on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\r\n\r\n  d.dragFunctions = {\r\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\r\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\r\n    start: function (e) { return onDragStart(cm, e); },\r\n    drop: operation(cm, onDrop),\r\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\r\n  };\r\n\r\n  var inp = d.input.getField();\r\n  on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\r\n  on(inp, \"keydown\", operation(cm, onKeyDown));\r\n  on(inp, \"keypress\", operation(cm, onKeyPress));\r\n  on(inp, \"focus\", function (e) { return onFocus(cm, e); });\r\n  on(inp, \"blur\", function (e) { return onBlur(cm, e); });\r\n}\r\n\r\nvar initHooks = [];\r\nCodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };\r\n\r\n// Indent the given line. The how parameter can be \"smart\",\r\n// \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\r\n// (typically set to true for forced single-line indents), empty\r\n// lines are not indented, and places where the mode returns Pass\r\n// are left alone.\r\nfunction indentLine(cm, n, how, aggressive) {\r\n  var doc = cm.doc, state;\r\n  if (how == null) { how = \"add\"; }\r\n  if (how == \"smart\") {\r\n    // Fall back to \"prev\" when the mode doesn't have an indentation\r\n    // method.\r\n    if (!doc.mode.indent) { how = \"prev\"; }\r\n    else { state = getStateBefore(cm, n); }\r\n  }\r\n\r\n  var tabSize = cm.options.tabSize;\r\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\r\n  if (line.stateAfter) { line.stateAfter = null; }\r\n  var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\r\n  if (!aggressive && !/\\S/.test(line.text)) {\r\n    indentation = 0;\r\n    how = \"not\";\r\n  } else if (how == \"smart\") {\r\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\r\n    if (indentation == Pass || indentation > 150) {\r\n      if (!aggressive) { return }\r\n      how = \"prev\";\r\n    }\r\n  }\r\n  if (how == \"prev\") {\r\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\r\n    else { indentation = 0; }\r\n  } else if (how == \"add\") {\r\n    indentation = curSpace + cm.options.indentUnit;\r\n  } else if (how == \"subtract\") {\r\n    indentation = curSpace - cm.options.indentUnit;\r\n  } else if (typeof how == \"number\") {\r\n    indentation = curSpace + how;\r\n  }\r\n  indentation = Math.max(0, indentation);\r\n\r\n  var indentString = \"\", pos = 0;\r\n  if (cm.options.indentWithTabs)\r\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\r\n  if (pos < indentation) { indentString += spaceStr(indentation - pos); }\r\n\r\n  if (indentString != curSpaceString) {\r\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\r\n    line.stateAfter = null;\r\n    return true\r\n  } else {\r\n    // Ensure that, if the cursor was in the whitespace at the start\r\n    // of the line, it is moved to the end of that space.\r\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\r\n      var range = doc.sel.ranges[i$1];\r\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\r\n        var pos$1 = Pos(n, curSpaceString.length);\r\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\r\n        break\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// This will be set to a {lineWise: bool, text: [string]} object, so\r\n// that, when pasting, we know what kind of selections the copied\r\n// text was made out of.\r\nvar lastCopied = null;\r\n\r\nfunction setLastCopied(newLastCopied) {\r\n  lastCopied = newLastCopied;\r\n}\r\n\r\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\r\n  var doc = cm.doc;\r\n  cm.display.shift = false;\r\n  if (!sel) { sel = doc.sel; }\r\n\r\n  var paste = cm.state.pasteIncoming || origin == \"paste\";\r\n  var textLines = splitLinesAuto(inserted), multiPaste = null;\r\n  // When pasing N lines into N selections, insert one line per selection\r\n  if (paste && sel.ranges.length > 1) {\r\n    if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\r\n      if (sel.ranges.length % lastCopied.text.length == 0) {\r\n        multiPaste = [];\r\n        for (var i = 0; i < lastCopied.text.length; i++)\r\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\r\n      }\r\n    } else if (textLines.length == sel.ranges.length) {\r\n      multiPaste = map(textLines, function (l) { return [l]; });\r\n    }\r\n  }\r\n\r\n  var updateInput;\r\n  // Normal behavior is to insert the new text into every selection\r\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\r\n    var range$$1 = sel.ranges[i$1];\r\n    var from = range$$1.from(), to = range$$1.to();\r\n    if (range$$1.empty()) {\r\n      if (deleted && deleted > 0) // Handle deletion\r\n        { from = Pos(from.line, from.ch - deleted); }\r\n      else if (cm.state.overwrite && !paste) // Handle overwrite\r\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\r\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\r\n        { from = to = Pos(from.line, 0); }\r\n    }\r\n    updateInput = cm.curOp.updateInput;\r\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\r\n                       origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\r\n    makeChange(cm.doc, changeEvent);\r\n    signalLater(cm, \"inputRead\", cm, changeEvent);\r\n  }\r\n  if (inserted && !paste)\r\n    { triggerElectric(cm, inserted); }\r\n\r\n  ensureCursorVisible(cm);\r\n  cm.curOp.updateInput = updateInput;\r\n  cm.curOp.typing = true;\r\n  cm.state.pasteIncoming = cm.state.cutIncoming = false;\r\n}\r\n\r\nfunction handlePaste(e, cm) {\r\n  var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\r\n  if (pasted) {\r\n    e.preventDefault();\r\n    if (!cm.isReadOnly() && !cm.options.disableInput)\r\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\r\n    return true\r\n  }\r\n}\r\n\r\nfunction triggerElectric(cm, inserted) {\r\n  // When an 'electric' character is inserted, immediately trigger a reindent\r\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\r\n  var sel = cm.doc.sel;\r\n\r\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\r\n    var range$$1 = sel.ranges[i];\r\n    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\r\n    var mode = cm.getModeAt(range$$1.head);\r\n    var indented = false;\r\n    if (mode.electricChars) {\r\n      for (var j = 0; j < mode.electricChars.length; j++)\r\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\r\n          indented = indentLine(cm, range$$1.head.line, \"smart\");\r\n          break\r\n        } }\r\n    } else if (mode.electricInput) {\r\n      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\r\n        { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\r\n    }\r\n    if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\r\n  }\r\n}\r\n\r\nfunction copyableRanges(cm) {\r\n  var text = [], ranges = [];\r\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\r\n    var line = cm.doc.sel.ranges[i].head.line;\r\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\r\n    ranges.push(lineRange);\r\n    text.push(cm.getRange(lineRange.anchor, lineRange.head));\r\n  }\r\n  return {text: text, ranges: ranges}\r\n}\r\n\r\nfunction disableBrowserMagic(field, spellcheck) {\r\n  field.setAttribute(\"autocorrect\", \"off\");\r\n  field.setAttribute(\"autocapitalize\", \"off\");\r\n  field.setAttribute(\"spellcheck\", !!spellcheck);\r\n}\r\n\r\nfunction hiddenTextarea() {\r\n  var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\r\n  var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\r\n  // The textarea is kept positioned near the cursor to prevent the\r\n  // fact that it'll be scrolled into view on input from scrolling\r\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\r\n  // very slow. So make the area wide instead.\r\n  if (webkit) { te.style.width = \"1000px\"; }\r\n  else { te.setAttribute(\"wrap\", \"off\"); }\r\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\r\n  if (ios) { te.style.border = \"1px solid black\"; }\r\n  disableBrowserMagic(te);\r\n  return div\r\n}\r\n\r\n// The publicly visible API. Note that methodOp(f) means\r\n// 'wrap f in an operation, performed on its `this` parameter'.\r\n\r\n// This is not the complete set of editor methods. Most of the\r\n// methods defined on the Doc type are also injected into\r\n// CodeMirror.prototype, for backwards compatibility and\r\n// convenience.\r\n\r\nvar addEditorMethods = function(CodeMirror) {\r\n  var optionHandlers = CodeMirror.optionHandlers;\r\n\r\n  var helpers = CodeMirror.helpers = {};\r\n\r\n  CodeMirror.prototype = {\r\n    constructor: CodeMirror,\r\n    focus: function(){window.focus(); this.display.input.focus();},\r\n\r\n    setOption: function(option, value) {\r\n      var options = this.options, old = options[option];\r\n      if (options[option] == value && option != \"mode\") { return }\r\n      options[option] = value;\r\n      if (optionHandlers.hasOwnProperty(option))\r\n        { operation(this, optionHandlers[option])(this, value, old); }\r\n      signal(this, \"optionChange\", this, option);\r\n    },\r\n\r\n    getOption: function(option) {return this.options[option]},\r\n    getDoc: function() {return this.doc},\r\n\r\n    addKeyMap: function(map$$1, bottom) {\r\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\r\n    },\r\n    removeKeyMap: function(map$$1) {\r\n      var maps = this.state.keyMaps;\r\n      for (var i = 0; i < maps.length; ++i)\r\n        { if (maps[i] == map$$1 || maps[i].name == map$$1) {\r\n          maps.splice(i, 1);\r\n          return true\r\n        } }\r\n    },\r\n\r\n    addOverlay: methodOp(function(spec, options) {\r\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\r\n      if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\r\n      insertSorted(this.state.overlays,\r\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\r\n                    priority: (options && options.priority) || 0},\r\n                   function (overlay) { return overlay.priority; });\r\n      this.state.modeGen++;\r\n      regChange(this);\r\n    }),\r\n    removeOverlay: methodOp(function(spec) {\r\n      var this$1 = this;\r\n\r\n      var overlays = this.state.overlays;\r\n      for (var i = 0; i < overlays.length; ++i) {\r\n        var cur = overlays[i].modeSpec;\r\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\r\n          overlays.splice(i, 1);\r\n          this$1.state.modeGen++;\r\n          regChange(this$1);\r\n          return\r\n        }\r\n      }\r\n    }),\r\n\r\n    indentLine: methodOp(function(n, dir, aggressive) {\r\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\r\n        if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\r\n        else { dir = dir ? \"add\" : \"subtract\"; }\r\n      }\r\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\r\n    }),\r\n    indentSelection: methodOp(function(how) {\r\n      var this$1 = this;\r\n\r\n      var ranges = this.doc.sel.ranges, end = -1;\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var range$$1 = ranges[i];\r\n        if (!range$$1.empty()) {\r\n          var from = range$$1.from(), to = range$$1.to();\r\n          var start = Math.max(end, from.line);\r\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\r\n          for (var j = start; j < end; ++j)\r\n            { indentLine(this$1, j, how); }\r\n          var newRanges = this$1.doc.sel.ranges;\r\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\r\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\r\n        } else if (range$$1.head.line > end) {\r\n          indentLine(this$1, range$$1.head.line, how, true);\r\n          end = range$$1.head.line;\r\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\r\n        }\r\n      }\r\n    }),\r\n\r\n    // Fetch the parser token for a given character. Useful for hacks\r\n    // that want to inspect the mode state (say, for completion).\r\n    getTokenAt: function(pos, precise) {\r\n      return takeToken(this, pos, precise)\r\n    },\r\n\r\n    getLineTokens: function(line, precise) {\r\n      return takeToken(this, Pos(line), precise, true)\r\n    },\r\n\r\n    getTokenTypeAt: function(pos) {\r\n      pos = clipPos(this.doc, pos);\r\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\r\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\r\n      var type;\r\n      if (ch == 0) { type = styles[2]; }\r\n      else { for (;;) {\r\n        var mid = (before + after) >> 1;\r\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\r\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\r\n        else { type = styles[mid * 2 + 2]; break }\r\n      } }\r\n      var cut = type ? type.indexOf(\"overlay \") : -1;\r\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\r\n    },\r\n\r\n    getModeAt: function(pos) {\r\n      var mode = this.doc.mode;\r\n      if (!mode.innerMode) { return mode }\r\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\r\n    },\r\n\r\n    getHelper: function(pos, type) {\r\n      return this.getHelpers(pos, type)[0]\r\n    },\r\n\r\n    getHelpers: function(pos, type) {\r\n      var this$1 = this;\r\n\r\n      var found = [];\r\n      if (!helpers.hasOwnProperty(type)) { return found }\r\n      var help = helpers[type], mode = this.getModeAt(pos);\r\n      if (typeof mode[type] == \"string\") {\r\n        if (help[mode[type]]) { found.push(help[mode[type]]); }\r\n      } else if (mode[type]) {\r\n        for (var i = 0; i < mode[type].length; i++) {\r\n          var val = help[mode[type][i]];\r\n          if (val) { found.push(val); }\r\n        }\r\n      } else if (mode.helperType && help[mode.helperType]) {\r\n        found.push(help[mode.helperType]);\r\n      } else if (help[mode.name]) {\r\n        found.push(help[mode.name]);\r\n      }\r\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\r\n        var cur = help._global[i$1];\r\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\r\n          { found.push(cur.val); }\r\n      }\r\n      return found\r\n    },\r\n\r\n    getStateAfter: function(line, precise) {\r\n      var doc = this.doc;\r\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\r\n      return getStateBefore(this, line + 1, precise)\r\n    },\r\n\r\n    cursorCoords: function(start, mode) {\r\n      var pos, range$$1 = this.doc.sel.primary();\r\n      if (start == null) { pos = range$$1.head; }\r\n      else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\r\n      else { pos = start ? range$$1.from() : range$$1.to(); }\r\n      return cursorCoords(this, pos, mode || \"page\")\r\n    },\r\n\r\n    charCoords: function(pos, mode) {\r\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\r\n    },\r\n\r\n    coordsChar: function(coords, mode) {\r\n      coords = fromCoordSystem(this, coords, mode || \"page\");\r\n      return coordsChar(this, coords.left, coords.top)\r\n    },\r\n\r\n    lineAtHeight: function(height, mode) {\r\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\r\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\r\n    },\r\n    heightAtLine: function(line, mode, includeWidgets) {\r\n      var end = false, lineObj;\r\n      if (typeof line == \"number\") {\r\n        var last = this.doc.first + this.doc.size - 1;\r\n        if (line < this.doc.first) { line = this.doc.first; }\r\n        else if (line > last) { line = last; end = true; }\r\n        lineObj = getLine(this.doc, line);\r\n      } else {\r\n        lineObj = line;\r\n      }\r\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\r\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\r\n    },\r\n\r\n    defaultTextHeight: function() { return textHeight(this.display) },\r\n    defaultCharWidth: function() { return charWidth(this.display) },\r\n\r\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\r\n\r\n    addWidget: function(pos, node, scroll, vert, horiz) {\r\n      var display = this.display;\r\n      pos = cursorCoords(this, clipPos(this.doc, pos));\r\n      var top = pos.bottom, left = pos.left;\r\n      node.style.position = \"absolute\";\r\n      node.setAttribute(\"cm-ignore-events\", \"true\");\r\n      this.display.input.setUneditable(node);\r\n      display.sizer.appendChild(node);\r\n      if (vert == \"over\") {\r\n        top = pos.top;\r\n      } else if (vert == \"above\" || vert == \"near\") {\r\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\r\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\r\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\r\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\r\n          { top = pos.top - node.offsetHeight; }\r\n        else if (pos.bottom + node.offsetHeight <= vspace)\r\n          { top = pos.bottom; }\r\n        if (left + node.offsetWidth > hspace)\r\n          { left = hspace - node.offsetWidth; }\r\n      }\r\n      node.style.top = top + \"px\";\r\n      node.style.left = node.style.right = \"\";\r\n      if (horiz == \"right\") {\r\n        left = display.sizer.clientWidth - node.offsetWidth;\r\n        node.style.right = \"0px\";\r\n      } else {\r\n        if (horiz == \"left\") { left = 0; }\r\n        else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\r\n        node.style.left = left + \"px\";\r\n      }\r\n      if (scroll)\r\n        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\r\n    },\r\n\r\n    triggerOnKeyDown: methodOp(onKeyDown),\r\n    triggerOnKeyPress: methodOp(onKeyPress),\r\n    triggerOnKeyUp: onKeyUp,\r\n\r\n    execCommand: function(cmd) {\r\n      if (commands.hasOwnProperty(cmd))\r\n        { return commands[cmd].call(null, this) }\r\n    },\r\n\r\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\r\n\r\n    findPosH: function(from, amount, unit, visually) {\r\n      var this$1 = this;\r\n\r\n      var dir = 1;\r\n      if (amount < 0) { dir = -1; amount = -amount; }\r\n      var cur = clipPos(this.doc, from);\r\n      for (var i = 0; i < amount; ++i) {\r\n        cur = findPosH(this$1.doc, cur, dir, unit, visually);\r\n        if (cur.hitSide) { break }\r\n      }\r\n      return cur\r\n    },\r\n\r\n    moveH: methodOp(function(dir, unit) {\r\n      var this$1 = this;\r\n\r\n      this.extendSelectionsBy(function (range$$1) {\r\n        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\r\n          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\r\n        else\r\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\r\n      }, sel_move);\r\n    }),\r\n\r\n    deleteH: methodOp(function(dir, unit) {\r\n      var sel = this.doc.sel, doc = this.doc;\r\n      if (sel.somethingSelected())\r\n        { doc.replaceSelection(\"\", null, \"+delete\"); }\r\n      else\r\n        { deleteNearSelection(this, function (range$$1) {\r\n          var other = findPosH(doc, range$$1.head, dir, unit, false);\r\n          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\r\n        }); }\r\n    }),\r\n\r\n    findPosV: function(from, amount, unit, goalColumn) {\r\n      var this$1 = this;\r\n\r\n      var dir = 1, x = goalColumn;\r\n      if (amount < 0) { dir = -1; amount = -amount; }\r\n      var cur = clipPos(this.doc, from);\r\n      for (var i = 0; i < amount; ++i) {\r\n        var coords = cursorCoords(this$1, cur, \"div\");\r\n        if (x == null) { x = coords.left; }\r\n        else { coords.left = x; }\r\n        cur = findPosV(this$1, coords, dir, unit);\r\n        if (cur.hitSide) { break }\r\n      }\r\n      return cur\r\n    },\r\n\r\n    moveV: methodOp(function(dir, unit) {\r\n      var this$1 = this;\r\n\r\n      var doc = this.doc, goals = [];\r\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\r\n      doc.extendSelectionsBy(function (range$$1) {\r\n        if (collapse)\r\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\r\n        var headPos = cursorCoords(this$1, range$$1.head, \"div\");\r\n        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\r\n        goals.push(headPos.left);\r\n        var pos = findPosV(this$1, headPos, dir, unit);\r\n        if (unit == \"page\" && range$$1 == doc.sel.primary())\r\n          { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\r\n        return pos\r\n      }, sel_move);\r\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\r\n        { doc.sel.ranges[i].goalColumn = goals[i]; } }\r\n    }),\r\n\r\n    // Find the word at the given position (as returned by coordsChar).\r\n    findWordAt: function(pos) {\r\n      var doc = this.doc, line = getLine(doc, pos.line).text;\r\n      var start = pos.ch, end = pos.ch;\r\n      if (line) {\r\n        var helper = this.getHelper(pos, \"wordChars\");\r\n        if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\r\n        var startChar = line.charAt(start);\r\n        var check = isWordChar(startChar, helper)\r\n          ? function (ch) { return isWordChar(ch, helper); }\r\n          : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\r\n          : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\r\n        while (start > 0 && check(line.charAt(start - 1))) { --start; }\r\n        while (end < line.length && check(line.charAt(end))) { ++end; }\r\n      }\r\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\r\n    },\r\n\r\n    toggleOverwrite: function(value) {\r\n      if (value != null && value == this.state.overwrite) { return }\r\n      if (this.state.overwrite = !this.state.overwrite)\r\n        { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\r\n      else\r\n        { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\r\n\r\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\r\n    },\r\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\r\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\r\n\r\n    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\r\n    getScrollInfo: function() {\r\n      var scroller = this.display.scroller;\r\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\r\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\r\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\r\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\r\n    },\r\n\r\n    scrollIntoView: methodOp(function(range$$1, margin) {\r\n      if (range$$1 == null) {\r\n        range$$1 = {from: this.doc.sel.primary().head, to: null};\r\n        if (margin == null) { margin = this.options.cursorScrollMargin; }\r\n      } else if (typeof range$$1 == \"number\") {\r\n        range$$1 = {from: Pos(range$$1, 0), to: null};\r\n      } else if (range$$1.from == null) {\r\n        range$$1 = {from: range$$1, to: null};\r\n      }\r\n      if (!range$$1.to) { range$$1.to = range$$1.from; }\r\n      range$$1.margin = margin || 0;\r\n\r\n      if (range$$1.from.line != null) {\r\n        scrollToRange(this, range$$1);\r\n      } else {\r\n        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\r\n      }\r\n    }),\r\n\r\n    setSize: methodOp(function(width, height) {\r\n      var this$1 = this;\r\n\r\n      var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\r\n      if (width != null) { this.display.wrapper.style.width = interpret(width); }\r\n      if (height != null) { this.display.wrapper.style.height = interpret(height); }\r\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\r\n      var lineNo$$1 = this.display.viewFrom;\r\n      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\r\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\r\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\r\n        ++lineNo$$1;\r\n      });\r\n      this.curOp.forceUpdate = true;\r\n      signal(this, \"refresh\", this);\r\n    }),\r\n\r\n    operation: function(f){return runInOp(this, f)},\r\n\r\n    refresh: methodOp(function() {\r\n      var oldHeight = this.display.cachedTextHeight;\r\n      regChange(this);\r\n      this.curOp.forceUpdate = true;\r\n      clearCaches(this);\r\n      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\r\n      updateGutterSpace(this);\r\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\r\n        { estimateLineHeights(this); }\r\n      signal(this, \"refresh\", this);\r\n    }),\r\n\r\n    swapDoc: methodOp(function(doc) {\r\n      var old = this.doc;\r\n      old.cm = null;\r\n      attachDoc(this, doc);\r\n      clearCaches(this);\r\n      this.display.input.reset();\r\n      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\r\n      this.curOp.forceScroll = true;\r\n      signalLater(this, \"swapDoc\", this, old);\r\n      return old\r\n    }),\r\n\r\n    getInputField: function(){return this.display.input.getField()},\r\n    getWrapperElement: function(){return this.display.wrapper},\r\n    getScrollerElement: function(){return this.display.scroller},\r\n    getGutterElement: function(){return this.display.gutters}\r\n  };\r\n  eventMixin(CodeMirror);\r\n\r\n  CodeMirror.registerHelper = function(type, name, value) {\r\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\r\n    helpers[type][name] = value;\r\n  };\r\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\r\n    CodeMirror.registerHelper(type, name, value);\r\n    helpers[type]._global.push({pred: predicate, val: value});\r\n  };\r\n};\r\n\r\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\r\n// right), unit can be \"char\", \"column\" (like char, but doesn't\r\n// cross line boundaries), \"word\" (across next word), or \"group\" (to\r\n// the start of next group of word or non-word-non-whitespace\r\n// chars). The visually param controls whether, in right-to-left\r\n// text, direction 1 means to move towards the next index in the\r\n// string, or towards the character to the right of the current\r\n// position. The resulting position will have a hitSide=true\r\n// property if it reached the end of the document.\r\nfunction findPosH(doc, pos, dir, unit, visually) {\r\n  var oldPos = pos;\r\n  var origDir = dir;\r\n  var lineObj = getLine(doc, pos.line);\r\n  function findNextLine() {\r\n    var l = pos.line + dir;\r\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\r\n    pos = new Pos(l, pos.ch, pos.sticky);\r\n    return lineObj = getLine(doc, l)\r\n  }\r\n  function moveOnce(boundToLine) {\r\n    var next;\r\n    if (visually) {\r\n      next = moveVisually(doc.cm, lineObj, pos, dir);\r\n    } else {\r\n      next = moveLogically(lineObj, pos, dir);\r\n    }\r\n    if (next == null) {\r\n      if (!boundToLine && findNextLine())\r\n        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\r\n      else\r\n        { return false }\r\n    } else {\r\n      pos = next;\r\n    }\r\n    return true\r\n  }\r\n\r\n  if (unit == \"char\") {\r\n    moveOnce();\r\n  } else if (unit == \"column\") {\r\n    moveOnce(true);\r\n  } else if (unit == \"word\" || unit == \"group\") {\r\n    var sawType = null, group = unit == \"group\";\r\n    var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\r\n    for (var first = true;; first = false) {\r\n      if (dir < 0 && !moveOnce(!first)) { break }\r\n      var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\r\n      var type = isWordChar(cur, helper) ? \"w\"\r\n        : group && cur == \"\\n\" ? \"n\"\r\n        : !group || /\\s/.test(cur) ? null\r\n        : \"p\";\r\n      if (group && !first && !type) { type = \"s\"; }\r\n      if (sawType && sawType != type) {\r\n        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\r\n        break\r\n      }\r\n\r\n      if (type) { sawType = type; }\r\n      if (dir > 0 && !moveOnce(!first)) { break }\r\n    }\r\n  }\r\n  var result = skipAtomic(doc, pos, oldPos, origDir, true);\r\n  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\r\n  return result\r\n}\r\n\r\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\r\n// \"page\" or \"line\". The resulting position will have a hitSide=true\r\n// property if it reached the end of the document.\r\nfunction findPosV(cm, pos, dir, unit) {\r\n  var doc = cm.doc, x = pos.left, y;\r\n  if (unit == \"page\") {\r\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\r\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\r\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\r\n\r\n  } else if (unit == \"line\") {\r\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\r\n  }\r\n  var target;\r\n  for (;;) {\r\n    target = coordsChar(cm, x, y);\r\n    if (!target.outside) { break }\r\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\r\n    y += dir * 5;\r\n  }\r\n  return target\r\n}\r\n\r\n// CONTENTEDITABLE INPUT STYLE\r\n\r\nvar ContentEditableInput = function(cm) {\r\n  this.cm = cm;\r\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\r\n  this.polling = new Delayed();\r\n  this.composing = null;\r\n  this.gracePeriod = false;\r\n  this.readDOMTimeout = null;\r\n};\r\n\r\nContentEditableInput.prototype.init = function (display) {\r\n    var this$1 = this;\r\n\r\n  var input = this, cm = input.cm;\r\n  var div = input.div = display.lineDiv;\r\n  disableBrowserMagic(div, cm.options.spellcheck);\r\n\r\n  on(div, \"paste\", function (e) {\r\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\r\n    // IE doesn't fire input events, so we schedule a read for the pasted content in this way\r\n    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\r\n  });\r\n\r\n  on(div, \"compositionstart\", function (e) {\r\n    this$1.composing = {data: e.data, done: false};\r\n  });\r\n  on(div, \"compositionupdate\", function (e) {\r\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\r\n  });\r\n  on(div, \"compositionend\", function (e) {\r\n    if (this$1.composing) {\r\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\r\n      this$1.composing.done = true;\r\n    }\r\n  });\r\n\r\n  on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\r\n\r\n  on(div, \"input\", function () {\r\n    if (!this$1.composing) { this$1.readFromDOMSoon(); }\r\n  });\r\n\r\n  function onCopyCut(e) {\r\n    if (signalDOMEvent(cm, e)) { return }\r\n    if (cm.somethingSelected()) {\r\n      setLastCopied({lineWise: false, text: cm.getSelections()});\r\n      if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\r\n    } else if (!cm.options.lineWiseCopyCut) {\r\n      return\r\n    } else {\r\n      var ranges = copyableRanges(cm);\r\n      setLastCopied({lineWise: true, text: ranges.text});\r\n      if (e.type == \"cut\") {\r\n        cm.operation(function () {\r\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll);\r\n          cm.replaceSelection(\"\", null, \"cut\");\r\n        });\r\n      }\r\n    }\r\n    if (e.clipboardData) {\r\n      e.clipboardData.clearData();\r\n      var content = lastCopied.text.join(\"\\n\");\r\n      // iOS exposes the clipboard API, but seems to discard content inserted into it\r\n      e.clipboardData.setData(\"Text\", content);\r\n      if (e.clipboardData.getData(\"Text\") == content) {\r\n        e.preventDefault();\r\n        return\r\n      }\r\n    }\r\n    // Old-fashioned briefly-focus-a-textarea hack\r\n    var kludge = hiddenTextarea(), te = kludge.firstChild;\r\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\r\n    te.value = lastCopied.text.join(\"\\n\");\r\n    var hadFocus = document.activeElement;\r\n    selectInput(te);\r\n    setTimeout(function () {\r\n      cm.display.lineSpace.removeChild(kludge);\r\n      hadFocus.focus();\r\n      if (hadFocus == div) { input.showPrimarySelection(); }\r\n    }, 50);\r\n  }\r\n  on(div, \"copy\", onCopyCut);\r\n  on(div, \"cut\", onCopyCut);\r\n};\r\n\r\nContentEditableInput.prototype.prepareSelection = function () {\r\n  var result = prepareSelection(this.cm, false);\r\n  result.focus = this.cm.state.focused;\r\n  return result\r\n};\r\n\r\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\r\n  if (!info || !this.cm.display.view.length) { return }\r\n  if (info.focus || takeFocus) { this.showPrimarySelection(); }\r\n  this.showMultipleSelections(info);\r\n};\r\n\r\nContentEditableInput.prototype.showPrimarySelection = function () {\r\n  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\r\n  var from = prim.from(), to = prim.to();\r\n\r\n  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\r\n    sel.removeAllRanges();\r\n    return\r\n  }\r\n\r\n  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\r\n  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\r\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\r\n      cmp(minPos(curAnchor, curFocus), from) == 0 &&\r\n      cmp(maxPos(curAnchor, curFocus), to) == 0)\r\n    { return }\r\n\r\n  var view = cm.display.view;\r\n  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\r\n      {node: view[0].measure.map[2], offset: 0};\r\n  var end = to.line < cm.display.viewTo && posToDOM(cm, to);\r\n  if (!end) {\r\n    var measure = view[view.length - 1].measure;\r\n    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\r\n    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\r\n  }\r\n\r\n  if (!start || !end) {\r\n    sel.removeAllRanges();\r\n    return\r\n  }\r\n\r\n  var old = sel.rangeCount && sel.getRangeAt(0), rng;\r\n  try { rng = range(start.node, start.offset, end.offset, end.node); }\r\n  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\r\n  if (rng) {\r\n    if (!gecko && cm.state.focused) {\r\n      sel.collapse(start.node, start.offset);\r\n      if (!rng.collapsed) {\r\n        sel.removeAllRanges();\r\n        sel.addRange(rng);\r\n      }\r\n    } else {\r\n      sel.removeAllRanges();\r\n      sel.addRange(rng);\r\n    }\r\n    if (old && sel.anchorNode == null) { sel.addRange(old); }\r\n    else if (gecko) { this.startGracePeriod(); }\r\n  }\r\n  this.rememberSelection();\r\n};\r\n\r\nContentEditableInput.prototype.startGracePeriod = function () {\r\n    var this$1 = this;\r\n\r\n  clearTimeout(this.gracePeriod);\r\n  this.gracePeriod = setTimeout(function () {\r\n    this$1.gracePeriod = false;\r\n    if (this$1.selectionChanged())\r\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\r\n  }, 20);\r\n};\r\n\r\nContentEditableInput.prototype.showMultipleSelections = function (info) {\r\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\r\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\r\n};\r\n\r\nContentEditableInput.prototype.rememberSelection = function () {\r\n  var sel = window.getSelection();\r\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\r\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\r\n};\r\n\r\nContentEditableInput.prototype.selectionInEditor = function () {\r\n  var sel = window.getSelection();\r\n  if (!sel.rangeCount) { return false }\r\n  var node = sel.getRangeAt(0).commonAncestorContainer;\r\n  return contains(this.div, node)\r\n};\r\n\r\nContentEditableInput.prototype.focus = function () {\r\n  if (this.cm.options.readOnly != \"nocursor\") {\r\n    if (!this.selectionInEditor())\r\n      { this.showSelection(this.prepareSelection(), true); }\r\n    this.div.focus();\r\n  }\r\n};\r\nContentEditableInput.prototype.blur = function () { this.div.blur(); };\r\nContentEditableInput.prototype.getField = function () { return this.div };\r\n\r\nContentEditableInput.prototype.supportsTouch = function () { return true };\r\n\r\nContentEditableInput.prototype.receivedFocus = function () {\r\n  var input = this;\r\n  if (this.selectionInEditor())\r\n    { this.pollSelection(); }\r\n  else\r\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\r\n\r\n  function poll() {\r\n    if (input.cm.state.focused) {\r\n      input.pollSelection();\r\n      input.polling.set(input.cm.options.pollInterval, poll);\r\n    }\r\n  }\r\n  this.polling.set(this.cm.options.pollInterval, poll);\r\n};\r\n\r\nContentEditableInput.prototype.selectionChanged = function () {\r\n  var sel = window.getSelection();\r\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\r\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\r\n};\r\n\r\nContentEditableInput.prototype.pollSelection = function () {\r\n  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\r\n  var sel = window.getSelection(), cm = this.cm;\r\n  // On Android Chrome (version 56, at least), backspacing into an\r\n  // uneditable block element will put the cursor in that element,\r\n  // and then, because it's not editable, hide the virtual keyboard.\r\n  // Because Android doesn't allow us to actually detect backspace\r\n  // presses in a sane way, this code checks for when that happens\r\n  // and simulates a backspace press in this case.\r\n  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\r\n    this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\r\n    this.blur();\r\n    this.focus();\r\n    return\r\n  }\r\n  if (this.composing) { return }\r\n  this.rememberSelection();\r\n  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\r\n  var head = domToPos(cm, sel.focusNode, sel.focusOffset);\r\n  if (anchor && head) { runInOp(cm, function () {\r\n    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\r\n    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\r\n  }); }\r\n};\r\n\r\nContentEditableInput.prototype.pollContent = function () {\r\n  if (this.readDOMTimeout != null) {\r\n    clearTimeout(this.readDOMTimeout);\r\n    this.readDOMTimeout = null;\r\n  }\r\n\r\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\r\n  var from = sel.from(), to = sel.to();\r\n  if (from.ch == 0 && from.line > cm.firstLine())\r\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\r\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\r\n    { to = Pos(to.line + 1, 0); }\r\n  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\r\n\r\n  var fromIndex, fromLine, fromNode;\r\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\r\n    fromLine = lineNo(display.view[0].line);\r\n    fromNode = display.view[0].node;\r\n  } else {\r\n    fromLine = lineNo(display.view[fromIndex].line);\r\n    fromNode = display.view[fromIndex - 1].node.nextSibling;\r\n  }\r\n  var toIndex = findViewIndex(cm, to.line);\r\n  var toLine, toNode;\r\n  if (toIndex == display.view.length - 1) {\r\n    toLine = display.viewTo - 1;\r\n    toNode = display.lineDiv.lastChild;\r\n  } else {\r\n    toLine = lineNo(display.view[toIndex + 1].line) - 1;\r\n    toNode = display.view[toIndex + 1].node.previousSibling;\r\n  }\r\n\r\n  if (!fromNode) { return false }\r\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\r\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\r\n  while (newText.length > 1 && oldText.length > 1) {\r\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\r\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\r\n    else { break }\r\n  }\r\n\r\n  var cutFront = 0, cutEnd = 0;\r\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\r\n  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\r\n    { ++cutFront; }\r\n  var newBot = lst(newText), oldBot = lst(oldText);\r\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\r\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0));\r\n  while (cutEnd < maxCutEnd &&\r\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\r\n    { ++cutEnd; }\r\n  // Try to move start of change to start of selection if ambiguous\r\n  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\r\n    while (cutFront && cutFront > from.ch &&\r\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\r\n      cutFront--;\r\n      cutEnd++;\r\n    }\r\n  }\r\n\r\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\r\n  newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\r\n\r\n  var chFrom = Pos(fromLine, cutFront);\r\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\r\n  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\r\n    replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\r\n    return true\r\n  }\r\n};\r\n\r\nContentEditableInput.prototype.ensurePolled = function () {\r\n  this.forceCompositionEnd();\r\n};\r\nContentEditableInput.prototype.reset = function () {\r\n  this.forceCompositionEnd();\r\n};\r\nContentEditableInput.prototype.forceCompositionEnd = function () {\r\n  if (!this.composing) { return }\r\n  clearTimeout(this.readDOMTimeout);\r\n  this.composing = null;\r\n  this.updateFromDOM();\r\n  this.div.blur();\r\n  this.div.focus();\r\n};\r\nContentEditableInput.prototype.readFromDOMSoon = function () {\r\n    var this$1 = this;\r\n\r\n  if (this.readDOMTimeout != null) { return }\r\n  this.readDOMTimeout = setTimeout(function () {\r\n    this$1.readDOMTimeout = null;\r\n    if (this$1.composing) {\r\n      if (this$1.composing.done) { this$1.composing = null; }\r\n      else { return }\r\n    }\r\n    this$1.updateFromDOM();\r\n  }, 80);\r\n};\r\n\r\nContentEditableInput.prototype.updateFromDOM = function () {\r\n    var this$1 = this;\r\n\r\n  if (this.cm.isReadOnly() || !this.pollContent())\r\n    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\r\n};\r\n\r\nContentEditableInput.prototype.setUneditable = function (node) {\r\n  node.contentEditable = \"false\";\r\n};\r\n\r\nContentEditableInput.prototype.onKeyPress = function (e) {\r\n  if (e.charCode == 0) { return }\r\n  e.preventDefault();\r\n  if (!this.cm.isReadOnly())\r\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\r\n};\r\n\r\nContentEditableInput.prototype.readOnlyChanged = function (val) {\r\n  this.div.contentEditable = String(val != \"nocursor\");\r\n};\r\n\r\nContentEditableInput.prototype.onContextMenu = function () {};\r\nContentEditableInput.prototype.resetPosition = function () {};\r\n\r\nContentEditableInput.prototype.needsContentAttribute = true;\r\n\r\nfunction posToDOM(cm, pos) {\r\n  var view = findViewForLine(cm, pos.line);\r\n  if (!view || view.hidden) { return null }\r\n  var line = getLine(cm.doc, pos.line);\r\n  var info = mapFromLineView(view, line, pos.line);\r\n\r\n  var order = getOrder(line, cm.doc.direction), side = \"left\";\r\n  if (order) {\r\n    var partPos = getBidiPartAt(order, pos.ch);\r\n    side = partPos % 2 ? \"right\" : \"left\";\r\n  }\r\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\r\n  result.offset = result.collapse == \"right\" ? result.end : result.start;\r\n  return result\r\n}\r\n\r\nfunction isInGutter(node) {\r\n  for (var scan = node; scan; scan = scan.parentNode)\r\n    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\r\n  return false\r\n}\r\n\r\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\r\n\r\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\r\n  var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\r\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\r\n  function close() {\r\n    if (closing) {\r\n      text += lineSep;\r\n      closing = false;\r\n    }\r\n  }\r\n  function addText(str) {\r\n    if (str) {\r\n      close();\r\n      text += str;\r\n    }\r\n  }\r\n  function walk(node) {\r\n    if (node.nodeType == 1) {\r\n      var cmText = node.getAttribute(\"cm-text\");\r\n      if (cmText != null) {\r\n        addText(cmText || node.textContent.replace(/\\u200b/g, \"\"));\r\n        return\r\n      }\r\n      var markerID = node.getAttribute(\"cm-marker\"), range$$1;\r\n      if (markerID) {\r\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\r\n        if (found.length && (range$$1 = found[0].find()))\r\n          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\r\n        return\r\n      }\r\n      if (node.getAttribute(\"contenteditable\") == \"false\") { return }\r\n      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);\r\n      if (isBlock) { close(); }\r\n      for (var i = 0; i < node.childNodes.length; i++)\r\n        { walk(node.childNodes[i]); }\r\n      if (isBlock) { closing = true; }\r\n    } else if (node.nodeType == 3) {\r\n      addText(node.nodeValue);\r\n    }\r\n  }\r\n  for (;;) {\r\n    walk(from);\r\n    if (from == to) { break }\r\n    from = from.nextSibling;\r\n  }\r\n  return text\r\n}\r\n\r\nfunction domToPos(cm, node, offset) {\r\n  var lineNode;\r\n  if (node == cm.display.lineDiv) {\r\n    lineNode = cm.display.lineDiv.childNodes[offset];\r\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\r\n    node = null; offset = 0;\r\n  } else {\r\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\r\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\r\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\r\n    }\r\n  }\r\n  for (var i = 0; i < cm.display.view.length; i++) {\r\n    var lineView = cm.display.view[i];\r\n    if (lineView.node == lineNode)\r\n      { return locateNodeInLineView(lineView, node, offset) }\r\n  }\r\n}\r\n\r\nfunction locateNodeInLineView(lineView, node, offset) {\r\n  var wrapper = lineView.text.firstChild, bad = false;\r\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\r\n  if (node == wrapper) {\r\n    bad = true;\r\n    node = wrapper.childNodes[offset];\r\n    offset = 0;\r\n    if (!node) {\r\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line;\r\n      return badPos(Pos(lineNo(line), line.text.length), bad)\r\n    }\r\n  }\r\n\r\n  var textNode = node.nodeType == 3 ? node : null, topNode = node;\r\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\r\n    textNode = node.firstChild;\r\n    if (offset) { offset = textNode.nodeValue.length; }\r\n  }\r\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\r\n  var measure = lineView.measure, maps = measure.maps;\r\n\r\n  function find(textNode, topNode, offset) {\r\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\r\n      var map$$1 = i < 0 ? measure.map : maps[i];\r\n      for (var j = 0; j < map$$1.length; j += 3) {\r\n        var curNode = map$$1[j + 2];\r\n        if (curNode == textNode || curNode == topNode) {\r\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\r\n          var ch = map$$1[j] + offset;\r\n          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\r\n          return Pos(line, ch)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  var found = find(textNode, topNode, offset);\r\n  if (found) { return badPos(found, bad) }\r\n\r\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\r\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\r\n    found = find(after, after.firstChild, 0);\r\n    if (found)\r\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\r\n    else\r\n      { dist += after.textContent.length; }\r\n  }\r\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\r\n    found = find(before, before.firstChild, -1);\r\n    if (found)\r\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\r\n    else\r\n      { dist$1 += before.textContent.length; }\r\n  }\r\n}\r\n\r\n// TEXTAREA INPUT STYLE\r\n\r\nvar TextareaInput = function(cm) {\r\n  this.cm = cm;\r\n  // See input.poll and input.reset\r\n  this.prevInput = \"\";\r\n\r\n  // Flag that indicates whether we expect input to appear real soon\r\n  // now (after some event like 'keypress' or 'input') and are\r\n  // polling intensively.\r\n  this.pollingFast = false;\r\n  // Self-resetting timeout for the poller\r\n  this.polling = new Delayed();\r\n  // Tracks when input.reset has punted to just putting a short\r\n  // string into the textarea instead of the full selection.\r\n  this.inaccurateSelection = false;\r\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\r\n  this.hasSelection = false;\r\n  this.composing = null;\r\n};\r\n\r\nTextareaInput.prototype.init = function (display) {\r\n    var this$1 = this;\r\n\r\n  var input = this, cm = this.cm;\r\n\r\n  // Wraps and hides input textarea\r\n  var div = this.wrapper = hiddenTextarea();\r\n  // The semihidden textarea that is focused when the editor is\r\n  // focused, and receives input.\r\n  var te = this.textarea = div.firstChild;\r\n  display.wrapper.insertBefore(div, display.wrapper.firstChild);\r\n\r\n  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\r\n  if (ios) { te.style.width = \"0px\"; }\r\n\r\n  on(te, \"input\", function () {\r\n    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\r\n    input.poll();\r\n  });\r\n\r\n  on(te, \"paste\", function (e) {\r\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\r\n\r\n    cm.state.pasteIncoming = true;\r\n    input.fastPoll();\r\n  });\r\n\r\n  function prepareCopyCut(e) {\r\n    if (signalDOMEvent(cm, e)) { return }\r\n    if (cm.somethingSelected()) {\r\n      setLastCopied({lineWise: false, text: cm.getSelections()});\r\n      if (input.inaccurateSelection) {\r\n        input.prevInput = \"\";\r\n        input.inaccurateSelection = false;\r\n        te.value = lastCopied.text.join(\"\\n\");\r\n        selectInput(te);\r\n      }\r\n    } else if (!cm.options.lineWiseCopyCut) {\r\n      return\r\n    } else {\r\n      var ranges = copyableRanges(cm);\r\n      setLastCopied({lineWise: true, text: ranges.text});\r\n      if (e.type == \"cut\") {\r\n        cm.setSelections(ranges.ranges, null, sel_dontScroll);\r\n      } else {\r\n        input.prevInput = \"\";\r\n        te.value = ranges.text.join(\"\\n\");\r\n        selectInput(te);\r\n      }\r\n    }\r\n    if (e.type == \"cut\") { cm.state.cutIncoming = true; }\r\n  }\r\n  on(te, \"cut\", prepareCopyCut);\r\n  on(te, \"copy\", prepareCopyCut);\r\n\r\n  on(display.scroller, \"paste\", function (e) {\r\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\r\n    cm.state.pasteIncoming = true;\r\n    input.focus();\r\n  });\r\n\r\n  // Prevent normal selection in the editor (we handle our own)\r\n  on(display.lineSpace, \"selectstart\", function (e) {\r\n    if (!eventInWidget(display, e)) { e_preventDefault(e); }\r\n  });\r\n\r\n  on(te, \"compositionstart\", function () {\r\n    var start = cm.getCursor(\"from\");\r\n    if (input.composing) { input.composing.range.clear(); }\r\n    input.composing = {\r\n      start: start,\r\n      range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\r\n    };\r\n  });\r\n  on(te, \"compositionend\", function () {\r\n    if (input.composing) {\r\n      input.poll();\r\n      input.composing.range.clear();\r\n      input.composing = null;\r\n    }\r\n  });\r\n};\r\n\r\nTextareaInput.prototype.prepareSelection = function () {\r\n  // Redraw the selection and/or cursor\r\n  var cm = this.cm, display = cm.display, doc = cm.doc;\r\n  var result = prepareSelection(cm);\r\n\r\n  // Move the hidden textarea near the cursor to prevent scrolling artifacts\r\n  if (cm.options.moveInputWithCursor) {\r\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\r\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\r\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\r\n                                        headPos.top + lineOff.top - wrapOff.top));\r\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\r\n                                         headPos.left + lineOff.left - wrapOff.left));\r\n  }\r\n\r\n  return result\r\n};\r\n\r\nTextareaInput.prototype.showSelection = function (drawn) {\r\n  var cm = this.cm, display = cm.display;\r\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\r\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection);\r\n  if (drawn.teTop != null) {\r\n    this.wrapper.style.top = drawn.teTop + \"px\";\r\n    this.wrapper.style.left = drawn.teLeft + \"px\";\r\n  }\r\n};\r\n\r\n// Reset the input to correspond to the selection (or to be empty,\r\n// when not typing and nothing is selected)\r\nTextareaInput.prototype.reset = function (typing) {\r\n  if (this.contextMenuPending || this.composing) { return }\r\n  var minimal, selected, cm = this.cm, doc = cm.doc;\r\n  if (cm.somethingSelected()) {\r\n    this.prevInput = \"\";\r\n    var range$$1 = doc.sel.primary();\r\n    minimal = hasCopyEvent &&\r\n      (range$$1.to().line - range$$1.from().line > 100 || (selected = cm.getSelection()).length > 1000);\r\n    var content = minimal ? \"-\" : selected || cm.getSelection();\r\n    this.textarea.value = content;\r\n    if (cm.state.focused) { selectInput(this.textarea); }\r\n    if (ie && ie_version >= 9) { this.hasSelection = content; }\r\n  } else if (!typing) {\r\n    this.prevInput = this.textarea.value = \"\";\r\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\r\n  }\r\n  this.inaccurateSelection = minimal;\r\n};\r\n\r\nTextareaInput.prototype.getField = function () { return this.textarea };\r\n\r\nTextareaInput.prototype.supportsTouch = function () { return false };\r\n\r\nTextareaInput.prototype.focus = function () {\r\n  if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\r\n    try { this.textarea.focus(); }\r\n    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\r\n  }\r\n};\r\n\r\nTextareaInput.prototype.blur = function () { this.textarea.blur(); };\r\n\r\nTextareaInput.prototype.resetPosition = function () {\r\n  this.wrapper.style.top = this.wrapper.style.left = 0;\r\n};\r\n\r\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\r\n\r\n// Poll for input changes, using the normal rate of polling. This\r\n// runs as long as the editor is focused.\r\nTextareaInput.prototype.slowPoll = function () {\r\n    var this$1 = this;\r\n\r\n  if (this.pollingFast) { return }\r\n  this.polling.set(this.cm.options.pollInterval, function () {\r\n    this$1.poll();\r\n    if (this$1.cm.state.focused) { this$1.slowPoll(); }\r\n  });\r\n};\r\n\r\n// When an event has just come in that is likely to add or change\r\n// something in the input textarea, we poll faster, to ensure that\r\n// the change appears on the screen quickly.\r\nTextareaInput.prototype.fastPoll = function () {\r\n  var missed = false, input = this;\r\n  input.pollingFast = true;\r\n  function p() {\r\n    var changed = input.poll();\r\n    if (!changed && !missed) {missed = true; input.polling.set(60, p);}\r\n    else {input.pollingFast = false; input.slowPoll();}\r\n  }\r\n  input.polling.set(20, p);\r\n};\r\n\r\n// Read input from the textarea, and update the document to match.\r\n// When something is selected, it is present in the textarea, and\r\n// selected (unless it is huge, in which case a placeholder is\r\n// used). When nothing is selected, the cursor sits after previously\r\n// seen text (can be empty), which is stored in prevInput (we must\r\n// not reset the textarea when typing, because that breaks IME).\r\nTextareaInput.prototype.poll = function () {\r\n    var this$1 = this;\r\n\r\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\r\n  // Since this is called a *lot*, try to bail out as cheaply as\r\n  // possible when it is clear that nothing happened. hasSelection\r\n  // will be the case when there is a lot of text in the textarea,\r\n  // in which case reading its value would be expensive.\r\n  if (this.contextMenuPending || !cm.state.focused ||\r\n      (hasSelection(input) && !prevInput && !this.composing) ||\r\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\r\n    { return false }\r\n\r\n  var text = input.value;\r\n  // If nothing changed, bail.\r\n  if (text == prevInput && !cm.somethingSelected()) { return false }\r\n  // Work around nonsensical selection resetting in IE9/10, and\r\n  // inexplicable appearance of private area unicode characters on\r\n  // some key combos in Mac (#2689).\r\n  if (ie && ie_version >= 9 && this.hasSelection === text ||\r\n      mac && /[\\uf700-\\uf7ff]/.test(text)) {\r\n    cm.display.input.reset();\r\n    return false\r\n  }\r\n\r\n  if (cm.doc.sel == cm.display.selForContextMenu) {\r\n    var first = text.charCodeAt(0);\r\n    if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\r\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\r\n  }\r\n  // Find the part of the input that is actually new\r\n  var same = 0, l = Math.min(prevInput.length, text.length);\r\n  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\r\n\r\n  runInOp(cm, function () {\r\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\r\n                   null, this$1.composing ? \"*compose\" : null);\r\n\r\n    // Don't leave long text in the textarea, since it makes further polling slow\r\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\r\n    else { this$1.prevInput = text; }\r\n\r\n    if (this$1.composing) {\r\n      this$1.composing.range.clear();\r\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\r\n                                         {className: \"CodeMirror-composing\"});\r\n    }\r\n  });\r\n  return true\r\n};\r\n\r\nTextareaInput.prototype.ensurePolled = function () {\r\n  if (this.pollingFast && this.poll()) { this.pollingFast = false; }\r\n};\r\n\r\nTextareaInput.prototype.onKeyPress = function () {\r\n  if (ie && ie_version >= 9) { this.hasSelection = null; }\r\n  this.fastPoll();\r\n};\r\n\r\nTextareaInput.prototype.onContextMenu = function (e) {\r\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea;\r\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\r\n  if (!pos || presto) { return } // Opera is difficult.\r\n\r\n  // Reset the current text selection only if the click is done outside of the selection\r\n  // and 'resetSelectionOnContextMenu' option is true.\r\n  var reset = cm.options.resetSelectionOnContextMenu;\r\n  if (reset && cm.doc.sel.contains(pos) == -1)\r\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\r\n\r\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\r\n  input.wrapper.style.cssText = \"position: absolute\";\r\n  var wrapperBox = input.wrapper.getBoundingClientRect();\r\n  te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\r\n  var oldScrollY;\r\n  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\r\n  display.input.focus();\r\n  if (webkit) { window.scrollTo(null, oldScrollY); }\r\n  display.input.reset();\r\n  // Adds \"Select all\" to context menu in FF\r\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\r\n  input.contextMenuPending = true;\r\n  display.selForContextMenu = cm.doc.sel;\r\n  clearTimeout(display.detectingSelectAll);\r\n\r\n  // Select-all will be greyed out if there's nothing to select, so\r\n  // this adds a zero-width space so that we can later check whether\r\n  // it got selected.\r\n  function prepareSelectAllHack() {\r\n    if (te.selectionStart != null) {\r\n      var selected = cm.somethingSelected();\r\n      var extval = \"\\u200b\" + (selected ? te.value : \"\");\r\n      te.value = \"\\u21da\"; // Used to catch context-menu undo\r\n      te.value = extval;\r\n      input.prevInput = selected ? \"\" : \"\\u200b\";\r\n      te.selectionStart = 1; te.selectionEnd = extval.length;\r\n      // Re-set this, in case some other handler touched the\r\n      // selection in the meantime.\r\n      display.selForContextMenu = cm.doc.sel;\r\n    }\r\n  }\r\n  function rehide() {\r\n    input.contextMenuPending = false;\r\n    input.wrapper.style.cssText = oldWrapperCSS;\r\n    te.style.cssText = oldCSS;\r\n    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\r\n\r\n    // Try to detect the user choosing select-all\r\n    if (te.selectionStart != null) {\r\n      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\r\n      var i = 0, poll = function () {\r\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\r\n            te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\r\n          operation(cm, selectAll)(cm);\r\n        } else if (i++ < 10) {\r\n          display.detectingSelectAll = setTimeout(poll, 500);\r\n        } else {\r\n          display.selForContextMenu = null;\r\n          display.input.reset();\r\n        }\r\n      };\r\n      display.detectingSelectAll = setTimeout(poll, 200);\r\n    }\r\n  }\r\n\r\n  if (ie && ie_version >= 9) { prepareSelectAllHack(); }\r\n  if (captureRightClick) {\r\n    e_stop(e);\r\n    var mouseup = function () {\r\n      off(window, \"mouseup\", mouseup);\r\n      setTimeout(rehide, 20);\r\n    };\r\n    on(window, \"mouseup\", mouseup);\r\n  } else {\r\n    setTimeout(rehide, 50);\r\n  }\r\n};\r\n\r\nTextareaInput.prototype.readOnlyChanged = function (val) {\r\n  if (!val) { this.reset(); }\r\n};\r\n\r\nTextareaInput.prototype.setUneditable = function () {};\r\n\r\nTextareaInput.prototype.needsContentAttribute = false;\r\n\r\nfunction fromTextArea(textarea, options) {\r\n  options = options ? copyObj(options) : {};\r\n  options.value = textarea.value;\r\n  if (!options.tabindex && textarea.tabIndex)\r\n    { options.tabindex = textarea.tabIndex; }\r\n  if (!options.placeholder && textarea.placeholder)\r\n    { options.placeholder = textarea.placeholder; }\r\n  // Set autofocus to true if this textarea is focused, or if it has\r\n  // autofocus and no other element is focused.\r\n  if (options.autofocus == null) {\r\n    var hasFocus = activeElt();\r\n    options.autofocus = hasFocus == textarea ||\r\n      textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\r\n  }\r\n\r\n  function save() {textarea.value = cm.getValue();}\r\n\r\n  var realSubmit;\r\n  if (textarea.form) {\r\n    on(textarea.form, \"submit\", save);\r\n    // Deplorable hack to make the submit method do the right thing.\r\n    if (!options.leaveSubmitMethodAlone) {\r\n      var form = textarea.form;\r\n      realSubmit = form.submit;\r\n      try {\r\n        var wrappedSubmit = form.submit = function () {\r\n          save();\r\n          form.submit = realSubmit;\r\n          form.submit();\r\n          form.submit = wrappedSubmit;\r\n        };\r\n      } catch(e) {}\r\n    }\r\n  }\r\n\r\n  options.finishInit = function (cm) {\r\n    cm.save = save;\r\n    cm.getTextArea = function () { return textarea; };\r\n    cm.toTextArea = function () {\r\n      cm.toTextArea = isNaN; // Prevent this from being ran twice\r\n      save();\r\n      textarea.parentNode.removeChild(cm.getWrapperElement());\r\n      textarea.style.display = \"\";\r\n      if (textarea.form) {\r\n        off(textarea.form, \"submit\", save);\r\n        if (typeof textarea.form.submit == \"function\")\r\n          { textarea.form.submit = realSubmit; }\r\n      }\r\n    };\r\n  };\r\n\r\n  textarea.style.display = \"none\";\r\n  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\r\n    options);\r\n  return cm\r\n}\r\n\r\nfunction addLegacyProps(CodeMirror) {\r\n  CodeMirror.off = off;\r\n  CodeMirror.on = on;\r\n  CodeMirror.wheelEventPixels = wheelEventPixels;\r\n  CodeMirror.Doc = Doc;\r\n  CodeMirror.splitLines = splitLinesAuto;\r\n  CodeMirror.countColumn = countColumn;\r\n  CodeMirror.findColumn = findColumn;\r\n  CodeMirror.isWordChar = isWordCharBasic;\r\n  CodeMirror.Pass = Pass;\r\n  CodeMirror.signal = signal;\r\n  CodeMirror.Line = Line;\r\n  CodeMirror.changeEnd = changeEnd;\r\n  CodeMirror.scrollbarModel = scrollbarModel;\r\n  CodeMirror.Pos = Pos;\r\n  CodeMirror.cmpPos = cmp;\r\n  CodeMirror.modes = modes;\r\n  CodeMirror.mimeModes = mimeModes;\r\n  CodeMirror.resolveMode = resolveMode;\r\n  CodeMirror.getMode = getMode;\r\n  CodeMirror.modeExtensions = modeExtensions;\r\n  CodeMirror.extendMode = extendMode;\r\n  CodeMirror.copyState = copyState;\r\n  CodeMirror.startState = startState;\r\n  CodeMirror.innerMode = innerMode;\r\n  CodeMirror.commands = commands;\r\n  CodeMirror.keyMap = keyMap;\r\n  CodeMirror.keyName = keyName;\r\n  CodeMirror.isModifierKey = isModifierKey;\r\n  CodeMirror.lookupKey = lookupKey;\r\n  CodeMirror.normalizeKeyMap = normalizeKeyMap;\r\n  CodeMirror.StringStream = StringStream;\r\n  CodeMirror.SharedTextMarker = SharedTextMarker;\r\n  CodeMirror.TextMarker = TextMarker;\r\n  CodeMirror.LineWidget = LineWidget;\r\n  CodeMirror.e_preventDefault = e_preventDefault;\r\n  CodeMirror.e_stopPropagation = e_stopPropagation;\r\n  CodeMirror.e_stop = e_stop;\r\n  CodeMirror.addClass = addClass;\r\n  CodeMirror.contains = contains;\r\n  CodeMirror.rmClass = rmClass;\r\n  CodeMirror.keyNames = keyNames;\r\n}\r\n\r\n// EDITOR CONSTRUCTOR\r\n\r\ndefineOptions(CodeMirror$1);\r\n\r\naddEditorMethods(CodeMirror$1);\r\n\r\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\r\nvar dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\r\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\r\n  { CodeMirror$1.prototype[prop] = (function(method) {\r\n    return function() {return method.apply(this.doc, arguments)}\r\n  })(Doc.prototype[prop]); } }\r\n\r\neventMixin(Doc);\r\n\r\n// INPUT HANDLING\r\n\r\nCodeMirror$1.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\r\n\r\n// MODE DEFINITION AND QUERYING\r\n\r\n// Extra arguments are stored as the mode's dependencies, which is\r\n// used by (legacy) mechanisms like loadmode.js to automatically\r\n// load a mode. (Preferred mechanism is the require/define calls.)\r\nCodeMirror$1.defineMode = function(name/*, mode, …*/) {\r\n  if (!CodeMirror$1.defaults.mode && name != \"null\") { CodeMirror$1.defaults.mode = name; }\r\n  defineMode.apply(this, arguments);\r\n};\r\n\r\nCodeMirror$1.defineMIME = defineMIME;\r\n\r\n// Minimal default mode.\r\nCodeMirror$1.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\r\nCodeMirror$1.defineMIME(\"text/plain\", \"null\");\r\n\r\n// EXTENSIONS\r\n\r\nCodeMirror$1.defineExtension = function (name, func) {\r\n  CodeMirror$1.prototype[name] = func;\r\n};\r\nCodeMirror$1.defineDocExtension = function (name, func) {\r\n  Doc.prototype[name] = func;\r\n};\r\n\r\nCodeMirror$1.fromTextArea = fromTextArea;\r\n\r\naddLegacyProps(CodeMirror$1);\r\n\r\nCodeMirror$1.version = \"5.26.0\";\r\n\r\nreturn CodeMirror$1;\r\n\r\n})));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/lib/codemirror.js\n// module id = 877\n// module chunks = 18 21","'use strict'\r\n\r\nexports.byteLength = byteLength\r\nexports.toByteArray = toByteArray\r\nexports.fromByteArray = fromByteArray\r\n\r\nvar lookup = []\r\nvar revLookup = []\r\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\r\n\r\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\nfor (var i = 0, len = code.length; i < len; ++i) {\r\n  lookup[i] = code[i]\r\n  revLookup[code.charCodeAt(i)] = i\r\n}\r\n\r\nrevLookup['-'.charCodeAt(0)] = 62\r\nrevLookup['_'.charCodeAt(0)] = 63\r\n\r\nfunction placeHoldersCount (b64) {\r\n  var len = b64.length\r\n  if (len % 4 > 0) {\r\n    throw new Error('Invalid string. Length must be a multiple of 4')\r\n  }\r\n\r\n  // the number of equal signs (place holders)\r\n  // if there are two placeholders, than the two characters before it\r\n  // represent one byte\r\n  // if there is only one, then the three characters before it represent 2 bytes\r\n  // this is just a cheap hack to not do indexOf twice\r\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\r\n}\r\n\r\nfunction byteLength (b64) {\r\n  // base64 is 4/3 + up to two characters of the original data\r\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\r\n}\r\n\r\nfunction toByteArray (b64) {\r\n  var i, l, tmp, placeHolders, arr\r\n  var len = b64.length\r\n  placeHolders = placeHoldersCount(b64)\r\n\r\n  arr = new Arr((len * 3 / 4) - placeHolders)\r\n\r\n  // if there are placeholders, only get up to the last complete 4 chars\r\n  l = placeHolders > 0 ? len - 4 : len\r\n\r\n  var L = 0\r\n\r\n  for (i = 0; i < l; i += 4) {\r\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\r\n    arr[L++] = (tmp >> 16) & 0xFF\r\n    arr[L++] = (tmp >> 8) & 0xFF\r\n    arr[L++] = tmp & 0xFF\r\n  }\r\n\r\n  if (placeHolders === 2) {\r\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\r\n    arr[L++] = tmp & 0xFF\r\n  } else if (placeHolders === 1) {\r\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\r\n    arr[L++] = (tmp >> 8) & 0xFF\r\n    arr[L++] = tmp & 0xFF\r\n  }\r\n\r\n  return arr\r\n}\r\n\r\nfunction tripletToBase64 (num) {\r\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\r\n}\r\n\r\nfunction encodeChunk (uint8, start, end) {\r\n  var tmp\r\n  var output = []\r\n  for (var i = start; i < end; i += 3) {\r\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\r\n    output.push(tripletToBase64(tmp))\r\n  }\r\n  return output.join('')\r\n}\r\n\r\nfunction fromByteArray (uint8) {\r\n  var tmp\r\n  var len = uint8.length\r\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\r\n  var output = ''\r\n  var parts = []\r\n  var maxChunkLength = 16383 // must be multiple of 3\r\n\r\n  // go through the array every three bytes, we'll deal with trailing stuff later\r\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\r\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\r\n  }\r\n\r\n  // pad the end with zeros, but make sure to not forget the extra bytes\r\n  if (extraBytes === 1) {\r\n    tmp = uint8[len - 1]\r\n    output += lookup[tmp >> 2]\r\n    output += lookup[(tmp << 4) & 0x3F]\r\n    output += '=='\r\n  } else if (extraBytes === 2) {\r\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\r\n    output += lookup[tmp >> 10]\r\n    output += lookup[(tmp >> 4) & 0x3F]\r\n    output += lookup[(tmp << 2) & 0x3F]\r\n    output += '='\r\n  }\r\n\r\n  parts.push(output)\r\n\r\n  return parts.join('')\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 932\n// module chunks = 2 18","/*!\r\n * The buffer module from node.js, for the browser.\r\n *\r\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\r\n * @license  MIT\r\n */\r\n/* eslint-disable no-proto */\r\n\r\n'use strict'\r\n\r\nvar base64 = require('base64-js')\r\nvar ieee754 = require('ieee754')\r\nvar isArray = require('isarray')\r\n\r\nexports.Buffer = Buffer\r\nexports.SlowBuffer = SlowBuffer\r\nexports.INSPECT_MAX_BYTES = 50\r\n\r\n/**\r\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\r\n *   === true    Use Uint8Array implementation (fastest)\r\n *   === false   Use Object implementation (most compatible, even IE6)\r\n *\r\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\r\n * Opera 11.6+, iOS 4.2+.\r\n *\r\n * Due to various browser bugs, sometimes the Object implementation will be used even\r\n * when the browser supports typed arrays.\r\n *\r\n * Note:\r\n *\r\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\r\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\r\n *\r\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\r\n *\r\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\r\n *     incorrect length in some situations.\r\n\r\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\r\n * get the Object implementation, which is slower but behaves correctly.\r\n */\r\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\r\n  ? global.TYPED_ARRAY_SUPPORT\r\n  : typedArraySupport()\r\n\r\n/*\r\n * Export kMaxLength after typed array support is determined.\r\n */\r\nexports.kMaxLength = kMaxLength()\r\n\r\nfunction typedArraySupport () {\r\n  try {\r\n    var arr = new Uint8Array(1)\r\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\r\n    return arr.foo() === 42 && // typed array instances can be augmented\r\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\r\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\r\n  } catch (e) {\r\n    return false\r\n  }\r\n}\r\n\r\nfunction kMaxLength () {\r\n  return Buffer.TYPED_ARRAY_SUPPORT\r\n    ? 0x7fffffff\r\n    : 0x3fffffff\r\n}\r\n\r\nfunction createBuffer (that, length) {\r\n  if (kMaxLength() < length) {\r\n    throw new RangeError('Invalid typed array length')\r\n  }\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    // Return an augmented `Uint8Array` instance, for best performance\r\n    that = new Uint8Array(length)\r\n    that.__proto__ = Buffer.prototype\r\n  } else {\r\n    // Fallback: Return an object instance of the Buffer class\r\n    if (that === null) {\r\n      that = new Buffer(length)\r\n    }\r\n    that.length = length\r\n  }\r\n\r\n  return that\r\n}\r\n\r\n/**\r\n * The Buffer constructor returns instances of `Uint8Array` that have their\r\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\r\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\r\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\r\n * returns a single octet.\r\n *\r\n * The `Uint8Array` prototype remains unmodified.\r\n */\r\n\r\nfunction Buffer (arg, encodingOrOffset, length) {\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\r\n    return new Buffer(arg, encodingOrOffset, length)\r\n  }\r\n\r\n  // Common case.\r\n  if (typeof arg === 'number') {\r\n    if (typeof encodingOrOffset === 'string') {\r\n      throw new Error(\r\n        'If encoding is specified then the first argument must be a string'\r\n      )\r\n    }\r\n    return allocUnsafe(this, arg)\r\n  }\r\n  return from(this, arg, encodingOrOffset, length)\r\n}\r\n\r\nBuffer.poolSize = 8192 // not used by this implementation\r\n\r\n// TODO: Legacy, not needed anymore. Remove in next major version.\r\nBuffer._augment = function (arr) {\r\n  arr.__proto__ = Buffer.prototype\r\n  return arr\r\n}\r\n\r\nfunction from (that, value, encodingOrOffset, length) {\r\n  if (typeof value === 'number') {\r\n    throw new TypeError('\"value\" argument must not be a number')\r\n  }\r\n\r\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\r\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\r\n  }\r\n\r\n  if (typeof value === 'string') {\r\n    return fromString(that, value, encodingOrOffset)\r\n  }\r\n\r\n  return fromObject(that, value)\r\n}\r\n\r\n/**\r\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\r\n * if value is a number.\r\n * Buffer.from(str[, encoding])\r\n * Buffer.from(array)\r\n * Buffer.from(buffer)\r\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\r\n **/\r\nBuffer.from = function (value, encodingOrOffset, length) {\r\n  return from(null, value, encodingOrOffset, length)\r\n}\r\n\r\nif (Buffer.TYPED_ARRAY_SUPPORT) {\r\n  Buffer.prototype.__proto__ = Uint8Array.prototype\r\n  Buffer.__proto__ = Uint8Array\r\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\r\n      Buffer[Symbol.species] === Buffer) {\r\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\r\n    Object.defineProperty(Buffer, Symbol.species, {\r\n      value: null,\r\n      configurable: true\r\n    })\r\n  }\r\n}\r\n\r\nfunction assertSize (size) {\r\n  if (typeof size !== 'number') {\r\n    throw new TypeError('\"size\" argument must be a number')\r\n  } else if (size < 0) {\r\n    throw new RangeError('\"size\" argument must not be negative')\r\n  }\r\n}\r\n\r\nfunction alloc (that, size, fill, encoding) {\r\n  assertSize(size)\r\n  if (size <= 0) {\r\n    return createBuffer(that, size)\r\n  }\r\n  if (fill !== undefined) {\r\n    // Only pay attention to encoding if it's a string. This\r\n    // prevents accidentally sending in a number that would\r\n    // be interpretted as a start offset.\r\n    return typeof encoding === 'string'\r\n      ? createBuffer(that, size).fill(fill, encoding)\r\n      : createBuffer(that, size).fill(fill)\r\n  }\r\n  return createBuffer(that, size)\r\n}\r\n\r\n/**\r\n * Creates a new filled Buffer instance.\r\n * alloc(size[, fill[, encoding]])\r\n **/\r\nBuffer.alloc = function (size, fill, encoding) {\r\n  return alloc(null, size, fill, encoding)\r\n}\r\n\r\nfunction allocUnsafe (that, size) {\r\n  assertSize(size)\r\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\r\n    for (var i = 0; i < size; ++i) {\r\n      that[i] = 0\r\n    }\r\n  }\r\n  return that\r\n}\r\n\r\n/**\r\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\r\n * */\r\nBuffer.allocUnsafe = function (size) {\r\n  return allocUnsafe(null, size)\r\n}\r\n/**\r\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\r\n */\r\nBuffer.allocUnsafeSlow = function (size) {\r\n  return allocUnsafe(null, size)\r\n}\r\n\r\nfunction fromString (that, string, encoding) {\r\n  if (typeof encoding !== 'string' || encoding === '') {\r\n    encoding = 'utf8'\r\n  }\r\n\r\n  if (!Buffer.isEncoding(encoding)) {\r\n    throw new TypeError('\"encoding\" must be a valid string encoding')\r\n  }\r\n\r\n  var length = byteLength(string, encoding) | 0\r\n  that = createBuffer(that, length)\r\n\r\n  var actual = that.write(string, encoding)\r\n\r\n  if (actual !== length) {\r\n    // Writing a hex string, for example, that contains invalid characters will\r\n    // cause everything after the first invalid character to be ignored. (e.g.\r\n    // 'abxxcd' will be treated as 'ab')\r\n    that = that.slice(0, actual)\r\n  }\r\n\r\n  return that\r\n}\r\n\r\nfunction fromArrayLike (that, array) {\r\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\r\n  that = createBuffer(that, length)\r\n  for (var i = 0; i < length; i += 1) {\r\n    that[i] = array[i] & 255\r\n  }\r\n  return that\r\n}\r\n\r\nfunction fromArrayBuffer (that, array, byteOffset, length) {\r\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\r\n\r\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\r\n    throw new RangeError('\\'offset\\' is out of bounds')\r\n  }\r\n\r\n  if (array.byteLength < byteOffset + (length || 0)) {\r\n    throw new RangeError('\\'length\\' is out of bounds')\r\n  }\r\n\r\n  if (byteOffset === undefined && length === undefined) {\r\n    array = new Uint8Array(array)\r\n  } else if (length === undefined) {\r\n    array = new Uint8Array(array, byteOffset)\r\n  } else {\r\n    array = new Uint8Array(array, byteOffset, length)\r\n  }\r\n\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    // Return an augmented `Uint8Array` instance, for best performance\r\n    that = array\r\n    that.__proto__ = Buffer.prototype\r\n  } else {\r\n    // Fallback: Return an object instance of the Buffer class\r\n    that = fromArrayLike(that, array)\r\n  }\r\n  return that\r\n}\r\n\r\nfunction fromObject (that, obj) {\r\n  if (Buffer.isBuffer(obj)) {\r\n    var len = checked(obj.length) | 0\r\n    that = createBuffer(that, len)\r\n\r\n    if (that.length === 0) {\r\n      return that\r\n    }\r\n\r\n    obj.copy(that, 0, 0, len)\r\n    return that\r\n  }\r\n\r\n  if (obj) {\r\n    if ((typeof ArrayBuffer !== 'undefined' &&\r\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\r\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\r\n        return createBuffer(that, 0)\r\n      }\r\n      return fromArrayLike(that, obj)\r\n    }\r\n\r\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\r\n      return fromArrayLike(that, obj.data)\r\n    }\r\n  }\r\n\r\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\r\n}\r\n\r\nfunction checked (length) {\r\n  // Note: cannot use `length < kMaxLength()` here because that fails when\r\n  // length is NaN (which is otherwise coerced to zero.)\r\n  if (length >= kMaxLength()) {\r\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\r\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\r\n  }\r\n  return length | 0\r\n}\r\n\r\nfunction SlowBuffer (length) {\r\n  if (+length != length) { // eslint-disable-line eqeqeq\r\n    length = 0\r\n  }\r\n  return Buffer.alloc(+length)\r\n}\r\n\r\nBuffer.isBuffer = function isBuffer (b) {\r\n  return !!(b != null && b._isBuffer)\r\n}\r\n\r\nBuffer.compare = function compare (a, b) {\r\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\r\n    throw new TypeError('Arguments must be Buffers')\r\n  }\r\n\r\n  if (a === b) return 0\r\n\r\n  var x = a.length\r\n  var y = b.length\r\n\r\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\r\n    if (a[i] !== b[i]) {\r\n      x = a[i]\r\n      y = b[i]\r\n      break\r\n    }\r\n  }\r\n\r\n  if (x < y) return -1\r\n  if (y < x) return 1\r\n  return 0\r\n}\r\n\r\nBuffer.isEncoding = function isEncoding (encoding) {\r\n  switch (String(encoding).toLowerCase()) {\r\n    case 'hex':\r\n    case 'utf8':\r\n    case 'utf-8':\r\n    case 'ascii':\r\n    case 'latin1':\r\n    case 'binary':\r\n    case 'base64':\r\n    case 'ucs2':\r\n    case 'ucs-2':\r\n    case 'utf16le':\r\n    case 'utf-16le':\r\n      return true\r\n    default:\r\n      return false\r\n  }\r\n}\r\n\r\nBuffer.concat = function concat (list, length) {\r\n  if (!isArray(list)) {\r\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n  }\r\n\r\n  if (list.length === 0) {\r\n    return Buffer.alloc(0)\r\n  }\r\n\r\n  var i\r\n  if (length === undefined) {\r\n    length = 0\r\n    for (i = 0; i < list.length; ++i) {\r\n      length += list[i].length\r\n    }\r\n  }\r\n\r\n  var buffer = Buffer.allocUnsafe(length)\r\n  var pos = 0\r\n  for (i = 0; i < list.length; ++i) {\r\n    var buf = list[i]\r\n    if (!Buffer.isBuffer(buf)) {\r\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n    }\r\n    buf.copy(buffer, pos)\r\n    pos += buf.length\r\n  }\r\n  return buffer\r\n}\r\n\r\nfunction byteLength (string, encoding) {\r\n  if (Buffer.isBuffer(string)) {\r\n    return string.length\r\n  }\r\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\r\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\r\n    return string.byteLength\r\n  }\r\n  if (typeof string !== 'string') {\r\n    string = '' + string\r\n  }\r\n\r\n  var len = string.length\r\n  if (len === 0) return 0\r\n\r\n  // Use a for loop to avoid recursion\r\n  var loweredCase = false\r\n  for (;;) {\r\n    switch (encoding) {\r\n      case 'ascii':\r\n      case 'latin1':\r\n      case 'binary':\r\n        return len\r\n      case 'utf8':\r\n      case 'utf-8':\r\n      case undefined:\r\n        return utf8ToBytes(string).length\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return len * 2\r\n      case 'hex':\r\n        return len >>> 1\r\n      case 'base64':\r\n        return base64ToBytes(string).length\r\n      default:\r\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\r\n        encoding = ('' + encoding).toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\nBuffer.byteLength = byteLength\r\n\r\nfunction slowToString (encoding, start, end) {\r\n  var loweredCase = false\r\n\r\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\r\n  // property of a typed array.\r\n\r\n  // This behaves neither like String nor Uint8Array in that we set start/end\r\n  // to their upper/lower bounds if the value passed is out of range.\r\n  // undefined is handled specially as per ECMA-262 6th Edition,\r\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\r\n  if (start === undefined || start < 0) {\r\n    start = 0\r\n  }\r\n  // Return early if start > this.length. Done here to prevent potential uint32\r\n  // coercion fail below.\r\n  if (start > this.length) {\r\n    return ''\r\n  }\r\n\r\n  if (end === undefined || end > this.length) {\r\n    end = this.length\r\n  }\r\n\r\n  if (end <= 0) {\r\n    return ''\r\n  }\r\n\r\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\r\n  end >>>= 0\r\n  start >>>= 0\r\n\r\n  if (end <= start) {\r\n    return ''\r\n  }\r\n\r\n  if (!encoding) encoding = 'utf8'\r\n\r\n  while (true) {\r\n    switch (encoding) {\r\n      case 'hex':\r\n        return hexSlice(this, start, end)\r\n\r\n      case 'utf8':\r\n      case 'utf-8':\r\n        return utf8Slice(this, start, end)\r\n\r\n      case 'ascii':\r\n        return asciiSlice(this, start, end)\r\n\r\n      case 'latin1':\r\n      case 'binary':\r\n        return latin1Slice(this, start, end)\r\n\r\n      case 'base64':\r\n        return base64Slice(this, start, end)\r\n\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return utf16leSlice(this, start, end)\r\n\r\n      default:\r\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n        encoding = (encoding + '').toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\n\r\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\r\n// Buffer instances.\r\nBuffer.prototype._isBuffer = true\r\n\r\nfunction swap (b, n, m) {\r\n  var i = b[n]\r\n  b[n] = b[m]\r\n  b[m] = i\r\n}\r\n\r\nBuffer.prototype.swap16 = function swap16 () {\r\n  var len = this.length\r\n  if (len % 2 !== 0) {\r\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\r\n  }\r\n  for (var i = 0; i < len; i += 2) {\r\n    swap(this, i, i + 1)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.swap32 = function swap32 () {\r\n  var len = this.length\r\n  if (len % 4 !== 0) {\r\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\r\n  }\r\n  for (var i = 0; i < len; i += 4) {\r\n    swap(this, i, i + 3)\r\n    swap(this, i + 1, i + 2)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.swap64 = function swap64 () {\r\n  var len = this.length\r\n  if (len % 8 !== 0) {\r\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\r\n  }\r\n  for (var i = 0; i < len; i += 8) {\r\n    swap(this, i, i + 7)\r\n    swap(this, i + 1, i + 6)\r\n    swap(this, i + 2, i + 5)\r\n    swap(this, i + 3, i + 4)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.toString = function toString () {\r\n  var length = this.length | 0\r\n  if (length === 0) return ''\r\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\r\n  return slowToString.apply(this, arguments)\r\n}\r\n\r\nBuffer.prototype.equals = function equals (b) {\r\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\r\n  if (this === b) return true\r\n  return Buffer.compare(this, b) === 0\r\n}\r\n\r\nBuffer.prototype.inspect = function inspect () {\r\n  var str = ''\r\n  var max = exports.INSPECT_MAX_BYTES\r\n  if (this.length > 0) {\r\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\r\n    if (this.length > max) str += ' ... '\r\n  }\r\n  return '<Buffer ' + str + '>'\r\n}\r\n\r\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\r\n  if (!Buffer.isBuffer(target)) {\r\n    throw new TypeError('Argument must be a Buffer')\r\n  }\r\n\r\n  if (start === undefined) {\r\n    start = 0\r\n  }\r\n  if (end === undefined) {\r\n    end = target ? target.length : 0\r\n  }\r\n  if (thisStart === undefined) {\r\n    thisStart = 0\r\n  }\r\n  if (thisEnd === undefined) {\r\n    thisEnd = this.length\r\n  }\r\n\r\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\r\n    throw new RangeError('out of range index')\r\n  }\r\n\r\n  if (thisStart >= thisEnd && start >= end) {\r\n    return 0\r\n  }\r\n  if (thisStart >= thisEnd) {\r\n    return -1\r\n  }\r\n  if (start >= end) {\r\n    return 1\r\n  }\r\n\r\n  start >>>= 0\r\n  end >>>= 0\r\n  thisStart >>>= 0\r\n  thisEnd >>>= 0\r\n\r\n  if (this === target) return 0\r\n\r\n  var x = thisEnd - thisStart\r\n  var y = end - start\r\n  var len = Math.min(x, y)\r\n\r\n  var thisCopy = this.slice(thisStart, thisEnd)\r\n  var targetCopy = target.slice(start, end)\r\n\r\n  for (var i = 0; i < len; ++i) {\r\n    if (thisCopy[i] !== targetCopy[i]) {\r\n      x = thisCopy[i]\r\n      y = targetCopy[i]\r\n      break\r\n    }\r\n  }\r\n\r\n  if (x < y) return -1\r\n  if (y < x) return 1\r\n  return 0\r\n}\r\n\r\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\r\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\r\n//\r\n// Arguments:\r\n// - buffer - a Buffer to search\r\n// - val - a string, Buffer, or number\r\n// - byteOffset - an index into `buffer`; will be clamped to an int32\r\n// - encoding - an optional encoding, relevant is val is a string\r\n// - dir - true for indexOf, false for lastIndexOf\r\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\r\n  // Empty buffer means no match\r\n  if (buffer.length === 0) return -1\r\n\r\n  // Normalize byteOffset\r\n  if (typeof byteOffset === 'string') {\r\n    encoding = byteOffset\r\n    byteOffset = 0\r\n  } else if (byteOffset > 0x7fffffff) {\r\n    byteOffset = 0x7fffffff\r\n  } else if (byteOffset < -0x80000000) {\r\n    byteOffset = -0x80000000\r\n  }\r\n  byteOffset = +byteOffset  // Coerce to Number.\r\n  if (isNaN(byteOffset)) {\r\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\r\n    byteOffset = dir ? 0 : (buffer.length - 1)\r\n  }\r\n\r\n  // Normalize byteOffset: negative offsets start from the end of the buffer\r\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\r\n  if (byteOffset >= buffer.length) {\r\n    if (dir) return -1\r\n    else byteOffset = buffer.length - 1\r\n  } else if (byteOffset < 0) {\r\n    if (dir) byteOffset = 0\r\n    else return -1\r\n  }\r\n\r\n  // Normalize val\r\n  if (typeof val === 'string') {\r\n    val = Buffer.from(val, encoding)\r\n  }\r\n\r\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\r\n  if (Buffer.isBuffer(val)) {\r\n    // Special case: looking for empty string/buffer always fails\r\n    if (val.length === 0) {\r\n      return -1\r\n    }\r\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\r\n  } else if (typeof val === 'number') {\r\n    val = val & 0xFF // Search for a byte value [0-255]\r\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\r\n        typeof Uint8Array.prototype.indexOf === 'function') {\r\n      if (dir) {\r\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\r\n      } else {\r\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\r\n      }\r\n    }\r\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\r\n  }\r\n\r\n  throw new TypeError('val must be string, number or Buffer')\r\n}\r\n\r\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\r\n  var indexSize = 1\r\n  var arrLength = arr.length\r\n  var valLength = val.length\r\n\r\n  if (encoding !== undefined) {\r\n    encoding = String(encoding).toLowerCase()\r\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\r\n        encoding === 'utf16le' || encoding === 'utf-16le') {\r\n      if (arr.length < 2 || val.length < 2) {\r\n        return -1\r\n      }\r\n      indexSize = 2\r\n      arrLength /= 2\r\n      valLength /= 2\r\n      byteOffset /= 2\r\n    }\r\n  }\r\n\r\n  function read (buf, i) {\r\n    if (indexSize === 1) {\r\n      return buf[i]\r\n    } else {\r\n      return buf.readUInt16BE(i * indexSize)\r\n    }\r\n  }\r\n\r\n  var i\r\n  if (dir) {\r\n    var foundIndex = -1\r\n    for (i = byteOffset; i < arrLength; i++) {\r\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\r\n        if (foundIndex === -1) foundIndex = i\r\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\r\n      } else {\r\n        if (foundIndex !== -1) i -= i - foundIndex\r\n        foundIndex = -1\r\n      }\r\n    }\r\n  } else {\r\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\r\n    for (i = byteOffset; i >= 0; i--) {\r\n      var found = true\r\n      for (var j = 0; j < valLength; j++) {\r\n        if (read(arr, i + j) !== read(val, j)) {\r\n          found = false\r\n          break\r\n        }\r\n      }\r\n      if (found) return i\r\n    }\r\n  }\r\n\r\n  return -1\r\n}\r\n\r\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\r\n  return this.indexOf(val, byteOffset, encoding) !== -1\r\n}\r\n\r\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\r\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\r\n}\r\n\r\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\r\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\r\n}\r\n\r\nfunction hexWrite (buf, string, offset, length) {\r\n  offset = Number(offset) || 0\r\n  var remaining = buf.length - offset\r\n  if (!length) {\r\n    length = remaining\r\n  } else {\r\n    length = Number(length)\r\n    if (length > remaining) {\r\n      length = remaining\r\n    }\r\n  }\r\n\r\n  // must be an even number of digits\r\n  var strLen = string.length\r\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\r\n\r\n  if (length > strLen / 2) {\r\n    length = strLen / 2\r\n  }\r\n  for (var i = 0; i < length; ++i) {\r\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\r\n    if (isNaN(parsed)) return i\r\n    buf[offset + i] = parsed\r\n  }\r\n  return i\r\n}\r\n\r\nfunction utf8Write (buf, string, offset, length) {\r\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\r\n}\r\n\r\nfunction asciiWrite (buf, string, offset, length) {\r\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\r\n}\r\n\r\nfunction latin1Write (buf, string, offset, length) {\r\n  return asciiWrite(buf, string, offset, length)\r\n}\r\n\r\nfunction base64Write (buf, string, offset, length) {\r\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\r\n}\r\n\r\nfunction ucs2Write (buf, string, offset, length) {\r\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\r\n}\r\n\r\nBuffer.prototype.write = function write (string, offset, length, encoding) {\r\n  // Buffer#write(string)\r\n  if (offset === undefined) {\r\n    encoding = 'utf8'\r\n    length = this.length\r\n    offset = 0\r\n  // Buffer#write(string, encoding)\r\n  } else if (length === undefined && typeof offset === 'string') {\r\n    encoding = offset\r\n    length = this.length\r\n    offset = 0\r\n  // Buffer#write(string, offset[, length][, encoding])\r\n  } else if (isFinite(offset)) {\r\n    offset = offset | 0\r\n    if (isFinite(length)) {\r\n      length = length | 0\r\n      if (encoding === undefined) encoding = 'utf8'\r\n    } else {\r\n      encoding = length\r\n      length = undefined\r\n    }\r\n  // legacy write(string, encoding, offset, length) - remove in v0.13\r\n  } else {\r\n    throw new Error(\r\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\r\n    )\r\n  }\r\n\r\n  var remaining = this.length - offset\r\n  if (length === undefined || length > remaining) length = remaining\r\n\r\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\r\n    throw new RangeError('Attempt to write outside buffer bounds')\r\n  }\r\n\r\n  if (!encoding) encoding = 'utf8'\r\n\r\n  var loweredCase = false\r\n  for (;;) {\r\n    switch (encoding) {\r\n      case 'hex':\r\n        return hexWrite(this, string, offset, length)\r\n\r\n      case 'utf8':\r\n      case 'utf-8':\r\n        return utf8Write(this, string, offset, length)\r\n\r\n      case 'ascii':\r\n        return asciiWrite(this, string, offset, length)\r\n\r\n      case 'latin1':\r\n      case 'binary':\r\n        return latin1Write(this, string, offset, length)\r\n\r\n      case 'base64':\r\n        // Warning: maxLength not taken into account in base64Write\r\n        return base64Write(this, string, offset, length)\r\n\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return ucs2Write(this, string, offset, length)\r\n\r\n      default:\r\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n        encoding = ('' + encoding).toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\n\r\nBuffer.prototype.toJSON = function toJSON () {\r\n  return {\r\n    type: 'Buffer',\r\n    data: Array.prototype.slice.call(this._arr || this, 0)\r\n  }\r\n}\r\n\r\nfunction base64Slice (buf, start, end) {\r\n  if (start === 0 && end === buf.length) {\r\n    return base64.fromByteArray(buf)\r\n  } else {\r\n    return base64.fromByteArray(buf.slice(start, end))\r\n  }\r\n}\r\n\r\nfunction utf8Slice (buf, start, end) {\r\n  end = Math.min(buf.length, end)\r\n  var res = []\r\n\r\n  var i = start\r\n  while (i < end) {\r\n    var firstByte = buf[i]\r\n    var codePoint = null\r\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\r\n      : (firstByte > 0xDF) ? 3\r\n      : (firstByte > 0xBF) ? 2\r\n      : 1\r\n\r\n    if (i + bytesPerSequence <= end) {\r\n      var secondByte, thirdByte, fourthByte, tempCodePoint\r\n\r\n      switch (bytesPerSequence) {\r\n        case 1:\r\n          if (firstByte < 0x80) {\r\n            codePoint = firstByte\r\n          }\r\n          break\r\n        case 2:\r\n          secondByte = buf[i + 1]\r\n          if ((secondByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\r\n            if (tempCodePoint > 0x7F) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n          break\r\n        case 3:\r\n          secondByte = buf[i + 1]\r\n          thirdByte = buf[i + 2]\r\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\r\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n          break\r\n        case 4:\r\n          secondByte = buf[i + 1]\r\n          thirdByte = buf[i + 2]\r\n          fourthByte = buf[i + 3]\r\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\r\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n      }\r\n    }\r\n\r\n    if (codePoint === null) {\r\n      // we did not generate a valid codePoint so insert a\r\n      // replacement char (U+FFFD) and advance only 1 byte\r\n      codePoint = 0xFFFD\r\n      bytesPerSequence = 1\r\n    } else if (codePoint > 0xFFFF) {\r\n      // encode to utf16 (surrogate pair dance)\r\n      codePoint -= 0x10000\r\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\r\n      codePoint = 0xDC00 | codePoint & 0x3FF\r\n    }\r\n\r\n    res.push(codePoint)\r\n    i += bytesPerSequence\r\n  }\r\n\r\n  return decodeCodePointsArray(res)\r\n}\r\n\r\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\r\n// the lowest limit is Chrome, with 0x10000 args.\r\n// We go 1 magnitude less, for safety\r\nvar MAX_ARGUMENTS_LENGTH = 0x1000\r\n\r\nfunction decodeCodePointsArray (codePoints) {\r\n  var len = codePoints.length\r\n  if (len <= MAX_ARGUMENTS_LENGTH) {\r\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\r\n  }\r\n\r\n  // Decode in chunks to avoid \"call stack size exceeded\".\r\n  var res = ''\r\n  var i = 0\r\n  while (i < len) {\r\n    res += String.fromCharCode.apply(\r\n      String,\r\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\r\n    )\r\n  }\r\n  return res\r\n}\r\n\r\nfunction asciiSlice (buf, start, end) {\r\n  var ret = ''\r\n  end = Math.min(buf.length, end)\r\n\r\n  for (var i = start; i < end; ++i) {\r\n    ret += String.fromCharCode(buf[i] & 0x7F)\r\n  }\r\n  return ret\r\n}\r\n\r\nfunction latin1Slice (buf, start, end) {\r\n  var ret = ''\r\n  end = Math.min(buf.length, end)\r\n\r\n  for (var i = start; i < end; ++i) {\r\n    ret += String.fromCharCode(buf[i])\r\n  }\r\n  return ret\r\n}\r\n\r\nfunction hexSlice (buf, start, end) {\r\n  var len = buf.length\r\n\r\n  if (!start || start < 0) start = 0\r\n  if (!end || end < 0 || end > len) end = len\r\n\r\n  var out = ''\r\n  for (var i = start; i < end; ++i) {\r\n    out += toHex(buf[i])\r\n  }\r\n  return out\r\n}\r\n\r\nfunction utf16leSlice (buf, start, end) {\r\n  var bytes = buf.slice(start, end)\r\n  var res = ''\r\n  for (var i = 0; i < bytes.length; i += 2) {\r\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\r\n  }\r\n  return res\r\n}\r\n\r\nBuffer.prototype.slice = function slice (start, end) {\r\n  var len = this.length\r\n  start = ~~start\r\n  end = end === undefined ? len : ~~end\r\n\r\n  if (start < 0) {\r\n    start += len\r\n    if (start < 0) start = 0\r\n  } else if (start > len) {\r\n    start = len\r\n  }\r\n\r\n  if (end < 0) {\r\n    end += len\r\n    if (end < 0) end = 0\r\n  } else if (end > len) {\r\n    end = len\r\n  }\r\n\r\n  if (end < start) end = start\r\n\r\n  var newBuf\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    newBuf = this.subarray(start, end)\r\n    newBuf.__proto__ = Buffer.prototype\r\n  } else {\r\n    var sliceLen = end - start\r\n    newBuf = new Buffer(sliceLen, undefined)\r\n    for (var i = 0; i < sliceLen; ++i) {\r\n      newBuf[i] = this[i + start]\r\n    }\r\n  }\r\n\r\n  return newBuf\r\n}\r\n\r\n/*\r\n * Need to make sure that buffer isn't trying to write out of bounds.\r\n */\r\nfunction checkOffset (offset, ext, length) {\r\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\r\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\r\n}\r\n\r\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  var val = this[offset]\r\n  var mul = 1\r\n  var i = 0\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    val += this[offset + i] * mul\r\n  }\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) {\r\n    checkOffset(offset, byteLength, this.length)\r\n  }\r\n\r\n  var val = this[offset + --byteLength]\r\n  var mul = 1\r\n  while (byteLength > 0 && (mul *= 0x100)) {\r\n    val += this[offset + --byteLength] * mul\r\n  }\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 1, this.length)\r\n  return this[offset]\r\n}\r\n\r\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  return this[offset] | (this[offset + 1] << 8)\r\n}\r\n\r\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  return (this[offset] << 8) | this[offset + 1]\r\n}\r\n\r\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return ((this[offset]) |\r\n      (this[offset + 1] << 8) |\r\n      (this[offset + 2] << 16)) +\r\n      (this[offset + 3] * 0x1000000)\r\n}\r\n\r\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset] * 0x1000000) +\r\n    ((this[offset + 1] << 16) |\r\n    (this[offset + 2] << 8) |\r\n    this[offset + 3])\r\n}\r\n\r\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  var val = this[offset]\r\n  var mul = 1\r\n  var i = 0\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    val += this[offset + i] * mul\r\n  }\r\n  mul *= 0x80\r\n\r\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  var i = byteLength\r\n  var mul = 1\r\n  var val = this[offset + --i]\r\n  while (i > 0 && (mul *= 0x100)) {\r\n    val += this[offset + --i] * mul\r\n  }\r\n  mul *= 0x80\r\n\r\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 1, this.length)\r\n  if (!(this[offset] & 0x80)) return (this[offset])\r\n  return ((0xff - this[offset] + 1) * -1)\r\n}\r\n\r\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  var val = this[offset] | (this[offset + 1] << 8)\r\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n}\r\n\r\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  var val = this[offset + 1] | (this[offset] << 8)\r\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n}\r\n\r\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset]) |\r\n    (this[offset + 1] << 8) |\r\n    (this[offset + 2] << 16) |\r\n    (this[offset + 3] << 24)\r\n}\r\n\r\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset] << 24) |\r\n    (this[offset + 1] << 16) |\r\n    (this[offset + 2] << 8) |\r\n    (this[offset + 3])\r\n}\r\n\r\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n  return ieee754.read(this, offset, true, 23, 4)\r\n}\r\n\r\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n  return ieee754.read(this, offset, false, 23, 4)\r\n}\r\n\r\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 8, this.length)\r\n  return ieee754.read(this, offset, true, 52, 8)\r\n}\r\n\r\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 8, this.length)\r\n  return ieee754.read(this, offset, false, 52, 8)\r\n}\r\n\r\nfunction checkInt (buf, value, offset, ext, max, min) {\r\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\r\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\r\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n}\r\n\r\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) {\r\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n  }\r\n\r\n  var mul = 1\r\n  var i = 0\r\n  this[offset] = value & 0xFF\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    this[offset + i] = (value / mul) & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) {\r\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n  }\r\n\r\n  var i = byteLength - 1\r\n  var mul = 1\r\n  this[offset + i] = value & 0xFF\r\n  while (--i >= 0 && (mul *= 0x100)) {\r\n    this[offset + i] = (value / mul) & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\r\n  this[offset] = (value & 0xff)\r\n  return offset + 1\r\n}\r\n\r\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\r\n  if (value < 0) value = 0xffff + value + 1\r\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\r\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\r\n      (littleEndian ? i : 1 - i) * 8\r\n  }\r\n}\r\n\r\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, true)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, false)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\r\n  if (value < 0) value = 0xffffffff + value + 1\r\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\r\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\r\n  }\r\n}\r\n\r\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset + 3] = (value >>> 24)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, true)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, false)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) {\r\n    var limit = Math.pow(2, 8 * byteLength - 1)\r\n\r\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n  }\r\n\r\n  var i = 0\r\n  var mul = 1\r\n  var sub = 0\r\n  this[offset] = value & 0xFF\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\r\n      sub = 1\r\n    }\r\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) {\r\n    var limit = Math.pow(2, 8 * byteLength - 1)\r\n\r\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n  }\r\n\r\n  var i = byteLength - 1\r\n  var mul = 1\r\n  var sub = 0\r\n  this[offset + i] = value & 0xFF\r\n  while (--i >= 0 && (mul *= 0x100)) {\r\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\r\n      sub = 1\r\n    }\r\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\r\n  if (value < 0) value = 0xff + value + 1\r\n  this[offset] = (value & 0xff)\r\n  return offset + 1\r\n}\r\n\r\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, true)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, false)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 3] = (value >>> 24)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, true)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n  if (value < 0) value = 0xffffffff + value + 1\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, false)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\r\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n  if (offset < 0) throw new RangeError('Index out of range')\r\n}\r\n\r\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\r\n  if (!noAssert) {\r\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\r\n  }\r\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\r\n  return writeFloat(this, value, offset, true, noAssert)\r\n}\r\n\r\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\r\n  return writeFloat(this, value, offset, false, noAssert)\r\n}\r\n\r\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\r\n  if (!noAssert) {\r\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\r\n  }\r\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\r\n  return offset + 8\r\n}\r\n\r\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\r\n  return writeDouble(this, value, offset, true, noAssert)\r\n}\r\n\r\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\r\n  return writeDouble(this, value, offset, false, noAssert)\r\n}\r\n\r\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\r\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\r\n  if (!start) start = 0\r\n  if (!end && end !== 0) end = this.length\r\n  if (targetStart >= target.length) targetStart = target.length\r\n  if (!targetStart) targetStart = 0\r\n  if (end > 0 && end < start) end = start\r\n\r\n  // Copy 0 bytes; we're done\r\n  if (end === start) return 0\r\n  if (target.length === 0 || this.length === 0) return 0\r\n\r\n  // Fatal error conditions\r\n  if (targetStart < 0) {\r\n    throw new RangeError('targetStart out of bounds')\r\n  }\r\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\r\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\r\n\r\n  // Are we oob?\r\n  if (end > this.length) end = this.length\r\n  if (target.length - targetStart < end - start) {\r\n    end = target.length - targetStart + start\r\n  }\r\n\r\n  var len = end - start\r\n  var i\r\n\r\n  if (this === target && start < targetStart && targetStart < end) {\r\n    // descending copy from end\r\n    for (i = len - 1; i >= 0; --i) {\r\n      target[i + targetStart] = this[i + start]\r\n    }\r\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\r\n    // ascending copy from start\r\n    for (i = 0; i < len; ++i) {\r\n      target[i + targetStart] = this[i + start]\r\n    }\r\n  } else {\r\n    Uint8Array.prototype.set.call(\r\n      target,\r\n      this.subarray(start, start + len),\r\n      targetStart\r\n    )\r\n  }\r\n\r\n  return len\r\n}\r\n\r\n// Usage:\r\n//    buffer.fill(number[, offset[, end]])\r\n//    buffer.fill(buffer[, offset[, end]])\r\n//    buffer.fill(string[, offset[, end]][, encoding])\r\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\r\n  // Handle string cases:\r\n  if (typeof val === 'string') {\r\n    if (typeof start === 'string') {\r\n      encoding = start\r\n      start = 0\r\n      end = this.length\r\n    } else if (typeof end === 'string') {\r\n      encoding = end\r\n      end = this.length\r\n    }\r\n    if (val.length === 1) {\r\n      var code = val.charCodeAt(0)\r\n      if (code < 256) {\r\n        val = code\r\n      }\r\n    }\r\n    if (encoding !== undefined && typeof encoding !== 'string') {\r\n      throw new TypeError('encoding must be a string')\r\n    }\r\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\r\n      throw new TypeError('Unknown encoding: ' + encoding)\r\n    }\r\n  } else if (typeof val === 'number') {\r\n    val = val & 255\r\n  }\r\n\r\n  // Invalid ranges are not set to a default, so can range check early.\r\n  if (start < 0 || this.length < start || this.length < end) {\r\n    throw new RangeError('Out of range index')\r\n  }\r\n\r\n  if (end <= start) {\r\n    return this\r\n  }\r\n\r\n  start = start >>> 0\r\n  end = end === undefined ? this.length : end >>> 0\r\n\r\n  if (!val) val = 0\r\n\r\n  var i\r\n  if (typeof val === 'number') {\r\n    for (i = start; i < end; ++i) {\r\n      this[i] = val\r\n    }\r\n  } else {\r\n    var bytes = Buffer.isBuffer(val)\r\n      ? val\r\n      : utf8ToBytes(new Buffer(val, encoding).toString())\r\n    var len = bytes.length\r\n    for (i = 0; i < end - start; ++i) {\r\n      this[i + start] = bytes[i % len]\r\n    }\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n// HELPER FUNCTIONS\r\n// ================\r\n\r\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\r\n\r\nfunction base64clean (str) {\r\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\r\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\r\n  // Node converts strings with length < 2 to ''\r\n  if (str.length < 2) return ''\r\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\r\n  while (str.length % 4 !== 0) {\r\n    str = str + '='\r\n  }\r\n  return str\r\n}\r\n\r\nfunction stringtrim (str) {\r\n  if (str.trim) return str.trim()\r\n  return str.replace(/^\\s+|\\s+$/g, '')\r\n}\r\n\r\nfunction toHex (n) {\r\n  if (n < 16) return '0' + n.toString(16)\r\n  return n.toString(16)\r\n}\r\n\r\nfunction utf8ToBytes (string, units) {\r\n  units = units || Infinity\r\n  var codePoint\r\n  var length = string.length\r\n  var leadSurrogate = null\r\n  var bytes = []\r\n\r\n  for (var i = 0; i < length; ++i) {\r\n    codePoint = string.charCodeAt(i)\r\n\r\n    // is surrogate component\r\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\r\n      // last char was a lead\r\n      if (!leadSurrogate) {\r\n        // no lead yet\r\n        if (codePoint > 0xDBFF) {\r\n          // unexpected trail\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          continue\r\n        } else if (i + 1 === length) {\r\n          // unpaired lead\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          continue\r\n        }\r\n\r\n        // valid lead\r\n        leadSurrogate = codePoint\r\n\r\n        continue\r\n      }\r\n\r\n      // 2 leads in a row\r\n      if (codePoint < 0xDC00) {\r\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n        leadSurrogate = codePoint\r\n        continue\r\n      }\r\n\r\n      // valid surrogate pair\r\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\r\n    } else if (leadSurrogate) {\r\n      // valid bmp char, but last char was a lead\r\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n    }\r\n\r\n    leadSurrogate = null\r\n\r\n    // encode utf8\r\n    if (codePoint < 0x80) {\r\n      if ((units -= 1) < 0) break\r\n      bytes.push(codePoint)\r\n    } else if (codePoint < 0x800) {\r\n      if ((units -= 2) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0x6 | 0xC0,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else if (codePoint < 0x10000) {\r\n      if ((units -= 3) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0xC | 0xE0,\r\n        codePoint >> 0x6 & 0x3F | 0x80,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else if (codePoint < 0x110000) {\r\n      if ((units -= 4) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0x12 | 0xF0,\r\n        codePoint >> 0xC & 0x3F | 0x80,\r\n        codePoint >> 0x6 & 0x3F | 0x80,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else {\r\n      throw new Error('Invalid code point')\r\n    }\r\n  }\r\n\r\n  return bytes\r\n}\r\n\r\nfunction asciiToBytes (str) {\r\n  var byteArray = []\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Node's code seems to be doing this and not & 0x7F..\r\n    byteArray.push(str.charCodeAt(i) & 0xFF)\r\n  }\r\n  return byteArray\r\n}\r\n\r\nfunction utf16leToBytes (str, units) {\r\n  var c, hi, lo\r\n  var byteArray = []\r\n  for (var i = 0; i < str.length; ++i) {\r\n    if ((units -= 2) < 0) break\r\n\r\n    c = str.charCodeAt(i)\r\n    hi = c >> 8\r\n    lo = c % 256\r\n    byteArray.push(lo)\r\n    byteArray.push(hi)\r\n  }\r\n\r\n  return byteArray\r\n}\r\n\r\nfunction base64ToBytes (str) {\r\n  return base64.toByteArray(base64clean(str))\r\n}\r\n\r\nfunction blitBuffer (src, dst, offset, length) {\r\n  for (var i = 0; i < length; ++i) {\r\n    if ((i + offset >= dst.length) || (i >= src.length)) break\r\n    dst[i + offset] = src[i]\r\n  }\r\n  return i\r\n}\r\n\r\nfunction isnan (val) {\r\n  return val !== val // eslint-disable-line no-self-compare\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/index.js\n// module id = 933\n// module chunks = 2 18","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\r\n  var e, m\r\n  var eLen = nBytes * 8 - mLen - 1\r\n  var eMax = (1 << eLen) - 1\r\n  var eBias = eMax >> 1\r\n  var nBits = -7\r\n  var i = isLE ? (nBytes - 1) : 0\r\n  var d = isLE ? -1 : 1\r\n  var s = buffer[offset + i]\r\n\r\n  i += d\r\n\r\n  e = s & ((1 << (-nBits)) - 1)\r\n  s >>= (-nBits)\r\n  nBits += eLen\r\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n  m = e & ((1 << (-nBits)) - 1)\r\n  e >>= (-nBits)\r\n  nBits += mLen\r\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n  if (e === 0) {\r\n    e = 1 - eBias\r\n  } else if (e === eMax) {\r\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\r\n  } else {\r\n    m = m + Math.pow(2, mLen)\r\n    e = e - eBias\r\n  }\r\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\r\n}\r\n\r\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\r\n  var e, m, c\r\n  var eLen = nBytes * 8 - mLen - 1\r\n  var eMax = (1 << eLen) - 1\r\n  var eBias = eMax >> 1\r\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\r\n  var i = isLE ? 0 : (nBytes - 1)\r\n  var d = isLE ? 1 : -1\r\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\r\n\r\n  value = Math.abs(value)\r\n\r\n  if (isNaN(value) || value === Infinity) {\r\n    m = isNaN(value) ? 1 : 0\r\n    e = eMax\r\n  } else {\r\n    e = Math.floor(Math.log(value) / Math.LN2)\r\n    if (value * (c = Math.pow(2, -e)) < 1) {\r\n      e--\r\n      c *= 2\r\n    }\r\n    if (e + eBias >= 1) {\r\n      value += rt / c\r\n    } else {\r\n      value += rt * Math.pow(2, 1 - eBias)\r\n    }\r\n    if (value * c >= 2) {\r\n      e++\r\n      c /= 2\r\n    }\r\n\r\n    if (e + eBias >= eMax) {\r\n      m = 0\r\n      e = eMax\r\n    } else if (e + eBias >= 1) {\r\n      m = (value * c - 1) * Math.pow(2, mLen)\r\n      e = e + eBias\r\n    } else {\r\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\r\n      e = 0\r\n    }\r\n  }\r\n\r\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\r\n\r\n  e = (e << mLen) | m\r\n  eLen += mLen\r\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\r\n\r\n  buffer[offset + i - d] |= s * 128\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ieee754/index.js\n// module id = 944\n// module chunks = 2 18","var toString = {}.toString;\r\n\r\nmodule.exports = Array.isArray || function (arr) {\r\n  return toString.call(arr) == '[object Array]';\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isarray/index.js\n// module id = 945\n// module chunks = 2 18","// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// Utility function that allows modes to be combined. The mode given\r\n// as the base argument takes care of most of the normal mode\r\n// functionality, but a second (typically simple) mode is used, which\r\n// can override the style of text. Both modes get to parse all of the\r\n// text, but when both assign a non-null style to a piece of code, the\r\n// overlay wins, unless the combine argument was true and not overridden,\r\n// or state.overlay.combineTokens was true, in which case the styles are\r\n// combined.\r\n\r\n(function(mod) {\r\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\r\n    mod(require(\"../../lib/codemirror\"));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n\"use strict\";\r\n\r\nCodeMirror.overlayMode = function(base, overlay, combine) {\r\n  return {\r\n    startState: function() {\r\n      return {\r\n        base: CodeMirror.startState(base),\r\n        overlay: CodeMirror.startState(overlay),\r\n        basePos: 0, baseCur: null,\r\n        overlayPos: 0, overlayCur: null,\r\n        streamSeen: null\r\n      };\r\n    },\r\n    copyState: function(state) {\r\n      return {\r\n        base: CodeMirror.copyState(base, state.base),\r\n        overlay: CodeMirror.copyState(overlay, state.overlay),\r\n        basePos: state.basePos, baseCur: null,\r\n        overlayPos: state.overlayPos, overlayCur: null\r\n      };\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      if (stream != state.streamSeen ||\r\n          Math.min(state.basePos, state.overlayPos) < stream.start) {\r\n        state.streamSeen = stream;\r\n        state.basePos = state.overlayPos = stream.start;\r\n      }\r\n\r\n      if (stream.start == state.basePos) {\r\n        state.baseCur = base.token(stream, state.base);\r\n        state.basePos = stream.pos;\r\n      }\r\n      if (stream.start == state.overlayPos) {\r\n        stream.pos = stream.start;\r\n        state.overlayCur = overlay.token(stream, state.overlay);\r\n        state.overlayPos = stream.pos;\r\n      }\r\n      stream.pos = Math.min(state.basePos, state.overlayPos);\r\n\r\n      // state.overlay.combineTokens always takes precedence over combine,\r\n      // unless set to null\r\n      if (state.overlayCur == null) return state.baseCur;\r\n      else if (state.baseCur != null &&\r\n               state.overlay.combineTokens ||\r\n               combine && state.overlay.combineTokens == null)\r\n        return state.baseCur + \" \" + state.overlayCur;\r\n      else return state.overlayCur;\r\n    },\r\n\r\n    indent: base.indent && function(state, textAfter) {\r\n      return base.indent(state.base, textAfter);\r\n    },\r\n    electricChars: base.electricChars,\r\n\r\n    innerMode: function(state) { return {state: state.base, mode: base}; },\r\n\r\n    blankLine: function(state) {\r\n      var baseToken, overlayToken;\r\n      if (base.blankLine) baseToken = base.blankLine(state.base);\r\n      if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);\r\n\r\n      return overlayToken == null ?\r\n        baseToken :\r\n        (combine && baseToken != null ? baseToken + \" \" + overlayToken : overlayToken);\r\n    }\r\n  };\r\n};\r\n\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/mode/overlay.js\n// module id = 959\n// module chunks = 18","// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\r\n    mod(require(\"../../lib/codemirror\"), require(\"../xml/xml\"), require(\"../meta\"));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../meta\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n\"use strict\";\r\n\r\nCodeMirror.defineMode(\"markdown\", function(cmCfg, modeCfg) {\r\n\r\n  var htmlMode = CodeMirror.getMode(cmCfg, \"text/html\");\r\n  var htmlModeMissing = htmlMode.name == \"null\"\r\n\r\n  function getMode(name) {\r\n    if (CodeMirror.findModeByName) {\r\n      var found = CodeMirror.findModeByName(name);\r\n      if (found) name = found.mime || found.mimes[0];\r\n    }\r\n    var mode = CodeMirror.getMode(cmCfg, name);\r\n    return mode.name == \"null\" ? null : mode;\r\n  }\r\n\r\n  // Should characters that affect highlighting be highlighted separate?\r\n  // Does not include characters that will be output (such as `1.` and `-` for lists)\r\n  if (modeCfg.highlightFormatting === undefined)\r\n    modeCfg.highlightFormatting = false;\r\n\r\n  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.\r\n  // Excess `>` will emit `error` token.\r\n  if (modeCfg.maxBlockquoteDepth === undefined)\r\n    modeCfg.maxBlockquoteDepth = 0;\r\n\r\n  // Use `fencedCodeBlocks` to configure fenced code blocks. false to\r\n  // disable, string to specify a precise regexp that the fence should\r\n  // match, and true to allow three or more backticks or tildes (as\r\n  // per CommonMark).\r\n\r\n  // Turn on task lists? (\"- [ ] \" and \"- [x] \")\r\n  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;\r\n\r\n  // Turn on strikethrough syntax\r\n  if (modeCfg.strikethrough === undefined)\r\n    modeCfg.strikethrough = false;\r\n\r\n  // Allow token types to be overridden by user-provided token types.\r\n  if (modeCfg.tokenTypeOverrides === undefined)\r\n    modeCfg.tokenTypeOverrides = {};\r\n\r\n  var tokenTypes = {\r\n    header: \"header\",\r\n    code: \"comment\",\r\n    quote: \"quote\",\r\n    list1: \"variable-2\",\r\n    list2: \"variable-3\",\r\n    list3: \"keyword\",\r\n    hr: \"hr\",\r\n    image: \"image\",\r\n    imageAltText: \"image-alt-text\",\r\n    imageMarker: \"image-marker\",\r\n    formatting: \"formatting\",\r\n    linkInline: \"link\",\r\n    linkEmail: \"link\",\r\n    linkText: \"link\",\r\n    linkHref: \"string\",\r\n    em: \"em\",\r\n    strong: \"strong\",\r\n    strikethrough: \"strikethrough\"\r\n  };\r\n\r\n  for (var tokenType in tokenTypes) {\r\n    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {\r\n      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];\r\n    }\r\n  }\r\n\r\n  var hrRE = /^([*\\-_])(?:\\s*\\1){2,}\\s*$/\r\n  ,   listRE = /^(?:[*\\-+]|^[0-9]+([.)]))\\s+/\r\n  ,   taskListRE = /^\\[(x| )\\](?=\\s)/ // Must follow listRE\r\n  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/\r\n  ,   setextHeaderRE = /^ *(?:\\={1,}|-{1,})\\s*$/\r\n  ,   textRE = /^[^#!\\[\\]*_\\\\<>` \"'(~]+/\r\n  ,   fencedCodeRE = new RegExp(\"^(\" + (modeCfg.fencedCodeBlocks === true ? \"~~~+|```+\" : modeCfg.fencedCodeBlocks) +\r\n                                \")[ \\\\t]*([\\\\w+#\\-]*)\")\r\n  ,   punctuation = /[!\\\"#$%&\\'()*+,\\-\\.\\/:;<=>?@\\[\\\\\\]^_`{|}~—]/\r\n\r\n  function switchInline(stream, state, f) {\r\n    state.f = state.inline = f;\r\n    return f(stream, state);\r\n  }\r\n\r\n  function switchBlock(stream, state, f) {\r\n    state.f = state.block = f;\r\n    return f(stream, state);\r\n  }\r\n\r\n  function lineIsEmpty(line) {\r\n    return !line || !/\\S/.test(line.string)\r\n  }\r\n\r\n  // Blocks\r\n\r\n  function blankLine(state) {\r\n    // Reset linkTitle state\r\n    state.linkTitle = false;\r\n    // Reset EM state\r\n    state.em = false;\r\n    // Reset STRONG state\r\n    state.strong = false;\r\n    // Reset strikethrough state\r\n    state.strikethrough = false;\r\n    // Reset state.quote\r\n    state.quote = 0;\r\n    // Reset state.indentedCode\r\n    state.indentedCode = false;\r\n    if (state.f == htmlBlock) {\r\n      state.f = inlineNormal;\r\n      state.block = blockNormal;\r\n    }\r\n    // Reset state.trailingSpace\r\n    state.trailingSpace = 0;\r\n    state.trailingSpaceNewLine = false;\r\n    // Mark this line as blank\r\n    state.prevLine = state.thisLine\r\n    state.thisLine = null\r\n    return null;\r\n  }\r\n\r\n  function blockNormal(stream, state) {\r\n\r\n    var sol = stream.sol();\r\n\r\n    var prevLineIsList = state.list !== false,\r\n        prevLineIsIndentedCode = state.indentedCode;\r\n\r\n    state.indentedCode = false;\r\n\r\n    if (prevLineIsList) {\r\n      if (state.indentationDiff >= 0) { // Continued list\r\n        if (state.indentationDiff < 4) { // Only adjust indentation if *not* a code block\r\n          state.indentation -= state.indentationDiff;\r\n        }\r\n        state.list = null;\r\n      } else if (state.indentation > 0) {\r\n        state.list = null;\r\n      } else { // No longer a list\r\n        state.list = false;\r\n      }\r\n    }\r\n\r\n    var match = null;\r\n    if (state.indentationDiff >= 4) {\r\n      stream.skipToEnd();\r\n      if (prevLineIsIndentedCode || lineIsEmpty(state.prevLine)) {\r\n        state.indentation -= 4;\r\n        state.indentedCode = true;\r\n        return tokenTypes.code;\r\n      } else {\r\n        return null;\r\n      }\r\n    } else if (stream.eatSpace()) {\r\n      return null;\r\n    } else if ((match = stream.match(atxHeaderRE)) && match[1].length <= 6) {\r\n      state.header = match[1].length;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\r\n      state.f = state.inline;\r\n      return getType(state);\r\n    } else if (!lineIsEmpty(state.prevLine) && !state.quote && !prevLineIsList &&\r\n               !prevLineIsIndentedCode && (match = stream.match(setextHeaderRE))) {\r\n      state.header = match[0].charAt(0) == '=' ? 1 : 2;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\r\n      state.f = state.inline;\r\n      return getType(state);\r\n    } else if (stream.eat('>')) {\r\n      state.quote = sol ? 1 : state.quote + 1;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"quote\";\r\n      stream.eatSpace();\r\n      return getType(state);\r\n    } else if (stream.peek() === '[') {\r\n      return switchInline(stream, state, footnoteLink);\r\n    } else if (stream.match(hrRE, true)) {\r\n      state.hr = true;\r\n      return tokenTypes.hr;\r\n    } else if (match = stream.match(listRE)) {\r\n      var listType = match[1] ? \"ol\" : \"ul\";\r\n      state.indentation = stream.column() + stream.current().length;\r\n      state.list = true;\r\n\r\n      // While this list item's marker's indentation\r\n      // is less than the deepest list item's content's indentation,\r\n      // pop the deepest list item indentation off the stack.\r\n      while (state.listStack && stream.column() < state.listStack[state.listStack.length - 1]) {\r\n        state.listStack.pop();\r\n      }\r\n\r\n      // Add this list item's content's indentation to the stack\r\n      state.listStack.push(state.indentation);\r\n\r\n      if (modeCfg.taskLists && stream.match(taskListRE, false)) {\r\n        state.taskList = true;\r\n      }\r\n      state.f = state.inline;\r\n      if (modeCfg.highlightFormatting) state.formatting = [\"list\", \"list-\" + listType];\r\n      return getType(state);\r\n    } else if (modeCfg.fencedCodeBlocks && (match = stream.match(fencedCodeRE, true))) {\r\n      state.fencedChars = match[1]\r\n      // try switching mode\r\n      state.localMode = getMode(match[2]);\r\n      if (state.localMode) state.localState = CodeMirror.startState(state.localMode);\r\n      state.f = state.block = local;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\r\n      state.code = -1\r\n      return getType(state);\r\n    }\r\n\r\n    return switchInline(stream, state, state.inline);\r\n  }\r\n\r\n  function htmlBlock(stream, state) {\r\n    var style = htmlMode.token(stream, state.htmlState);\r\n    if (!htmlModeMissing) {\r\n      var inner = CodeMirror.innerMode(htmlMode, state.htmlState)\r\n      if ((inner.mode.name == \"xml\" && inner.state.tagStart === null &&\r\n           (!inner.state.context && inner.state.tokenize.isInText)) ||\r\n          (state.md_inside && stream.current().indexOf(\">\") > -1)) {\r\n        state.f = inlineNormal;\r\n        state.block = blockNormal;\r\n        state.htmlState = null;\r\n      }\r\n    }\r\n    return style;\r\n  }\r\n\r\n  function local(stream, state) {\r\n    if (state.fencedChars && stream.match(state.fencedChars)) {\r\n      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\r\n      var returnType = getType(state)\r\n      state.localMode = state.localState = null;\r\n      state.block = blockNormal;\r\n      state.f = inlineNormal;\r\n      state.fencedChars = null;\r\n      state.code = 0\r\n      return returnType;\r\n    } else if (state.fencedChars && stream.skipTo(state.fencedChars)) {\r\n      return \"comment\"\r\n    } else if (state.localMode) {\r\n      return state.localMode.token(stream, state.localState);\r\n    } else {\r\n      stream.skipToEnd();\r\n      return tokenTypes.code;\r\n    }\r\n  }\r\n\r\n  // Inline\r\n  function getType(state) {\r\n    var styles = [];\r\n\r\n    if (state.formatting) {\r\n      styles.push(tokenTypes.formatting);\r\n\r\n      if (typeof state.formatting === \"string\") state.formatting = [state.formatting];\r\n\r\n      for (var i = 0; i < state.formatting.length; i++) {\r\n        styles.push(tokenTypes.formatting + \"-\" + state.formatting[i]);\r\n\r\n        if (state.formatting[i] === \"header\") {\r\n          styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.header);\r\n        }\r\n\r\n        // Add `formatting-quote` and `formatting-quote-#` for blockquotes\r\n        // Add `error` instead if the maximum blockquote nesting depth is passed\r\n        if (state.formatting[i] === \"quote\") {\r\n          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\r\n            styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.quote);\r\n          } else {\r\n            styles.push(\"error\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (state.taskOpen) {\r\n      styles.push(\"meta\");\r\n      return styles.length ? styles.join(' ') : null;\r\n    }\r\n    if (state.taskClosed) {\r\n      styles.push(\"property\");\r\n      return styles.length ? styles.join(' ') : null;\r\n    }\r\n\r\n    if (state.linkHref) {\r\n      styles.push(tokenTypes.linkHref, \"url\");\r\n    } else { // Only apply inline styles to non-url text\r\n      if (state.strong) { styles.push(tokenTypes.strong); }\r\n      if (state.em) { styles.push(tokenTypes.em); }\r\n      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }\r\n      if (state.linkText) { styles.push(tokenTypes.linkText); }\r\n      if (state.code) { styles.push(tokenTypes.code); }\r\n      if (state.image) { styles.push(tokenTypes.image); }\r\n      if (state.imageAltText) { styles.push(tokenTypes.imageAltText, \"link\"); }\r\n      if (state.imageMarker) { styles.push(tokenTypes.imageMarker); }\r\n    }\r\n\r\n    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + \"-\" + state.header); }\r\n\r\n    if (state.quote) {\r\n      styles.push(tokenTypes.quote);\r\n\r\n      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth\r\n      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\r\n        styles.push(tokenTypes.quote + \"-\" + state.quote);\r\n      } else {\r\n        styles.push(tokenTypes.quote + \"-\" + modeCfg.maxBlockquoteDepth);\r\n      }\r\n    }\r\n\r\n    if (state.list !== false) {\r\n      var listMod = (state.listStack.length - 1) % 3;\r\n      if (!listMod) {\r\n        styles.push(tokenTypes.list1);\r\n      } else if (listMod === 1) {\r\n        styles.push(tokenTypes.list2);\r\n      } else {\r\n        styles.push(tokenTypes.list3);\r\n      }\r\n    }\r\n\r\n    if (state.trailingSpaceNewLine) {\r\n      styles.push(\"trailing-space-new-line\");\r\n    } else if (state.trailingSpace) {\r\n      styles.push(\"trailing-space-\" + (state.trailingSpace % 2 ? \"a\" : \"b\"));\r\n    }\r\n\r\n    return styles.length ? styles.join(' ') : null;\r\n  }\r\n\r\n  function handleText(stream, state) {\r\n    if (stream.match(textRE, true)) {\r\n      return getType(state);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  function inlineNormal(stream, state) {\r\n    var style = state.text(stream, state);\r\n    if (typeof style !== 'undefined')\r\n      return style;\r\n\r\n    if (state.list) { // List marker (*, +, -, 1., etc)\r\n      state.list = null;\r\n      return getType(state);\r\n    }\r\n\r\n    if (state.taskList) {\r\n      var taskOpen = stream.match(taskListRE, true)[1] !== \"x\";\r\n      if (taskOpen) state.taskOpen = true;\r\n      else state.taskClosed = true;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"task\";\r\n      state.taskList = false;\r\n      return getType(state);\r\n    }\r\n\r\n    state.taskOpen = false;\r\n    state.taskClosed = false;\r\n\r\n    if (state.header && stream.match(/^#+$/, true)) {\r\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\r\n      return getType(state);\r\n    }\r\n\r\n    var ch = stream.next();\r\n\r\n    // Matches link titles present on next line\r\n    if (state.linkTitle) {\r\n      state.linkTitle = false;\r\n      var matchCh = ch;\r\n      if (ch === '(') {\r\n        matchCh = ')';\r\n      }\r\n      matchCh = (matchCh+'').replace(/([.?*+^\\[\\]\\\\(){}|-])/g, \"\\\\$1\");\r\n      var regex = '^\\\\s*(?:[^' + matchCh + '\\\\\\\\]+|\\\\\\\\\\\\\\\\|\\\\\\\\.)' + matchCh;\r\n      if (stream.match(new RegExp(regex), true)) {\r\n        return tokenTypes.linkHref;\r\n      }\r\n    }\r\n\r\n    // If this block is changed, it may need to be updated in GFM mode\r\n    if (ch === '`') {\r\n      var previousFormatting = state.formatting;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"code\";\r\n      stream.eatWhile('`');\r\n      var count = stream.current().length\r\n      if (state.code == 0) {\r\n        state.code = count\r\n        return getType(state)\r\n      } else if (count == state.code) { // Must be exact\r\n        var t = getType(state)\r\n        state.code = 0\r\n        return t\r\n      } else {\r\n        state.formatting = previousFormatting\r\n        return getType(state)\r\n      }\r\n    } else if (state.code) {\r\n      return getType(state);\r\n    }\r\n\r\n    if (ch === '\\\\') {\r\n      stream.next();\r\n      if (modeCfg.highlightFormatting) {\r\n        var type = getType(state);\r\n        var formattingEscape = tokenTypes.formatting + \"-escape\";\r\n        return type ? type + \" \" + formattingEscape : formattingEscape;\r\n      }\r\n    }\r\n\r\n    if (ch === '!' && stream.match(/\\[[^\\]]*\\] ?(?:\\(|\\[)/, false)) {\r\n      state.imageMarker = true;\r\n      state.image = true;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\r\n      return getType(state);\r\n    }\r\n\r\n    if (ch === '[' && state.imageMarker && stream.match(/[^\\]]*\\](\\(.*?\\)| ?\\[.*?\\])/, false)) {\r\n      state.imageMarker = false;\r\n      state.imageAltText = true\r\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\r\n      return getType(state);\r\n    }\r\n\r\n    if (ch === ']' && state.imageAltText) {\r\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\r\n      var type = getType(state);\r\n      state.imageAltText = false;\r\n      state.image = false;\r\n      state.inline = state.f = linkHref;\r\n      return type;\r\n    }\r\n\r\n    if (ch === '[' && !state.image) {\r\n      state.linkText = true;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      return getType(state);\r\n    }\r\n\r\n    if (ch === ']' && state.linkText) {\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var type = getType(state);\r\n      state.linkText = false;\r\n      state.inline = state.f = stream.match(/\\(.*?\\)| ?\\[.*?\\]/, false) ? linkHref : inlineNormal\r\n      return type;\r\n    }\r\n\r\n    if (ch === '<' && stream.match(/^(https?|ftps?):\\/\\/(?:[^\\\\>]|\\\\.)+>/, false)) {\r\n      state.f = state.inline = linkInline;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var type = getType(state);\r\n      if (type){\r\n        type += \" \";\r\n      } else {\r\n        type = \"\";\r\n      }\r\n      return type + tokenTypes.linkInline;\r\n    }\r\n\r\n    if (ch === '<' && stream.match(/^[^> \\\\]+@(?:[^\\\\>]|\\\\.)+>/, false)) {\r\n      state.f = state.inline = linkInline;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var type = getType(state);\r\n      if (type){\r\n        type += \" \";\r\n      } else {\r\n        type = \"\";\r\n      }\r\n      return type + tokenTypes.linkEmail;\r\n    }\r\n\r\n    if (ch === '<' && stream.match(/^(!--|[a-z]+(?:\\s+[a-z_:.\\-]+(?:\\s*=\\s*[^ >]+)?)*\\s*>)/i, false)) {\r\n      var end = stream.string.indexOf(\">\", stream.pos);\r\n      if (end != -1) {\r\n        var atts = stream.string.substring(stream.start, end);\r\n        if (/markdown\\s*=\\s*('|\"){0,1}1('|\"){0,1}/.test(atts)) state.md_inside = true;\r\n      }\r\n      stream.backUp(1);\r\n      state.htmlState = CodeMirror.startState(htmlMode);\r\n      return switchBlock(stream, state, htmlBlock);\r\n    }\r\n\r\n    if (ch === '<' && stream.match(/^\\/\\w*?>/)) {\r\n      state.md_inside = false;\r\n      return \"tag\";\r\n    } else if (ch === \"*\" || ch === \"_\") {\r\n      var len = 1, before = stream.pos == 1 ? \" \" : stream.string.charAt(stream.pos - 2)\r\n      while (len < 3 && stream.eat(ch)) len++\r\n      var after = stream.peek() || \" \"\r\n      // See http://spec.commonmark.org/0.27/#emphasis-and-strong-emphasis\r\n      var leftFlanking = !/\\s/.test(after) && (!punctuation.test(after) || /\\s/.test(before) || punctuation.test(before))\r\n      var rightFlanking = !/\\s/.test(before) && (!punctuation.test(before) || /\\s/.test(after) || punctuation.test(after))\r\n      var setEm = null, setStrong = null\r\n      if (len % 2) { // Em\r\n        if (!state.em && leftFlanking && (ch === \"*\" || !rightFlanking || punctuation.test(before)))\r\n          setEm = true\r\n        else if (state.em == ch && rightFlanking && (ch === \"*\" || !leftFlanking || punctuation.test(after)))\r\n          setEm = false\r\n      }\r\n      if (len > 1) { // Strong\r\n        if (!state.strong && leftFlanking && (ch === \"*\" || !rightFlanking || punctuation.test(before)))\r\n          setStrong = true\r\n        else if (state.strong == ch && rightFlanking && (ch === \"*\" || !leftFlanking || punctuation.test(after)))\r\n          setStrong = false\r\n      }\r\n      if (setStrong != null || setEm != null) {\r\n        if (modeCfg.highlightFormatting) state.formatting = setEm == null ? \"strong\" : setStrong == null ? \"em\" : \"strong em\"\r\n        if (setEm === true) state.em = ch\r\n        if (setStrong === true) state.strong = ch\r\n        var t = getType(state)\r\n        if (setEm === false) state.em = false\r\n        if (setStrong === false) state.strong = false\r\n        return t\r\n      }\r\n    } else if (ch === ' ') {\r\n      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces\r\n        if (stream.peek() === ' ') { // Surrounded by spaces, ignore\r\n          return getType(state);\r\n        } else { // Not surrounded by spaces, back up pointer\r\n          stream.backUp(1);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (modeCfg.strikethrough) {\r\n      if (ch === '~' && stream.eatWhile(ch)) {\r\n        if (state.strikethrough) {// Remove strikethrough\r\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\r\n          var t = getType(state);\r\n          state.strikethrough = false;\r\n          return t;\r\n        } else if (stream.match(/^[^\\s]/, false)) {// Add strikethrough\r\n          state.strikethrough = true;\r\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\r\n          return getType(state);\r\n        }\r\n      } else if (ch === ' ') {\r\n        if (stream.match(/^~~/, true)) { // Probably surrounded by space\r\n          if (stream.peek() === ' ') { // Surrounded by spaces, ignore\r\n            return getType(state);\r\n          } else { // Not surrounded by spaces, back up pointer\r\n            stream.backUp(2);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (ch === ' ') {\r\n      if (stream.match(/ +$/, false)) {\r\n        state.trailingSpace++;\r\n      } else if (state.trailingSpace) {\r\n        state.trailingSpaceNewLine = true;\r\n      }\r\n    }\r\n\r\n    return getType(state);\r\n  }\r\n\r\n  function linkInline(stream, state) {\r\n    var ch = stream.next();\r\n\r\n    if (ch === \">\") {\r\n      state.f = state.inline = inlineNormal;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var type = getType(state);\r\n      if (type){\r\n        type += \" \";\r\n      } else {\r\n        type = \"\";\r\n      }\r\n      return type + tokenTypes.linkInline;\r\n    }\r\n\r\n    stream.match(/^[^>]+/, true);\r\n\r\n    return tokenTypes.linkInline;\r\n  }\r\n\r\n  function linkHref(stream, state) {\r\n    // Check if space, and return NULL if so (to avoid marking the space)\r\n    if(stream.eatSpace()){\r\n      return null;\r\n    }\r\n    var ch = stream.next();\r\n    if (ch === '(' || ch === '[') {\r\n      state.f = state.inline = getLinkHrefInside(ch === \"(\" ? \")\" : \"]\");\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\r\n      state.linkHref = true;\r\n      return getType(state);\r\n    }\r\n    return 'error';\r\n  }\r\n\r\n  var linkRE = {\r\n    \")\": /^(?:[^\\\\\\(\\)]|\\\\.|\\((?:[^\\\\\\(\\)]|\\\\.)*\\))*?(?=\\))/,\r\n    \"]\": /^(?:[^\\\\\\[\\]]|\\\\.|\\[(?:[^\\\\\\[\\]]|\\\\.)*\\])*?(?=\\])/\r\n  }\r\n\r\n  function getLinkHrefInside(endChar) {\r\n    return function(stream, state) {\r\n      var ch = stream.next();\r\n\r\n      if (ch === endChar) {\r\n        state.f = state.inline = inlineNormal;\r\n        if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\r\n        var returnState = getType(state);\r\n        state.linkHref = false;\r\n        return returnState;\r\n      }\r\n\r\n      stream.match(linkRE[endChar])\r\n      state.linkHref = true;\r\n      return getType(state);\r\n    };\r\n  }\r\n\r\n  function footnoteLink(stream, state) {\r\n    if (stream.match(/^([^\\]\\\\]|\\\\.)*\\]:/, false)) {\r\n      state.f = footnoteLinkInside;\r\n      stream.next(); // Consume [\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      state.linkText = true;\r\n      return getType(state);\r\n    }\r\n    return switchInline(stream, state, inlineNormal);\r\n  }\r\n\r\n  function footnoteLinkInside(stream, state) {\r\n    if (stream.match(/^\\]:/, true)) {\r\n      state.f = state.inline = footnoteUrl;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var returnType = getType(state);\r\n      state.linkText = false;\r\n      return returnType;\r\n    }\r\n\r\n    stream.match(/^([^\\]\\\\]|\\\\.)+/, true);\r\n\r\n    return tokenTypes.linkText;\r\n  }\r\n\r\n  function footnoteUrl(stream, state) {\r\n    // Check if space, and return NULL if so (to avoid marking the space)\r\n    if(stream.eatSpace()){\r\n      return null;\r\n    }\r\n    // Match URL\r\n    stream.match(/^[^\\s]+/, true);\r\n    // Check for link title\r\n    if (stream.peek() === undefined) { // End of line, set flag to check next line\r\n      state.linkTitle = true;\r\n    } else { // More content on line, check if link title\r\n      stream.match(/^(?:\\s+(?:\"(?:[^\"\\\\]|\\\\\\\\|\\\\.)+\"|'(?:[^'\\\\]|\\\\\\\\|\\\\.)+'|\\((?:[^)\\\\]|\\\\\\\\|\\\\.)+\\)))?/, true);\r\n    }\r\n    state.f = state.inline = inlineNormal;\r\n    return tokenTypes.linkHref + \" url\";\r\n  }\r\n\r\n  var mode = {\r\n    startState: function() {\r\n      return {\r\n        f: blockNormal,\r\n\r\n        prevLine: null,\r\n        thisLine: null,\r\n\r\n        block: blockNormal,\r\n        htmlState: null,\r\n        indentation: 0,\r\n\r\n        inline: inlineNormal,\r\n        text: handleText,\r\n\r\n        formatting: false,\r\n        linkText: false,\r\n        linkHref: false,\r\n        linkTitle: false,\r\n        code: 0,\r\n        em: false,\r\n        strong: false,\r\n        header: 0,\r\n        hr: false,\r\n        taskList: false,\r\n        list: false,\r\n        listStack: [],\r\n        quote: 0,\r\n        trailingSpace: 0,\r\n        trailingSpaceNewLine: false,\r\n        strikethrough: false,\r\n        fencedChars: null\r\n      };\r\n    },\r\n\r\n    copyState: function(s) {\r\n      return {\r\n        f: s.f,\r\n\r\n        prevLine: s.prevLine,\r\n        thisLine: s.thisLine,\r\n\r\n        block: s.block,\r\n        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),\r\n        indentation: s.indentation,\r\n\r\n        localMode: s.localMode,\r\n        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,\r\n\r\n        inline: s.inline,\r\n        text: s.text,\r\n        formatting: false,\r\n        linkText: s.linkText,\r\n        linkTitle: s.linkTitle,\r\n        code: s.code,\r\n        em: s.em,\r\n        strong: s.strong,\r\n        strikethrough: s.strikethrough,\r\n        header: s.header,\r\n        hr: s.hr,\r\n        taskList: s.taskList,\r\n        list: s.list,\r\n        listStack: s.listStack.slice(0),\r\n        quote: s.quote,\r\n        indentedCode: s.indentedCode,\r\n        trailingSpace: s.trailingSpace,\r\n        trailingSpaceNewLine: s.trailingSpaceNewLine,\r\n        md_inside: s.md_inside,\r\n        fencedChars: s.fencedChars\r\n      };\r\n    },\r\n\r\n    token: function(stream, state) {\r\n\r\n      // Reset state.formatting\r\n      state.formatting = false;\r\n\r\n      if (stream != state.thisLine) {\r\n        var forceBlankLine = state.header || state.hr;\r\n\r\n        // Reset state.header and state.hr\r\n        state.header = 0;\r\n        state.hr = false;\r\n\r\n        if (stream.match(/^\\s*$/, true) || forceBlankLine) {\r\n          blankLine(state);\r\n          if (!forceBlankLine) return null\r\n          state.prevLine = null\r\n        }\r\n\r\n        state.prevLine = state.thisLine\r\n        state.thisLine = stream\r\n\r\n        // Reset state.taskList\r\n        state.taskList = false;\r\n\r\n        // Reset state.trailingSpace\r\n        state.trailingSpace = 0;\r\n        state.trailingSpaceNewLine = false;\r\n\r\n        state.f = state.block;\r\n        var indentation = stream.match(/^\\s*/, true)[0].replace(/\\t/g, '    ').length;\r\n        state.indentationDiff = Math.min(indentation - state.indentation, 4);\r\n        state.indentation = state.indentation + state.indentationDiff;\r\n        if (indentation > 0) return null;\r\n      }\r\n      return state.f(stream, state);\r\n    },\r\n\r\n    innerMode: function(state) {\r\n      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};\r\n      if (state.localState) return {state: state.localState, mode: state.localMode};\r\n      return {state: state, mode: mode};\r\n    },\r\n\r\n    blankLine: blankLine,\r\n\r\n    getType: getType,\r\n\r\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\r\n    fold: \"markdown\"\r\n  };\r\n  return mode;\r\n}, \"xml\");\r\n\r\nCodeMirror.defineMIME(\"text/x-markdown\", \"markdown\");\r\n\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/mode/markdown/markdown.js\n// module id = 960\n// module chunks = 18","// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\r\n    mod(require(\"../../lib/codemirror\"));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n\"use strict\";\r\n\r\nvar htmlConfig = {\r\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\r\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\r\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\r\n                    'track': true, 'wbr': true, 'menuitem': true},\r\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\r\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\r\n                     'th': true, 'tr': true},\r\n  contextGrabbers: {\r\n    'dd': {'dd': true, 'dt': true},\r\n    'dt': {'dd': true, 'dt': true},\r\n    'li': {'li': true},\r\n    'option': {'option': true, 'optgroup': true},\r\n    'optgroup': {'optgroup': true},\r\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\r\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\r\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\r\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\r\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\r\n    'rp': {'rp': true, 'rt': true},\r\n    'rt': {'rp': true, 'rt': true},\r\n    'tbody': {'tbody': true, 'tfoot': true},\r\n    'td': {'td': true, 'th': true},\r\n    'tfoot': {'tbody': true},\r\n    'th': {'td': true, 'th': true},\r\n    'thead': {'tbody': true, 'tfoot': true},\r\n    'tr': {'tr': true}\r\n  },\r\n  doNotIndent: {\"pre\": true},\r\n  allowUnquoted: true,\r\n  allowMissing: true,\r\n  caseFold: true\r\n}\r\n\r\nvar xmlConfig = {\r\n  autoSelfClosers: {},\r\n  implicitlyClosed: {},\r\n  contextGrabbers: {},\r\n  doNotIndent: {},\r\n  allowUnquoted: false,\r\n  allowMissing: false,\r\n  caseFold: false\r\n}\r\n\r\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\r\n  var indentUnit = editorConf.indentUnit\r\n  var config = {}\r\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\r\n  for (var prop in defaults) config[prop] = defaults[prop]\r\n  for (var prop in config_) config[prop] = config_[prop]\r\n\r\n  // Return variables for tokenizers\r\n  var type, setStyle;\r\n\r\n  function inText(stream, state) {\r\n    function chain(parser) {\r\n      state.tokenize = parser;\r\n      return parser(stream, state);\r\n    }\r\n\r\n    var ch = stream.next();\r\n    if (ch == \"<\") {\r\n      if (stream.eat(\"!\")) {\r\n        if (stream.eat(\"[\")) {\r\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\r\n          else return null;\r\n        } else if (stream.match(\"--\")) {\r\n          return chain(inBlock(\"comment\", \"-->\"));\r\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\r\n          stream.eatWhile(/[\\w\\._\\-]/);\r\n          return chain(doctype(1));\r\n        } else {\r\n          return null;\r\n        }\r\n      } else if (stream.eat(\"?\")) {\r\n        stream.eatWhile(/[\\w\\._\\-]/);\r\n        state.tokenize = inBlock(\"meta\", \"?>\");\r\n        return \"meta\";\r\n      } else {\r\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\r\n        state.tokenize = inTag;\r\n        return \"tag bracket\";\r\n      }\r\n    } else if (ch == \"&\") {\r\n      var ok;\r\n      if (stream.eat(\"#\")) {\r\n        if (stream.eat(\"x\")) {\r\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\r\n        } else {\r\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\r\n        }\r\n      } else {\r\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\r\n      }\r\n      return ok ? \"atom\" : \"error\";\r\n    } else {\r\n      stream.eatWhile(/[^&<]/);\r\n      return null;\r\n    }\r\n  }\r\n  inText.isInText = true;\r\n\r\n  function inTag(stream, state) {\r\n    var ch = stream.next();\r\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\r\n      state.tokenize = inText;\r\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\r\n      return \"tag bracket\";\r\n    } else if (ch == \"=\") {\r\n      type = \"equals\";\r\n      return null;\r\n    } else if (ch == \"<\") {\r\n      state.tokenize = inText;\r\n      state.state = baseState;\r\n      state.tagName = state.tagStart = null;\r\n      var next = state.tokenize(stream, state);\r\n      return next ? next + \" tag error\" : \"tag error\";\r\n    } else if (/[\\'\\\"]/.test(ch)) {\r\n      state.tokenize = inAttribute(ch);\r\n      state.stringStartCol = stream.column();\r\n      return state.tokenize(stream, state);\r\n    } else {\r\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\r\n      return \"word\";\r\n    }\r\n  }\r\n\r\n  function inAttribute(quote) {\r\n    var closure = function(stream, state) {\r\n      while (!stream.eol()) {\r\n        if (stream.next() == quote) {\r\n          state.tokenize = inTag;\r\n          break;\r\n        }\r\n      }\r\n      return \"string\";\r\n    };\r\n    closure.isInAttribute = true;\r\n    return closure;\r\n  }\r\n\r\n  function inBlock(style, terminator) {\r\n    return function(stream, state) {\r\n      while (!stream.eol()) {\r\n        if (stream.match(terminator)) {\r\n          state.tokenize = inText;\r\n          break;\r\n        }\r\n        stream.next();\r\n      }\r\n      return style;\r\n    };\r\n  }\r\n  function doctype(depth) {\r\n    return function(stream, state) {\r\n      var ch;\r\n      while ((ch = stream.next()) != null) {\r\n        if (ch == \"<\") {\r\n          state.tokenize = doctype(depth + 1);\r\n          return state.tokenize(stream, state);\r\n        } else if (ch == \">\") {\r\n          if (depth == 1) {\r\n            state.tokenize = inText;\r\n            break;\r\n          } else {\r\n            state.tokenize = doctype(depth - 1);\r\n            return state.tokenize(stream, state);\r\n          }\r\n        }\r\n      }\r\n      return \"meta\";\r\n    };\r\n  }\r\n\r\n  function Context(state, tagName, startOfLine) {\r\n    this.prev = state.context;\r\n    this.tagName = tagName;\r\n    this.indent = state.indented;\r\n    this.startOfLine = startOfLine;\r\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\r\n      this.noIndent = true;\r\n  }\r\n  function popContext(state) {\r\n    if (state.context) state.context = state.context.prev;\r\n  }\r\n  function maybePopContext(state, nextTagName) {\r\n    var parentTagName;\r\n    while (true) {\r\n      if (!state.context) {\r\n        return;\r\n      }\r\n      parentTagName = state.context.tagName;\r\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\r\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\r\n        return;\r\n      }\r\n      popContext(state);\r\n    }\r\n  }\r\n\r\n  function baseState(type, stream, state) {\r\n    if (type == \"openTag\") {\r\n      state.tagStart = stream.column();\r\n      return tagNameState;\r\n    } else if (type == \"closeTag\") {\r\n      return closeTagNameState;\r\n    } else {\r\n      return baseState;\r\n    }\r\n  }\r\n  function tagNameState(type, stream, state) {\r\n    if (type == \"word\") {\r\n      state.tagName = stream.current();\r\n      setStyle = \"tag\";\r\n      return attrState;\r\n    } else {\r\n      setStyle = \"error\";\r\n      return tagNameState;\r\n    }\r\n  }\r\n  function closeTagNameState(type, stream, state) {\r\n    if (type == \"word\") {\r\n      var tagName = stream.current();\r\n      if (state.context && state.context.tagName != tagName &&\r\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\r\n        popContext(state);\r\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\r\n        setStyle = \"tag\";\r\n        return closeState;\r\n      } else {\r\n        setStyle = \"tag error\";\r\n        return closeStateErr;\r\n      }\r\n    } else {\r\n      setStyle = \"error\";\r\n      return closeStateErr;\r\n    }\r\n  }\r\n\r\n  function closeState(type, _stream, state) {\r\n    if (type != \"endTag\") {\r\n      setStyle = \"error\";\r\n      return closeState;\r\n    }\r\n    popContext(state);\r\n    return baseState;\r\n  }\r\n  function closeStateErr(type, stream, state) {\r\n    setStyle = \"error\";\r\n    return closeState(type, stream, state);\r\n  }\r\n\r\n  function attrState(type, _stream, state) {\r\n    if (type == \"word\") {\r\n      setStyle = \"attribute\";\r\n      return attrEqState;\r\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\r\n      var tagName = state.tagName, tagStart = state.tagStart;\r\n      state.tagName = state.tagStart = null;\r\n      if (type == \"selfcloseTag\" ||\r\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\r\n        maybePopContext(state, tagName);\r\n      } else {\r\n        maybePopContext(state, tagName);\r\n        state.context = new Context(state, tagName, tagStart == state.indented);\r\n      }\r\n      return baseState;\r\n    }\r\n    setStyle = \"error\";\r\n    return attrState;\r\n  }\r\n  function attrEqState(type, stream, state) {\r\n    if (type == \"equals\") return attrValueState;\r\n    if (!config.allowMissing) setStyle = \"error\";\r\n    return attrState(type, stream, state);\r\n  }\r\n  function attrValueState(type, stream, state) {\r\n    if (type == \"string\") return attrContinuedState;\r\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\r\n    setStyle = \"error\";\r\n    return attrState(type, stream, state);\r\n  }\r\n  function attrContinuedState(type, stream, state) {\r\n    if (type == \"string\") return attrContinuedState;\r\n    return attrState(type, stream, state);\r\n  }\r\n\r\n  return {\r\n    startState: function(baseIndent) {\r\n      var state = {tokenize: inText,\r\n                   state: baseState,\r\n                   indented: baseIndent || 0,\r\n                   tagName: null, tagStart: null,\r\n                   context: null}\r\n      if (baseIndent != null) state.baseIndent = baseIndent\r\n      return state\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      if (!state.tagName && stream.sol())\r\n        state.indented = stream.indentation();\r\n\r\n      if (stream.eatSpace()) return null;\r\n      type = null;\r\n      var style = state.tokenize(stream, state);\r\n      if ((style || type) && style != \"comment\") {\r\n        setStyle = null;\r\n        state.state = state.state(type || style, stream, state);\r\n        if (setStyle)\r\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\r\n      }\r\n      return style;\r\n    },\r\n\r\n    indent: function(state, textAfter, fullLine) {\r\n      var context = state.context;\r\n      // Indent multi-line strings (e.g. css).\r\n      if (state.tokenize.isInAttribute) {\r\n        if (state.tagStart == state.indented)\r\n          return state.stringStartCol + 1;\r\n        else\r\n          return state.indented + indentUnit;\r\n      }\r\n      if (context && context.noIndent) return CodeMirror.Pass;\r\n      if (state.tokenize != inTag && state.tokenize != inText)\r\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\r\n      // Indent the starts of attribute names.\r\n      if (state.tagName) {\r\n        if (config.multilineTagIndentPastTag !== false)\r\n          return state.tagStart + state.tagName.length + 2;\r\n        else\r\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\r\n      }\r\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\r\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\r\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\r\n        while (context) {\r\n          if (context.tagName == tagAfter[2]) {\r\n            context = context.prev;\r\n            break;\r\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\r\n            context = context.prev;\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n      } else if (tagAfter) { // Opening tag spotted\r\n        while (context) {\r\n          var grabbers = config.contextGrabbers[context.tagName];\r\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\r\n            context = context.prev;\r\n          else\r\n            break;\r\n        }\r\n      }\r\n      while (context && context.prev && !context.startOfLine)\r\n        context = context.prev;\r\n      if (context) return context.indent + indentUnit;\r\n      else return state.baseIndent || 0;\r\n    },\r\n\r\n    electricInput: /<\\/[\\s\\w:]+>$/,\r\n    blockCommentStart: \"<!--\",\r\n    blockCommentEnd: \"-->\",\r\n\r\n    configuration: config.htmlMode ? \"html\" : \"xml\",\r\n    helperType: config.htmlMode ? \"html\" : \"xml\",\r\n\r\n    skipAttribute: function(state) {\r\n      if (state.state == attrValueState)\r\n        state.state = attrState\r\n    }\r\n  };\r\n});\r\n\r\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\r\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\r\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\r\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\r\n\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/mode/xml/xml.js\n// module id = 961\n// module chunks = 18","<template>\r\n  <div class='simplemde-container' :style=\"{height:height+'px',zIndex:zIndex}\">\r\n    <textarea :id='id'>\r\n    </textarea>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  import 'simplemde/dist/simplemde.min.css';\r\n  import SimpleMDE from 'simplemde';\r\n\r\n  export default {\r\n    name: 'Sticky',\r\n    props: {\r\n      value: String,\r\n      id: {\r\n        type: String,\r\n        default: 'markdown-editor'\r\n      },\r\n      autofocus: {\r\n        type: Boolean,\r\n        default: false\r\n      },\r\n      placeholder: {\r\n        type: String,\r\n        default: ''\r\n      },\r\n      height: {\r\n        type: Number,\r\n        default: 150\r\n      },\r\n      zIndex: {\r\n        type: Number,\r\n        default: 10\r\n      },\r\n      toolbar: {\r\n        type: Array\r\n      }\r\n    },\r\n    data() {\r\n      return {\r\n        simplemde: null,\r\n        hasChange: false\r\n      };\r\n    },\r\n    watch: {\r\n      value(val) {\r\n        if (val === this.simplemde.value() && !this.hasChange) return;\r\n        this.simplemde.value(val);\r\n      }\r\n    },\r\n    mounted() {\r\n      this.simplemde = new SimpleMDE({\r\n        element: document.getElementById(this.id),\r\n        autofocus: this.autofocus,\r\n        toolbar: this.toolbar,\r\n        spellChecker: false,\r\n        insertTexts: {\r\n          link: ['[', ']( )']\r\n        },\r\n      // hideIcons: ['guide', 'heading', 'quote', 'image', 'preview', 'side-by-side', 'fullscreen'],\r\n        placeholder: this.placeholder\r\n      });\r\n      if (this.value) {\r\n        this.simplemde.value(this.value);\r\n      }\r\n      this.simplemde.codemirror.on('change', () => {\r\n        if (this.hasChange) {\r\n          this.hasChange = true\r\n        }\r\n        this.$emit('input', this.simplemde.value());\r\n      });\r\n    },\r\n    destroyed() {\r\n      this.simplemde = null;\r\n    }\r\n};\r\n</script>\r\n\r\n<style>\r\n.simplemde-container .CodeMirror {\r\n  /*height: 150px;*/\r\n  min-height: 150px;\r\n}\r\n\r\n.simplemde-container .CodeMirror-scroll {\r\n  min-height: 150px;\r\n}\r\n\r\n.simplemde-container .CodeMirror-code {\r\n  padding-bottom: 40px;\r\n}\r\n\r\n.simplemde-container .editor-statusbar {\r\n  display: none;\r\n}\r\n\r\n.simplemde-container .CodeMirror .CodeMirror-code .cm-link {\r\n  color: #1482F0;\r\n}\r\n\r\n.simplemde-container .CodeMirror .CodeMirror-code .cm-string.cm-url {\r\n  color: #2d3b4d;\r\n  font-weight: bold;\r\n}\r\n\r\n.simplemde-container .CodeMirror .CodeMirror-code .cm-formatting-link-string.cm-url {\r\n  padding: 0 2px;\r\n  font-weight: bold;\r\n  color: #E61E1E;\r\n}\r\n</style>\r\n\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// index.vue?b86a0058"],"sourceRoot":""}