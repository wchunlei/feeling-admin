{"version":3,"sources":["webpack:///static/js/103.52962a96060c610519b6.js","webpack:///./~/showdown/dist/showdown.js"],"names":["webpackJsonp","1280","module","exports","__webpack_require__","__WEBPACK_AMD_DEFINE_RESULT__","getDefaultOpts","simple","defaultOptions","omitExtraWLInCodeBlocks","defaultValue","describe","type","noHeaderId","prefixHeaderId","ghCompatibleHeaderId","headerLevelStart","parseImgDimensions","simplifiedAutoLink","excludeTrailingPunctuationFromURLs","literalMidWordUnderscores","literalMidWordAsterisks","strikethrough","tables","tablesHeaderId","ghCodeBlocks","tasklists","smoothLivePreview","smartIndentationFix","description","disableForced4SpacesIndentedSublists","simpleLineBreaks","requireSpaceBeforeHeadingText","ghMentions","ghMentionsLink","encodeEmails","openLinksInNewWindow","JSON","parse","stringify","ret","opt","hasOwnProperty","validate","extension","name","errMsg","valid","error","showdown","helper","isArray","i","length","baseMsg","ext","isString","toLowerCase","isUndefined","listeners","filter","regex","ln","RegExp","replace","escapeCharactersCallback","wholeMatch","m1","charCodeAt","parsers","extensions","globalOptions","setFlavor","flavor","github","original","ghost","vanilla","allOn","options","setOption","key","value","this","getOption","getOptions","resetOptions","Error","preset","option","getFlavor","getFlavorOptions","getDefaultOptions","subParser","func","stdExtName","validExtension","getAllExtensions","removeExtension","resetExtensions","validateExtension","console","warn","a","String","isFunction","getType","toString","call","constructor","Array","forEach","obj","callback","prop","s","escapeCharacters","text","charsToEscape","afterBackslash","regexString","rgxFindMatchPos","str","left","right","flags","t","m","start","end","f","g","indexOf","x","l","pos","exec","test","lastIndex","index","match","push","matchRecursiveRegExp","matchPos","results","slice","replaceRecursiveRegExp","replacement","repStr","finalStr","lng","bits","join","regexIndexOf","fromIndex","substring","search","splitAtIndex","encodeEmailAddress","mail","encode","ch","Math","floor","random","r","msg","alert","log","regexes","asteriskAndDash","Converter","converterOptions","_parseExtension","legacyExtensionLoading","validExt","langExtensions","outputModifiers","listen","rTrimInputText","rsp","rgx","setConvFlavor","gOpt","_dispatch","evtName","globals","ei","nText","makeHtml","gHtmlBlocks","gHtmlMdBlocks","gHtmlSpans","gUrls","gTitles","gDimensions","gListLevel","hashLinkCounts","converter","addExtension","useExtension","extensionName","splice","language","output","writeAnchorTag","linkText","linkId","url","m5","m6","title","result","wm","st","escape","mentions","username","simpleURLRegex","simpleURLRegex2","delimUrlRegex","simpleMailRegex","delimMailRegex","replaceLink","link","m2","m3","trailingPunctuation","lnkTxt","append","target","replaceMail","b","href","bq","pre","pattern","codeblock","nextChar","c","leadingText","numSpaces","repFunc","blockText","blockTags","txt","opTagPos","rgx1","patLeft","patRight","subTexts","newSubText1","concat","hashHTMLSpan","html","repText","limit","num","$1","headerId","customizedHeaderId","ghHeaderId","isNaN","parseInt","setextRegexH1","setextRegexH2","spanGamut","hID","hLevel","hashBlock","matchFound","atxStyle","hText","span","header","writeImageTag","altText","width","height","gDims","inlineRegExp","crazyRegExp","referenceRegExp","refShortcutRegExp","parseInside","trim","processListItems","listStr","trimTrailing","isParagraphed","m4","taskbtn","checked","item","bulletStyle","otp","wm2","parseConsecutiveLists","list","listType","olRgx","ulRgx","counterRxg","parseCL","grafs","split","grafsOut","grafsOutIt","codeFlag","delim","$2","re","blankLines","parseStyles","sLine","parseHeaders","style","id","tableHeaderId","parseCells","cell","buildTable","headers","cells","tb","tblLgn","ii","tableRgx","rawTable","tableLines","rawHeaders","map","rawStyles","rawCells","styles","shift","row","charCodeToReplace","fromCharCode","undefined"],"mappings":"AAAAA,cAAc,MAERC,KACA,SAAUC,EAAQC,EAASC,GCHjC,GAAAC;CACA,WAKA,QAAAC,GAAAC,GACA,YAEA,IAAAC,IACAC,yBACAC,cAAA,EACAC,SAAA,wDACAC,KAAA,WAEAC,YACAH,cAAA,EACAC,SAAA,kCACAC,KAAA,WAEAE,gBACAJ,cAAA,EACAC,SAAA,2CACAC,KAAA,UAEAG,sBACAL,cAAA,EACAC,SAAA,oIACAC,KAAA,WAEAI,kBACAN,cAAA,EACAC,SAAA,gCACAC,KAAA,WAEAK,oBACAP,cAAA,EACAC,SAAA,sCACAC,KAAA,WAEAM,oBACAR,cAAA,EACAC,SAAA,iCACAC,KAAA,WAEAO,oCACAT,cAAA,EACAC,SAAA,sEACAC,KAAA,WAEAQ,2BACAV,cAAA,EACAC,SAAA,mDACAC,KAAA,WAEAS,yBACAX,cAAA,EACAC,SAAA,+CACAC,KAAA,WAEAU,eACAZ,cAAA,EACAC,SAAA,oCACAC,KAAA,WAEAW,QACAb,cAAA,EACAC,SAAA,6BACAC,KAAA,WAEAY,gBACAd,cAAA,EACAC,SAAA,6BACAC,KAAA,WAEAa,cACAf,cAAA,EACAC,SAAA,6CACAC,KAAA,WAEAc,WACAhB,cAAA,EACAC,SAAA,mCACAC,KAAA,WAEAe,mBACAjB,cAAA,EACAC,SAAA,kEACAC,KAAA,WAEAgB,qBACAlB,cAAA,EACAmB,YAAA,kDACAjB,KAAA,WAEAkB,sCACApB,cAAA,EACAmB,YAAA,oEACAjB,KAAA,WAEAmB,kBACArB,cAAA,EACAmB,YAAA,gDACAjB,KAAA,WAEAoB,+BACAtB,cAAA,EACAmB,YAAA,6EACAjB,KAAA,WAEAqB,YACAvB,cAAA,EACAmB,YAAA,2BACAjB,KAAA,WAEAsB,gBACAxB,aAAA,yBACAmB,YAAA,yFACAjB,KAAA,UAEAuB,cACAzB,cAAA,EACAmB,YAAA,0IACAjB,KAAA,WAEAwB,sBACA1B,cAAA,EACAmB,YAAA,gCACAjB,KAAA,WAGA,SAAAL,EACA,MAAA8B,MAAAC,MAAAD,KAAAE,UAAA/B,GAEA,IAAAgC,KACA,QAAAC,KAAAjC,GACAA,EAAAkC,eAAAD,KACAD,EAAAC,GAAAjC,EAAAiC,GAAA/B,aAGA,OAAA8B,GAmRA,QAAAG,GAAAC,EAAAC,GACA,YAEA,IAAAC,GAAA,cAAAD,EAAA,4CACAL,GACAO,OAAA,EACAC,MAAA,GAGAC,GAAAC,OAAAC,QAAAP,KACAA,MAGA,QAAAQ,GAAA,EAAiBA,EAAAR,EAAAS,SAAsBD,EAAA,CACvC,GAAAE,GAAAR,EAAA,kBAAAM,EAAA,KACAG,EAAAX,EAAAQ,EACA,oBAAAG,GAGA,MAFAf,GAAAO,OAAA,EACAP,EAAAQ,MAAAM,EAAA,gCAAAC,GAAA,SACAf,CAGA,KAAAS,EAAAC,OAAAM,SAAAD,EAAA3C,MAGA,MAFA4B,GAAAO,OAAA,EACAP,EAAAQ,MAAAM,EAAA,+CAAAC,GAAA3C,KAAA,SACA4B,CAGA,IAAA5B,GAAA2C,EAAA3C,KAAA2C,EAAA3C,KAAA6C,aAWA,IARA,aAAA7C,IACAA,EAAA2C,EAAA3C,KAAA,QAGA,SAAAA,IACAA,EAAA2C,EAAA3C,KAAA,UAGA,SAAAA,GAAA,WAAAA,GAAA,aAAAA,EAGA,MAFA4B,GAAAO,OAAA,EACAP,EAAAQ,MAAAM,EAAA,QAAA1C,EAAA,iFACA4B,CAGA,iBAAA5B,GACA,GAAAqC,EAAAC,OAAAQ,YAAAH,EAAAI,WAGA,MAFAnB,GAAAO,OAAA,EACAP,EAAAQ,MAAAM,EAAA,0EACAd,MAGA,IAAAS,EAAAC,OAAAQ,YAAAH,EAAAK,SAAAX,EAAAC,OAAAQ,YAAAH,EAAAM,OAGA,MAFArB,GAAAO,OAAA,EACAP,EAAAQ,MAAAM,EAAA1C,EAAA,yEACA4B,CAIA,IAAAe,EAAAI,UAAA,CACA,mBAAAJ,GAAAI,UAGA,MAFAnB,GAAAO,OAAA,EACAP,EAAAQ,MAAAM,EAAA,oDAAAC,GAAAI,UAAA,SACAnB,CAEA,QAAAsB,KAAAP,GAAAI,UACA,GAAAJ,EAAAI,UAAAjB,eAAAoB,IACA,kBAAAP,GAAAI,UAAAG,GAIA,MAHAtB,GAAAO,OAAA,EACAP,EAAAQ,MAAAM,EAAA,+EAAAQ,EACA,iCAAAP,GAAAI,UAAAG,GAAA,SACAtB,EAMA,GAAAe,EAAAK,QACA,qBAAAL,GAAAK,OAGA,MAFApB,GAAAO,OAAA,EACAP,EAAAQ,MAAAM,EAAA,0CAAAC,GAAAK,OAAA,SACApB,MAEK,IAAAe,EAAAM,MAAA,CAIL,GAHAZ,EAAAC,OAAAM,SAAAD,EAAAM,SACAN,EAAAM,MAAA,GAAAE,QAAAR,EAAAM,MAAA,QAEAN,EAAAM,gBAAAE,SAGA,MAFAvB,GAAAO,OAAA,EACAP,EAAAQ,MAAAM,EAAA,0EAAAC,GAAAM,MAAA,SACArB,CAEA,IAAAS,EAAAC,OAAAQ,YAAAH,EAAAS,SAGA,MAFAxB,GAAAO,OAAA,EACAP,EAAAQ,MAAAM,EAAA,iEACAd,GAIA,MAAAA,GA0HA,QAAAyB,GAAAC,EAAAC,GACA,YAEA,YADAA,EAAAC,WAAA,GACA,IA/dA,GAAAnB,MACAoB,KACAC,KACAC,EAAAjE,GAAA,GACAkE,EAAA,UACAC,GACAC,QACAjE,yBAAA,EACAS,oBAAA,EACAC,oCAAA,EACAC,2BAAA,EACAE,eAAA,EACAC,QAAA,EACAC,gBAAA,EACAC,cAAA,EACAC,WAAA,EACAI,sCAAA,EACAC,kBAAA,EACAC,+BAAA,EACAjB,sBAAA,EACAkB,YAAA,GAEA0C,UACA9D,YAAA,EACAY,cAAA,GAEAmD,OACAnE,yBAAA,EACAQ,oBAAA,EACAC,oBAAA,EACAC,oCAAA,EACAC,2BAAA,EACAE,eAAA,EACAC,QAAA,EACAC,gBAAA,EACAC,cAAA,EACAC,WAAA,EACAC,mBAAA,EACAI,kBAAA,EACAC,+BAAA,EACAC,YAAA,EACAE,cAAA,GAEA0C,QAAAvE,GAAA,GACAwE,MA7DA,WACA,YACA,IAAAC,GAAAzE,GAAA,GACAkC,IACA,QAAAC,KAAAsC,GACAA,EAAArC,eAAAD,KACAD,EAAAC,IAAA,EAGA,OAAAD,MA2DAS,GAAAC,UAMAD,EAAAqB,cASArB,EAAA+B,UAAA,SAAAC,EAAAC,GACA,YAEA,OADAX,GAAAU,GAAAC,EACAC,MASAlC,EAAAmC,UAAA,SAAAH,GACA,YACA,OAAAV,GAAAU,IAQAhC,EAAAoC,WAAA,WACA,YACA,OAAAd,IAOAtB,EAAAqC,aAAA,WACA,YACAf,GAAAjE,GAAA,IAOA2C,EAAAuB,UAAA,SAAA3B,GACA,YACA,KAAA4B,EAAA/B,eAAAG,GACA,KAAA0C,OAAA1C,EAAA,wBAEAI,GAAAqC,cACA,IAAAE,GAAAf,EAAA5B,EACA2B,GAAA3B,CACA,QAAA4C,KAAAD,GACAA,EAAA9C,eAAA+C,KACAlB,EAAAkB,GAAAD,EAAAC,KASAxC,EAAAyC,UAAA,WACA,YACA,OAAAlB,IAQAvB,EAAA0C,iBAAA,SAAA9C,GACA,YACA,IAAA4B,EAAA/B,eAAAG,GACA,MAAA4B,GAAA5B,IAUAI,EAAA2C,kBAAA,SAAArF,GACA,YACA,OAAAD,GAAAC,IAaA0C,EAAA4C,UAAA,SAAAhD,EAAAiD,GACA,YACA,IAAA7C,EAAAC,OAAAM,SAAAX,GAAA,CACA,YAAAiD,EAEK,CACL,GAAAzB,EAAA3B,eAAAG,GACA,MAAAwB,GAAAxB,EAEA,MAAA0C,OAAA,mBAAA1C,EAAA,oBALAwB,EAAAxB,GAAAiD,IAkBA7C,EAAAL,UAAA,SAAAC,EAAAU,GACA,YAEA,KAAAN,EAAAC,OAAAM,SAAAX,GACA,KAAA0C,OAAA,oCAMA,IAHA1C,EAAAI,EAAAC,OAAA6C,WAAAlD,GAGAI,EAAAC,OAAAQ,YAAAH,GAAA,CACA,IAAAe,EAAA5B,eAAAG,GACA,KAAA0C,OAAA,mBAAA1C,EAAA,sBAEA,OAAAyB,GAAAzB,GAKA,kBAAAU,KACAA,OAIAN,EAAAC,OAAAC,QAAAI,KACAA,MAGA,IAAAyC,GAAArD,EAAAY,EAAAV,EAEA,KAAAmD,EAAAjD,MAGA,KAAAwC,OAAAS,EAAAhD,MAFAsB,GAAAzB,GAAAU,GAWAN,EAAAgD,iBAAA,WACA,YACA,OAAA3B,IAOArB,EAAAiD,gBAAA,SAAArD,GACA,mBACAyB,GAAAzB,IAMAI,EAAAkD,gBAAA,WACA,YACA7B,OAoHArB,EAAAmD,kBAAA,SAAA7C,GACA,YAEA,IAAA6C,GAAAzD,EAAAY,EAAA,KACA,SAAA6C,EAAArD,QACAsD,QAAAC,KAAAF,EAAApD,QACA,IASAC,EAAAP,eAAA,YACAO,EAAAC,WASAD,EAAAC,OAAAM,SAAA,SAAA+C,GACA,YACA,uBAAAA,gBAAAC,SASAvD,EAAAC,OAAAuD,WAAA,SAAAF,GACA,YACA,IAAAG,KACA,OAAAH,IAAA,sBAAAG,EAAAC,SAAAC,KAAAL,IASAtD,EAAAC,OAAAC,QAAA,SAAAoD,GACA,YACA,OAAAA,GAAAM,cAAAC,OASA7D,EAAAC,OAAAQ,YAAA,SAAAwB,GACA,YACA,iBAAAA,GAUAjC,EAAAC,OAAA6D,QAAA,SAAAC,EAAAC,GACA,YAEA,IAAAhE,EAAAC,OAAAQ,YAAAsD,GACA,SAAAzB,OAAA,wBAGA,IAAAtC,EAAAC,OAAAQ,YAAAuD,GACA,SAAA1B,OAAA,6BAGA,KAAAtC,EAAAC,OAAAuD,WAAAQ,GACA,SAAA1B,OAAA,4CAGA,sBAAAyB,GAAAD,QACAC,EAAAD,QAAAE,OACG,IAAAhE,EAAAC,OAAAC,QAAA6D,GACH,OAAA5D,GAAA,EAAmBA,EAAA4D,EAAA3D,OAAgBD,IACnC6D,EAAAD,EAAA5D,KAAA4D,OAEG,uBAOH,SAAAzB,OAAA,yDANA,QAAA2B,KAAAF,GACAA,EAAAtE,eAAAwE,IACAD,EAAAD,EAAAE,KAAAF,KAcA/D,EAAAC,OAAA6C,WAAA,SAAAoB,GACA,YACA,OAAAA,GAAAnD,QAAA,qBAAAA,QAAA,UAAAP,eAgBAR,EAAAC,OAAAe,2BAUAhB,EAAAC,OAAAkE,iBAAA,SAAAC,EAAAC,EAAAC,GACA,YAGA,IAAAC,GAAA,KAAAF,EAAAtD,QAAA,0BAEAuD,KACAC,EAAA,OAAAA,EAGA,IAAA3D,GAAA,GAAAE,QAAAyD,EAAA,IAGA,OAFAH,KAAArD,QAAAH,EAAAI,GAKA,IAAAwD,GAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,YACA,IAKAC,GAAAX,EAAAY,EAAAC,EAAAC,EALAC,EAAAL,GAAA,GACAM,EAAAD,EAAAE,QAAA,QACAC,EAAA,GAAAtE,QAAA4D,EAAA,IAAAC,EAAA,IAAAM,EAAAlE,QAAA,UACAsE,EAAA,GAAAvE,QAAA4D,EAAAO,EAAAlE,QAAA,UACAuE,IAGA,IAEA,IADAT,EAAA,EACAC,EAAAM,EAAAG,KAAAd,IACA,GAAAY,EAAAG,KAAAV,EAAA,IACAD,MACAX,EAAAkB,EAAAK,UACAV,EAAAb,EAAAY,EAAA,GAAA1E,YAEO,IAAAyE,MACPA,EAAA,CACAG,EAAAF,EAAAY,MAAAZ,EAAA,GAAA1E,MACA,IAAA2D,IACAW,MAAmBK,QAAAC,IAAAd,GACnByB,OAAoBZ,MAAAb,EAAAc,IAAAF,EAAAY,OACpBf,OAAoBI,MAAAD,EAAAY,MAAAV,OACpB/D,YAAyB8D,QAAAC,OAGzB,IADAM,EAAAM,KAAA7B,IACAmB,EACA,MAAAI,UAKGT,IAAAO,EAAAK,UAAAvB,GAEH,OAAAoB,GAgCAtF,GAAAC,OAAA4F,qBAAA,SAAApB,EAAAC,EAAAC,EAAAC,GACA,YAKA,QAHAkB,GAAAtB,EAAAC,EAAAC,EAAAC,EAAAC,GACAmB,KAEA5F,EAAA,EAAiBA,EAAA2F,EAAA1F,SAAqBD,EACtC4F,EAAAH,MACAnB,EAAAuB,MAAAF,EAAA3F,GAAAc,WAAA8D,MAAAe,EAAA3F,GAAAc,WAAA+D,KACAP,EAAAuB,MAAAF,EAAA3F,GAAAwF,MAAAZ,MAAAe,EAAA3F,GAAAwF,MAAAX,KACAP,EAAAuB,MAAAF,EAAA3F,GAAAuE,KAAAK,MAAAe,EAAA3F,GAAAuE,KAAAM,KACAP,EAAAuB,MAAAF,EAAA3F,GAAAwE,MAAAI,MAAAe,EAAA3F,GAAAwE,MAAAK,MAGA,OAAAe,IAYA/F,EAAAC,OAAAgG,uBAAA,SAAAxB,EAAAyB,EAAAxB,EAAAC,EAAAC,GACA,YAEA,KAAA5E,EAAAC,OAAAuD,WAAA0C,GAAA,CACA,GAAAC,GAAAD,CACAA,GAAA,WACA,MAAAC,IAIA,GAAAL,GAAAtB,EAAAC,EAAAC,EAAAC,EAAAC,GACAwB,EAAA3B,EACA4B,EAAAP,EAAA1F,MAEA,IAAAiG,EAAA,GACA,GAAAC,KACA,KAAAR,EAAA,GAAA7E,WAAA8D,OACAuB,EAAAV,KAAAnB,EAAAuB,MAAA,EAAAF,EAAA,GAAA7E,WAAA8D,OAEA,QAAA5E,GAAA,EAAmBA,EAAAkG,IAASlG,EAC5BmG,EAAAV,KACAM,EACAzB,EAAAuB,MAAAF,EAAA3F,GAAAc,WAAA8D,MAAAe,EAAA3F,GAAAc,WAAA+D,KACAP,EAAAuB,MAAAF,EAAA3F,GAAAwF,MAAAZ,MAAAe,EAAA3F,GAAAwF,MAAAX,KACAP,EAAAuB,MAAAF,EAAA3F,GAAAuE,KAAAK,MAAAe,EAAA3F,GAAAuE,KAAAM,KACAP,EAAAuB,MAAAF,EAAA3F,GAAAwE,MAAAI,MAAAe,EAAA3F,GAAAwE,MAAAK,OAGA7E,EAAAkG,EAAA,GACAC,EAAAV,KAAAnB,EAAAuB,MAAAF,EAAA3F,GAAAc,WAAA+D,IAAAc,EAAA3F,EAAA,GAAAc,WAAA8D,OAGAe,GAAAO,EAAA,GAAApF,WAAA+D,IAAAP,EAAArE,QACAkG,EAAAV,KAAAnB,EAAAuB,MAAAF,EAAAO,EAAA,GAAApF,WAAA+D,MAEAoB,EAAAE,EAAAC,KAAA,IAEA,MAAAH,IAaApG,EAAAC,OAAAuG,aAAA,SAAA/B,EAAA7D,EAAA6F,GACA,YACA,KAAAzG,EAAAC,OAAAM,SAAAkE,GACA,sGAEA,IAAA7D,YAAAE,UAAA,EACA,oHAEA,IAAAqE,GAAAV,EAAAiC,UAAAD,GAAA,GAAAE,OAAA/F,EACA,OAAAuE,IAAA,EAAAA,GAAAsB,GAAA,GAAAtB,GAUAnF,EAAAC,OAAA2G,aAAA,SAAAnC,EAAAiB,GACA,YACA,KAAA1F,EAAAC,OAAAM,SAAAkE,GACA,sGAEA,QAAAA,EAAAiC,UAAA,EAAAhB,GAAAjB,EAAAiC,UAAAhB,KAYA1F,EAAAC,OAAA4G,mBAAA,SAAAC,GACA,YACA,IAAAC,IACA,SAAAC,GACA,WAAAA,EAAA7F,WAAA,QAEA,SAAA6F,GACA,YAAAA,EAAA7F,WAAA,GAAAuC,SAAA,SAEA,SAAAsD,GACA,MAAAA,IAkBA,OAdAF,KAAA/F,QAAA,cAAAiG,GACA,SAAAA,EAEAA,EAAAD,EAAAE,KAAAC,MAAA,EAAAD,KAAAE,WAAAH,OACK,CACL,GAAAI,GAAAH,KAAAE,QAEAH,GACAI,EAAA,GAAAL,EAAA,GAAAC,GAAAI,EAAA,IAAAL,EAAA,GAAAC,GAAAD,EAAA,GAAAC,GAGA,MAAAA,MAUA,8BACA5D,SACAC,KAAA,SAAAgE,GACA,YACAC,OAAAD,IAEAE,IAAA,SAAAF,GACA,YACAC,OAAAD,IAEAtH,MAAA,SAAAsH,GACA,YACA,MAAAA,MASArH,EAAAC,OAAAuH,SACAC,gBAAA,WAaAzH,EAAA0H,UAAA,SAAAC,GACA,YA0EA,SAAAC,GAAAtH,EAAAV,GAIA,GAFAA,KAAA,KAEAI,EAAAC,OAAAM,SAAAD,GAAA,CAKA,GAJAA,EAAAN,EAAAC,OAAA6C,WAAAxC,GACAV,EAAAU,EAGAN,EAAAqB,WAAAf,GAIA,MAHA8C,SAAAC,KAAA,wBAAA/C,EAAA,oIAEAuH,GAAA7H,EAAAqB,WAAAf,KAIO,IAAAN,EAAAC,OAAAQ,YAAAY,EAAAf,IAIP,KAAAgC,OAAA,cAAAhC,EAAA,8EAHAA,GAAAe,EAAAf,GAOA,kBAAAA,KACAA,OAGAN,EAAAC,OAAAC,QAAAI,KACAA,MAGA,IAAAwH,GAAApI,EAAAY,EAAAV,EACA,KAAAkI,EAAAhI,MACA,KAAAwC,OAAAwF,EAAA/H,MAGA,QAAAI,GAAA,EAAmBA,EAAAG,EAAAF,SAAgBD,EAAA,CACnC,OAAAG,EAAAH,GAAAxC,MAEA,WACAoK,EAAAnC,KAAAtF,EAAAH,GACA,MAEA,cACA6H,EAAApC,KAAAtF,EAAAH,IAGA,GAAAG,EAAAH,GAAAV,eAAA,aACA,OAAAoB,KAAAP,GAAAH,GAAAO,UACAJ,EAAAH,GAAAO,UAAAjB,eAAAoB,IACAoH,EAAApH,EAAAP,EAAAH,GAAAO,UAAAG,KAaA,QAAAgH,GAAAvH,EAAAV,GACA,kBAAAU,KACAA,IAAA,GAAAN,GAAA0H,YAEA1H,EAAAC,OAAAC,QAAAI,KACAA,MAEA,IAAAR,GAAAJ,EAAAY,EAAAV,EAEA,KAAAE,QACA,KAAAwC,OAAAxC,EAAAC,MAGA,QAAAI,GAAA,EAAmBA,EAAAG,EAAAF,SAAgBD,EACnC,OAAAG,EAAAH,GAAAxC,MACA,WACAoK,EAAAnC,KAAAtF,EAAAH,GACA,MACA,cACA6H,EAAApC,KAAAtF,EAAAH,GACA,MACA,SACA,KAAAmC,OAAA,iDAUA,QAAA2F,GAAArI,EAAAoE,GACA,IAAAhE,EAAAC,OAAAM,SAAAX,GACA,KAAA0C,OAAA,mFAAA1C,GAAA,SAGA,sBAAAoE,GACA,KAAA1B,OAAA,yFAAA0B,GAAA,SAGAtD,GAAAjB,eAAAG,KACAc,EAAAd,OAEAc,EAAAd,GAAAgG,KAAA5B,GAGA,QAAAkE,GAAA9D,GACA,GAAA+D,GAAA/D,EAAAuB,MAAA,WAAAvF,OACAgI,EAAA,GAAAtH,QAAA,UAA+BqH,EAAA,IAAc,KAC7C,OAAA/D,GAAArD,QAAAqH,EAAA,IA1LA,GAMAtG,MAOAiG,KAOAC,KAOAtH,KAKA2H,EAAA9G,GAQA,WACAoG,OAEA,QAAAW,KAAAhH,GACAA,EAAA7B,eAAA6I,KACAxG,EAAAwG,GAAAhH,EAAAgH,GAKA,oBAAAX,GAOA,KAAArF,OAAA,qEAAAqF,GACA,uBAPA,QAAAnI,KAAAmI,GACAA,EAAAlI,eAAAD,KACAsC,EAAAtC,GAAAmI,EAAAnI,GAQAsC,GAAAT,YACArB,EAAAC,OAAA6D,QAAAhC,EAAAT,WAAAuG,MAwIA1F,KAAAqG,UAAA,SAAAC,EAAApE,EAAAtC,EAAA2G,GACA,GAAA/H,EAAAjB,eAAA+I,GACA,OAAAE,GAAA,EAAsBA,EAAAhI,EAAA8H,GAAApI,SAAgCsI,EAAA,CACtD,GAAAC,GAAAjI,EAAA8H,GAAAE,GAAAF,EAAApE,EAAAlC,KAAAJ,EAAA2G,EACAE,QAAA,KAAAA,IACAvE,EAAAuE,GAIA,MAAAvE,IASAlC,KAAA+F,OAAA,SAAArI,EAAAoE,GAEA,MADAiE,GAAArI,EAAAoE,GACA9B,MAQAA,KAAA0G,SAAA,SAAAxE,GAEA,IAAAA,EACA,MAAAA,EAGA,IAAAqE,IACAI,eACAC,iBACAC,cACAC,SACAC,WACAC,eACAC,WAAA,EACAC,kBACArB,iBACAC,kBACAqB,UAAAnH,KACA1D,gBAgEA,OA1DA4F,KAAArD,QAAA,WAKAqD,IAAArD,QAAA,YAGAqD,IAAArD,QAAA,cACAqD,IAAArD,QAAA,YAGAqD,IAAArD,QAAA,eAEAe,EAAAnD,sBACAyF,EAAA8D,EAAA9D,IAIAA,EAAA,OAAAA,EAAA,OAGAA,EAAApE,EAAA4C,UAAA,SAAAwB,EAAAtC,EAAA2G,GAQArE,IAAArD,QAAA,iBAGAf,EAAAC,OAAA6D,QAAAiE,EAAA,SAAAzH,GACA8D,EAAApE,EAAA4C,UAAA,gBAAAtC,EAAA8D,EAAAtC,EAAA2G,KAIArE,EAAApE,EAAA4C,UAAA,mBAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,oBAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,kBAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,gBAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,wBAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,cAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,mBAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,wBAAAwB,EAAAtC,EAAA2G,GAGArE,IAAArD,QAAA,YAGAqD,IAAArD,QAAA,WAGAf,EAAAC,OAAA6D,QAAAkE,EAAA,SAAA1H,GACA8D,EAAApE,EAAA4C,UAAA,gBAAAtC,EAAA8D,EAAAtC,EAAA2G,KAGArE,GAQAlC,KAAAH,UAAA,SAAAC,EAAAC,GACAH,EAAAE,GAAAC,GAQAC,KAAAC,UAAA,SAAAH,GACA,MAAAF,GAAAE,IAOAE,KAAAE,WAAA,WACA,MAAAN,IAQAI,KAAAoH,aAAA,SAAA3J,EAAAC,GACAA,KAAA,KACAgI,EAAAjI,EAAAC,IAOAsC,KAAAqH,aAAA,SAAAC,GACA5B,EAAA4B,IAOAtH,KAAAX,UAAA,SAAA3B,GACA,IAAA4B,EAAA/B,eAAAG,GACA,KAAA0C,OAAA1C,EAAA,wBAEA,IAAA2C,GAAAf,EAAA5B,EACAyI,GAAAzI,CACA,QAAA4C,KAAAD,GACAA,EAAA9C,eAAA+C,KACAV,EAAAU,GAAAD,EAAAC,KASAN,KAAAO,UAAA,WACA,MAAA4F,IASAnG,KAAAe,gBAAA,SAAAtD,GACAK,EAAAC,OAAAC,QAAAP,KACAA,MAEA,QAAA2D,GAAA,EAAmBA,EAAA3D,EAAAS,SAAsBkD,EAAA,CAEzC,OADAhD,GAAAX,EAAA2D,GACAnD,EAAA,EAAqBA,EAAA4H,EAAA3H,SAA2BD,EAChD4H,EAAA5H,KAAAG,GACAyH,EAAA5H,GAAAsJ,OAAAtJ,EAAA,EAGA,QAAsB6H,EAAA5H,SAA6BD,EACnD6H,EADA,KACA1H,GACA0H,EAFA,GAEAyB,OAAAtJ,EAAA,KAUA+B,KAAAc,iBAAA,WACA,OACA0G,SAAA3B,EACA4B,OAAA3B,KAQAhI,EAAA4C,UAAA,mBAAAwB,EAAAtC,EAAA2G,GACA,YAEArE,GAAAqE,EAAAY,UAAAd,UAAA,iBAAAnE,EAAAtC,EAAA2G,EAEA,IAAAmB,GAAA,SAAA3I,EAAA4I,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAOA,GANAlK,EAAAC,OAAAQ,YAAAyJ,KACAA,EAAA,IAEAJ,IAAAtJ,cAGAS,EAAA0F,OAAA,mCACAoD,EAAA,OACK,KAAAA,EAAA,CAOL,GANAD,IAEAA,EAAAD,EAAArJ,cAAAO,QAAA,cAEAgJ,EAAA,IAAAD,EAEA9J,EAAAC,OAAAQ,YAAAgI,EAAAO,MAAAc,IAMA,MAAA7I,EALA8I,GAAAtB,EAAAO,MAAAc,GACA9J,EAAAC,OAAAQ,YAAAgI,EAAAQ,QAAAa,MACAI,EAAAzB,EAAAQ,QAAAa,IAQAC,IAAAhJ,QAAAf,EAAAC,OAAAuH,QAAAC,gBAAAzH,EAAAC,OAAAe,yBAEA,IAAAmJ,GAAA,YAAAJ,EAAA,GAgBA,OAdA,KAAAG,GAAA,OAAAA,IACAA,IAAAnJ,QAAA,eAEAmJ,IAAAnJ,QAAAf,EAAAC,OAAAuH,QAAAC,gBAAAzH,EAAAC,OAAAe,0BACAmJ,GAAA,WAAAD,EAAA,KAGApI,EAAA3C,uBAEAgL,GAAA,wBAGAA,GAAA,IAAAN,EAAA,OAuCA,OAjCAzF,KAAArD,QAAA,0DAAA6I,GAIAxF,IAAArD,QAAA,6FACA6I,GAGAxF,IAAArD,QAAA,qHACA6I,GAKAxF,IAAArD,QAAA,2BAAA6I,GAGA9H,EAAA9C,aACAoF,IAAArD,QAAA,qDAA2D,SAAAqJ,EAAAC,EAAAC,EAAAC,EAAAC,GAC3D,UAAAF,EACA,MAAAD,GAAAE,CAIA,KAAAvK,EAAAC,OAAAM,SAAAuB,EAAA7C,gBACA,SAAAqD,OAAA,yCAGA,OAAA+H,GAAA,YADAvI,EAAA7C,eAAA8B,QAAA,QAAoDyJ,GACpD,KAAAD,EAAA,UAIAnG,EAAAqE,EAAAY,UAAAd,UAAA,gBAAAnE,EAAAtC,EAAA2G,IAMA,IAAAgC,GAAA,8EACAC,EAAA,4FAEAC,EAAA,kDACAC,EAAA,qGACAC,EAAA,gEAEAC,EAAA,SAAAhJ,GACA,YAEA,iBAAAsI,EAAAW,EAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAJ,EACAK,EAAA,GACAC,EAAA,EAUA,OATA,UAAA7F,KAAAuF,KACAA,IAAAhK,QAAA,0BAEAe,EAAA5D,oCAAAgN,IACAE,EAAAF,GAEApJ,EAAA3C,uBACAkM,EAAA,wBAEA,YAAAN,EAAA,IAAAM,EAAA,IAAAF,EAAA,OAAAC,IAIAE,EAAA,SAAAxJ,EAAA2G,GACA,YACA,iBAAAxH,EAAAsK,EAAAzE,GACA,GAAA0E,GAAA,SASA,OARAD,MAAA,GACAzE,EAAA9G,EAAA4C,UAAA,wBAAAkE,EAAAhF,EAAA2G,GACA3G,EAAA5C,cACAsM,EAAAxL,EAAAC,OAAA4G,mBAAA2E,EAAA1E,GACAA,EAAA9G,EAAAC,OAAA4G,mBAAAC,IAEA0E,GAAA1E,EAEAyE,EAAA,YAAAC,EAAA,KAAA1E,EAAA,QAIA9G,GAAA4C,UAAA,qBAAAwB,EAAAtC,EAAA2G,GACA,YASA,OAPArE,GAAAqE,EAAAY,UAAAd,UAAA,mBAAAnE,EAAAtC,EAAA2G,GAEArE,IAAArD,QAAA4J,EAAAG,EAAAhJ,IACAsC,IAAArD,QAAA8J,EAAAS,EAAAxJ,EAAA2G,IAEArE,EAAAqE,EAAAY,UAAAd,UAAA,kBAAAnE,EAAAtC,EAAA2G,KAKAzI,EAAA4C,UAAA,+BAAAwB,EAAAtC,EAAA2G,GACA,YAEA,OAAA3G,GAAA7D,oBAIAmG,EAAAqE,EAAAY,UAAAd,UAAA,6BAAAnE,EAAAtC,EAAA2G,GAGArE,EADAtC,EAAA5D,mCACAkG,EAAArD,QAAA2J,EAAAI,EAAAhJ,IAEAsC,EAAArD,QAAA0J,EAAAK,EAAAhJ,IAEAsC,IAAArD,QAAA6J,EAAAU,EAAAxJ,EAAA2G,IAEArE,EAAAqE,EAAAY,UAAAd,UAAA,4BAAAnE,EAAAtC,EAAA2G,IAZArE,IAqBApE,EAAA4C,UAAA,sBAAAwB,EAAAtC,EAAA2G,GACA,YAyBA,OAvBArE,GAAAqE,EAAAY,UAAAd,UAAA,oBAAAnE,EAAAtC,EAAA2G,GAIArE,EAAApE,EAAA4C,UAAA,eAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,WAAAwB,EAAAtC,EAAA2G,GAGArE,EAAApE,EAAA4C,UAAA,kBAAAwB,EAAAtC,EAAA2G,GAEArE,EAAApE,EAAA4C,UAAA,SAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,cAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,UAAAwB,EAAAtC,EAAA2G,GAMArE,EAAApE,EAAA4C,UAAA,kBAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,cAAAwB,EAAAtC,EAAA2G,GAEArE,EAAAqE,EAAAY,UAAAd,UAAA,mBAAAnE,EAAAtC,EAAA2G,KAKAzI,EAAA4C,UAAA,uBAAAwB,EAAAtC,EAAA2G,GACA,YAgCA,OA9BArE,GAAAqE,EAAAY,UAAAd,UAAA,qBAAAnE,EAAAtC,EAAA2G,GAEArE,IAAArD,QAAA,sCAAgC,SAAAE,EAAAC,GAChC,GAAAuK,GAAAvK,CAuBA,OAnBAuK,KAAA1K,QAAA,yBAGA0K,IAAA1K,QAAA,UAEA0K,IAAA1K,QAAA,iBACA0K,EAAAzL,EAAA4C,UAAA,oBAAA6I,EAAA3J,EAAA2G,GACAgD,EAAAzL,EAAA4C,UAAA,cAAA6I,EAAA3J,EAAA2G,GAEAgD,IAAA1K,QAAA,kBAEA0K,IAAA1K,QAAA,sCAAAE,EAAAC,GACA,GAAAwK,GAAAxK,CAIA,OAFAwK,KAAA3K,QAAA,cACA2K,IAAA3K,QAAA,YAIAf,EAAA4C,UAAA,8BAAA6I,EAAA,kBAAA3J,EAAA2G,KAGArE,EAAAqE,EAAAY,UAAAd,UAAA,oBAAAnE,EAAAtC,EAAA2G,KAOAzI,EAAA4C,UAAA,sBAAAwB,EAAAtC,EAAA2G,GACA,YAEArE,GAAAqE,EAAAY,UAAAd,UAAA,oBAAAnE,EAAAtC,EAAA2G,GAGArE,GAAA,IAEA,IAAAuH,GAAA,kEAyBA,OAxBAvH,KAAArD,QAAA4K,EAAA,SAAA1K,EAAAC,EAAA8J,GACA,GAAAY,GAAA1K,EACA2K,EAAAb,EACAhG,EAAA,IAcA,OAZA4G,GAAA5L,EAAA4C,UAAA,WAAAgJ,EAAA9J,EAAA2G,GACAmD,EAAA5L,EAAA4C,UAAA,cAAAgJ,EAAA9J,EAAA2G,GACAmD,EAAA5L,EAAA4C,UAAA,SAAAgJ,EAAA9J,EAAA2G,GACAmD,IAAA7K,QAAA,YACA6K,IAAA7K,QAAA,YAEAe,EAAAtE,0BACAwH,EAAA,IAGA4G,EAAA,cAAAA,EAAA5G,EAAA,gBAEAhF,EAAA4C,UAAA,aAAAgJ,EAAA9J,EAAA2G,GAAAoD,IAIAzH,IAAArD,QAAA,SAEAqD,EAAAqE,EAAAY,UAAAd,UAAA,mBAAAnE,EAAAtC,EAAA2G,KA6BAzI,EAAA4C,UAAA,qBAAAwB,EAAAtC,EAAA2G,GACA,YAkBA,OAhBArE,GAAAqE,EAAAY,UAAAd,UAAA,mBAAAnE,EAAAtC,EAAA2G,OAEA,SACArE,EAAA,IAEAA,IAAArD,QAAA,sCACA,SAAAE,EAAAC,EAAA8J,EAAAC,GACA,GAAAa,GAAAb,CAIA,OAHAa,KAAA/K,QAAA,iBACA+K,IAAA/K,QAAA,eACA+K,EAAA9L,EAAA4C,UAAA,cAAAkJ,EAAAhK,EAAA2G,GACAvH,EAAA,SAAA4K,EAAA,YAIA1H,EAAAqE,EAAAY,UAAAd,UAAA,kBAAAnE,EAAAtC,EAAA2G,KAOAzI,EAAA4C,UAAA,iBAAAwB,EAAAtC,EAAA2G,GACA,YA2BA,OA1BArE,GAAAqE,EAAAY,UAAAd,UAAA,eAAAnE,EAAAtC,EAAA2G,GAGArE,IAAArD,QAAA,oBAGAqD,IAAArD,QAAA,cAGAqD,IAAArD,QAAA,sBAAAE,EAAAC,GAKA,OAJA6K,GAAA7K,EACA8K,EAAA,EAAAD,EAAA3L,OAAA,EAGAD,EAAA,EAAmBA,EAAA6L,EAAe7L,IAClC4L,GAAA,GAGA,OAAAA,KAIA3H,IAAArD,QAAA,cACAqD,IAAArD,QAAA,UAEAqD,EAAAqE,EAAAY,UAAAd,UAAA,cAAAnE,EAAAtC,EAAA2G,KAOAzI,EAAA4C,UAAA,+BAAAwB,EAAAtC,EAAA2G,GACA,YAiBA,OAhBArE,GAAAqE,EAAAY,UAAAd,UAAA,6BAAAnE,EAAAtC,EAAA2G,GAIArE,IAAArD,QAAA,qCAAuD,SAGvDqD,IAAArD,QAAA,4BAGAqD,IAAArD,QAAA,aAGAqD,IAAArD,QAAA,aAEAqD,EAAAqE,EAAAY,UAAAd,UAAA,4BAAAnE,EAAAtC,EAAA2G,KAeAzI,EAAA4C,UAAA,kCAAAwB,EAAAtC,EAAA2G,GACA,YAOA,OANArE,GAAAqE,EAAAY,UAAAd,UAAA,gCAAAnE,EAAAtC,EAAA2G,GAEArE,IAAArD,QAAA,UAAAf,EAAAC,OAAAe,0BACAoD,IAAArD,QAAA,8BAAgCf,EAAAC,OAAAe,0BAEhCoD,EAAAqE,EAAAY,UAAAd,UAAA,+BAAAnE,EAAAtC,EAAA2G,KASAzI,EAAA4C,UAAA,sBAAAwB,EAAAtC,EAAA2G,GACA,YAeA,OAbArE,GAAAqE,EAAAY,UAAAd,UAAA,oBAAAnE,EAAAtC,EAAA2G,GAIArE,IACArD,QAAA,cAEAA,QAAA,aACAA,QAAA,aAEAA,QAAA,qBAAoBf,EAAAC,OAAAe,0BAEpBoD,EAAAqE,EAAAY,UAAAd,UAAA,mBAAAnE,EAAAtC,EAAA2G,KAQAzI,EAAA4C,UAAA,iDAAAwB,EAAAtC,EAAA2G,GACA,YACArE,GAAAqE,EAAAY,UAAAd,UAAA,+CAAAnE,EAAAtC,EAAA2G,EAIA,IAAA7H,GAAA,2DASA,OAPAwD,KAAArD,QAAAH,EAAA,SAAAK,GACA,MAAAA,GACAF,QAAA,4BACAA,QAAA,gBAAAf,EAAAC,OAAAe,4BAGAoD,EAAAqE,EAAAY,UAAAd,UAAA,8CAAAnE,EAAAtC,EAAA2G,KAcAzI,EAAA4C,UAAA,4BAAAwB,EAAAtC,EAAA2G,GACA,YAGA,OAAA3G,GAAAtD,cAIA4F,EAAAqE,EAAAY,UAAAd,UAAA,0BAAAnE,EAAAtC,EAAA2G,GAEArE,GAAA,KAEAA,IAAArD,QAAA,6CAAAE,EAAAyI,EAAAkC,GACA,GAAA5G,GAAAlD,EAAA,+BAeA,OAZA8J,GAAA5L,EAAA4C,UAAA,cAAAgJ,EAAA9J,EAAA2G,GACAmD,EAAA5L,EAAA4C,UAAA,SAAAgJ,EAAA9J,EAAA2G,GACAmD,IAAA7K,QAAA,YACA6K,IAAA7K,QAAA,YAEA6K,EAAA,cAAAlC,EAAA,WAAAA,EAAA,aAAAA,EAAA,YAAAkC,EAAA5G,EAAA,gBAEA4G,EAAA5L,EAAA4C,UAAA,aAAAgJ,EAAA9J,EAAA2G,GAKA,UAAAA,EAAAjK,aAAAoH,MAAkDxB,KAAAnD,EAAA2K,cAAuC,aAIzFxH,IAAArD,QAAA,SAEA0H,EAAAY,UAAAd,UAAA,yBAAAnE,EAAAtC,EAAA2G,IA7BArE,IAgCApE,EAAA4C,UAAA,qBAAAwB,EAAAtC,EAAA2G,GACA,YAKA,OAJArE,GAAAqE,EAAAY,UAAAd,UAAA,mBAAAnE,EAAAtC,EAAA2G,GACArE,IAAArD,QAAA,mBACAqD,EAAA,UAAAqE,EAAAI,YAAAjD,KAAAxB,GAAA,WACAA,EAAAqE,EAAAY,UAAAd,UAAA,kBAAAnE,EAAAtC,EAAA2G,KAOAzI,EAAA4C,UAAA,wBAAAwB,EAAAtC,EAAA2G,GACA,YACArE,GAAAqE,EAAAY,UAAAd,UAAA,sBAAAnE,EAAAtC,EAAA2G,EAEA,IAAAwD,GAAA,SAAAhL,EAAA0E,EAAAjB,EAAAC,GACA,GAAAiH,GAAAlH,EAAA1E,EAAA4C,UAAA,cAAA+C,EAAA7D,EAAA2G,GAAA9D,CACA,aAAA8D,EAAAM,WAAAnD,KAAAgG,GAAA,OAOA,OAHAxH,GAAApE,EAAAC,OAAAgG,uBAAA7B,EAAA6H,EAAA,kCAEA7H,EAAAqE,EAAAY,UAAAd,UAAA,qBAAAnE,EAAAtC,EAAA2G,KAIAzI,EAAA4C,UAAA,uBAAAwB,EAAAtC,EAAA2G,GACA,YAEA,iBAAAxH,EAAAC,GACA,GAAAgL,GAAAhL,CAYA,OATAgL,KAAAnL,QAAA,cACAmL,IAAAnL,QAAA,UAGAmL,IAAAnL,QAAA,YAGAmL,EAAA,UAAAzD,EAAAI,YAAAjD,KAAAsG,GAAA,cAMAlM,EAAA4C,UAAA,0BAAAwB,EAAAtC,EAAA2G,GACA,YACArE,GAAAqE,EAAAY,UAAAd,UAAA,wBAAAnE,EAAAtC,EAAA2G,EAgDA,QA9CA0D,IACA,MACA,MACA,KACA,KACA,KACA,KACA,KACA,KACA,aACA,QACA,KACA,KACA,KACA,SACA,WACA,OACA,WACA,SACA,OACA,QACA,UACA,SACA,SACA,MACA,UACA,QACA,UACA,QACA,SACA,SACA,SACA,SACA,QACA,KAEAF,EAAA,SAAAhL,EAAA0E,EAAAjB,EAAAC,GACA,GAAAyH,GAAAnL,CAMA,QAHA,IAAAyD,EAAAiC,OAAA,kBACAyF,EAAA1H,EAAA+D,EAAAY,UAAAT,SAAAjD,GAAAhB,GAEA,UAAA8D,EAAAI,YAAAjD,KAAAwG,GAAA,YAGAjM,EAAA,EAAiBA,EAAAgM,EAAA/L,SAAsBD,EAOvC,IALA,GAAAkM,GACAC,EAAA,GAAAxL,QAAA,WAAsCqL,EAAAhM,GAAA,kBACtCoM,EAAA,IAAAJ,EAAAhM,GAAA,YACAqM,EAAA,KAAAL,EAAAhM,GAAA,KAEA,KAAAkM,EAAArM,EAAAC,OAAAuG,aAAApC,EAAAkI,KAAA,CAEA,GAAAG,GAAAzM,EAAAC,OAAA2G,aAAAxC,EAAAiI,GAEAK,EAAA1M,EAAAC,OAAAgG,uBAAAwG,EAAA,GAAAR,EAAAM,EAAAC,EAAA,KAGA,IAAAE,IAAAD,EAAA,GACA,KAEArI,GAAAqI,EAAA,GAAAE,OAAAD,GAiBA,MAbAtI,KAAArD,QAAA,oDACAf,EAAA4C,UAAA,eAAAwB,EAAAtC,EAAA2G,IAGArE,EAAApE,EAAAC,OAAAgG,uBAAA7B,EAAA,SAAAgI,GACA,gBAAA3D,EAAAI,YAAAjD,KAAAwG,GAAA,YACG,iBAAU,eAGbhI,IAAArD,QAAA,yDACAf,EAAA4C,UAAA,eAAAwB,EAAAtC,EAAA2G,IAEArE,EAAAqE,EAAAY,UAAAd,UAAA,uBAAAnE,EAAAtC,EAAA2G,KAOAzI,EAAA4C,UAAA,yBAAAwB,EAAAtC,EAAA2G,GACA,YAGA,SAAAmE,GAAAC,GACA,YAAApE,EAAAM,WAAAnD,KAAAiH,GAAA,OA0BA,MA7BAzI,GAAAqE,EAAAY,UAAAd,UAAA,uBAAAnE,EAAAtC,EAAA2G,GAOArE,IAAArD,QAAA,wBAAAqJ,GACA,MAAAwC,GAAAxC,KAIAhG,IAAArD,QAAA,qCAAAqJ,GACA,MAAAwC,GAAAxC,KAIAhG,IAAArD,QAAA,6CAAAqJ,GACA,MAAAwC,GAAAxC,KAIAhG,IAAArD,QAAA,sBAAAqJ,GACA,MAAAwC,GAAAxC,KAKAhG,EAAAqE,EAAAY,UAAAd,UAAA,sBAAAnE,EAAAtC,EAAA2G,KAOAzI,EAAA4C,UAAA,2BAAAwB,EAAAtC,EAAA2G,GACA,YACArE,GAAAqE,EAAAY,UAAAd,UAAA,yBAAAnE,EAAAtC,EAAA2G,EAEA,QAAAtI,GAAA,EAAiBA,EAAAsI,EAAAM,WAAA3I,SAA+BD,EAAA,CAKhD,IAJA,GAAA2M,GAAArE,EAAAM,WAAA5I,GAEA4M,EAAA,EAEA,WAAAvH,KAAAsH,IAAA,CACA,GAAAE,GAAAlM,OAAAmM,EAEA,IADAH,IAAA/L,QAAA,KAAAiM,EAAA,IAAAvE,EAAAM,WAAAiE,IACA,KAAAD,EACA,QAEAA,EAEA3I,IAAArD,QAAA,KAAAZ,EAAA,IAAA2M,GAIA,MADA1I,GAAAqE,EAAAY,UAAAd,UAAA,wBAAAnE,EAAAtC,EAAA2G,KAOAzI,EAAA4C,UAAA,2BAAAwB,EAAAtC,EAAA2G,GACA,YACArE,GAAAqE,EAAAY,UAAAd,UAAA,yBAAAnE,EAAAtC,EAAA2G,EAEA,IAAAwD,GAAA,SAAAhL,EAAA0E,EAAAjB,EAAAC,GAEA,GAAAiH,GAAAlH,EAAA1E,EAAA4C,UAAA,cAAA+C,EAAA7D,EAAA2G,GAAA9D,CACA,iBAAA8D,EAAAjK,aAAAoH,MAAkDxB,KAAAnD,EAAA2K,cAAuC,WAOzF,OAHAxH,GAAApE,EAAAC,OAAAgG,uBAAA7B,EAAA6H,EAAA,yCAAuE,2BAA0C,OAEjH7H,EAAAqE,EAAAY,UAAAd,UAAA,wBAAAnE,EAAAtC,EAAA2G,KAIAzI,EAAA4C,UAAA,mBAAAwB,EAAAtC,EAAA2G,GACA,YAyDA,SAAAyE,GAAApI,GACA,GAAAoF,EAGA,IAAApI,EAAAqL,mBAAA,CACA,GAAAxH,GAAAb,EAAAa,MAAA,kBACAA,MAAA,KACAb,EAAAa,EAAA,IAmCA,MA7BAuE,GADAlK,EAAAC,OAAAM,SAAAuB,EAAAjE,gBACAiE,EAAAjE,eAAAiH,GACK,IAAAhD,EAAAjE,eACL,WAAAiH,EAEAA,EAIAoF,EADAkD,EACAlD,EACAnJ,QAAA,UAEAA,QAAA,SAAuB,IACvBA,QAAA,UACAA,QAAA,UAGAA,QAAA,yCAAkC,IAClCP,cAEA0J,EACAnJ,QAAA,aACAP,cAGAiI,EAAAW,eAAAc,GACAA,IAAA,IAAAzB,EAAAW,eAAAc,KAEAzB,EAAAW,eAAAc,GAAA,EAEAA,EAjGA9F,EAAAqE,EAAAY,UAAAd,UAAA,iBAAAnE,EAAAtC,EAAA2G,EAEA,IAAA1K,GAAAsP,MAAAC,SAAAxL,EAAA/D,mBAAA,EAAAuP,SAAAxL,EAAA/D,kBACAqP,EAAAtL,EAAAhE,qBASAyP,EAAAzL,EAAA,kDAAuE,6BACvE0L,EAAA1L,EAAA,kDAAuE,4BAEvEsC,KAAArD,QAAAwM,EAAA,SAAAtM,EAAAC,GAEA,GAAAuM,GAAAzN,EAAA4C,UAAA,aAAA1B,EAAAY,EAAA2G,GACAiF,EAAA5L,EAAA,sBAAAoL,EAAAhM,GAAA,IACAyM,EAAA5P,EACA6P,EAAA,KAAAD,EAAAD,EAAA,IAAAD,EAAA,MAAAE,EAAA,GACA,OAAA3N,GAAA4C,UAAA,aAAAgL,EAAA9L,EAAA2G,KAGArE,IAAArD,QAAAyM,EAAA,SAAAK,EAAA3M,GACA,GAAAuM,GAAAzN,EAAA4C,UAAA,aAAA1B,EAAAY,EAAA2G,GACAiF,EAAA5L,EAAA,sBAAAoL,EAAAhM,GAAA,IACAyM,EAAA5P,EAAA,EACA6P,EAAA,KAAAD,EAAAD,EAAA,IAAAD,EAAA,MAAAE,EAAA,GACA,OAAA3N,GAAA4C,UAAA,aAAAgL,EAAA9L,EAAA2G,IAUA,IAAAqF,GAAAhM,EAAA,kEAAoE,mCA8DpE,OA5DAsC,KAAArD,QAAA+M,EAAA,SAAA7M,EAAAC,EAAA8J,GACA,GAAA+C,GAAA/C,CACAlJ,GAAAqL,qBACAY,EAAA/C,EAAAjK,QAAA,qBAAwC,IAGxC,IAAAiN,GAAAhO,EAAA4C,UAAA,aAAAmL,EAAAjM,EAAA2G,GACAiF,EAAA5L,EAAA,sBAAAoL,EAAAlC,GAAA,IACA2C,EAAA5P,EAAA,EAAAmD,EAAAd,OACA6N,EAAA,KAAAN,EAAAD,EAAA,IAAAM,EAAA,MAAAL,EAAA,GAEA,OAAA3N,GAAA4C,UAAA,aAAAqL,EAAAnM,EAAA2G,KAgDArE,EAAAqE,EAAAY,UAAAd,UAAA,gBAAAnE,EAAAtC,EAAA2G,KAOAzI,EAAA4C,UAAA,0BAAAwB,EAAAtC,EAAA2G,GACA,YACArE,GAAAqE,EAAAY,UAAAd,UAAA,wBAAAnE,EAAAtC,EAAA2G,EAEA,IAAAzG,GAAAhC,EAAA4C,UAAA,sBAAAd,EAAA2G,EAMA,OALArE,KAAArD,QAAA,4BAAuCiB,GACvCoC,IAAArD,QAAA,6BAAwCiB,GACxCoC,IAAArD,QAAA,4BAAuCiB,GAEvCoC,EAAAqE,EAAAY,UAAAd,UAAA,uBAAAnE,EAAAtC,EAAA2G,KAOAzI,EAAA4C,UAAA,kBAAAwB,EAAAtC,EAAA2G,GACA,YASA,SAAAyF,GAAAjN,EAAAkN,EAAArE,EAAAC,EAAAqE,EAAAC,EAAArE,EAAAE,GAEA,GAAAlB,GAAAP,EAAAO,MACAC,EAAAR,EAAAQ,QACAqF,EAAA7F,EAAAS,WAQA,IANAY,IAAAtJ,cAEA0J,IACAA,EAAA,IAGAjJ,EAAA0F,OAAA,mCACAoD,EAAA,OAEK,SAAAA,GAAA,OAAAA,EAAA,CAOL,GANA,KAAAD,GAAA,OAAAA,IAEAA,EAAAqE,EAAA3N,cAAAO,QAAA,cAEAgJ,EAAA,IAAAD,EAEA9J,EAAAC,OAAAQ,YAAAuI,EAAAc,IAUA,MAAA7I,EATA8I,GAAAf,EAAAc,GACA9J,EAAAC,OAAAQ,YAAAwI,EAAAa,MACAI,EAAAjB,EAAAa,IAEA9J,EAAAC,OAAAQ,YAAA6N,EAAAxE,MACAsE,EAAAE,EAAAxE,GAAAsE,MACAC,EAAAC,EAAAxE,GAAAuE,QAOAF,IACApN,QAAA,eAEAA,QAAAf,EAAAC,OAAAuH,QAAAC,gBAAAzH,EAAAC,OAAAe,0BAEA+I,IAAAhJ,QAAAf,EAAAC,OAAAuH,QAAAC,gBAAAzH,EAAAC,OAAAe,yBACA,IAAAmJ,GAAA,aAAAJ,EAAA,UAAAoE,EAAA,GAoBA,OAlBAjE,KACAA,IACAnJ,QAAA,eAEAA,QAAAf,EAAAC,OAAAuH,QAAAC,gBAAAzH,EAAAC,OAAAe,0BACAmJ,GAAA,WAAAD,EAAA,KAGAkE,GAAAC,IACAD,EAAA,MAAAA,EAAA,OAAAA,EACAC,EAAA,MAAAA,EAAA,OAAAA,EAEAlE,GAAA,WAAAiE,EAAA,IACAjE,GAAA,YAAAkE,EAAA,KAGAlE,GAAA,MAnEA/F,EAAAqE,EAAAY,UAAAd,UAAA,gBAAAnE,EAAAtC,EAAA2G,EAEA,IAAA8F,GAAA,yJACAC,EAAA,qIACAC,EAAA,8CACAC,EAAA,2BAiFA,OAbAtK,KAAArD,QAAA0N,EAAAP,GAIA9J,IAAArD,QAAAyN,EAAAN,GAGA9J,IAAArD,QAAAwN,EAAAL,GAGA9J,IAAArD,QAAA2N,EAAAR,GAEA9J,EAAAqE,EAAAY,UAAAd,UAAA,eAAAnE,EAAAtC,EAAA2G,KAIAzI,EAAA4C,UAAA,0BAAAwB,EAAAtC,EAAA2G,GACA,YAQA,SAAAkG,GAAAvC,EAAA1H,EAAAC,GAIA,MAHA7C,GAAA7D,qBACAmO,EAAApM,EAAA4C,UAAA,uBAAAwJ,EAAAtK,EAAA2G,IAEA/D,EAAA0H,EAAAzH,EAqDA,MA/DAP,GAAAqE,EAAAY,UAAAd,UAAA,wBAAAnE,EAAAtC,EAAA2G,GAcA3G,EAAA3D,2BACAiG,IAAArD,QAAA,kCAAAqJ,EAAAgC,GACA,MAAAuC,GAAAvC,EAAA,mCAEAhI,IAAArD,QAAA,gCAAAqJ,EAAAgC,GACA,MAAAuC,GAAAvC,EAAA,0BAEAhI,IAAArD,QAAA,+BAAAqJ,EAAAgC,GACA,MAAAuC,GAAAvC,EAAA,oBAGAhI,IAAArD,QAAA,+BAAAqJ,EAAAtF,GACA,YAAAU,KAAAV,GAAA6J,EAAA7J,EAAA,iCAAAsF,IAEAhG,IAAArD,QAAA,6BAAAqJ,EAAAtF,GACA,YAAAU,KAAAV,GAAA6J,EAAA7J,EAAA,wBAAAsF,IAEAhG,IAAArD,QAAA,+BAAAqJ,EAAAtF,GAEA,YAAAU,KAAAV,GAAA6J,EAAA7J,EAAA,gBAAAsF,KAKAtI,EAAA1D,yBACAgG,IAAAwK,OAAA7N,QAAA,0CAA8D,SAAAqJ,EAAAgC,GAC9D,MAAAuC,GAAAvC,EAAA,qCAEAhI,IAAAwK,OAAA7N,QAAA,0CAA8D,SAAAqJ,EAAAgC,GAC9D,MAAAuC,GAAAvC,EAAA,4BAEAhI,IAAAwK,OAAA7N,QAAA,0CAA8D,SAAAqJ,EAAAgC,GAC9D,MAAAuC,GAAAvC,EAAA,uBAAAhC,EAAApE,OAAA,gBAGA5B,IAAArD,QAAA,qCAAAqJ,EAAAtF,GACA,YAAAU,KAAAV,GAAA6J,EAAA7J,EAAA,iCAAAsF,IAEAhG,IAAArD,QAAA,iCAAAqJ,EAAAtF,GACA,YAAAU,KAAAV,GAAA6J,EAAA7J,EAAA,wBAAAsF,IAEAhG,IAAArD,QAAA,iCAAAqJ,EAAAtF,GAEA,YAAAU,KAAAV,GAAA6J,EAAA7J,EAAA,gBAAAsF,KAKAhG,EAAAqE,EAAAY,UAAAd,UAAA,uBAAAnE,EAAAtC,EAAA2G,KAOAzI,EAAA4C,UAAA,iBAAAwB,EAAAtC,EAAA2G,GACA,YAUA,SAAAoG,GAAAC,EAAAC,GAqBAtG,EAAAU,aAGA2F,IAAA/N,QAAA,UAAqC,MAGrC+N,GAAA,IAEA,IAAA1G,GAAA,mHACA4G,EAAA,mBAAAxJ,KAAAsJ,EAgFA,OA3EAhN,GAAAjD,uCACAuJ,EAAA,gHAGA0G,IAAA/N,QAAAqH,EAAA,SAAAnH,EAAAC,EAAA8J,EAAAC,EAAAgE,EAAAC,EAAAC,GACAA,KAAA,KAAAA,EAAAP,MAEA,IAAAQ,GAAApP,EAAA4C,UAAA,WAAAqM,EAAAnN,EAAA2G,GACA4G,EAAA,EAuDA,OApDAH,IAAApN,EAAArD,YACA4Q,EAAA,yDACAD,IAAArO,QAAA,iCACA,GAAAuO,GAAA,mGAKA,OAJAH,KACAG,GAAA,YAEAA,GAAA,OAaAF,IAAArO,QAAA,wCAAAwO,GACA,WAAAA,IAMArO,GAAAkO,EAAAzI,OAAA,WAAoC,GACpCyI,EAAApP,EAAA4C,UAAA,oBAAAwM,EAAAtN,EAAA2G,GACA2G,EAAApP,EAAA4C,UAAA,cAAAwM,EAAAtN,EAAA2G,KAGA2G,EAAApP,EAAA4C,UAAA,SAAAwM,EAAAtN,EAAA2G,GACA2G,IAAArO,QAAA,UACAqO,EAAApP,EAAA4C,UAAA,kBAAAwM,EAAAtN,EAAA2G,GAEA2G,IAAArO,QAAA,iBAEAqO,IAAArO,QAAA,cAEAqO,EADAJ,EACAhP,EAAA4C,UAAA,cAAAwM,EAAAtN,EAAA2G,GAEAzI,EAAA4C,UAAA,aAAAwM,EAAAtN,EAAA2G,GAEA2G,IAAArO,QAAA,eAIAqO,IAAArO,QAAA,SAEAqO,EAAA,MAAAC,EAAA,IAAAD,EAAA,YAMAN,IAAA/N,QAAA,UAEA0H,EAAAU,aAEA4F,IACAD,IAAA/N,QAAA,YAGA+N,EAUA,QAAAU,GAAAC,EAAAC,EAAAX,GAGA,GAAAY,GAAA7N,EAAA,6EACA8N,EAAA9N,EAAA,6EACA+N,EAAA,OAAAH,EAAAC,EAAAC,EACAzF,EAAA,EAuBA,QArBA,IAAAsF,EAAA9I,OAAAkJ,GACA,QAAAC,GAAA1D,GACA,GAAA9G,GAAA8G,EAAAzF,OAAAkJ,IACA,IAAAvK,GAEA6E,GAAA,MAAAuF,EAAA,MAAAb,EAAAzC,EAAApG,MAAA,EAAAV,KAAAyJ,GAAA,KAAAW,EAAA,MAGAA,EAAA,OAAAA,EAAA,UACAG,EAAA,OAAAH,EAAAC,EAAAC,EAGAE,EAAA1D,EAAApG,MAAAV,KAEA6E,GAAA,MAAAuF,EAAA,MAAAb,EAAAzC,IAAA2C,GAAA,KAAAW,EAAA,OAEOD,GAEPtF,EAAA,MAAAuF,EAAA,MAAAb,EAAAY,IAAAV,GAAA,KAAAW,EAAA,MAGAvF,EA0BA,MAxLA/F,GAAAqE,EAAAY,UAAAd,UAAA,eAAAnE,EAAAtC,EAAA2G,GAmKArE,GAAA,KAGAA,EADAqE,EAAAU,WACA/E,EAAArD,QAAA,4FACA,SAAAE,EAAAwO,EAAAzE,GAEA,MAAAwE,GAAAC,EADAzE,EAAArE,OAAA,wBACA,KAIAvC,EAAArD,QAAA,sGACA,SAAAE,EAAAC,EAAAuO,EAAAxE,GAEA,MAAAuE,GAAAC,EADAxE,EAAAtE,OAAA,wBACA,KAMAvC,IAAArD,QAAA,SACAqD,EAAAqE,EAAAY,UAAAd,UAAA,cAAAnE,EAAAtC,EAAA2G,KAOAzI,EAAA4C,UAAA,mBAAAwB,EAAAtC,EAAA2G,GACA,YAWA,OAVArE,GAAAqE,EAAAY,UAAAd,UAAA,iBAAAnE,EAAAtC,EAAA2G,GAIArE,IAAArD,QAAA,mBAAoC,MAGpCqD,IAAArD,QAAA,UAEAqD,EAAAqE,EAAAY,UAAAd,UAAA,gBAAAnE,EAAAtC,EAAA2G,KAOAzI,EAAA4C,UAAA,sBAAAwB,EAAAtC,EAAA2G,GACA,YAEArE,GAAAqE,EAAAY,UAAAd,UAAA,oBAAAnE,EAAAtC,EAAA2G,GAEArE,IAAArD,QAAA,YACAqD,IAAArD,QAAA,WAMA,QAJAgP,GAAA3L,EAAA4L,MAAA,WACAC,KACAjL,EAAA+K,EAAA3P,OAEAD,EAAA,EAAiBA,EAAA6E,EAAS7E,IAAA,CAC1B,GAAAsE,GAAAsL,EAAA5P,EAEAsE,GAAAkC,OAAA,qBACAsJ,EAAArK,KAAAnB,GAIKA,EAAAkC,OAAA,WACLlC,EAAAzE,EAAA4C,UAAA,aAAA6B,EAAA3C,EAAA2G,GACAhE,IAAA1D,QAAA,oBACA0D,GAAA,OACAwL,EAAArK,KAAAnB,IAMA,IADAO,EAAAiL,EAAA7P,OACAD,EAAA,EAAaA,EAAA6E,EAAS7E,IAAA,CAMtB,IALA,GAAA+L,GAAA,GACAgE,EAAAD,EAAA9P,GACAgQ,GAAA,EAGA,gBAAA3K,KAAA0K,IAAA,CACA,GAAAE,GAAAtP,OAAAmM,GACAD,EAAAlM,OAAAuP,EAGAnE,GADA,MAAAkE,EACA3H,EAAAI,YAAAmE,GAGAmD,EAEAnQ,EAAA4C,UAAA,cAAA6F,EAAAjK,aAAAwO,GAAA5I,KAAAtC,EAAA2G,GAEAA,EAAAjK,aAAAwO,GAAApB,UAGAM,IAAAnL,QAAA,cAEAmP,IAAAnP,QAAA,4BAAAmL,GAEA,gCAAA1G,KAAA0K,KACAC,GAAA,GAGAF,EAAA9P,GAAA+P,EAMA,MAJA9L,GAAA6L,EAAA1J,KAAA,MAEAnC,IAAArD,QAAA,YACAqD,IAAArD,QAAA,YACA0H,EAAAY,UAAAd,UAAA,mBAAAnE,EAAAtC,EAAA2G,KAMAzI,EAAA4C,UAAA,wBAAAtC,EAAA8D,EAAAtC,EAAA2G,GACA,YAEA,IAAAnI,EAAAK,OACAyD,EAAA9D,EAAAK,OAAAyD,EAAAqE,EAAAY,UAAAvH,OAEG,IAAAxB,EAAAM,MAAA,CAEH,GAAA0P,GAAAhQ,EAAAM,KACA0P,aAAAxP,UACAwP,EAAA,GAAAxP,QAAAwP,EAAA,MAEAlM,IAAArD,QAAAuP,EAAAhQ,EAAAS,SAGA,MAAAqD,KAOApE,EAAA4C,UAAA,qBAAAwB,EAAAtC,EAAA2G,GACA,YAoCA,OAlCArE,GAAAqE,EAAAY,UAAAd,UAAA,mBAAAnE,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,aAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,yCAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,0BAAAwB,EAAAtC,EAAA2G,GAIArE,EAAApE,EAAA4C,UAAA,UAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,WAAAwB,EAAAtC,EAAA2G,GAKArE,EAAApE,EAAA4C,UAAA,aAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,kBAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,iBAAAwB,EAAAtC,EAAA2G,GACArE,EAAApE,EAAA4C,UAAA,uBAAAwB,EAAAtC,EAAA2G,GAGArE,EAAApE,EAAA4C,UAAA,iBAAAwB,EAAAtC,EAAA2G,GAGArE,EAAApE,EAAA4C,UAAA,uBAAAwB,EAAAtC,EAAA2G,GAKArE,EAFAtC,EAAAhD,iBAEAsF,EAAArD,QAAA,kBAGAqD,EAAArD,QAAA,qBAGAqD,EAAAqE,EAAAY,UAAAd,UAAA,kBAAAnE,EAAAtC,EAAA2G,KAIAzI,EAAA4C,UAAA,yBAAAwB,EAAAtC,EAAA2G,GACA,YAEA,SAAAkG,GAAAvC,GAIA,MAHAtK,GAAA7D,qBACAmO,EAAApM,EAAA4C,UAAA,uBAAAwJ,EAAAtK,EAAA2G,IAEA,QAAA2D,EAAA,SASA,MANAtK,GAAAzD,gBACA+F,EAAAqE,EAAAY,UAAAd,UAAA,uBAAAnE,EAAAtC,EAAA2G,GACArE,IAAArD,QAAA,8BAAmD,SAAAqJ,EAAAgC,GAAwB,MAAAuC,GAAAvC,KAC3EhI,EAAAqE,EAAAY,UAAAd,UAAA,sBAAAnE,EAAAtC,EAAA2G,IAGArE,IAQApE,EAAA4C,UAAA,gCAAAwB,EAAAtC,EAAA2G,GACA,YAEA,IAAA7H,GAAA,iKAgCA,OA7BAwD,IAAA,KAEAA,IAAArD,QAAAH,EAAA,SAAAK,EAAA6I,EAAAC,EAAAqE,EAAAC,EAAAkC,EAAArG,GAIA,MAHAJ,KAAAtJ,cACAiI,EAAAO,MAAAc,GAAA9J,EAAA4C,UAAA,uBAAAmH,EAAAjI,EAAA2G,GAEA8H,EAGAA,EAAArG,GAGAA,IACAzB,EAAAQ,QAAAa,GAAAI,EAAAnJ,QAAA,kBAEAe,EAAA9D,oBAAAoQ,GAAAC,IACA5F,EAAAS,YAAAY,IACAsE,QACAC,WAKA,MAIAjK,IAAArD,QAAA,WAKAf,EAAA4C,UAAA,kBAAAwB,EAAAtC,EAAA2G,GACA,YAQA,SAAA+H,GAAAC,GACA,qBAAAjL,KAAAiL,GACA,4BACK,qBAAAjL,KAAAiL,GACL,6BACK,sBAAAjL,KAAAiL,GACL,8BAEA,GAIA,QAAAC,GAAAzC,EAAA0C,GACA,GAAAC,GAAA,EAOA,OANA3C,KAAAW,OACA9M,EAAA+O,gBACAD,EAAA,QAAA3C,EAAAlN,QAAA,UAAAP,cAAA,KAEAyN,EAAAjO,EAAA4C,UAAA,aAAAqL,EAAAnM,EAAA2G,GAEA,MAAAmI,EAAAD,EAAA,IAAA1C,EAAA,UAGA,QAAA6C,GAAAC,EAAAJ,GAEA,YAAAA,EAAA,IADA3Q,EAAA4C,UAAA,aAAAmO,EAAAjP,EAAA2G,GACA,UAGA,QAAAuI,GAAAC,EAAAC,GAIA,OAHAC,GAAA,2BACAC,EAAAH,EAAA7Q,OAEAD,EAAA,EAAmBA,EAAAiR,IAAYjR,EAC/BgR,GAAAF,EAAA9Q,EAIA,KAFAgR,GAAA,6BAEAhR,EAAA,EAAeA,EAAA+Q,EAAA9Q,SAAkBD,EAAA,CACjCgR,GAAA,QACA,QAAAE,GAAA,EAAsBA,EAAAD,IAAaC,EACnCF,GAAAD,EAAA/Q,GAAAkR,EAEAF,IAAA,UAGA,MADAA,IAAA,uBAlDA,IAAArP,EAAAxD,OACA,MAAA8F,EAGA,IAAAkN,GAAA,wHA4HA,OA1EAlN,GAAAqE,EAAAY,UAAAd,UAAA,gBAAAnE,EAAAtC,EAAA2G,GAGArE,IAAArD,QAAA,UAAAf,EAAAC,OAAAe,0BAGAoD,IAAArD,QAAAuQ,EAAA,SAAAC,GAEA,GAAApR,GAAAqR,EAAAD,EAAAvB,MAAA,KAGA,KAAA7P,EAAA,EAAeA,EAAAqR,EAAApR,SAAuBD,EACtC,YAAkBqF,KAAAgM,EAAArR,MAClBqR,EAAArR,GAAAqR,EAAArR,GAAAY,QAAA,YAAsD,KAEtD,YAAAyE,KAAAgM,EAAArR,MACAqR,EAAArR,GAAAqR,EAAArR,GAAAY,QAAA,gBAIA,IAAA0Q,GAAAD,EAAA,GAAAxB,MAAA,KAAA0B,IAAA,SAAAxN,GAAgE,MAAAA,GAAA0K,SAChE+C,EAAAH,EAAA,GAAAxB,MAAA,KAAA0B,IAAA,SAAAxN,GAA+D,MAAAA,GAAA0K,SAC/DgD,KACAX,KACAY,KACAX,IAKA,KAHAM,EAAAM,QACAN,EAAAM,QAEA3R,EAAA,EAAeA,EAAAqR,EAAApR,SAAuBD,EACtC,KAAAqR,EAAArR,GAAAyO,QAGAgD,EAAAhM,KACA4L,EAAArR,GACA6P,MAAA,KACA0B,IAAA,SAAAxN,GACA,MAAAA,GAAA0K,SAKA,IAAA6C,EAAArR,OAAAuR,EAAAvR,OACA,MAAAmR,EAGA,KAAApR,EAAA,EAAeA,EAAAwR,EAAAvR,SAAsBD,EACrC0R,EAAAjM,KAAA4K,EAAAmB,EAAAxR,IAGA,KAAAA,EAAA,EAAeA,EAAAsR,EAAArR,SAAuBD,EACtCH,EAAAC,OAAAQ,YAAAoR,EAAA1R,MACA0R,EAAA1R,GAAA,IAEA8Q,EAAArL,KAAA8K,EAAAe,EAAAtR,GAAA0R,EAAA1R,IAGA,KAAAA,EAAA,EAAeA,EAAAyR,EAAAxR,SAAqBD,EAAA,CAEpC,OADA4R,MACAV,EAAA,EAAsBA,EAAAJ,EAAA7Q,SAAqBiR,EAC3CrR,EAAAC,OAAAQ,YAAAmR,EAAAzR,GAAAkR,IAGAU,EAAAnM,KAAAkL,EAAAc,EAAAzR,GAAAkR,GAAAQ,EAAAR,IAEAH,GAAAtL,KAAAmM,GAGA,MAAAf,GAAAC,EAAAC,KAGA9M,EAAAqE,EAAAY,UAAAd,UAAA,eAAAnE,EAAAtC,EAAA2G,KAQAzI,EAAA4C,UAAA,gCAAAwB,EAAAtC,EAAA2G,GACA,YASA,OARArE,GAAAqE,EAAAY,UAAAd,UAAA,8BAAAnE,EAAAtC,EAAA2G,GAEArE,IAAArD,QAAA,qBAAAE,EAAAC,GACA,GAAA8Q,GAAA1E,SAAApM,EACA,OAAAqC,QAAA0O,aAAAD,KAGA5N,EAAAqE,EAAAY,UAAAd,UAAA,6BAAAnE,EAAAtC,EAAA2G,SAOA,KAAAxL,KAAAC,QACAD,EAAAC,QAAA8C,MAOGkS,MAHH9U,EAAA,WACA,YACA,OAAA4C,IACG2D,KAAAzG,EAAAC,EAAAD,EAAAD,QAAAC,QAAAE,KAMFuG,KAAAzB","file":"static/js/103.52962a96060c610519b6.js","sourcesContent":["webpackJsonp([103],{\n\n/***/ 1280:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;;/*! showdown 02-06-2017 */\r\n(function(){\r\n/**\r\n * Created by Tivie on 13-07-2015.\r\n */\r\n\r\nfunction getDefaultOpts (simple) {\r\n  'use strict';\r\n\r\n  var defaultOptions = {\r\n    omitExtraWLInCodeBlocks: {\r\n      defaultValue: false,\r\n      describe: 'Omit the default extra whiteline added to code blocks',\r\n      type: 'boolean'\r\n    },\r\n    noHeaderId: {\r\n      defaultValue: false,\r\n      describe: 'Turn on/off generated header id',\r\n      type: 'boolean'\r\n    },\r\n    prefixHeaderId: {\r\n      defaultValue: false,\r\n      describe: 'Specify a prefix to generated header ids',\r\n      type: 'string'\r\n    },\r\n    ghCompatibleHeaderId: {\r\n      defaultValue: false,\r\n      describe: 'Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)',\r\n      type: 'boolean'\r\n    },\r\n    headerLevelStart: {\r\n      defaultValue: false,\r\n      describe: 'The header blocks level start',\r\n      type: 'integer'\r\n    },\r\n    parseImgDimensions: {\r\n      defaultValue: false,\r\n      describe: 'Turn on/off image dimension parsing',\r\n      type: 'boolean'\r\n    },\r\n    simplifiedAutoLink: {\r\n      defaultValue: false,\r\n      describe: 'Turn on/off GFM autolink style',\r\n      type: 'boolean'\r\n    },\r\n    excludeTrailingPunctuationFromURLs: {\r\n      defaultValue: false,\r\n      describe: 'Excludes trailing punctuation from links generated with autoLinking',\r\n      type: 'boolean'\r\n    },\r\n    literalMidWordUnderscores: {\r\n      defaultValue: false,\r\n      describe: 'Parse midword underscores as literal underscores',\r\n      type: 'boolean'\r\n    },\r\n    literalMidWordAsterisks: {\r\n      defaultValue: false,\r\n      describe: 'Parse midword asterisks as literal asterisks',\r\n      type: 'boolean'\r\n    },\r\n    strikethrough: {\r\n      defaultValue: false,\r\n      describe: 'Turn on/off strikethrough support',\r\n      type: 'boolean'\r\n    },\r\n    tables: {\r\n      defaultValue: false,\r\n      describe: 'Turn on/off tables support',\r\n      type: 'boolean'\r\n    },\r\n    tablesHeaderId: {\r\n      defaultValue: false,\r\n      describe: 'Add an id to table headers',\r\n      type: 'boolean'\r\n    },\r\n    ghCodeBlocks: {\r\n      defaultValue: true,\r\n      describe: 'Turn on/off GFM fenced code blocks support',\r\n      type: 'boolean'\r\n    },\r\n    tasklists: {\r\n      defaultValue: false,\r\n      describe: 'Turn on/off GFM tasklist support',\r\n      type: 'boolean'\r\n    },\r\n    smoothLivePreview: {\r\n      defaultValue: false,\r\n      describe: 'Prevents weird effects in live previews due to incomplete input',\r\n      type: 'boolean'\r\n    },\r\n    smartIndentationFix: {\r\n      defaultValue: false,\r\n      description: 'Tries to smartly fix indentation in es6 strings',\r\n      type: 'boolean'\r\n    },\r\n    disableForced4SpacesIndentedSublists: {\r\n      defaultValue: false,\r\n      description: 'Disables the requirement of indenting nested sublists by 4 spaces',\r\n      type: 'boolean'\r\n    },\r\n    simpleLineBreaks: {\r\n      defaultValue: false,\r\n      description: 'Parses simple line breaks as <br> (GFM Style)',\r\n      type: 'boolean'\r\n    },\r\n    requireSpaceBeforeHeadingText: {\r\n      defaultValue: false,\r\n      description: 'Makes adding a space between `#` and the header text mandatory (GFM Style)',\r\n      type: 'boolean'\r\n    },\r\n    ghMentions: {\r\n      defaultValue: false,\r\n      description: 'Enables github @mentions',\r\n      type: 'boolean'\r\n    },\r\n    ghMentionsLink: {\r\n      defaultValue: 'https://github.com/{u}',\r\n      description: 'Changes the link generated by @mentions. Only applies if ghMentions option is enabled.',\r\n      type: 'string'\r\n    },\r\n    encodeEmails: {\r\n      defaultValue: true,\r\n      description: 'Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities',\r\n      type: 'boolean'\r\n    },\r\n    openLinksInNewWindow: {\r\n      defaultValue: false,\r\n      description: 'Open all links in new windows',\r\n      type: 'boolean'\r\n    }\r\n  };\r\n  if (simple === false) {\r\n    return JSON.parse(JSON.stringify(defaultOptions));\r\n  }\r\n  var ret = {};\r\n  for (var opt in defaultOptions) {\r\n    if (defaultOptions.hasOwnProperty(opt)) {\r\n      ret[opt] = defaultOptions[opt].defaultValue;\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n\r\nfunction allOptionsOn () {\r\n  'use strict';\r\n  var options = getDefaultOpts(true),\r\n      ret = {};\r\n  for (var opt in options) {\r\n    if (options.hasOwnProperty(opt)) {\r\n      ret[opt] = true;\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Created by Tivie on 06-01-2015.\r\n */\r\n\r\n// Private properties\r\nvar showdown = {},\r\n    parsers = {},\r\n    extensions = {},\r\n    globalOptions = getDefaultOpts(true),\r\n    setFlavor = 'vanilla',\r\n    flavor = {\r\n      github: {\r\n        omitExtraWLInCodeBlocks:              true,\r\n        simplifiedAutoLink:                   true,\r\n        excludeTrailingPunctuationFromURLs:   true,\r\n        literalMidWordUnderscores:            true,\r\n        strikethrough:                        true,\r\n        tables:                               true,\r\n        tablesHeaderId:                       true,\r\n        ghCodeBlocks:                         true,\r\n        tasklists:                            true,\r\n        disableForced4SpacesIndentedSublists: true,\r\n        simpleLineBreaks:                     true,\r\n        requireSpaceBeforeHeadingText:        true,\r\n        ghCompatibleHeaderId:                 true,\r\n        ghMentions:                           true\r\n      },\r\n      original: {\r\n        noHeaderId:                           true,\r\n        ghCodeBlocks:                         false\r\n      },\r\n      ghost: {\r\n        omitExtraWLInCodeBlocks:              true,\r\n        parseImgDimensions:                   true,\r\n        simplifiedAutoLink:                   true,\r\n        excludeTrailingPunctuationFromURLs:   true,\r\n        literalMidWordUnderscores:            true,\r\n        strikethrough:                        true,\r\n        tables:                               true,\r\n        tablesHeaderId:                       true,\r\n        ghCodeBlocks:                         true,\r\n        tasklists:                            true,\r\n        smoothLivePreview:                    true,\r\n        simpleLineBreaks:                     true,\r\n        requireSpaceBeforeHeadingText:        true,\r\n        ghMentions:                           false,\r\n        encodeEmails:                         true\r\n      },\r\n      vanilla: getDefaultOpts(true),\r\n      allOn: allOptionsOn()\r\n    };\r\n\r\n/**\r\n * helper namespace\r\n * @type {{}}\r\n */\r\nshowdown.helper = {};\r\n\r\n/**\r\n * TODO LEGACY SUPPORT CODE\r\n * @type {{}}\r\n */\r\nshowdown.extensions = {};\r\n\r\n/**\r\n * Set a global option\r\n * @static\r\n * @param {string} key\r\n * @param {*} value\r\n * @returns {showdown}\r\n */\r\nshowdown.setOption = function (key, value) {\r\n  'use strict';\r\n  globalOptions[key] = value;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Get a global option\r\n * @static\r\n * @param {string} key\r\n * @returns {*}\r\n */\r\nshowdown.getOption = function (key) {\r\n  'use strict';\r\n  return globalOptions[key];\r\n};\r\n\r\n/**\r\n * Get the global options\r\n * @static\r\n * @returns {{}}\r\n */\r\nshowdown.getOptions = function () {\r\n  'use strict';\r\n  return globalOptions;\r\n};\r\n\r\n/**\r\n * Reset global options to the default values\r\n * @static\r\n */\r\nshowdown.resetOptions = function () {\r\n  'use strict';\r\n  globalOptions = getDefaultOpts(true);\r\n};\r\n\r\n/**\r\n * Set the flavor showdown should use as default\r\n * @param {string} name\r\n */\r\nshowdown.setFlavor = function (name) {\r\n  'use strict';\r\n  if (!flavor.hasOwnProperty(name)) {\r\n    throw Error(name + ' flavor was not found');\r\n  }\r\n  showdown.resetOptions();\r\n  var preset = flavor[name];\r\n  setFlavor = name;\r\n  for (var option in preset) {\r\n    if (preset.hasOwnProperty(option)) {\r\n      globalOptions[option] = preset[option];\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Get the currently set flavor\r\n * @returns {string}\r\n */\r\nshowdown.getFlavor = function () {\r\n  'use strict';\r\n  return setFlavor;\r\n};\r\n\r\n/**\r\n * Get the options of a specified flavor. Returns undefined if the flavor was not found\r\n * @param {string} name Name of the flavor\r\n * @returns {{}|undefined}\r\n */\r\nshowdown.getFlavorOptions = function (name) {\r\n  'use strict';\r\n  if (flavor.hasOwnProperty(name)) {\r\n    return flavor[name];\r\n  }\r\n};\r\n\r\n/**\r\n * Get the default options\r\n * @static\r\n * @param {boolean} [simple=true]\r\n * @returns {{}}\r\n */\r\nshowdown.getDefaultOptions = function (simple) {\r\n  'use strict';\r\n  return getDefaultOpts(simple);\r\n};\r\n\r\n/**\r\n * Get or set a subParser\r\n *\r\n * subParser(name)       - Get a registered subParser\r\n * subParser(name, func) - Register a subParser\r\n * @static\r\n * @param {string} name\r\n * @param {function} [func]\r\n * @returns {*}\r\n */\r\nshowdown.subParser = function (name, func) {\r\n  'use strict';\r\n  if (showdown.helper.isString(name)) {\r\n    if (typeof func !== 'undefined') {\r\n      parsers[name] = func;\r\n    } else {\r\n      if (parsers.hasOwnProperty(name)) {\r\n        return parsers[name];\r\n      } else {\r\n        throw Error('SubParser named ' + name + ' not registered!');\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Gets or registers an extension\r\n * @static\r\n * @param {string} name\r\n * @param {object|function=} ext\r\n * @returns {*}\r\n */\r\nshowdown.extension = function (name, ext) {\r\n  'use strict';\r\n\r\n  if (!showdown.helper.isString(name)) {\r\n    throw Error('Extension \\'name\\' must be a string');\r\n  }\r\n\r\n  name = showdown.helper.stdExtName(name);\r\n\r\n  // Getter\r\n  if (showdown.helper.isUndefined(ext)) {\r\n    if (!extensions.hasOwnProperty(name)) {\r\n      throw Error('Extension named ' + name + ' is not registered!');\r\n    }\r\n    return extensions[name];\r\n\r\n    // Setter\r\n  } else {\r\n    // Expand extension if it's wrapped in a function\r\n    if (typeof ext === 'function') {\r\n      ext = ext();\r\n    }\r\n\r\n    // Ensure extension is an array\r\n    if (!showdown.helper.isArray(ext)) {\r\n      ext = [ext];\r\n    }\r\n\r\n    var validExtension = validate(ext, name);\r\n\r\n    if (validExtension.valid) {\r\n      extensions[name] = ext;\r\n    } else {\r\n      throw Error(validExtension.error);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Gets all extensions registered\r\n * @returns {{}}\r\n */\r\nshowdown.getAllExtensions = function () {\r\n  'use strict';\r\n  return extensions;\r\n};\r\n\r\n/**\r\n * Remove an extension\r\n * @param {string} name\r\n */\r\nshowdown.removeExtension = function (name) {\r\n  'use strict';\r\n  delete extensions[name];\r\n};\r\n\r\n/**\r\n * Removes all extensions\r\n */\r\nshowdown.resetExtensions = function () {\r\n  'use strict';\r\n  extensions = {};\r\n};\r\n\r\n/**\r\n * Validate extension\r\n * @param {array} extension\r\n * @param {string} name\r\n * @returns {{valid: boolean, error: string}}\r\n */\r\nfunction validate (extension, name) {\r\n  'use strict';\r\n\r\n  var errMsg = (name) ? 'Error in ' + name + ' extension->' : 'Error in unnamed extension',\r\n      ret = {\r\n        valid: true,\r\n        error: ''\r\n      };\r\n\r\n  if (!showdown.helper.isArray(extension)) {\r\n    extension = [extension];\r\n  }\r\n\r\n  for (var i = 0; i < extension.length; ++i) {\r\n    var baseMsg = errMsg + ' sub-extension ' + i + ': ',\r\n        ext = extension[i];\r\n    if (typeof ext !== 'object') {\r\n      ret.valid = false;\r\n      ret.error = baseMsg + 'must be an object, but ' + typeof ext + ' given';\r\n      return ret;\r\n    }\r\n\r\n    if (!showdown.helper.isString(ext.type)) {\r\n      ret.valid = false;\r\n      ret.error = baseMsg + 'property \"type\" must be a string, but ' + typeof ext.type + ' given';\r\n      return ret;\r\n    }\r\n\r\n    var type = ext.type = ext.type.toLowerCase();\r\n\r\n    // normalize extension type\r\n    if (type === 'language') {\r\n      type = ext.type = 'lang';\r\n    }\r\n\r\n    if (type === 'html') {\r\n      type = ext.type = 'output';\r\n    }\r\n\r\n    if (type !== 'lang' && type !== 'output' && type !== 'listener') {\r\n      ret.valid = false;\r\n      ret.error = baseMsg + 'type ' + type + ' is not recognized. Valid values: \"lang/language\", \"output/html\" or \"listener\"';\r\n      return ret;\r\n    }\r\n\r\n    if (type === 'listener') {\r\n      if (showdown.helper.isUndefined(ext.listeners)) {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '. Extensions of type \"listener\" must have a property called \"listeners\"';\r\n        return ret;\r\n      }\r\n    } else {\r\n      if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + type + ' extensions must define either a \"regex\" property or a \"filter\" method';\r\n        return ret;\r\n      }\r\n    }\r\n\r\n    if (ext.listeners) {\r\n      if (typeof ext.listeners !== 'object') {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '\"listeners\" property must be an object but ' + typeof ext.listeners + ' given';\r\n        return ret;\r\n      }\r\n      for (var ln in ext.listeners) {\r\n        if (ext.listeners.hasOwnProperty(ln)) {\r\n          if (typeof ext.listeners[ln] !== 'function') {\r\n            ret.valid = false;\r\n            ret.error = baseMsg + '\"listeners\" property must be an hash of [event name]: [callback]. listeners.' + ln +\r\n              ' must be a function but ' + typeof ext.listeners[ln] + ' given';\r\n            return ret;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (ext.filter) {\r\n      if (typeof ext.filter !== 'function') {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '\"filter\" must be a function, but ' + typeof ext.filter + ' given';\r\n        return ret;\r\n      }\r\n    } else if (ext.regex) {\r\n      if (showdown.helper.isString(ext.regex)) {\r\n        ext.regex = new RegExp(ext.regex, 'g');\r\n      }\r\n      if (!(ext.regex instanceof RegExp)) {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '\"regex\" property must either be a string or a RegExp object, but ' + typeof ext.regex + ' given';\r\n        return ret;\r\n      }\r\n      if (showdown.helper.isUndefined(ext.replace)) {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '\"regex\" extensions must implement a replace string or function';\r\n        return ret;\r\n      }\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Validate extension\r\n * @param {object} ext\r\n * @returns {boolean}\r\n */\r\nshowdown.validateExtension = function (ext) {\r\n  'use strict';\r\n\r\n  var validateExtension = validate(ext, null);\r\n  if (!validateExtension.valid) {\r\n    console.warn(validateExtension.error);\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * showdownjs helper functions\r\n */\r\n\r\nif (!showdown.hasOwnProperty('helper')) {\r\n  showdown.helper = {};\r\n}\r\n\r\n/**\r\n * Check if var is string\r\n * @static\r\n * @param {string} a\r\n * @returns {boolean}\r\n */\r\nshowdown.helper.isString = function (a) {\r\n  'use strict';\r\n  return (typeof a === 'string' || a instanceof String);\r\n};\r\n\r\n/**\r\n * Check if var is a function\r\n * @static\r\n * @param {*} a\r\n * @returns {boolean}\r\n */\r\nshowdown.helper.isFunction = function (a) {\r\n  'use strict';\r\n  var getType = {};\r\n  return a && getType.toString.call(a) === '[object Function]';\r\n};\r\n\r\n/**\r\n * isArray helper function\r\n * @static\r\n * @param {*} a\r\n * @returns {boolean}\r\n */\r\nshowdown.helper.isArray = function (a) {\r\n  'use strict';\r\n  return a.constructor === Array;\r\n};\r\n\r\n/**\r\n * Check if value is undefined\r\n * @static\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\r\n */\r\nshowdown.helper.isUndefined = function (value) {\r\n  'use strict';\r\n  return typeof value === 'undefined';\r\n};\r\n\r\n/**\r\n * ForEach helper function\r\n * Iterates over Arrays and Objects (own properties only)\r\n * @static\r\n * @param {*} obj\r\n * @param {function} callback Accepts 3 params: 1. value, 2. key, 3. the original array/object\r\n */\r\nshowdown.helper.forEach = function (obj, callback) {\r\n  'use strict';\r\n  // check if obj is defined\r\n  if (showdown.helper.isUndefined(obj)) {\r\n    throw new Error('obj param is required');\r\n  }\r\n\r\n  if (showdown.helper.isUndefined(callback)) {\r\n    throw new Error('callback param is required');\r\n  }\r\n\r\n  if (!showdown.helper.isFunction(callback)) {\r\n    throw new Error('callback param must be a function/closure');\r\n  }\r\n\r\n  if (typeof obj.forEach === 'function') {\r\n    obj.forEach(callback);\r\n  } else if (showdown.helper.isArray(obj)) {\r\n    for (var i = 0; i < obj.length; i++) {\r\n      callback(obj[i], i, obj);\r\n    }\r\n  } else if (typeof (obj) === 'object') {\r\n    for (var prop in obj) {\r\n      if (obj.hasOwnProperty(prop)) {\r\n        callback(obj[prop], prop, obj);\r\n      }\r\n    }\r\n  } else {\r\n    throw new Error('obj does not seem to be an array or an iterable object');\r\n  }\r\n};\r\n\r\n/**\r\n * Standardidize extension name\r\n * @static\r\n * @param {string} s extension name\r\n * @returns {string}\r\n */\r\nshowdown.helper.stdExtName = function (s) {\r\n  'use strict';\r\n  return s.replace(/[_?*+\\/\\\\.^-]/g, '').replace(/\\s/g, '').toLowerCase();\r\n};\r\n\r\nfunction escapeCharactersCallback (wholeMatch, m1) {\r\n  'use strict';\r\n  var charCodeToEscape = m1.charCodeAt(0);\r\n  return 'E' + charCodeToEscape + 'E';\r\n}\r\n\r\n/**\r\n * Callback used to escape characters when passing through String.replace\r\n * @static\r\n * @param {string} wholeMatch\r\n * @param {string} m1\r\n * @returns {string}\r\n */\r\nshowdown.helper.escapeCharactersCallback = escapeCharactersCallback;\r\n\r\n/**\r\n * Escape characters in a string\r\n * @static\r\n * @param {string} text\r\n * @param {string} charsToEscape\r\n * @param {boolean} afterBackslash\r\n * @returns {XML|string|void|*}\r\n */\r\nshowdown.helper.escapeCharacters = function (text, charsToEscape, afterBackslash) {\r\n  'use strict';\r\n  // First we have to escape the escape characters so that\r\n  // we can build a character class out of them\r\n  var regexString = '([' + charsToEscape.replace(/([\\[\\]\\\\])/g, '\\\\$1') + '])';\r\n\r\n  if (afterBackslash) {\r\n    regexString = '\\\\\\\\' + regexString;\r\n  }\r\n\r\n  var regex = new RegExp(regexString, 'g');\r\n  text = text.replace(regex, escapeCharactersCallback);\r\n\r\n  return text;\r\n};\r\n\r\nvar rgxFindMatchPos = function (str, left, right, flags) {\r\n  'use strict';\r\n  var f = flags || '',\r\n      g = f.indexOf('g') > -1,\r\n      x = new RegExp(left + '|' + right, 'g' + f.replace(/g/g, '')),\r\n      l = new RegExp(left, f.replace(/g/g, '')),\r\n      pos = [],\r\n      t, s, m, start, end;\r\n\r\n  do {\r\n    t = 0;\r\n    while ((m = x.exec(str))) {\r\n      if (l.test(m[0])) {\r\n        if (!(t++)) {\r\n          s = x.lastIndex;\r\n          start = s - m[0].length;\r\n        }\r\n      } else if (t) {\r\n        if (!--t) {\r\n          end = m.index + m[0].length;\r\n          var obj = {\r\n            left: {start: start, end: s},\r\n            match: {start: s, end: m.index},\r\n            right: {start: m.index, end: end},\r\n            wholeMatch: {start: start, end: end}\r\n          };\r\n          pos.push(obj);\r\n          if (!g) {\r\n            return pos;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } while (t && (x.lastIndex = s));\r\n\r\n  return pos;\r\n};\r\n\r\n/**\r\n * matchRecursiveRegExp\r\n *\r\n * (c) 2007 Steven Levithan <stevenlevithan.com>\r\n * MIT License\r\n *\r\n * Accepts a string to search, a left and right format delimiter\r\n * as regex patterns, and optional regex flags. Returns an array\r\n * of matches, allowing nested instances of left/right delimiters.\r\n * Use the \"g\" flag to return all matches, otherwise only the\r\n * first is returned. Be careful to ensure that the left and\r\n * right format delimiters produce mutually exclusive matches.\r\n * Backreferences are not supported within the right delimiter\r\n * due to how it is internally combined with the left delimiter.\r\n * When matching strings whose format delimiters are unbalanced\r\n * to the left or right, the output is intentionally as a\r\n * conventional regex library with recursion support would\r\n * produce, e.g. \"<<x>\" and \"<x>>\" both produce [\"x\"] when using\r\n * \"<\" and \">\" as the delimiters (both strings contain a single,\r\n * balanced instance of \"<x>\").\r\n *\r\n * examples:\r\n * matchRecursiveRegExp(\"test\", \"\\\\(\", \"\\\\)\")\r\n * returns: []\r\n * matchRecursiveRegExp(\"<t<<e>><s>>t<>\", \"<\", \">\", \"g\")\r\n * returns: [\"t<<e>><s>\", \"\"]\r\n * matchRecursiveRegExp(\"<div id=\\\"x\\\">test</div>\", \"<div\\\\b[^>]*>\", \"</div>\", \"gi\")\r\n * returns: [\"test\"]\r\n */\r\nshowdown.helper.matchRecursiveRegExp = function (str, left, right, flags) {\r\n  'use strict';\r\n\r\n  var matchPos = rgxFindMatchPos (str, left, right, flags),\r\n      results = [];\r\n\r\n  for (var i = 0; i < matchPos.length; ++i) {\r\n    results.push([\r\n      str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),\r\n      str.slice(matchPos[i].match.start, matchPos[i].match.end),\r\n      str.slice(matchPos[i].left.start, matchPos[i].left.end),\r\n      str.slice(matchPos[i].right.start, matchPos[i].right.end)\r\n    ]);\r\n  }\r\n  return results;\r\n};\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @param {string|function} replacement\r\n * @param {string} left\r\n * @param {string} right\r\n * @param {string} flags\r\n * @returns {string}\r\n */\r\nshowdown.helper.replaceRecursiveRegExp = function (str, replacement, left, right, flags) {\r\n  'use strict';\r\n\r\n  if (!showdown.helper.isFunction(replacement)) {\r\n    var repStr = replacement;\r\n    replacement = function () {\r\n      return repStr;\r\n    };\r\n  }\r\n\r\n  var matchPos = rgxFindMatchPos(str, left, right, flags),\r\n      finalStr = str,\r\n      lng = matchPos.length;\r\n\r\n  if (lng > 0) {\r\n    var bits = [];\r\n    if (matchPos[0].wholeMatch.start !== 0) {\r\n      bits.push(str.slice(0, matchPos[0].wholeMatch.start));\r\n    }\r\n    for (var i = 0; i < lng; ++i) {\r\n      bits.push(\r\n        replacement(\r\n          str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),\r\n          str.slice(matchPos[i].match.start, matchPos[i].match.end),\r\n          str.slice(matchPos[i].left.start, matchPos[i].left.end),\r\n          str.slice(matchPos[i].right.start, matchPos[i].right.end)\r\n        )\r\n      );\r\n      if (i < lng - 1) {\r\n        bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));\r\n      }\r\n    }\r\n    if (matchPos[lng - 1].wholeMatch.end < str.length) {\r\n      bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));\r\n    }\r\n    finalStr = bits.join('');\r\n  }\r\n  return finalStr;\r\n};\r\n\r\n/**\r\n * Returns the index within the passed String object of the first occurrence of the specified regex,\r\n * starting the search at fromIndex. Returns -1 if the value is not found.\r\n *\r\n * @param {string} str string to search\r\n * @param {RegExp} regex Regular expression to search\r\n * @param {int} [fromIndex = 0] Index to start the search\r\n * @returns {Number}\r\n * @throws InvalidArgumentError\r\n */\r\nshowdown.helper.regexIndexOf = function (str, regex, fromIndex) {\r\n  'use strict';\r\n  if (!showdown.helper.isString(str)) {\r\n    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';\r\n  }\r\n  if (regex instanceof RegExp === false) {\r\n    throw 'InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp';\r\n  }\r\n  var indexOf = str.substring(fromIndex || 0).search(regex);\r\n  return (indexOf >= 0) ? (indexOf + (fromIndex || 0)) : indexOf;\r\n};\r\n\r\n/**\r\n * Splits the passed string object at the defined index, and returns an array composed of the two substrings\r\n * @param {string} str string to split\r\n * @param {int} index index to split string at\r\n * @returns {[string,string]}\r\n * @throws InvalidArgumentError\r\n */\r\nshowdown.helper.splitAtIndex = function (str, index) {\r\n  'use strict';\r\n  if (!showdown.helper.isString(str)) {\r\n    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';\r\n  }\r\n  return [str.substring(0, index), str.substring(index)];\r\n};\r\n\r\n/**\r\n * Obfuscate an e-mail address through the use of Character Entities,\r\n * transforming ASCII characters into their equivalent decimal or hex entities.\r\n *\r\n * Since it has a random component, subsequent calls to this function produce different results\r\n *\r\n * @param {string} mail\r\n * @returns {string}\r\n */\r\nshowdown.helper.encodeEmailAddress = function (mail) {\r\n  'use strict';\r\n  var encode = [\r\n    function (ch) {\r\n      return '&#' + ch.charCodeAt(0) + ';';\r\n    },\r\n    function (ch) {\r\n      return '&#x' + ch.charCodeAt(0).toString(16) + ';';\r\n    },\r\n    function (ch) {\r\n      return ch;\r\n    }\r\n  ];\r\n\r\n  mail = mail.replace(/./g, function (ch) {\r\n    if (ch === '@') {\r\n      // this *must* be encoded. I insist.\r\n      ch = encode[Math.floor(Math.random() * 2)](ch);\r\n    } else {\r\n      var r = Math.random();\r\n      // roughly 10% raw, 45% hex, 45% dec\r\n      ch = (\r\n        r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch)\r\n      );\r\n    }\r\n    return ch;\r\n  });\r\n\r\n  return mail;\r\n};\r\n\r\n/**\r\n * POLYFILLS\r\n */\r\n// use this instead of builtin is undefined for IE8 compatibility\r\nif (typeof(console) === 'undefined') {\r\n  console = {\r\n    warn: function (msg) {\r\n      'use strict';\r\n      alert(msg);\r\n    },\r\n    log: function (msg) {\r\n      'use strict';\r\n      alert(msg);\r\n    },\r\n    error: function (msg) {\r\n      'use strict';\r\n      throw msg;\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Common regexes.\r\n * We declare some common regexes to improve performance\r\n */\r\nshowdown.helper.regexes = {\r\n  asteriskAndDash: /([*_])/g\r\n};\r\n\r\n/**\r\n * Created by Estevao on 31-05-2015.\r\n */\r\n\r\n/**\r\n * Showdown Converter class\r\n * @class\r\n * @param {object} [converterOptions]\r\n * @returns {Converter}\r\n */\r\nshowdown.Converter = function (converterOptions) {\r\n  'use strict';\r\n\r\n  var\r\n      /**\r\n       * Options used by this converter\r\n       * @private\r\n       * @type {{}}\r\n       */\r\n      options = {},\r\n\r\n      /**\r\n       * Language extensions used by this converter\r\n       * @private\r\n       * @type {Array}\r\n       */\r\n      langExtensions = [],\r\n\r\n      /**\r\n       * Output modifiers extensions used by this converter\r\n       * @private\r\n       * @type {Array}\r\n       */\r\n      outputModifiers = [],\r\n\r\n      /**\r\n       * Event listeners\r\n       * @private\r\n       * @type {{}}\r\n       */\r\n      listeners = {},\r\n\r\n      /**\r\n       * The flavor set in this converter\r\n       */\r\n      setConvFlavor = setFlavor;\r\n\r\n  _constructor();\r\n\r\n  /**\r\n   * Converter constructor\r\n   * @private\r\n   */\r\n  function _constructor () {\r\n    converterOptions = converterOptions || {};\r\n\r\n    for (var gOpt in globalOptions) {\r\n      if (globalOptions.hasOwnProperty(gOpt)) {\r\n        options[gOpt] = globalOptions[gOpt];\r\n      }\r\n    }\r\n\r\n    // Merge options\r\n    if (typeof converterOptions === 'object') {\r\n      for (var opt in converterOptions) {\r\n        if (converterOptions.hasOwnProperty(opt)) {\r\n          options[opt] = converterOptions[opt];\r\n        }\r\n      }\r\n    } else {\r\n      throw Error('Converter expects the passed parameter to be an object, but ' + typeof converterOptions +\r\n      ' was passed instead.');\r\n    }\r\n\r\n    if (options.extensions) {\r\n      showdown.helper.forEach(options.extensions, _parseExtension);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse extension\r\n   * @param {*} ext\r\n   * @param {string} [name='']\r\n   * @private\r\n   */\r\n  function _parseExtension (ext, name) {\r\n\r\n    name = name || null;\r\n    // If it's a string, the extension was previously loaded\r\n    if (showdown.helper.isString(ext)) {\r\n      ext = showdown.helper.stdExtName(ext);\r\n      name = ext;\r\n\r\n      // LEGACY_SUPPORT CODE\r\n      if (showdown.extensions[ext]) {\r\n        console.warn('DEPRECATION WARNING: ' + ext + ' is an old extension that uses a deprecated loading method.' +\r\n          'Please inform the developer that the extension should be updated!');\r\n        legacyExtensionLoading(showdown.extensions[ext], ext);\r\n        return;\r\n      // END LEGACY SUPPORT CODE\r\n\r\n      } else if (!showdown.helper.isUndefined(extensions[ext])) {\r\n        ext = extensions[ext];\r\n\r\n      } else {\r\n        throw Error('Extension \"' + ext + '\" could not be loaded. It was either not found or is not a valid extension.');\r\n      }\r\n    }\r\n\r\n    if (typeof ext === 'function') {\r\n      ext = ext();\r\n    }\r\n\r\n    if (!showdown.helper.isArray(ext)) {\r\n      ext = [ext];\r\n    }\r\n\r\n    var validExt = validate(ext, name);\r\n    if (!validExt.valid) {\r\n      throw Error(validExt.error);\r\n    }\r\n\r\n    for (var i = 0; i < ext.length; ++i) {\r\n      switch (ext[i].type) {\r\n\r\n        case 'lang':\r\n          langExtensions.push(ext[i]);\r\n          break;\r\n\r\n        case 'output':\r\n          outputModifiers.push(ext[i]);\r\n          break;\r\n      }\r\n      if (ext[i].hasOwnProperty('listeners')) {\r\n        for (var ln in ext[i].listeners) {\r\n          if (ext[i].listeners.hasOwnProperty(ln)) {\r\n            listen(ln, ext[i].listeners[ln]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * LEGACY_SUPPORT\r\n   * @param {*} ext\r\n   * @param {string} name\r\n   */\r\n  function legacyExtensionLoading (ext, name) {\r\n    if (typeof ext === 'function') {\r\n      ext = ext(new showdown.Converter());\r\n    }\r\n    if (!showdown.helper.isArray(ext)) {\r\n      ext = [ext];\r\n    }\r\n    var valid = validate(ext, name);\r\n\r\n    if (!valid.valid) {\r\n      throw Error(valid.error);\r\n    }\r\n\r\n    for (var i = 0; i < ext.length; ++i) {\r\n      switch (ext[i].type) {\r\n        case 'lang':\r\n          langExtensions.push(ext[i]);\r\n          break;\r\n        case 'output':\r\n          outputModifiers.push(ext[i]);\r\n          break;\r\n        default:// should never reach here\r\n          throw Error('Extension loader error: Type unrecognized!!!');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Listen to an event\r\n   * @param {string} name\r\n   * @param {function} callback\r\n   */\r\n  function listen (name, callback) {\r\n    if (!showdown.helper.isString(name)) {\r\n      throw Error('Invalid argument in converter.listen() method: name must be a string, but ' + typeof name + ' given');\r\n    }\r\n\r\n    if (typeof callback !== 'function') {\r\n      throw Error('Invalid argument in converter.listen() method: callback must be a function, but ' + typeof callback + ' given');\r\n    }\r\n\r\n    if (!listeners.hasOwnProperty(name)) {\r\n      listeners[name] = [];\r\n    }\r\n    listeners[name].push(callback);\r\n  }\r\n\r\n  function rTrimInputText (text) {\r\n    var rsp = text.match(/^\\s*/)[0].length,\r\n        rgx = new RegExp('^\\\\s{0,' + rsp + '}', 'gm');\r\n    return text.replace(rgx, '');\r\n  }\r\n\r\n  /**\r\n   * Dispatch an event\r\n   * @private\r\n   * @param {string} evtName Event name\r\n   * @param {string} text Text\r\n   * @param {{}} options Converter Options\r\n   * @param {{}} globals\r\n   * @returns {string}\r\n   */\r\n  this._dispatch = function dispatch (evtName, text, options, globals) {\r\n    if (listeners.hasOwnProperty(evtName)) {\r\n      for (var ei = 0; ei < listeners[evtName].length; ++ei) {\r\n        var nText = listeners[evtName][ei](evtName, text, this, options, globals);\r\n        if (nText && typeof nText !== 'undefined') {\r\n          text = nText;\r\n        }\r\n      }\r\n    }\r\n    return text;\r\n  };\r\n\r\n  /**\r\n   * Listen to an event\r\n   * @param {string} name\r\n   * @param {function} callback\r\n   * @returns {showdown.Converter}\r\n   */\r\n  this.listen = function (name, callback) {\r\n    listen(name, callback);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Converts a markdown string into HTML\r\n   * @param {string} text\r\n   * @returns {*}\r\n   */\r\n  this.makeHtml = function (text) {\r\n    //check if text is not falsy\r\n    if (!text) {\r\n      return text;\r\n    }\r\n\r\n    var globals = {\r\n      gHtmlBlocks:     [],\r\n      gHtmlMdBlocks:   [],\r\n      gHtmlSpans:      [],\r\n      gUrls:           {},\r\n      gTitles:         {},\r\n      gDimensions:     {},\r\n      gListLevel:      0,\r\n      hashLinkCounts:  {},\r\n      langExtensions:  langExtensions,\r\n      outputModifiers: outputModifiers,\r\n      converter:       this,\r\n      ghCodeBlocks:    []\r\n    };\r\n\r\n    // This lets us use  trema as an escape char to avoid md5 hashes\r\n    // The choice of character is arbitrary; anything that isn't\r\n    // magic in Markdown will work.\r\n    text = text.replace(//g, 'T');\r\n\r\n    // Replace $ with D\r\n    // RegExp interprets $ as a special character\r\n    // when it's in a replacement string\r\n    text = text.replace(/\\$/g, 'D');\r\n\r\n    // Standardize line endings\r\n    text = text.replace(/\\r\\n/g, '\\n'); // DOS to Unix\r\n    text = text.replace(/\\r/g, '\\n'); // Mac to Unix\r\n\r\n    // Stardardize line spaces (nbsp causes trouble in older browsers and some regex flavors)\r\n    text = text.replace(/\\u00A0/g, ' ');\r\n\r\n    if (options.smartIndentationFix) {\r\n      text = rTrimInputText(text);\r\n    }\r\n\r\n    // Make sure text begins and ends with a couple of newlines:\r\n    text = '\\n\\n' + text + '\\n\\n';\r\n\r\n    // detab\r\n    text = showdown.subParser('detab')(text, options, globals);\r\n\r\n    /**\r\n     * Strip any lines consisting only of spaces and tabs.\r\n     * This makes subsequent regexs easier to write, because we can\r\n     * match consecutive blank lines with /\\n+/ instead of something\r\n     * contorted like /[ \\t]*\\n+/\r\n     */\r\n    text = text.replace(/^[ \\t]+$/mg, '');\r\n\r\n    //run languageExtensions\r\n    showdown.helper.forEach(langExtensions, function (ext) {\r\n      text = showdown.subParser('runExtension')(ext, text, options, globals);\r\n    });\r\n\r\n    // run the sub parsers\r\n    text = showdown.subParser('hashPreCodeTags')(text, options, globals);\r\n    text = showdown.subParser('githubCodeBlocks')(text, options, globals);\r\n    text = showdown.subParser('hashHTMLBlocks')(text, options, globals);\r\n    text = showdown.subParser('hashCodeTags')(text, options, globals);\r\n    text = showdown.subParser('stripLinkDefinitions')(text, options, globals);\r\n    text = showdown.subParser('blockGamut')(text, options, globals);\r\n    text = showdown.subParser('unhashHTMLSpans')(text, options, globals);\r\n    text = showdown.subParser('unescapeSpecialChars')(text, options, globals);\r\n\r\n    // attacklab: Restore dollar signs\r\n    text = text.replace(/D/g, '$$');\r\n\r\n    // attacklab: Restore tremas\r\n    text = text.replace(/T/g, '');\r\n\r\n    // Run output modifiers\r\n    showdown.helper.forEach(outputModifiers, function (ext) {\r\n      text = showdown.subParser('runExtension')(ext, text, options, globals);\r\n    });\r\n\r\n    return text;\r\n  };\r\n\r\n  /**\r\n   * Set an option of this Converter instance\r\n   * @param {string} key\r\n   * @param {*} value\r\n   */\r\n  this.setOption = function (key, value) {\r\n    options[key] = value;\r\n  };\r\n\r\n  /**\r\n   * Get the option of this Converter instance\r\n   * @param {string} key\r\n   * @returns {*}\r\n   */\r\n  this.getOption = function (key) {\r\n    return options[key];\r\n  };\r\n\r\n  /**\r\n   * Get the options of this Converter instance\r\n   * @returns {{}}\r\n   */\r\n  this.getOptions = function () {\r\n    return options;\r\n  };\r\n\r\n  /**\r\n   * Add extension to THIS converter\r\n   * @param {{}} extension\r\n   * @param {string} [name=null]\r\n   */\r\n  this.addExtension = function (extension, name) {\r\n    name = name || null;\r\n    _parseExtension(extension, name);\r\n  };\r\n\r\n  /**\r\n   * Use a global registered extension with THIS converter\r\n   * @param {string} extensionName Name of the previously registered extension\r\n   */\r\n  this.useExtension = function (extensionName) {\r\n    _parseExtension(extensionName);\r\n  };\r\n\r\n  /**\r\n   * Set the flavor THIS converter should use\r\n   * @param {string} name\r\n   */\r\n  this.setFlavor = function (name) {\r\n    if (!flavor.hasOwnProperty(name)) {\r\n      throw Error(name + ' flavor was not found');\r\n    }\r\n    var preset = flavor[name];\r\n    setConvFlavor = name;\r\n    for (var option in preset) {\r\n      if (preset.hasOwnProperty(option)) {\r\n        options[option] = preset[option];\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the currently set flavor of this converter\r\n   * @returns {string}\r\n   */\r\n  this.getFlavor = function () {\r\n    return setConvFlavor;\r\n  };\r\n\r\n  /**\r\n   * Remove an extension from THIS converter.\r\n   * Note: This is a costly operation. It's better to initialize a new converter\r\n   * and specify the extensions you wish to use\r\n   * @param {Array} extension\r\n   */\r\n  this.removeExtension = function (extension) {\r\n    if (!showdown.helper.isArray(extension)) {\r\n      extension = [extension];\r\n    }\r\n    for (var a = 0; a < extension.length; ++a) {\r\n      var ext = extension[a];\r\n      for (var i = 0; i < langExtensions.length; ++i) {\r\n        if (langExtensions[i] === ext) {\r\n          langExtensions[i].splice(i, 1);\r\n        }\r\n      }\r\n      for (var ii = 0; ii < outputModifiers.length; ++i) {\r\n        if (outputModifiers[ii] === ext) {\r\n          outputModifiers[ii].splice(i, 1);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get all extension of THIS converter\r\n   * @returns {{language: Array, output: Array}}\r\n   */\r\n  this.getAllExtensions = function () {\r\n    return {\r\n      language: langExtensions,\r\n      output: outputModifiers\r\n    };\r\n  };\r\n};\r\n\r\n/**\r\n * Turn Markdown link shortcuts into XHTML <a> tags.\r\n */\r\nshowdown.subParser('anchors', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('anchors.before', text, options, globals);\r\n\r\n  var writeAnchorTag = function (wholeMatch, linkText, linkId, url, m5, m6, title) {\r\n    if (showdown.helper.isUndefined(title)) {\r\n      title = '';\r\n    }\r\n    linkId = linkId.toLowerCase();\r\n\r\n    // Special case for explicit empty url\r\n    if (wholeMatch.search(/\\(<?\\s*>? ?(['\"].*['\"])?\\)$/m) > -1) {\r\n      url = '';\r\n    } else if (!url) {\r\n      if (!linkId) {\r\n        // lower-case and turn embedded newlines into spaces\r\n        linkId = linkText.toLowerCase().replace(/ ?\\n/g, ' ');\r\n      }\r\n      url = '#' + linkId;\r\n\r\n      if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {\r\n        url = globals.gUrls[linkId];\r\n        if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {\r\n          title = globals.gTitles[linkId];\r\n        }\r\n      } else {\r\n        return wholeMatch;\r\n      }\r\n    }\r\n\r\n    //url = showdown.helper.escapeCharacters(url, '*_', false); // replaced line to improve performance\r\n    url = url.replace(showdown.helper.regexes.asteriskAndDash, showdown.helper.escapeCharactersCallback);\r\n\r\n    var result = '<a href=\"' + url + '\"';\r\n\r\n    if (title !== '' && title !== null) {\r\n      title = title.replace(/\"/g, '&quot;');\r\n      //title = showdown.helper.escapeCharacters(title, '*_', false); // replaced line to improve performance\r\n      title = title.replace(showdown.helper.regexes.asteriskAndDash, showdown.helper.escapeCharactersCallback);\r\n      result += ' title=\"' + title + '\"';\r\n    }\r\n\r\n    if (options.openLinksInNewWindow) {\r\n      // escaped _\r\n      result += ' target=\"E95Eblank\"';\r\n    }\r\n\r\n    result += '>' + linkText + '</a>';\r\n\r\n    return result;\r\n  };\r\n\r\n  // First, handle reference-style links: [link text] [id]\r\n  text = text.replace(/\\[((?:\\[[^\\]]*]|[^\\[\\]])*)] ?(?:\\n *)?\\[(.*?)]()()()()/g, writeAnchorTag);\r\n\r\n  // Next, inline-style links: [link text](url \"optional title\")\r\n  // cases with crazy urls like ./image/cat1).png\r\n  text = text.replace(/\\[((?:\\[[^\\]]*]|[^\\[\\]])*)]()[ \\t]*\\([ \\t]?<([^>]*)>(?:[ \\t]*(([\"'])([^\"]*?)\\5))?[ \\t]?\\)/g,\r\n    writeAnchorTag);\r\n\r\n  // normal cases\r\n  text = text.replace(/\\[((?:\\[[^\\]]*]|[^\\[\\]])*)]()[ \\t]*\\([ \\t]?<?([\\S]+?(?:\\([\\S]*?\\)[\\S]*?)?)>?(?:[ \\t]*(([\"'])([^\"]*?)\\5))?[ \\t]?\\)/g,\r\n                      writeAnchorTag);\r\n\r\n  // handle reference-style shortcuts: [link text]\r\n  // These must come last in case you've also got [link test][1]\r\n  // or [link test](/foo)\r\n  text = text.replace(/\\[([^\\[\\]]+)]()()()()()/g, writeAnchorTag);\r\n\r\n  // Lastly handle GithubMentions if option is enabled\r\n  if (options.ghMentions) {\r\n    text = text.replace(/(^|\\s)(\\\\)?(@([a-z\\d\\-]+))(?=[.!?;,[\\]()]|\\s|$)/gmi, function (wm, st, escape, mentions, username) {\r\n      if (escape === '\\\\') {\r\n        return st + mentions;\r\n      }\r\n\r\n      //check if options.ghMentionsLink is a string\r\n      if (!showdown.helper.isString(options.ghMentionsLink)) {\r\n        throw new Error('ghMentionsLink option must be a string');\r\n      }\r\n      var lnk = options.ghMentionsLink.replace(/\\{u}/g, username);\r\n      return st + '<a href=\"' + lnk + '\">' + mentions + '</a>';\r\n    });\r\n  }\r\n\r\n  text = globals.converter._dispatch('anchors.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n// url allowed chars [a-z\\d_.~:/?#[]@!$&'()*+,;=-]\r\n\r\nvar simpleURLRegex  = /\\b(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+\\.[^'\">\\s]+)()(?=\\s|$)(?![\"<>])/gi,\r\n    simpleURLRegex2 = /\\b(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+\\.[^'\">\\s]+?)([.!?,()\\[\\]]?)(?=\\s|$)(?![\"<>])/gi,\r\n    //simpleURLRegex3 = /\\b(((https?|ftp):\\/\\/|www\\.)[a-z\\d.-]+\\.[a-z\\d_.~:/?#\\[\\]@!$&'()*+,;=-]+?)([.!?()]?)(?=\\s|$)(?![\"<>])/gi,\r\n    delimUrlRegex   = /<(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+)()>/gi,\r\n    simpleMailRegex = /(^|\\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)(?=$|\\s)/gmi,\r\n    delimMailRegex  = /<()(?:mailto:)?([-.\\w]+@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi,\r\n\r\n    replaceLink = function (options) {\r\n      'use strict';\r\n\r\n      return function (wm, link, m2, m3, trailingPunctuation) {\r\n        var lnkTxt = link,\r\n            append = '',\r\n            target = '';\r\n        if (/^www\\./i.test(link)) {\r\n          link = link.replace(/^www\\./i, 'http://www.');\r\n        }\r\n        if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {\r\n          append = trailingPunctuation;\r\n        }\r\n        if (options.openLinksInNewWindow) {\r\n          target = ' target=\"E95Eblank\"';\r\n        }\r\n        return '<a href=\"' + link + '\"' + target + '>' + lnkTxt + '</a>' + append;\r\n      };\r\n    },\r\n\r\n    replaceMail = function (options, globals) {\r\n      'use strict';\r\n      return function (wholeMatch, b, mail) {\r\n        var href = 'mailto:';\r\n        b = b || '';\r\n        mail = showdown.subParser('unescapeSpecialChars')(mail, options, globals);\r\n        if (options.encodeEmails) {\r\n          href = showdown.helper.encodeEmailAddress(href + mail);\r\n          mail = showdown.helper.encodeEmailAddress(mail);\r\n        } else {\r\n          href = href + mail;\r\n        }\r\n        return b + '<a href=\"' + href + '\">' + mail + '</a>';\r\n      };\r\n    };\r\n\r\nshowdown.subParser('autoLinks', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('autoLinks.before', text, options, globals);\r\n\r\n  text = text.replace(delimUrlRegex, replaceLink(options));\r\n  text = text.replace(delimMailRegex, replaceMail(options, globals));\r\n\r\n  text = globals.converter._dispatch('autoLinks.after', text, options, globals);\r\n\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('simplifiedAutoLinks', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  if (!options.simplifiedAutoLink) {\r\n    return text;\r\n  }\r\n\r\n  text = globals.converter._dispatch('simplifiedAutoLinks.before', text, options, globals);\r\n\r\n  if (options.excludeTrailingPunctuationFromURLs) {\r\n    text = text.replace(simpleURLRegex2, replaceLink(options));\r\n  } else {\r\n    text = text.replace(simpleURLRegex, replaceLink(options));\r\n  }\r\n  text = text.replace(simpleMailRegex, replaceMail(options, globals));\r\n\r\n  text = globals.converter._dispatch('simplifiedAutoLinks.after', text, options, globals);\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * These are all the transformations that form block-level\r\n * tags like paragraphs, headers, and list items.\r\n */\r\nshowdown.subParser('blockGamut', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('blockGamut.before', text, options, globals);\r\n\r\n  // we parse blockquotes first so that we can have headings and hrs\r\n  // inside blockquotes\r\n  text = showdown.subParser('blockQuotes')(text, options, globals);\r\n  text = showdown.subParser('headers')(text, options, globals);\r\n\r\n  // Do Horizontal Rules:\r\n  text = showdown.subParser('horizontalRule')(text, options, globals);\r\n\r\n  text = showdown.subParser('lists')(text, options, globals);\r\n  text = showdown.subParser('codeBlocks')(text, options, globals);\r\n  text = showdown.subParser('tables')(text, options, globals);\r\n\r\n  // We already ran _HashHTMLBlocks() before, in Markdown(), but that\r\n  // was to escape raw HTML in the original Markdown source. This time,\r\n  // we're escaping the markup we've just created, so that we don't wrap\r\n  // <p> tags around block-level tags.\r\n  text = showdown.subParser('hashHTMLBlocks')(text, options, globals);\r\n  text = showdown.subParser('paragraphs')(text, options, globals);\r\n\r\n  text = globals.converter._dispatch('blockGamut.after', text, options, globals);\r\n\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('blockQuotes', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('blockQuotes.before', text, options, globals);\r\n\r\n  text = text.replace(/((^ {0,3}>[ \\t]?.+\\n(.+\\n)*\\n*)+)/gm, function (wholeMatch, m1) {\r\n    var bq = m1;\r\n\r\n    // attacklab: hack around Konqueror 3.5.4 bug:\r\n    // \"----------bug\".replace(/^-/g,\"\") == \"bug\"\r\n    bq = bq.replace(/^[ \\t]*>[ \\t]?/gm, '0'); // trim one level of quoting\r\n\r\n    // attacklab: clean up hack\r\n    bq = bq.replace(/0/g, '');\r\n\r\n    bq = bq.replace(/^[ \\t]+$/gm, ''); // trim whitespace-only lines\r\n    bq = showdown.subParser('githubCodeBlocks')(bq, options, globals);\r\n    bq = showdown.subParser('blockGamut')(bq, options, globals); // recurse\r\n\r\n    bq = bq.replace(/(^|\\n)/g, '$1  ');\r\n    // These leading spaces screw with <pre> content, so we need to fix that:\r\n    bq = bq.replace(/(\\s*<pre>[^\\r]+?<\\/pre>)/gm, function (wholeMatch, m1) {\r\n      var pre = m1;\r\n      // attacklab: hack around Konqueror 3.5.4 bug:\r\n      pre = pre.replace(/^  /mg, '0');\r\n      pre = pre.replace(/0/g, '');\r\n      return pre;\r\n    });\r\n\r\n    return showdown.subParser('hashBlock')('<blockquote>\\n' + bq + '\\n</blockquote>', options, globals);\r\n  });\r\n\r\n  text = globals.converter._dispatch('blockQuotes.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Process Markdown `<pre><code>` blocks.\r\n */\r\nshowdown.subParser('codeBlocks', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('codeBlocks.before', text, options, globals);\r\n\r\n  // sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\r\n  text += '0';\r\n\r\n  var pattern = /(?:\\n\\n|^)((?:(?:[ ]{4}|\\t).*\\n+)+)(\\n*[ ]{0,3}[^ \\t\\n]|(?=0))/g;\r\n  text = text.replace(pattern, function (wholeMatch, m1, m2) {\r\n    var codeblock = m1,\r\n        nextChar = m2,\r\n        end = '\\n';\r\n\r\n    codeblock = showdown.subParser('outdent')(codeblock, options, globals);\r\n    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);\r\n    codeblock = showdown.subParser('detab')(codeblock, options, globals);\r\n    codeblock = codeblock.replace(/^\\n+/g, ''); // trim leading newlines\r\n    codeblock = codeblock.replace(/\\n+$/g, ''); // trim trailing newlines\r\n\r\n    if (options.omitExtraWLInCodeBlocks) {\r\n      end = '';\r\n    }\r\n\r\n    codeblock = '<pre><code>' + codeblock + end + '</code></pre>';\r\n\r\n    return showdown.subParser('hashBlock')(codeblock, options, globals) + nextChar;\r\n  });\r\n\r\n  // strip sentinel\r\n  text = text.replace(/0/, '');\r\n\r\n  text = globals.converter._dispatch('codeBlocks.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n *\r\n *   *  Backtick quotes are used for <code></code> spans.\r\n *\r\n *   *  You can use multiple backticks as the delimiters if you want to\r\n *     include literal backticks in the code span. So, this input:\r\n *\r\n *         Just type ``foo `bar` baz`` at the prompt.\r\n *\r\n *       Will translate to:\r\n *\r\n *         <p>Just type <code>foo `bar` baz</code> at the prompt.</p>\r\n *\r\n *    There's no arbitrary limit to the number of backticks you\r\n *    can use as delimters. If you need three consecutive backticks\r\n *    in your code, use four for delimiters, etc.\r\n *\r\n *  *  You can use spaces to get literal backticks at the edges:\r\n *\r\n *         ... type `` `bar` `` ...\r\n *\r\n *       Turns to:\r\n *\r\n *         ... type <code>`bar`</code> ...\r\n */\r\nshowdown.subParser('codeSpans', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('codeSpans.before', text, options, globals);\r\n\r\n  if (typeof(text) === 'undefined') {\r\n    text = '';\r\n  }\r\n  text = text.replace(/(^|[^\\\\])(`+)([^\\r]*?[^`])\\2(?!`)/gm,\r\n    function (wholeMatch, m1, m2, m3) {\r\n      var c = m3;\r\n      c = c.replace(/^([ \\t]*)/g, '');\t// leading whitespace\r\n      c = c.replace(/[ \\t]*$/g, '');\t// trailing whitespace\r\n      c = showdown.subParser('encodeCode')(c, options, globals);\r\n      return m1 + '<code>' + c + '</code>';\r\n    }\r\n  );\r\n\r\n  text = globals.converter._dispatch('codeSpans.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Convert all tabs to spaces\r\n */\r\nshowdown.subParser('detab', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('detab.before', text, options, globals);\r\n\r\n  // expand first n-1 tabs\r\n  text = text.replace(/\\t(?=\\t)/g, '    '); // g_tab_width\r\n\r\n  // replace the nth with two sentinels\r\n  text = text.replace(/\\t/g, 'AB');\r\n\r\n  // use the sentinel to anchor our regex so it doesn't explode\r\n  text = text.replace(/B(.+?)A/g, function (wholeMatch, m1) {\r\n    var leadingText = m1,\r\n        numSpaces = 4 - leadingText.length % 4;  // g_tab_width\r\n\r\n    // there *must* be a better way to do this:\r\n    for (var i = 0; i < numSpaces; i++) {\r\n      leadingText += ' ';\r\n    }\r\n\r\n    return leadingText;\r\n  });\r\n\r\n  // clean up sentinels\r\n  text = text.replace(/A/g, '    ');  // g_tab_width\r\n  text = text.replace(/B/g, '');\r\n\r\n  text = globals.converter._dispatch('detab.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Smart processing for ampersands and angle brackets that need to be encoded.\r\n */\r\nshowdown.subParser('encodeAmpsAndAngles', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('encodeAmpsAndAngles.before', text, options, globals);\r\n\r\n  // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:\r\n  // http://bumppo.net/projects/amputator/\r\n  text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\\w+);)/g, '&amp;');\r\n\r\n  // Encode naked <'s\r\n  text = text.replace(/<(?![a-z\\/?$!])/gi, '&lt;');\r\n\r\n  // Encode <\r\n  text = text.replace(/</g, '&lt;');\r\n\r\n  // Encode >\r\n  text = text.replace(/>/g, '&gt;');\r\n\r\n  text = globals.converter._dispatch('encodeAmpsAndAngles.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Returns the string, with after processing the following backslash escape sequences.\r\n *\r\n * attacklab: The polite way to do this is with the new escapeCharacters() function:\r\n *\r\n *    text = escapeCharacters(text,\"\\\\\",true);\r\n *    text = escapeCharacters(text,\"`*_{}[]()>#+-.!\",true);\r\n *\r\n * ...but we're sidestepping its use of the (slow) RegExp constructor\r\n * as an optimization for Firefox.  This function gets called a LOT.\r\n */\r\nshowdown.subParser('encodeBackslashEscapes', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('encodeBackslashEscapes.before', text, options, globals);\r\n\r\n  text = text.replace(/\\\\(\\\\)/g, showdown.helper.escapeCharactersCallback);\r\n  text = text.replace(/\\\\([`*_{}\\[\\]()>#+.!~=|-])/g, showdown.helper.escapeCharactersCallback);\r\n\r\n  text = globals.converter._dispatch('encodeBackslashEscapes.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Encode/escape certain characters inside Markdown code runs.\r\n * The point is that in code, these characters are literals,\r\n * and lose their special Markdown meanings.\r\n */\r\nshowdown.subParser('encodeCode', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('encodeCode.before', text, options, globals);\r\n\r\n  // Encode all ampersands; HTML entities are not\r\n  // entities within a Markdown code span.\r\n  text = text\r\n    .replace(/&/g, '&amp;')\r\n  // Do the angle bracket song and dance:\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n  // Now, escape characters that are magic in Markdown:\r\n    .replace(/([*_{}\\[\\]\\\\=~-])/g, showdown.helper.escapeCharactersCallback);\r\n\r\n  text = globals.converter._dispatch('encodeCode.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Within tags -- meaning between < and > -- encode [\\ ` * _ ~ =] so they\r\n * don't conflict with their use in Markdown for code, italics and strong.\r\n */\r\nshowdown.subParser('escapeSpecialCharsWithinTagAttributes', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.before', text, options, globals);\r\n\r\n  // Build a regex to find HTML tags and comments.  See Friedl's\r\n  // \"Mastering Regular Expressions\", 2nd Ed., pp. 200-201.\r\n  var regex = /(<[a-z\\/!$](\"[^\"]*\"|'[^']*'|[^'\">])*>|<!(--.*?--\\s*)+>)/gi;\r\n\r\n  text = text.replace(regex, function (wholeMatch) {\r\n    return wholeMatch\r\n      .replace(/(.)<\\/?code>(?=.)/g, '$1`')\r\n      .replace(/([\\\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);\r\n  });\r\n\r\n  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Handle github codeblocks prior to running HashHTML so that\r\n * HTML contained within the codeblock gets escaped properly\r\n * Example:\r\n * ```ruby\r\n *     def hello_world(x)\r\n *       puts \"Hello, #{x}\"\r\n *     end\r\n * ```\r\n */\r\nshowdown.subParser('githubCodeBlocks', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  // early exit if option is not enabled\r\n  if (!options.ghCodeBlocks) {\r\n    return text;\r\n  }\r\n\r\n  text = globals.converter._dispatch('githubCodeBlocks.before', text, options, globals);\r\n\r\n  text += '0';\r\n\r\n  text = text.replace(/(?:^|\\n)```(.*)\\n([\\s\\S]*?)\\n```/g, function (wholeMatch, language, codeblock) {\r\n    var end = (options.omitExtraWLInCodeBlocks) ? '' : '\\n';\r\n\r\n    // First parse the github code block\r\n    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);\r\n    codeblock = showdown.subParser('detab')(codeblock, options, globals);\r\n    codeblock = codeblock.replace(/^\\n+/g, ''); // trim leading newlines\r\n    codeblock = codeblock.replace(/\\n+$/g, ''); // trim trailing whitespace\r\n\r\n    codeblock = '<pre><code' + (language ? ' class=\"' + language + ' language-' + language + '\"' : '') + '>' + codeblock + end + '</code></pre>';\r\n\r\n    codeblock = showdown.subParser('hashBlock')(codeblock, options, globals);\r\n\r\n    // Since GHCodeblocks can be false positives, we need to\r\n    // store the primitive text and the parsed text in a global var,\r\n    // and then return a token\r\n    return '\\n\\nG' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\\n\\n';\r\n  });\r\n\r\n  // attacklab: strip sentinel\r\n  text = text.replace(/0/, '');\r\n\r\n  return globals.converter._dispatch('githubCodeBlocks.after', text, options, globals);\r\n});\r\n\r\nshowdown.subParser('hashBlock', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('hashBlock.before', text, options, globals);\r\n  text = text.replace(/(^\\n+|\\n+$)/g, '');\r\n  text = '\\n\\nK' + (globals.gHtmlBlocks.push(text) - 1) + 'K\\n\\n';\r\n  text = globals.converter._dispatch('hashBlock.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Hash and escape <code> elements that should not be parsed as markdown\r\n */\r\nshowdown.subParser('hashCodeTags', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('hashCodeTags.before', text, options, globals);\r\n\r\n  var repFunc = function (wholeMatch, match, left, right) {\r\n    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;\r\n    return 'C' + (globals.gHtmlSpans.push(codeblock) - 1) + 'C';\r\n  };\r\n\r\n  // Hash naked <code>\r\n  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '<code\\\\b[^>]*>', '</code>', 'gim');\r\n\r\n  text = globals.converter._dispatch('hashCodeTags.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('hashElement', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  return function (wholeMatch, m1) {\r\n    var blockText = m1;\r\n\r\n    // Undo double lines\r\n    blockText = blockText.replace(/\\n\\n/g, '\\n');\r\n    blockText = blockText.replace(/^\\n/, '');\r\n\r\n    // strip trailing blank lines\r\n    blockText = blockText.replace(/\\n+$/g, '');\r\n\r\n    // Replace the element text with a marker (\"KxK\" where x is its key)\r\n    blockText = '\\n\\nK' + (globals.gHtmlBlocks.push(blockText) - 1) + 'K\\n\\n';\r\n\r\n    return blockText;\r\n  };\r\n});\r\n\r\nshowdown.subParser('hashHTMLBlocks', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('hashHTMLBlocks.before', text, options, globals);\r\n\r\n  var blockTags = [\r\n        'pre',\r\n        'div',\r\n        'h1',\r\n        'h2',\r\n        'h3',\r\n        'h4',\r\n        'h5',\r\n        'h6',\r\n        'blockquote',\r\n        'table',\r\n        'dl',\r\n        'ol',\r\n        'ul',\r\n        'script',\r\n        'noscript',\r\n        'form',\r\n        'fieldset',\r\n        'iframe',\r\n        'math',\r\n        'style',\r\n        'section',\r\n        'header',\r\n        'footer',\r\n        'nav',\r\n        'article',\r\n        'aside',\r\n        'address',\r\n        'audio',\r\n        'canvas',\r\n        'figure',\r\n        'hgroup',\r\n        'output',\r\n        'video',\r\n        'p'\r\n      ],\r\n      repFunc = function (wholeMatch, match, left, right) {\r\n        var txt = wholeMatch;\r\n        // check if this html element is marked as markdown\r\n        // if so, it's contents should be parsed as markdown\r\n        if (left.search(/\\bmarkdown\\b/) !== -1) {\r\n          txt = left + globals.converter.makeHtml(match) + right;\r\n        }\r\n        return '\\n\\nK' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\\n\\n';\r\n      };\r\n\r\n  for (var i = 0; i < blockTags.length; ++i) {\r\n\r\n    var opTagPos,\r\n        rgx1     = new RegExp('^ {0,3}<' + blockTags[i] + '\\\\b[^>]*>', 'im'),\r\n        patLeft  = '<' + blockTags[i] + '\\\\b[^>]*>',\r\n        patRight = '</' + blockTags[i] + '>';\r\n    // 1. Look for the first position of the first opening HTML tag in the text\r\n    while ((opTagPos = showdown.helper.regexIndexOf(text, rgx1)) !== -1) {\r\n      //2. Split the text in that position\r\n      var subTexts = showdown.helper.splitAtIndex(text, opTagPos),\r\n      //3. Match recursively\r\n          newSubText1 = showdown.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, 'im');\r\n\r\n      // prevent an infinite loop\r\n      if (newSubText1 === subTexts[1]) {\r\n        break;\r\n      }\r\n      text = subTexts[0].concat(newSubText1);\r\n    }\r\n  }\r\n  // HR SPECIAL CASE\r\n  text = text.replace(/(\\n {0,3}(<(hr)\\b([^<>])*?\\/?>)[ \\t]*(?=\\n{2,}))/g,\r\n    showdown.subParser('hashElement')(text, options, globals));\r\n\r\n  // Special case for standalone HTML comments\r\n  text = showdown.helper.replaceRecursiveRegExp(text, function (txt) {\r\n    return '\\n\\nK' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\\n\\n';\r\n  }, '^ {0,3}<!--', '-->', 'gm');\r\n\r\n  // PHP and ASP-style processor instructions (<?...?> and <%...%>)\r\n  text = text.replace(/(?:\\n\\n)( {0,3}(?:<([?%])[^\\r]*?\\2>)[ \\t]*(?=\\n{2,}))/g,\r\n    showdown.subParser('hashElement')(text, options, globals));\r\n\r\n  text = globals.converter._dispatch('hashHTMLBlocks.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Hash span elements that should not be parsed as markdown\r\n */\r\nshowdown.subParser('hashHTMLSpans', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('hashHTMLSpans.before', text, options, globals);\r\n\r\n  function hashHTMLSpan (html) {\r\n    return 'C' + (globals.gHtmlSpans.push(html) - 1) + 'C';\r\n  }\r\n\r\n  // Hash Self Closing tags\r\n  text = text.replace(/<[^>]+?\\/>/gi, function (wm) {\r\n    return hashHTMLSpan(wm);\r\n  });\r\n\r\n  // Hash tags without properties\r\n  text = text.replace(/<([^>]+?)>[\\s\\S]*?<\\/\\1>/g, function (wm) {\r\n    return hashHTMLSpan(wm);\r\n  });\r\n\r\n  // Hash tags with properties\r\n  text = text.replace(/<([^>]+?)\\s[^>]+?>[\\s\\S]*?<\\/\\1>/g, function (wm) {\r\n    return hashHTMLSpan(wm);\r\n  });\r\n\r\n  // Hash self closing tags without />\r\n  text = text.replace(/<[^>]+?>/gi, function (wm) {\r\n    return hashHTMLSpan(wm);\r\n  });\r\n\r\n  /*showdown.helper.matchRecursiveRegExp(text, '<code\\\\b[^>]*>', '</code>', 'gi');*/\r\n\r\n  text = globals.converter._dispatch('hashHTMLSpans.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Unhash HTML spans\r\n */\r\nshowdown.subParser('unhashHTMLSpans', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('unhashHTMLSpans.before', text, options, globals);\r\n\r\n  for (var i = 0; i < globals.gHtmlSpans.length; ++i) {\r\n    var repText = globals.gHtmlSpans[i],\r\n        // limiter to prevent infinite loop (assume 10 as limit for recurse)\r\n        limit = 0;\r\n\r\n    while (/C(\\d+)C/.test(repText)) {\r\n      var num = RegExp.$1;\r\n      repText = repText.replace('C' + num + 'C', globals.gHtmlSpans[num]);\r\n      if (limit === 10) {\r\n        break;\r\n      }\r\n      ++limit;\r\n    }\r\n    text = text.replace('C' + i + 'C', repText);\r\n  }\r\n\r\n  text = globals.converter._dispatch('unhashHTMLSpans.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Hash and escape <pre><code> elements that should not be parsed as markdown\r\n */\r\nshowdown.subParser('hashPreCodeTags', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('hashPreCodeTags.before', text, options, globals);\r\n\r\n  var repFunc = function (wholeMatch, match, left, right) {\r\n    // encode html entities\r\n    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;\r\n    return '\\n\\nG' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\\n\\n';\r\n  };\r\n\r\n  // Hash <pre><code>\r\n  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '^ {0,3}<pre\\\\b[^>]*>\\\\s*<code\\\\b[^>]*>', '^ {0,3}</code>\\\\s*</pre>', 'gim');\r\n\r\n  text = globals.converter._dispatch('hashPreCodeTags.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('headers', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('headers.before', text, options, globals);\r\n\r\n  var headerLevelStart = (isNaN(parseInt(options.headerLevelStart))) ? 1 : parseInt(options.headerLevelStart),\r\n      ghHeaderId = options.ghCompatibleHeaderId,\r\n\r\n  // Set text-style headers:\r\n  //\tHeader 1\r\n  //\t========\r\n  //\r\n  //\tHeader 2\r\n  //\t--------\r\n  //\r\n      setextRegexH1 = (options.smoothLivePreview) ? /^(.+)[ \\t]*\\n={2,}[ \\t]*\\n+/gm : /^(.+)[ \\t]*\\n=+[ \\t]*\\n+/gm,\r\n      setextRegexH2 = (options.smoothLivePreview) ? /^(.+)[ \\t]*\\n-{2,}[ \\t]*\\n+/gm : /^(.+)[ \\t]*\\n-+[ \\t]*\\n+/gm;\r\n\r\n  text = text.replace(setextRegexH1, function (wholeMatch, m1) {\r\n\r\n    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),\r\n        hID = (options.noHeaderId) ? '' : ' id=\"' + headerId(m1) + '\"',\r\n        hLevel = headerLevelStart,\r\n        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';\r\n    return showdown.subParser('hashBlock')(hashBlock, options, globals);\r\n  });\r\n\r\n  text = text.replace(setextRegexH2, function (matchFound, m1) {\r\n    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),\r\n        hID = (options.noHeaderId) ? '' : ' id=\"' + headerId(m1) + '\"',\r\n        hLevel = headerLevelStart + 1,\r\n        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';\r\n    return showdown.subParser('hashBlock')(hashBlock, options, globals);\r\n  });\r\n\r\n  // atx-style headers:\r\n  //  # Header 1\r\n  //  ## Header 2\r\n  //  ## Header 2 with closing hashes ##\r\n  //  ...\r\n  //  ###### Header 6\r\n  //\r\n  var atxStyle = (options.requireSpaceBeforeHeadingText) ? /^(#{1,6})[ \\t]+(.+?)[ \\t]*#*\\n+/gm : /^(#{1,6})[ \\t]*(.+?)[ \\t]*#*\\n+/gm;\r\n\r\n  text = text.replace(atxStyle, function (wholeMatch, m1, m2) {\r\n    var hText = m2;\r\n    if (options.customizedHeaderId) {\r\n      hText = m2.replace(/\\s?\\{([^{]+?)}\\s*$/, '');\r\n    }\r\n\r\n    var span = showdown.subParser('spanGamut')(hText, options, globals),\r\n        hID = (options.noHeaderId) ? '' : ' id=\"' + headerId(m2) + '\"',\r\n        hLevel = headerLevelStart - 1 + m1.length,\r\n        header = '<h' + hLevel + hID + '>' + span + '</h' + hLevel + '>';\r\n\r\n    return showdown.subParser('hashBlock')(header, options, globals);\r\n  });\r\n\r\n  function headerId (m) {\r\n    var title;\r\n\r\n    // It is separate from other options to allow combining prefix and customized\r\n    if (options.customizedHeaderId) {\r\n      var match = m.match(/\\{([^{]+?)}\\s*$/);\r\n      if (match && match[1]) {\r\n        m = match[1];\r\n      }\r\n    }\r\n\r\n    // Prefix id to prevent causing inadvertent pre-existing style matches.\r\n    if (showdown.helper.isString(options.prefixHeaderId)) {\r\n      title = options.prefixHeaderId + m;\r\n    } else if (options.prefixHeaderId === true) {\r\n      title = 'section ' + m;\r\n    } else {\r\n      title = m;\r\n    }\r\n\r\n    if (ghHeaderId) {\r\n      title = title\r\n        .replace(/ /g, '-')\r\n        // replace previously escaped chars (&,  and $)\r\n        .replace(/&amp;/g, '')\r\n        .replace(/T/g, '')\r\n        .replace(/D/g, '')\r\n        // replace rest of the chars (&~$ are repeated as they might have been escaped)\r\n        // borrowed from github's redcarpet (some they should produce similar results)\r\n        .replace(/[&+$,\\/:;=?@\"#{}|^~\\[\\]`\\\\*)(%.!'<>]/g, '')\r\n        .toLowerCase();\r\n    } else {\r\n      title = title\r\n        .replace(/[^\\w]/g, '')\r\n        .toLowerCase();\r\n    }\r\n\r\n    if (globals.hashLinkCounts[title]) {\r\n      title = title + '-' + (globals.hashLinkCounts[title]++);\r\n    } else {\r\n      globals.hashLinkCounts[title] = 1;\r\n    }\r\n    return title;\r\n  }\r\n\r\n  text = globals.converter._dispatch('headers.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Turn Markdown link shortcuts into XHTML <a> tags.\r\n */\r\nshowdown.subParser('horizontalRule', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('horizontalRule.before', text, options, globals);\r\n\r\n  var key = showdown.subParser('hashBlock')('<hr />', options, globals);\r\n  text = text.replace(/^ {0,2}( ?-){3,}[ \\t]*$/gm, key);\r\n  text = text.replace(/^ {0,2}( ?\\*){3,}[ \\t]*$/gm, key);\r\n  text = text.replace(/^ {0,2}( ?_){3,}[ \\t]*$/gm, key);\r\n\r\n  text = globals.converter._dispatch('horizontalRule.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Turn Markdown image shortcuts into <img> tags.\r\n */\r\nshowdown.subParser('images', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('images.before', text, options, globals);\r\n\r\n  var inlineRegExp      = /!\\[([^\\]]*?)][ \\t]*()\\([ \\t]?<?([\\S]+?(?:\\([\\S]*?\\)[\\S]*?)?)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*(?:([\"'])([^\"]*?)\\6)?[ \\t]?\\)/g,\r\n      crazyRegExp       = /!\\[([^\\]]*?)][ \\t]*()\\([ \\t]?<([^>]*)>(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*(?:(?:([\"'])([^\"]*?)\\6))?[ \\t]?\\)/g,\r\n      referenceRegExp   = /!\\[([^\\]]*?)] ?(?:\\n *)?\\[(.*?)]()()()()()/g,\r\n      refShortcutRegExp = /!\\[([^\\[\\]]+)]()()()()()/g;\r\n\r\n  function writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title) {\r\n\r\n    var gUrls   = globals.gUrls,\r\n        gTitles = globals.gTitles,\r\n        gDims   = globals.gDimensions;\r\n\r\n    linkId = linkId.toLowerCase();\r\n\r\n    if (!title) {\r\n      title = '';\r\n    }\r\n    // Special case for explicit empty url\r\n    if (wholeMatch.search(/\\(<?\\s*>? ?(['\"].*['\"])?\\)$/m) > -1) {\r\n      url = '';\r\n\r\n    } else if (url === '' || url === null) {\r\n      if (linkId === '' || linkId === null) {\r\n        // lower-case and turn embedded newlines into spaces\r\n        linkId = altText.toLowerCase().replace(/ ?\\n/g, ' ');\r\n      }\r\n      url = '#' + linkId;\r\n\r\n      if (!showdown.helper.isUndefined(gUrls[linkId])) {\r\n        url = gUrls[linkId];\r\n        if (!showdown.helper.isUndefined(gTitles[linkId])) {\r\n          title = gTitles[linkId];\r\n        }\r\n        if (!showdown.helper.isUndefined(gDims[linkId])) {\r\n          width = gDims[linkId].width;\r\n          height = gDims[linkId].height;\r\n        }\r\n      } else {\r\n        return wholeMatch;\r\n      }\r\n    }\r\n\r\n    altText = altText\r\n      .replace(/\"/g, '&quot;')\r\n    //altText = showdown.helper.escapeCharacters(altText, '*_', false);\r\n      .replace(showdown.helper.regexes.asteriskAndDash, showdown.helper.escapeCharactersCallback);\r\n    //url = showdown.helper.escapeCharacters(url, '*_', false);\r\n    url = url.replace(showdown.helper.regexes.asteriskAndDash, showdown.helper.escapeCharactersCallback);\r\n    var result = '<img src=\"' + url + '\" alt=\"' + altText + '\"';\r\n\r\n    if (title) {\r\n      title = title\r\n        .replace(/\"/g, '&quot;')\r\n      //title = showdown.helper.escapeCharacters(title, '*_', false);\r\n        .replace(showdown.helper.regexes.asteriskAndDash, showdown.helper.escapeCharactersCallback);\r\n      result += ' title=\"' + title + '\"';\r\n    }\r\n\r\n    if (width && height) {\r\n      width  = (width === '*') ? 'auto' : width;\r\n      height = (height === '*') ? 'auto' : height;\r\n\r\n      result += ' width=\"' + width + '\"';\r\n      result += ' height=\"' + height + '\"';\r\n    }\r\n\r\n    result += ' />';\r\n\r\n    return result;\r\n  }\r\n\r\n  // First, handle reference-style labeled images: ![alt text][id]\r\n  text = text.replace(referenceRegExp, writeImageTag);\r\n\r\n  // Next, handle inline images:  ![alt text](url =<width>x<height> \"optional title\")\r\n  // cases with crazy urls like ./image/cat1).png\r\n  text = text.replace(crazyRegExp, writeImageTag);\r\n\r\n  // normal cases\r\n  text = text.replace(inlineRegExp, writeImageTag);\r\n\r\n  // handle reference-style shortcuts: |[img text]\r\n  text = text.replace(refShortcutRegExp, writeImageTag);\r\n\r\n  text = globals.converter._dispatch('images.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('italicsAndBold', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('italicsAndBold.before', text, options, globals);\r\n\r\n  // it's faster to have 3 separate regexes for each case than have just one\r\n  // because of backtracing, in some cases, it could lead to an exponential effect\r\n  // called \"catastrophic backtrace\". Ominous!\r\n\r\n  function parseInside (txt, left, right) {\r\n    if (options.simplifiedAutoLink) {\r\n      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);\r\n    }\r\n    return left + txt + right;\r\n  }\r\n\r\n  // Parse underscores\r\n  if (options.literalMidWordUnderscores) {\r\n    text = text.replace(/\\b___(\\S[\\s\\S]*)___\\b/g, function (wm, txt) {\r\n      return parseInside (txt, '<strong><em>', '</em></strong>');\r\n    });\r\n    text = text.replace(/\\b__(\\S[\\s\\S]*)__\\b/g, function (wm, txt) {\r\n      return parseInside (txt, '<strong>', '</strong>');\r\n    });\r\n    text = text.replace(/\\b_(\\S[\\s\\S]*?)_\\b/g, function (wm, txt) {\r\n      return parseInside (txt, '<em>', '</em>');\r\n    });\r\n  } else {\r\n    text = text.replace(/___(\\S[\\s\\S]*?)___/g, function (wm, m) {\r\n      return (/\\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;\r\n    });\r\n    text = text.replace(/__(\\S[\\s\\S]*?)__/g, function (wm, m) {\r\n      return (/\\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;\r\n    });\r\n    text = text.replace(/_([^\\s_][\\s\\S]*?)_/g, function (wm, m) {\r\n      // !/^_[^_]/.test(m) - test if it doesn't start with __ (since it seems redundant, we removed it)\r\n      return (/\\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;\r\n    });\r\n  }\r\n\r\n  // Now parse asterisks\r\n  if (options.literalMidWordAsterisks) {\r\n    text = text.trim().replace(/(?:^| +)\\*{3}(\\S[\\s\\S]*?)\\*{3}(?: +|$)/g, function (wm, txt) {\r\n      return parseInside (txt, ' <strong><em>', '</em></strong> ');\r\n    });\r\n    text = text.trim().replace(/(?:^| +)\\*{2}(\\S[\\s\\S]*?)\\*{2}(?: +|$)/g, function (wm, txt) {\r\n      return parseInside (txt, ' <strong>', '</strong> ');\r\n    });\r\n    text = text.trim().replace(/(?:^| +)\\*{1}(\\S[\\s\\S]*?)\\*{1}(?: +|$)/g, function (wm, txt) {\r\n      return parseInside (txt, ' <em>', '</em>' + (wm.slice(-1) === ' ' ? ' ' : ''));\r\n    });\r\n  } else {\r\n    text = text.replace(/\\*\\*\\*(\\S[\\s\\S]*?)\\*\\*\\*/g, function (wm, m) {\r\n      return (/\\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;\r\n    });\r\n    text = text.replace(/\\*\\*(\\S[\\s\\S]*?)\\*\\*/g, function (wm, m) {\r\n      return (/\\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;\r\n    });\r\n    text = text.replace(/\\*([^\\s*][\\s\\S]*?)\\*/g, function (wm, m) {\r\n      // !/^\\*[^*]/.test(m) - test if it doesn't start with ** (since it seems redundant, we removed it)\r\n      return (/\\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;\r\n    });\r\n  }\r\n\r\n\r\n  text = globals.converter._dispatch('italicsAndBold.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Form HTML ordered (numbered) and unordered (bulleted) lists.\r\n */\r\nshowdown.subParser('lists', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('lists.before', text, options, globals);\r\n\r\n  /**\r\n   * Process the contents of a single ordered or unordered list, splitting it\r\n   * into individual list items.\r\n   * @param {string} listStr\r\n   * @param {boolean} trimTrailing\r\n   * @returns {string}\r\n   */\r\n  function processListItems (listStr, trimTrailing) {\r\n    // The $g_list_level global keeps track of when we're inside a list.\r\n    // Each time we enter a list, we increment it; when we leave a list,\r\n    // we decrement. If it's zero, we're not in a list anymore.\r\n    //\r\n    // We do this because when we're not inside a list, we want to treat\r\n    // something like this:\r\n    //\r\n    //    I recommend upgrading to version\r\n    //    8. Oops, now this line is treated\r\n    //    as a sub-list.\r\n    //\r\n    // As a single paragraph, despite the fact that the second line starts\r\n    // with a digit-period-space sequence.\r\n    //\r\n    // Whereas when we're inside a list (or sub-list), that line will be\r\n    // treated as the start of a sub-list. What a kludge, huh? This is\r\n    // an aspect of Markdown's syntax that's hard to parse perfectly\r\n    // without resorting to mind-reading. Perhaps the solution is to\r\n    // change the syntax rules such that sub-lists must start with a\r\n    // starting cardinal number; e.g. \"1.\" or \"a.\".\r\n    globals.gListLevel++;\r\n\r\n    // trim trailing blank lines:\r\n    listStr = listStr.replace(/\\n{2,}$/, '\\n');\r\n\r\n    // attacklab: add sentinel to emulate \\z\r\n    listStr += '0';\r\n\r\n    var rgx = /(\\n)?(^ {0,3})([*+-]|\\d+[.])[ \\t]+((\\[(x|X| )?])?[ \\t]*[^\\r]+?(\\n{1,2}))(?=\\n*(0| {0,3}([*+-]|\\d+[.])[ \\t]+))/gm,\r\n        isParagraphed = (/\\n[ \\t]*\\n(?!0)/.test(listStr));\r\n\r\n    // Since version 1.5, nesting sublists requires 4 spaces (or 1 tab) indentation,\r\n    // which is a syntax breaking change\r\n    // activating this option reverts to old behavior\r\n    if (options.disableForced4SpacesIndentedSublists) {\r\n      rgx = /(\\n)?(^ {0,3})([*+-]|\\d+[.])[ \\t]+((\\[(x|X| )?])?[ \\t]*[^\\r]+?(\\n{1,2}))(?=\\n*(0|\\2([*+-]|\\d+[.])[ \\t]+))/gm;\r\n    }\r\n\r\n    listStr = listStr.replace(rgx, function (wholeMatch, m1, m2, m3, m4, taskbtn, checked) {\r\n      checked = (checked && checked.trim() !== '');\r\n\r\n      var item = showdown.subParser('outdent')(m4, options, globals),\r\n          bulletStyle = '';\r\n\r\n      // Support for github tasklists\r\n      if (taskbtn && options.tasklists) {\r\n        bulletStyle = ' class=\"task-list-item\" style=\"list-style-type: none;\"';\r\n        item = item.replace(/^[ \\t]*\\[(x|X| )?]/m, function () {\r\n          var otp = '<input type=\"checkbox\" disabled style=\"margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;\"';\r\n          if (checked) {\r\n            otp += ' checked';\r\n          }\r\n          otp += '>';\r\n          return otp;\r\n        });\r\n      }\r\n\r\n      // ISSUE #312\r\n      // This input: - - - a\r\n      // causes trouble to the parser, since it interprets it as:\r\n      // <ul><li><li><li>a</li></li></li></ul>\r\n      // instead of:\r\n      // <ul><li>- - a</li></ul>\r\n      // So, to prevent it, we will put a marker (A)in the beginning of the line\r\n      // Kind of hackish/monkey patching, but seems more effective than overcomplicating the list parser\r\n      item = item.replace(/^([-*+]|\\d\\.)[ \\t]+[\\S\\n ]*/g, function (wm2) {\r\n        return 'A' + wm2;\r\n      });\r\n\r\n      // m1 - Leading line or\r\n      // Has a double return (multi paragraph) or\r\n      // Has sublist\r\n      if (m1 || (item.search(/\\n{2,}/) > -1)) {\r\n        item = showdown.subParser('githubCodeBlocks')(item, options, globals);\r\n        item = showdown.subParser('blockGamut')(item, options, globals);\r\n      } else {\r\n        // Recursion for sub-lists:\r\n        item = showdown.subParser('lists')(item, options, globals);\r\n        item = item.replace(/\\n$/, ''); // chomp(item)\r\n        item = showdown.subParser('hashHTMLBlocks')(item, options, globals);\r\n        // Colapse double linebreaks\r\n        item = item.replace(/\\n\\n+/g, '\\n\\n');\r\n        // replace double linebreaks with a placeholder\r\n        item = item.replace(/\\n\\n/g, 'B');\r\n        if (isParagraphed) {\r\n          item = showdown.subParser('paragraphs')(item, options, globals);\r\n        } else {\r\n          item = showdown.subParser('spanGamut')(item, options, globals);\r\n        }\r\n        item = item.replace(/B/g, '\\n\\n');\r\n      }\r\n\r\n      // now we need to remove the marker (A)\r\n      item = item.replace('A', '');\r\n      // we can finally wrap the line in list item tags\r\n      item =  '<li' + bulletStyle + '>' + item + '</li>\\n';\r\n\r\n      return item;\r\n    });\r\n\r\n    // attacklab: strip sentinel\r\n    listStr = listStr.replace(/0/g, '');\r\n\r\n    globals.gListLevel--;\r\n\r\n    if (trimTrailing) {\r\n      listStr = listStr.replace(/\\s+$/, '');\r\n    }\r\n\r\n    return listStr;\r\n  }\r\n\r\n  /**\r\n   * Check and parse consecutive lists (better fix for issue #142)\r\n   * @param {string} list\r\n   * @param {string} listType\r\n   * @param {boolean} trimTrailing\r\n   * @returns {string}\r\n   */\r\n  function parseConsecutiveLists (list, listType, trimTrailing) {\r\n    // check if we caught 2 or more consecutive lists by mistake\r\n    // we use the counterRgx, meaning if listType is UL we look for OL and vice versa\r\n    var olRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?\\d+\\.[ \\t]/gm : /^ {0,3}\\d+\\.[ \\t]/gm,\r\n        ulRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?[*+-][ \\t]/gm : /^ {0,3}[*+-][ \\t]/gm,\r\n        counterRxg = (listType === 'ul') ? olRgx : ulRgx,\r\n        result = '';\r\n\r\n    if (list.search(counterRxg) !== -1) {\r\n      (function parseCL (txt) {\r\n        var pos = txt.search(counterRxg);\r\n        if (pos !== -1) {\r\n          // slice\r\n          result += '\\n<' + listType + '>\\n' + processListItems(txt.slice(0, pos), !!trimTrailing) + '</' + listType + '>\\n';\r\n\r\n          // invert counterType and listType\r\n          listType = (listType === 'ul') ? 'ol' : 'ul';\r\n          counterRxg = (listType === 'ul') ? olRgx : ulRgx;\r\n\r\n          //recurse\r\n          parseCL(txt.slice(pos));\r\n        } else {\r\n          result += '\\n<' + listType + '>\\n' + processListItems(txt, !!trimTrailing) + '</' + listType + '>\\n';\r\n        }\r\n      })(list);\r\n    } else {\r\n      result = '\\n<' + listType + '>\\n' + processListItems(list, !!trimTrailing) + '</' + listType + '>\\n';\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // add sentinel to hack around khtml/safari bug:\r\n  // http://bugs.webkit.org/show_bug.cgi?id=11231\r\n  text += '0';\r\n\r\n  if (globals.gListLevel) {\r\n    text = text.replace(/^(( {0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm,\r\n      function (wholeMatch, list, m2) {\r\n        var listType = (m2.search(/[*+-]/g) > -1) ? 'ul' : 'ol';\r\n        return parseConsecutiveLists(list, listType, true);\r\n      }\r\n    );\r\n  } else {\r\n    text = text.replace(/(\\n\\n|^\\n?)(( {0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm,\r\n      function (wholeMatch, m1, list, m3) {\r\n        var listType = (m3.search(/[*+-]/g) > -1) ? 'ul' : 'ol';\r\n        return parseConsecutiveLists(list, listType, false);\r\n      }\r\n    );\r\n  }\r\n\r\n  // strip sentinel\r\n  text = text.replace(/0/, '');\r\n  text = globals.converter._dispatch('lists.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Remove one level of line-leading tabs or spaces\r\n */\r\nshowdown.subParser('outdent', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('outdent.before', text, options, globals);\r\n\r\n  // attacklab: hack around Konqueror 3.5.4 bug:\r\n  // \"----------bug\".replace(/^-/g,\"\") == \"bug\"\r\n  text = text.replace(/^(\\t|[ ]{1,4})/gm, '0'); // attacklab: g_tab_width\r\n\r\n  // attacklab: clean up hack\r\n  text = text.replace(/0/g, '');\r\n\r\n  text = globals.converter._dispatch('outdent.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n *\r\n */\r\nshowdown.subParser('paragraphs', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('paragraphs.before', text, options, globals);\r\n  // Strip leading and trailing lines:\r\n  text = text.replace(/^\\n+/g, '');\r\n  text = text.replace(/\\n+$/g, '');\r\n\r\n  var grafs = text.split(/\\n{2,}/g),\r\n      grafsOut = [],\r\n      end = grafs.length; // Wrap <p> tags\r\n\r\n  for (var i = 0; i < end; i++) {\r\n    var str = grafs[i];\r\n    // if this is an HTML marker, copy it\r\n    if (str.search(/(K|G)(\\d+)\\1/g) >= 0) {\r\n      grafsOut.push(str);\r\n\r\n    // test for presence of characters to prevent empty lines being parsed\r\n    // as paragraphs (resulting in undesired extra empty paragraphs)\r\n    } else if (str.search(/\\S/) >= 0) {\r\n      str = showdown.subParser('spanGamut')(str, options, globals);\r\n      str = str.replace(/^([ \\t]*)/g, '<p>');\r\n      str += '</p>';\r\n      grafsOut.push(str);\r\n    }\r\n  }\r\n\r\n  /** Unhashify HTML blocks */\r\n  end = grafsOut.length;\r\n  for (i = 0; i < end; i++) {\r\n    var blockText = '',\r\n        grafsOutIt = grafsOut[i],\r\n        codeFlag = false;\r\n    // if this is a marker for an html block...\r\n    // use RegExp.test instead of string.search because of QML bug\r\n    while (/(K|G)(\\d+)\\1/.test(grafsOutIt)) {\r\n      var delim = RegExp.$1,\r\n          num   = RegExp.$2;\r\n\r\n      if (delim === 'K') {\r\n        blockText = globals.gHtmlBlocks[num];\r\n      } else {\r\n        // we need to check if ghBlock is a false positive\r\n        if (codeFlag) {\r\n          // use encoded version of all text\r\n          blockText = showdown.subParser('encodeCode')(globals.ghCodeBlocks[num].text, options, globals);\r\n        } else {\r\n          blockText = globals.ghCodeBlocks[num].codeblock;\r\n        }\r\n      }\r\n      blockText = blockText.replace(/\\$/g, '$$$$'); // Escape any dollar signs\r\n\r\n      grafsOutIt = grafsOutIt.replace(/(\\n\\n)?(K|G)\\d+\\2(\\n\\n)?/, blockText);\r\n      // Check if grafsOutIt is a pre->code\r\n      if (/^<pre\\b[^>]*>\\s*<code\\b[^>]*>/.test(grafsOutIt)) {\r\n        codeFlag = true;\r\n      }\r\n    }\r\n    grafsOut[i] = grafsOutIt;\r\n  }\r\n  text = grafsOut.join('\\n');\r\n  // Strip leading and trailing lines:\r\n  text = text.replace(/^\\n+/g, '');\r\n  text = text.replace(/\\n+$/g, '');\r\n  return globals.converter._dispatch('paragraphs.after', text, options, globals);\r\n});\r\n\r\n/**\r\n * Run extension\r\n */\r\nshowdown.subParser('runExtension', function (ext, text, options, globals) {\r\n  'use strict';\r\n\r\n  if (ext.filter) {\r\n    text = ext.filter(text, globals.converter, options);\r\n\r\n  } else if (ext.regex) {\r\n    // TODO remove this when old extension loading mechanism is deprecated\r\n    var re = ext.regex;\r\n    if (!(re instanceof RegExp)) {\r\n      re = new RegExp(re, 'g');\r\n    }\r\n    text = text.replace(re, ext.replace);\r\n  }\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * These are all the transformations that occur *within* block-level\r\n * tags like paragraphs, headers, and list items.\r\n */\r\nshowdown.subParser('spanGamut', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('spanGamut.before', text, options, globals);\r\n  text = showdown.subParser('codeSpans')(text, options, globals);\r\n  text = showdown.subParser('escapeSpecialCharsWithinTagAttributes')(text, options, globals);\r\n  text = showdown.subParser('encodeBackslashEscapes')(text, options, globals);\r\n\r\n  // Process anchor and image tags. Images must come first,\r\n  // because ![foo][f] looks like an anchor.\r\n  text = showdown.subParser('images')(text, options, globals);\r\n  text = showdown.subParser('anchors')(text, options, globals);\r\n\r\n  // Make links out of things like `<http://example.com/>`\r\n  // Must come after anchors, because you can use < and >\r\n  // delimiters in inline links like [this](<url>).\r\n  text = showdown.subParser('autoLinks')(text, options, globals);\r\n  text = showdown.subParser('italicsAndBold')(text, options, globals);\r\n  text = showdown.subParser('strikethrough')(text, options, globals);\r\n  text = showdown.subParser('simplifiedAutoLinks')(text, options, globals);\r\n\r\n  // we need to hash HTML tags inside spans\r\n  text = showdown.subParser('hashHTMLSpans')(text, options, globals);\r\n\r\n  // now we encode amps and angles\r\n  text = showdown.subParser('encodeAmpsAndAngles')(text, options, globals);\r\n\r\n  // Do hard breaks\r\n  if (options.simpleLineBreaks) {\r\n    // GFM style hard breaks\r\n    text = text.replace(/\\n/g, '<br />\\n');\r\n  } else {\r\n    // Vanilla hard breaks\r\n    text = text.replace(/  +\\n/g, '<br />\\n');\r\n  }\r\n\r\n  text = globals.converter._dispatch('spanGamut.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('strikethrough', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  function parseInside (txt) {\r\n    if (options.simplifiedAutoLink) {\r\n      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);\r\n    }\r\n    return '<del>' + txt + '</del>';\r\n  }\r\n\r\n  if (options.strikethrough) {\r\n    text = globals.converter._dispatch('strikethrough.before', text, options, globals);\r\n    text = text.replace(/(?:~){2}([\\s\\S]+?)(?:~){2}/g, function (wm, txt) { return parseInside(txt); });\r\n    text = globals.converter._dispatch('strikethrough.after', text, options, globals);\r\n  }\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * Strips link definitions from text, stores the URLs and titles in\r\n * hash references.\r\n * Link defs are in the form: ^[id]: url \"optional title\"\r\n */\r\nshowdown.subParser('stripLinkDefinitions', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  var regex = /^ {0,3}\\[(.+)]:[ \\t]*\\n?[ \\t]*<?([^>\\s]+)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"|'(](.+?)[\"|')][ \\t]*)?(?:\\n+|(?=0))/gm;\r\n\r\n  // attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\r\n  text += '0';\r\n\r\n  text = text.replace(regex, function (wholeMatch, linkId, url, width, height, blankLines, title) {\r\n    linkId = linkId.toLowerCase();\r\n    globals.gUrls[linkId] = showdown.subParser('encodeAmpsAndAngles')(url, options, globals);  // Link IDs are case-insensitive\r\n\r\n    if (blankLines) {\r\n      // Oops, found blank lines, so it's not a title.\r\n      // Put back the parenthetical statement we stole.\r\n      return blankLines + title;\r\n\r\n    } else {\r\n      if (title) {\r\n        globals.gTitles[linkId] = title.replace(/\"|'/g, '&quot;');\r\n      }\r\n      if (options.parseImgDimensions && width && height) {\r\n        globals.gDimensions[linkId] = {\r\n          width:  width,\r\n          height: height\r\n        };\r\n      }\r\n    }\r\n    // Completely remove the definition from the text\r\n    return '';\r\n  });\r\n\r\n  // attacklab: strip sentinel\r\n  text = text.replace(/0/, '');\r\n\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('tables', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  if (!options.tables) {\r\n    return text;\r\n  }\r\n\r\n  var tableRgx = /^ {0,3}\\|?.+\\|.+\\n[ \\t]{0,3}\\|?[ \\t]*:?[ \\t]*(?:-|=){2,}[ \\t]*:?[ \\t]*\\|[ \\t]*:?[ \\t]*(?:-|=){2,}[\\s\\S]+?(?:\\n\\n|0)/gm;\r\n\r\n  function parseStyles (sLine) {\r\n    if (/^:[ \\t]*--*$/.test(sLine)) {\r\n      return ' style=\"text-align:left;\"';\r\n    } else if (/^--*[ \\t]*:[ \\t]*$/.test(sLine)) {\r\n      return ' style=\"text-align:right;\"';\r\n    } else if (/^:[ \\t]*--*[ \\t]*:$/.test(sLine)) {\r\n      return ' style=\"text-align:center;\"';\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n\r\n  function parseHeaders (header, style) {\r\n    var id = '';\r\n    header = header.trim();\r\n    if (options.tableHeaderId) {\r\n      id = ' id=\"' + header.replace(/ /g, '_').toLowerCase() + '\"';\r\n    }\r\n    header = showdown.subParser('spanGamut')(header, options, globals);\r\n\r\n    return '<th' + id + style + '>' + header + '</th>\\n';\r\n  }\r\n\r\n  function parseCells (cell, style) {\r\n    var subText = showdown.subParser('spanGamut')(cell, options, globals);\r\n    return '<td' + style + '>' + subText + '</td>\\n';\r\n  }\r\n\r\n  function buildTable (headers, cells) {\r\n    var tb = '<table>\\n<thead>\\n<tr>\\n',\r\n        tblLgn = headers.length;\r\n\r\n    for (var i = 0; i < tblLgn; ++i) {\r\n      tb += headers[i];\r\n    }\r\n    tb += '</tr>\\n</thead>\\n<tbody>\\n';\r\n\r\n    for (i = 0; i < cells.length; ++i) {\r\n      tb += '<tr>\\n';\r\n      for (var ii = 0; ii < tblLgn; ++ii) {\r\n        tb += cells[i][ii];\r\n      }\r\n      tb += '</tr>\\n';\r\n    }\r\n    tb += '</tbody>\\n</table>\\n';\r\n    return tb;\r\n  }\r\n\r\n  text = globals.converter._dispatch('tables.before', text, options, globals);\r\n\r\n  // find escaped pipe characters\r\n  text = text.replace(/\\\\(\\|)/g, showdown.helper.escapeCharactersCallback);\r\n\r\n  // parse tables\r\n  text = text.replace(tableRgx, function (rawTable) {\r\n\r\n    var i, tableLines = rawTable.split('\\n');\r\n\r\n    // strip wrong first and last column if wrapped tables are used\r\n    for (i = 0; i < tableLines.length; ++i) {\r\n      if (/^ {0,3}\\|/.test(tableLines[i])) {\r\n        tableLines[i] = tableLines[i].replace(/^ {0,3}\\|/, '');\r\n      }\r\n      if (/\\|[ \\t]*$/.test(tableLines[i])) {\r\n        tableLines[i] = tableLines[i].replace(/\\|[ \\t]*$/, '');\r\n      }\r\n    }\r\n\r\n    var rawHeaders = tableLines[0].split('|').map(function (s) { return s.trim();}),\r\n        rawStyles = tableLines[1].split('|').map(function (s) { return s.trim();}),\r\n        rawCells = [],\r\n        headers = [],\r\n        styles = [],\r\n        cells = [];\r\n\r\n    tableLines.shift();\r\n    tableLines.shift();\r\n\r\n    for (i = 0; i < tableLines.length; ++i) {\r\n      if (tableLines[i].trim() === '') {\r\n        continue;\r\n      }\r\n      rawCells.push(\r\n        tableLines[i]\r\n          .split('|')\r\n          .map(function (s) {\r\n            return s.trim();\r\n          })\r\n      );\r\n    }\r\n\r\n    if (rawHeaders.length < rawStyles.length) {\r\n      return rawTable;\r\n    }\r\n\r\n    for (i = 0; i < rawStyles.length; ++i) {\r\n      styles.push(parseStyles(rawStyles[i]));\r\n    }\r\n\r\n    for (i = 0; i < rawHeaders.length; ++i) {\r\n      if (showdown.helper.isUndefined(styles[i])) {\r\n        styles[i] = '';\r\n      }\r\n      headers.push(parseHeaders(rawHeaders[i], styles[i]));\r\n    }\r\n\r\n    for (i = 0; i < rawCells.length; ++i) {\r\n      var row = [];\r\n      for (var ii = 0; ii < headers.length; ++ii) {\r\n        if (showdown.helper.isUndefined(rawCells[i][ii])) {\r\n\r\n        }\r\n        row.push(parseCells(rawCells[i][ii], styles[ii]));\r\n      }\r\n      cells.push(row);\r\n    }\r\n\r\n    return buildTable(headers, cells);\r\n  });\r\n\r\n  text = globals.converter._dispatch('tables.after', text, options, globals);\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * Swap back in all the special characters we've hidden.\r\n */\r\nshowdown.subParser('unescapeSpecialChars', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('unescapeSpecialChars.before', text, options, globals);\r\n\r\n  text = text.replace(/E(\\d+)E/g, function (wholeMatch, m1) {\r\n    var charCodeToReplace = parseInt(m1);\r\n    return String.fromCharCode(charCodeToReplace);\r\n  });\r\n\r\n  text = globals.converter._dispatch('unescapeSpecialChars.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\nvar root = this;\r\n\r\n// CommonJS/nodeJS Loader\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = showdown;\r\n\r\n// AMD Loader\r\n} else if (true) {\r\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\r\n    'use strict';\r\n    return showdown;\r\n  }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n// Regular Browser loader\r\n} else {\r\n  root.showdown = showdown;\r\n}\r\n}).call(this);\r\n\r\n//# sourceMappingURL=showdown.js.map\r\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/103.52962a96060c610519b6.js",";/*! showdown 02-06-2017 */\r\n(function(){\r\n/**\r\n * Created by Tivie on 13-07-2015.\r\n */\r\n\r\nfunction getDefaultOpts (simple) {\r\n  'use strict';\r\n\r\n  var defaultOptions = {\r\n    omitExtraWLInCodeBlocks: {\r\n      defaultValue: false,\r\n      describe: 'Omit the default extra whiteline added to code blocks',\r\n      type: 'boolean'\r\n    },\r\n    noHeaderId: {\r\n      defaultValue: false,\r\n      describe: 'Turn on/off generated header id',\r\n      type: 'boolean'\r\n    },\r\n    prefixHeaderId: {\r\n      defaultValue: false,\r\n      describe: 'Specify a prefix to generated header ids',\r\n      type: 'string'\r\n    },\r\n    ghCompatibleHeaderId: {\r\n      defaultValue: false,\r\n      describe: 'Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)',\r\n      type: 'boolean'\r\n    },\r\n    headerLevelStart: {\r\n      defaultValue: false,\r\n      describe: 'The header blocks level start',\r\n      type: 'integer'\r\n    },\r\n    parseImgDimensions: {\r\n      defaultValue: false,\r\n      describe: 'Turn on/off image dimension parsing',\r\n      type: 'boolean'\r\n    },\r\n    simplifiedAutoLink: {\r\n      defaultValue: false,\r\n      describe: 'Turn on/off GFM autolink style',\r\n      type: 'boolean'\r\n    },\r\n    excludeTrailingPunctuationFromURLs: {\r\n      defaultValue: false,\r\n      describe: 'Excludes trailing punctuation from links generated with autoLinking',\r\n      type: 'boolean'\r\n    },\r\n    literalMidWordUnderscores: {\r\n      defaultValue: false,\r\n      describe: 'Parse midword underscores as literal underscores',\r\n      type: 'boolean'\r\n    },\r\n    literalMidWordAsterisks: {\r\n      defaultValue: false,\r\n      describe: 'Parse midword asterisks as literal asterisks',\r\n      type: 'boolean'\r\n    },\r\n    strikethrough: {\r\n      defaultValue: false,\r\n      describe: 'Turn on/off strikethrough support',\r\n      type: 'boolean'\r\n    },\r\n    tables: {\r\n      defaultValue: false,\r\n      describe: 'Turn on/off tables support',\r\n      type: 'boolean'\r\n    },\r\n    tablesHeaderId: {\r\n      defaultValue: false,\r\n      describe: 'Add an id to table headers',\r\n      type: 'boolean'\r\n    },\r\n    ghCodeBlocks: {\r\n      defaultValue: true,\r\n      describe: 'Turn on/off GFM fenced code blocks support',\r\n      type: 'boolean'\r\n    },\r\n    tasklists: {\r\n      defaultValue: false,\r\n      describe: 'Turn on/off GFM tasklist support',\r\n      type: 'boolean'\r\n    },\r\n    smoothLivePreview: {\r\n      defaultValue: false,\r\n      describe: 'Prevents weird effects in live previews due to incomplete input',\r\n      type: 'boolean'\r\n    },\r\n    smartIndentationFix: {\r\n      defaultValue: false,\r\n      description: 'Tries to smartly fix indentation in es6 strings',\r\n      type: 'boolean'\r\n    },\r\n    disableForced4SpacesIndentedSublists: {\r\n      defaultValue: false,\r\n      description: 'Disables the requirement of indenting nested sublists by 4 spaces',\r\n      type: 'boolean'\r\n    },\r\n    simpleLineBreaks: {\r\n      defaultValue: false,\r\n      description: 'Parses simple line breaks as <br> (GFM Style)',\r\n      type: 'boolean'\r\n    },\r\n    requireSpaceBeforeHeadingText: {\r\n      defaultValue: false,\r\n      description: 'Makes adding a space between `#` and the header text mandatory (GFM Style)',\r\n      type: 'boolean'\r\n    },\r\n    ghMentions: {\r\n      defaultValue: false,\r\n      description: 'Enables github @mentions',\r\n      type: 'boolean'\r\n    },\r\n    ghMentionsLink: {\r\n      defaultValue: 'https://github.com/{u}',\r\n      description: 'Changes the link generated by @mentions. Only applies if ghMentions option is enabled.',\r\n      type: 'string'\r\n    },\r\n    encodeEmails: {\r\n      defaultValue: true,\r\n      description: 'Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities',\r\n      type: 'boolean'\r\n    },\r\n    openLinksInNewWindow: {\r\n      defaultValue: false,\r\n      description: 'Open all links in new windows',\r\n      type: 'boolean'\r\n    }\r\n  };\r\n  if (simple === false) {\r\n    return JSON.parse(JSON.stringify(defaultOptions));\r\n  }\r\n  var ret = {};\r\n  for (var opt in defaultOptions) {\r\n    if (defaultOptions.hasOwnProperty(opt)) {\r\n      ret[opt] = defaultOptions[opt].defaultValue;\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n\r\nfunction allOptionsOn () {\r\n  'use strict';\r\n  var options = getDefaultOpts(true),\r\n      ret = {};\r\n  for (var opt in options) {\r\n    if (options.hasOwnProperty(opt)) {\r\n      ret[opt] = true;\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Created by Tivie on 06-01-2015.\r\n */\r\n\r\n// Private properties\r\nvar showdown = {},\r\n    parsers = {},\r\n    extensions = {},\r\n    globalOptions = getDefaultOpts(true),\r\n    setFlavor = 'vanilla',\r\n    flavor = {\r\n      github: {\r\n        omitExtraWLInCodeBlocks:              true,\r\n        simplifiedAutoLink:                   true,\r\n        excludeTrailingPunctuationFromURLs:   true,\r\n        literalMidWordUnderscores:            true,\r\n        strikethrough:                        true,\r\n        tables:                               true,\r\n        tablesHeaderId:                       true,\r\n        ghCodeBlocks:                         true,\r\n        tasklists:                            true,\r\n        disableForced4SpacesIndentedSublists: true,\r\n        simpleLineBreaks:                     true,\r\n        requireSpaceBeforeHeadingText:        true,\r\n        ghCompatibleHeaderId:                 true,\r\n        ghMentions:                           true\r\n      },\r\n      original: {\r\n        noHeaderId:                           true,\r\n        ghCodeBlocks:                         false\r\n      },\r\n      ghost: {\r\n        omitExtraWLInCodeBlocks:              true,\r\n        parseImgDimensions:                   true,\r\n        simplifiedAutoLink:                   true,\r\n        excludeTrailingPunctuationFromURLs:   true,\r\n        literalMidWordUnderscores:            true,\r\n        strikethrough:                        true,\r\n        tables:                               true,\r\n        tablesHeaderId:                       true,\r\n        ghCodeBlocks:                         true,\r\n        tasklists:                            true,\r\n        smoothLivePreview:                    true,\r\n        simpleLineBreaks:                     true,\r\n        requireSpaceBeforeHeadingText:        true,\r\n        ghMentions:                           false,\r\n        encodeEmails:                         true\r\n      },\r\n      vanilla: getDefaultOpts(true),\r\n      allOn: allOptionsOn()\r\n    };\r\n\r\n/**\r\n * helper namespace\r\n * @type {{}}\r\n */\r\nshowdown.helper = {};\r\n\r\n/**\r\n * TODO LEGACY SUPPORT CODE\r\n * @type {{}}\r\n */\r\nshowdown.extensions = {};\r\n\r\n/**\r\n * Set a global option\r\n * @static\r\n * @param {string} key\r\n * @param {*} value\r\n * @returns {showdown}\r\n */\r\nshowdown.setOption = function (key, value) {\r\n  'use strict';\r\n  globalOptions[key] = value;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Get a global option\r\n * @static\r\n * @param {string} key\r\n * @returns {*}\r\n */\r\nshowdown.getOption = function (key) {\r\n  'use strict';\r\n  return globalOptions[key];\r\n};\r\n\r\n/**\r\n * Get the global options\r\n * @static\r\n * @returns {{}}\r\n */\r\nshowdown.getOptions = function () {\r\n  'use strict';\r\n  return globalOptions;\r\n};\r\n\r\n/**\r\n * Reset global options to the default values\r\n * @static\r\n */\r\nshowdown.resetOptions = function () {\r\n  'use strict';\r\n  globalOptions = getDefaultOpts(true);\r\n};\r\n\r\n/**\r\n * Set the flavor showdown should use as default\r\n * @param {string} name\r\n */\r\nshowdown.setFlavor = function (name) {\r\n  'use strict';\r\n  if (!flavor.hasOwnProperty(name)) {\r\n    throw Error(name + ' flavor was not found');\r\n  }\r\n  showdown.resetOptions();\r\n  var preset = flavor[name];\r\n  setFlavor = name;\r\n  for (var option in preset) {\r\n    if (preset.hasOwnProperty(option)) {\r\n      globalOptions[option] = preset[option];\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Get the currently set flavor\r\n * @returns {string}\r\n */\r\nshowdown.getFlavor = function () {\r\n  'use strict';\r\n  return setFlavor;\r\n};\r\n\r\n/**\r\n * Get the options of a specified flavor. Returns undefined if the flavor was not found\r\n * @param {string} name Name of the flavor\r\n * @returns {{}|undefined}\r\n */\r\nshowdown.getFlavorOptions = function (name) {\r\n  'use strict';\r\n  if (flavor.hasOwnProperty(name)) {\r\n    return flavor[name];\r\n  }\r\n};\r\n\r\n/**\r\n * Get the default options\r\n * @static\r\n * @param {boolean} [simple=true]\r\n * @returns {{}}\r\n */\r\nshowdown.getDefaultOptions = function (simple) {\r\n  'use strict';\r\n  return getDefaultOpts(simple);\r\n};\r\n\r\n/**\r\n * Get or set a subParser\r\n *\r\n * subParser(name)       - Get a registered subParser\r\n * subParser(name, func) - Register a subParser\r\n * @static\r\n * @param {string} name\r\n * @param {function} [func]\r\n * @returns {*}\r\n */\r\nshowdown.subParser = function (name, func) {\r\n  'use strict';\r\n  if (showdown.helper.isString(name)) {\r\n    if (typeof func !== 'undefined') {\r\n      parsers[name] = func;\r\n    } else {\r\n      if (parsers.hasOwnProperty(name)) {\r\n        return parsers[name];\r\n      } else {\r\n        throw Error('SubParser named ' + name + ' not registered!');\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Gets or registers an extension\r\n * @static\r\n * @param {string} name\r\n * @param {object|function=} ext\r\n * @returns {*}\r\n */\r\nshowdown.extension = function (name, ext) {\r\n  'use strict';\r\n\r\n  if (!showdown.helper.isString(name)) {\r\n    throw Error('Extension \\'name\\' must be a string');\r\n  }\r\n\r\n  name = showdown.helper.stdExtName(name);\r\n\r\n  // Getter\r\n  if (showdown.helper.isUndefined(ext)) {\r\n    if (!extensions.hasOwnProperty(name)) {\r\n      throw Error('Extension named ' + name + ' is not registered!');\r\n    }\r\n    return extensions[name];\r\n\r\n    // Setter\r\n  } else {\r\n    // Expand extension if it's wrapped in a function\r\n    if (typeof ext === 'function') {\r\n      ext = ext();\r\n    }\r\n\r\n    // Ensure extension is an array\r\n    if (!showdown.helper.isArray(ext)) {\r\n      ext = [ext];\r\n    }\r\n\r\n    var validExtension = validate(ext, name);\r\n\r\n    if (validExtension.valid) {\r\n      extensions[name] = ext;\r\n    } else {\r\n      throw Error(validExtension.error);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Gets all extensions registered\r\n * @returns {{}}\r\n */\r\nshowdown.getAllExtensions = function () {\r\n  'use strict';\r\n  return extensions;\r\n};\r\n\r\n/**\r\n * Remove an extension\r\n * @param {string} name\r\n */\r\nshowdown.removeExtension = function (name) {\r\n  'use strict';\r\n  delete extensions[name];\r\n};\r\n\r\n/**\r\n * Removes all extensions\r\n */\r\nshowdown.resetExtensions = function () {\r\n  'use strict';\r\n  extensions = {};\r\n};\r\n\r\n/**\r\n * Validate extension\r\n * @param {array} extension\r\n * @param {string} name\r\n * @returns {{valid: boolean, error: string}}\r\n */\r\nfunction validate (extension, name) {\r\n  'use strict';\r\n\r\n  var errMsg = (name) ? 'Error in ' + name + ' extension->' : 'Error in unnamed extension',\r\n      ret = {\r\n        valid: true,\r\n        error: ''\r\n      };\r\n\r\n  if (!showdown.helper.isArray(extension)) {\r\n    extension = [extension];\r\n  }\r\n\r\n  for (var i = 0; i < extension.length; ++i) {\r\n    var baseMsg = errMsg + ' sub-extension ' + i + ': ',\r\n        ext = extension[i];\r\n    if (typeof ext !== 'object') {\r\n      ret.valid = false;\r\n      ret.error = baseMsg + 'must be an object, but ' + typeof ext + ' given';\r\n      return ret;\r\n    }\r\n\r\n    if (!showdown.helper.isString(ext.type)) {\r\n      ret.valid = false;\r\n      ret.error = baseMsg + 'property \"type\" must be a string, but ' + typeof ext.type + ' given';\r\n      return ret;\r\n    }\r\n\r\n    var type = ext.type = ext.type.toLowerCase();\r\n\r\n    // normalize extension type\r\n    if (type === 'language') {\r\n      type = ext.type = 'lang';\r\n    }\r\n\r\n    if (type === 'html') {\r\n      type = ext.type = 'output';\r\n    }\r\n\r\n    if (type !== 'lang' && type !== 'output' && type !== 'listener') {\r\n      ret.valid = false;\r\n      ret.error = baseMsg + 'type ' + type + ' is not recognized. Valid values: \"lang/language\", \"output/html\" or \"listener\"';\r\n      return ret;\r\n    }\r\n\r\n    if (type === 'listener') {\r\n      if (showdown.helper.isUndefined(ext.listeners)) {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '. Extensions of type \"listener\" must have a property called \"listeners\"';\r\n        return ret;\r\n      }\r\n    } else {\r\n      if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + type + ' extensions must define either a \"regex\" property or a \"filter\" method';\r\n        return ret;\r\n      }\r\n    }\r\n\r\n    if (ext.listeners) {\r\n      if (typeof ext.listeners !== 'object') {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '\"listeners\" property must be an object but ' + typeof ext.listeners + ' given';\r\n        return ret;\r\n      }\r\n      for (var ln in ext.listeners) {\r\n        if (ext.listeners.hasOwnProperty(ln)) {\r\n          if (typeof ext.listeners[ln] !== 'function') {\r\n            ret.valid = false;\r\n            ret.error = baseMsg + '\"listeners\" property must be an hash of [event name]: [callback]. listeners.' + ln +\r\n              ' must be a function but ' + typeof ext.listeners[ln] + ' given';\r\n            return ret;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (ext.filter) {\r\n      if (typeof ext.filter !== 'function') {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '\"filter\" must be a function, but ' + typeof ext.filter + ' given';\r\n        return ret;\r\n      }\r\n    } else if (ext.regex) {\r\n      if (showdown.helper.isString(ext.regex)) {\r\n        ext.regex = new RegExp(ext.regex, 'g');\r\n      }\r\n      if (!(ext.regex instanceof RegExp)) {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '\"regex\" property must either be a string or a RegExp object, but ' + typeof ext.regex + ' given';\r\n        return ret;\r\n      }\r\n      if (showdown.helper.isUndefined(ext.replace)) {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '\"regex\" extensions must implement a replace string or function';\r\n        return ret;\r\n      }\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Validate extension\r\n * @param {object} ext\r\n * @returns {boolean}\r\n */\r\nshowdown.validateExtension = function (ext) {\r\n  'use strict';\r\n\r\n  var validateExtension = validate(ext, null);\r\n  if (!validateExtension.valid) {\r\n    console.warn(validateExtension.error);\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * showdownjs helper functions\r\n */\r\n\r\nif (!showdown.hasOwnProperty('helper')) {\r\n  showdown.helper = {};\r\n}\r\n\r\n/**\r\n * Check if var is string\r\n * @static\r\n * @param {string} a\r\n * @returns {boolean}\r\n */\r\nshowdown.helper.isString = function (a) {\r\n  'use strict';\r\n  return (typeof a === 'string' || a instanceof String);\r\n};\r\n\r\n/**\r\n * Check if var is a function\r\n * @static\r\n * @param {*} a\r\n * @returns {boolean}\r\n */\r\nshowdown.helper.isFunction = function (a) {\r\n  'use strict';\r\n  var getType = {};\r\n  return a && getType.toString.call(a) === '[object Function]';\r\n};\r\n\r\n/**\r\n * isArray helper function\r\n * @static\r\n * @param {*} a\r\n * @returns {boolean}\r\n */\r\nshowdown.helper.isArray = function (a) {\r\n  'use strict';\r\n  return a.constructor === Array;\r\n};\r\n\r\n/**\r\n * Check if value is undefined\r\n * @static\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\r\n */\r\nshowdown.helper.isUndefined = function (value) {\r\n  'use strict';\r\n  return typeof value === 'undefined';\r\n};\r\n\r\n/**\r\n * ForEach helper function\r\n * Iterates over Arrays and Objects (own properties only)\r\n * @static\r\n * @param {*} obj\r\n * @param {function} callback Accepts 3 params: 1. value, 2. key, 3. the original array/object\r\n */\r\nshowdown.helper.forEach = function (obj, callback) {\r\n  'use strict';\r\n  // check if obj is defined\r\n  if (showdown.helper.isUndefined(obj)) {\r\n    throw new Error('obj param is required');\r\n  }\r\n\r\n  if (showdown.helper.isUndefined(callback)) {\r\n    throw new Error('callback param is required');\r\n  }\r\n\r\n  if (!showdown.helper.isFunction(callback)) {\r\n    throw new Error('callback param must be a function/closure');\r\n  }\r\n\r\n  if (typeof obj.forEach === 'function') {\r\n    obj.forEach(callback);\r\n  } else if (showdown.helper.isArray(obj)) {\r\n    for (var i = 0; i < obj.length; i++) {\r\n      callback(obj[i], i, obj);\r\n    }\r\n  } else if (typeof (obj) === 'object') {\r\n    for (var prop in obj) {\r\n      if (obj.hasOwnProperty(prop)) {\r\n        callback(obj[prop], prop, obj);\r\n      }\r\n    }\r\n  } else {\r\n    throw new Error('obj does not seem to be an array or an iterable object');\r\n  }\r\n};\r\n\r\n/**\r\n * Standardidize extension name\r\n * @static\r\n * @param {string} s extension name\r\n * @returns {string}\r\n */\r\nshowdown.helper.stdExtName = function (s) {\r\n  'use strict';\r\n  return s.replace(/[_?*+\\/\\\\.^-]/g, '').replace(/\\s/g, '').toLowerCase();\r\n};\r\n\r\nfunction escapeCharactersCallback (wholeMatch, m1) {\r\n  'use strict';\r\n  var charCodeToEscape = m1.charCodeAt(0);\r\n  return 'E' + charCodeToEscape + 'E';\r\n}\r\n\r\n/**\r\n * Callback used to escape characters when passing through String.replace\r\n * @static\r\n * @param {string} wholeMatch\r\n * @param {string} m1\r\n * @returns {string}\r\n */\r\nshowdown.helper.escapeCharactersCallback = escapeCharactersCallback;\r\n\r\n/**\r\n * Escape characters in a string\r\n * @static\r\n * @param {string} text\r\n * @param {string} charsToEscape\r\n * @param {boolean} afterBackslash\r\n * @returns {XML|string|void|*}\r\n */\r\nshowdown.helper.escapeCharacters = function (text, charsToEscape, afterBackslash) {\r\n  'use strict';\r\n  // First we have to escape the escape characters so that\r\n  // we can build a character class out of them\r\n  var regexString = '([' + charsToEscape.replace(/([\\[\\]\\\\])/g, '\\\\$1') + '])';\r\n\r\n  if (afterBackslash) {\r\n    regexString = '\\\\\\\\' + regexString;\r\n  }\r\n\r\n  var regex = new RegExp(regexString, 'g');\r\n  text = text.replace(regex, escapeCharactersCallback);\r\n\r\n  return text;\r\n};\r\n\r\nvar rgxFindMatchPos = function (str, left, right, flags) {\r\n  'use strict';\r\n  var f = flags || '',\r\n      g = f.indexOf('g') > -1,\r\n      x = new RegExp(left + '|' + right, 'g' + f.replace(/g/g, '')),\r\n      l = new RegExp(left, f.replace(/g/g, '')),\r\n      pos = [],\r\n      t, s, m, start, end;\r\n\r\n  do {\r\n    t = 0;\r\n    while ((m = x.exec(str))) {\r\n      if (l.test(m[0])) {\r\n        if (!(t++)) {\r\n          s = x.lastIndex;\r\n          start = s - m[0].length;\r\n        }\r\n      } else if (t) {\r\n        if (!--t) {\r\n          end = m.index + m[0].length;\r\n          var obj = {\r\n            left: {start: start, end: s},\r\n            match: {start: s, end: m.index},\r\n            right: {start: m.index, end: end},\r\n            wholeMatch: {start: start, end: end}\r\n          };\r\n          pos.push(obj);\r\n          if (!g) {\r\n            return pos;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } while (t && (x.lastIndex = s));\r\n\r\n  return pos;\r\n};\r\n\r\n/**\r\n * matchRecursiveRegExp\r\n *\r\n * (c) 2007 Steven Levithan <stevenlevithan.com>\r\n * MIT License\r\n *\r\n * Accepts a string to search, a left and right format delimiter\r\n * as regex patterns, and optional regex flags. Returns an array\r\n * of matches, allowing nested instances of left/right delimiters.\r\n * Use the \"g\" flag to return all matches, otherwise only the\r\n * first is returned. Be careful to ensure that the left and\r\n * right format delimiters produce mutually exclusive matches.\r\n * Backreferences are not supported within the right delimiter\r\n * due to how it is internally combined with the left delimiter.\r\n * When matching strings whose format delimiters are unbalanced\r\n * to the left or right, the output is intentionally as a\r\n * conventional regex library with recursion support would\r\n * produce, e.g. \"<<x>\" and \"<x>>\" both produce [\"x\"] when using\r\n * \"<\" and \">\" as the delimiters (both strings contain a single,\r\n * balanced instance of \"<x>\").\r\n *\r\n * examples:\r\n * matchRecursiveRegExp(\"test\", \"\\\\(\", \"\\\\)\")\r\n * returns: []\r\n * matchRecursiveRegExp(\"<t<<e>><s>>t<>\", \"<\", \">\", \"g\")\r\n * returns: [\"t<<e>><s>\", \"\"]\r\n * matchRecursiveRegExp(\"<div id=\\\"x\\\">test</div>\", \"<div\\\\b[^>]*>\", \"</div>\", \"gi\")\r\n * returns: [\"test\"]\r\n */\r\nshowdown.helper.matchRecursiveRegExp = function (str, left, right, flags) {\r\n  'use strict';\r\n\r\n  var matchPos = rgxFindMatchPos (str, left, right, flags),\r\n      results = [];\r\n\r\n  for (var i = 0; i < matchPos.length; ++i) {\r\n    results.push([\r\n      str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),\r\n      str.slice(matchPos[i].match.start, matchPos[i].match.end),\r\n      str.slice(matchPos[i].left.start, matchPos[i].left.end),\r\n      str.slice(matchPos[i].right.start, matchPos[i].right.end)\r\n    ]);\r\n  }\r\n  return results;\r\n};\r\n\r\n/**\r\n *\r\n * @param {string} str\r\n * @param {string|function} replacement\r\n * @param {string} left\r\n * @param {string} right\r\n * @param {string} flags\r\n * @returns {string}\r\n */\r\nshowdown.helper.replaceRecursiveRegExp = function (str, replacement, left, right, flags) {\r\n  'use strict';\r\n\r\n  if (!showdown.helper.isFunction(replacement)) {\r\n    var repStr = replacement;\r\n    replacement = function () {\r\n      return repStr;\r\n    };\r\n  }\r\n\r\n  var matchPos = rgxFindMatchPos(str, left, right, flags),\r\n      finalStr = str,\r\n      lng = matchPos.length;\r\n\r\n  if (lng > 0) {\r\n    var bits = [];\r\n    if (matchPos[0].wholeMatch.start !== 0) {\r\n      bits.push(str.slice(0, matchPos[0].wholeMatch.start));\r\n    }\r\n    for (var i = 0; i < lng; ++i) {\r\n      bits.push(\r\n        replacement(\r\n          str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),\r\n          str.slice(matchPos[i].match.start, matchPos[i].match.end),\r\n          str.slice(matchPos[i].left.start, matchPos[i].left.end),\r\n          str.slice(matchPos[i].right.start, matchPos[i].right.end)\r\n        )\r\n      );\r\n      if (i < lng - 1) {\r\n        bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));\r\n      }\r\n    }\r\n    if (matchPos[lng - 1].wholeMatch.end < str.length) {\r\n      bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));\r\n    }\r\n    finalStr = bits.join('');\r\n  }\r\n  return finalStr;\r\n};\r\n\r\n/**\r\n * Returns the index within the passed String object of the first occurrence of the specified regex,\r\n * starting the search at fromIndex. Returns -1 if the value is not found.\r\n *\r\n * @param {string} str string to search\r\n * @param {RegExp} regex Regular expression to search\r\n * @param {int} [fromIndex = 0] Index to start the search\r\n * @returns {Number}\r\n * @throws InvalidArgumentError\r\n */\r\nshowdown.helper.regexIndexOf = function (str, regex, fromIndex) {\r\n  'use strict';\r\n  if (!showdown.helper.isString(str)) {\r\n    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';\r\n  }\r\n  if (regex instanceof RegExp === false) {\r\n    throw 'InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp';\r\n  }\r\n  var indexOf = str.substring(fromIndex || 0).search(regex);\r\n  return (indexOf >= 0) ? (indexOf + (fromIndex || 0)) : indexOf;\r\n};\r\n\r\n/**\r\n * Splits the passed string object at the defined index, and returns an array composed of the two substrings\r\n * @param {string} str string to split\r\n * @param {int} index index to split string at\r\n * @returns {[string,string]}\r\n * @throws InvalidArgumentError\r\n */\r\nshowdown.helper.splitAtIndex = function (str, index) {\r\n  'use strict';\r\n  if (!showdown.helper.isString(str)) {\r\n    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';\r\n  }\r\n  return [str.substring(0, index), str.substring(index)];\r\n};\r\n\r\n/**\r\n * Obfuscate an e-mail address through the use of Character Entities,\r\n * transforming ASCII characters into their equivalent decimal or hex entities.\r\n *\r\n * Since it has a random component, subsequent calls to this function produce different results\r\n *\r\n * @param {string} mail\r\n * @returns {string}\r\n */\r\nshowdown.helper.encodeEmailAddress = function (mail) {\r\n  'use strict';\r\n  var encode = [\r\n    function (ch) {\r\n      return '&#' + ch.charCodeAt(0) + ';';\r\n    },\r\n    function (ch) {\r\n      return '&#x' + ch.charCodeAt(0).toString(16) + ';';\r\n    },\r\n    function (ch) {\r\n      return ch;\r\n    }\r\n  ];\r\n\r\n  mail = mail.replace(/./g, function (ch) {\r\n    if (ch === '@') {\r\n      // this *must* be encoded. I insist.\r\n      ch = encode[Math.floor(Math.random() * 2)](ch);\r\n    } else {\r\n      var r = Math.random();\r\n      // roughly 10% raw, 45% hex, 45% dec\r\n      ch = (\r\n        r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch)\r\n      );\r\n    }\r\n    return ch;\r\n  });\r\n\r\n  return mail;\r\n};\r\n\r\n/**\r\n * POLYFILLS\r\n */\r\n// use this instead of builtin is undefined for IE8 compatibility\r\nif (typeof(console) === 'undefined') {\r\n  console = {\r\n    warn: function (msg) {\r\n      'use strict';\r\n      alert(msg);\r\n    },\r\n    log: function (msg) {\r\n      'use strict';\r\n      alert(msg);\r\n    },\r\n    error: function (msg) {\r\n      'use strict';\r\n      throw msg;\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Common regexes.\r\n * We declare some common regexes to improve performance\r\n */\r\nshowdown.helper.regexes = {\r\n  asteriskAndDash: /([*_])/g\r\n};\r\n\r\n/**\r\n * Created by Estevao on 31-05-2015.\r\n */\r\n\r\n/**\r\n * Showdown Converter class\r\n * @class\r\n * @param {object} [converterOptions]\r\n * @returns {Converter}\r\n */\r\nshowdown.Converter = function (converterOptions) {\r\n  'use strict';\r\n\r\n  var\r\n      /**\r\n       * Options used by this converter\r\n       * @private\r\n       * @type {{}}\r\n       */\r\n      options = {},\r\n\r\n      /**\r\n       * Language extensions used by this converter\r\n       * @private\r\n       * @type {Array}\r\n       */\r\n      langExtensions = [],\r\n\r\n      /**\r\n       * Output modifiers extensions used by this converter\r\n       * @private\r\n       * @type {Array}\r\n       */\r\n      outputModifiers = [],\r\n\r\n      /**\r\n       * Event listeners\r\n       * @private\r\n       * @type {{}}\r\n       */\r\n      listeners = {},\r\n\r\n      /**\r\n       * The flavor set in this converter\r\n       */\r\n      setConvFlavor = setFlavor;\r\n\r\n  _constructor();\r\n\r\n  /**\r\n   * Converter constructor\r\n   * @private\r\n   */\r\n  function _constructor () {\r\n    converterOptions = converterOptions || {};\r\n\r\n    for (var gOpt in globalOptions) {\r\n      if (globalOptions.hasOwnProperty(gOpt)) {\r\n        options[gOpt] = globalOptions[gOpt];\r\n      }\r\n    }\r\n\r\n    // Merge options\r\n    if (typeof converterOptions === 'object') {\r\n      for (var opt in converterOptions) {\r\n        if (converterOptions.hasOwnProperty(opt)) {\r\n          options[opt] = converterOptions[opt];\r\n        }\r\n      }\r\n    } else {\r\n      throw Error('Converter expects the passed parameter to be an object, but ' + typeof converterOptions +\r\n      ' was passed instead.');\r\n    }\r\n\r\n    if (options.extensions) {\r\n      showdown.helper.forEach(options.extensions, _parseExtension);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse extension\r\n   * @param {*} ext\r\n   * @param {string} [name='']\r\n   * @private\r\n   */\r\n  function _parseExtension (ext, name) {\r\n\r\n    name = name || null;\r\n    // If it's a string, the extension was previously loaded\r\n    if (showdown.helper.isString(ext)) {\r\n      ext = showdown.helper.stdExtName(ext);\r\n      name = ext;\r\n\r\n      // LEGACY_SUPPORT CODE\r\n      if (showdown.extensions[ext]) {\r\n        console.warn('DEPRECATION WARNING: ' + ext + ' is an old extension that uses a deprecated loading method.' +\r\n          'Please inform the developer that the extension should be updated!');\r\n        legacyExtensionLoading(showdown.extensions[ext], ext);\r\n        return;\r\n      // END LEGACY SUPPORT CODE\r\n\r\n      } else if (!showdown.helper.isUndefined(extensions[ext])) {\r\n        ext = extensions[ext];\r\n\r\n      } else {\r\n        throw Error('Extension \"' + ext + '\" could not be loaded. It was either not found or is not a valid extension.');\r\n      }\r\n    }\r\n\r\n    if (typeof ext === 'function') {\r\n      ext = ext();\r\n    }\r\n\r\n    if (!showdown.helper.isArray(ext)) {\r\n      ext = [ext];\r\n    }\r\n\r\n    var validExt = validate(ext, name);\r\n    if (!validExt.valid) {\r\n      throw Error(validExt.error);\r\n    }\r\n\r\n    for (var i = 0; i < ext.length; ++i) {\r\n      switch (ext[i].type) {\r\n\r\n        case 'lang':\r\n          langExtensions.push(ext[i]);\r\n          break;\r\n\r\n        case 'output':\r\n          outputModifiers.push(ext[i]);\r\n          break;\r\n      }\r\n      if (ext[i].hasOwnProperty('listeners')) {\r\n        for (var ln in ext[i].listeners) {\r\n          if (ext[i].listeners.hasOwnProperty(ln)) {\r\n            listen(ln, ext[i].listeners[ln]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * LEGACY_SUPPORT\r\n   * @param {*} ext\r\n   * @param {string} name\r\n   */\r\n  function legacyExtensionLoading (ext, name) {\r\n    if (typeof ext === 'function') {\r\n      ext = ext(new showdown.Converter());\r\n    }\r\n    if (!showdown.helper.isArray(ext)) {\r\n      ext = [ext];\r\n    }\r\n    var valid = validate(ext, name);\r\n\r\n    if (!valid.valid) {\r\n      throw Error(valid.error);\r\n    }\r\n\r\n    for (var i = 0; i < ext.length; ++i) {\r\n      switch (ext[i].type) {\r\n        case 'lang':\r\n          langExtensions.push(ext[i]);\r\n          break;\r\n        case 'output':\r\n          outputModifiers.push(ext[i]);\r\n          break;\r\n        default:// should never reach here\r\n          throw Error('Extension loader error: Type unrecognized!!!');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Listen to an event\r\n   * @param {string} name\r\n   * @param {function} callback\r\n   */\r\n  function listen (name, callback) {\r\n    if (!showdown.helper.isString(name)) {\r\n      throw Error('Invalid argument in converter.listen() method: name must be a string, but ' + typeof name + ' given');\r\n    }\r\n\r\n    if (typeof callback !== 'function') {\r\n      throw Error('Invalid argument in converter.listen() method: callback must be a function, but ' + typeof callback + ' given');\r\n    }\r\n\r\n    if (!listeners.hasOwnProperty(name)) {\r\n      listeners[name] = [];\r\n    }\r\n    listeners[name].push(callback);\r\n  }\r\n\r\n  function rTrimInputText (text) {\r\n    var rsp = text.match(/^\\s*/)[0].length,\r\n        rgx = new RegExp('^\\\\s{0,' + rsp + '}', 'gm');\r\n    return text.replace(rgx, '');\r\n  }\r\n\r\n  /**\r\n   * Dispatch an event\r\n   * @private\r\n   * @param {string} evtName Event name\r\n   * @param {string} text Text\r\n   * @param {{}} options Converter Options\r\n   * @param {{}} globals\r\n   * @returns {string}\r\n   */\r\n  this._dispatch = function dispatch (evtName, text, options, globals) {\r\n    if (listeners.hasOwnProperty(evtName)) {\r\n      for (var ei = 0; ei < listeners[evtName].length; ++ei) {\r\n        var nText = listeners[evtName][ei](evtName, text, this, options, globals);\r\n        if (nText && typeof nText !== 'undefined') {\r\n          text = nText;\r\n        }\r\n      }\r\n    }\r\n    return text;\r\n  };\r\n\r\n  /**\r\n   * Listen to an event\r\n   * @param {string} name\r\n   * @param {function} callback\r\n   * @returns {showdown.Converter}\r\n   */\r\n  this.listen = function (name, callback) {\r\n    listen(name, callback);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Converts a markdown string into HTML\r\n   * @param {string} text\r\n   * @returns {*}\r\n   */\r\n  this.makeHtml = function (text) {\r\n    //check if text is not falsy\r\n    if (!text) {\r\n      return text;\r\n    }\r\n\r\n    var globals = {\r\n      gHtmlBlocks:     [],\r\n      gHtmlMdBlocks:   [],\r\n      gHtmlSpans:      [],\r\n      gUrls:           {},\r\n      gTitles:         {},\r\n      gDimensions:     {},\r\n      gListLevel:      0,\r\n      hashLinkCounts:  {},\r\n      langExtensions:  langExtensions,\r\n      outputModifiers: outputModifiers,\r\n      converter:       this,\r\n      ghCodeBlocks:    []\r\n    };\r\n\r\n    // This lets us use  trema as an escape char to avoid md5 hashes\r\n    // The choice of character is arbitrary; anything that isn't\r\n    // magic in Markdown will work.\r\n    text = text.replace(//g, 'T');\r\n\r\n    // Replace $ with D\r\n    // RegExp interprets $ as a special character\r\n    // when it's in a replacement string\r\n    text = text.replace(/\\$/g, 'D');\r\n\r\n    // Standardize line endings\r\n    text = text.replace(/\\r\\n/g, '\\n'); // DOS to Unix\r\n    text = text.replace(/\\r/g, '\\n'); // Mac to Unix\r\n\r\n    // Stardardize line spaces (nbsp causes trouble in older browsers and some regex flavors)\r\n    text = text.replace(/\\u00A0/g, ' ');\r\n\r\n    if (options.smartIndentationFix) {\r\n      text = rTrimInputText(text);\r\n    }\r\n\r\n    // Make sure text begins and ends with a couple of newlines:\r\n    text = '\\n\\n' + text + '\\n\\n';\r\n\r\n    // detab\r\n    text = showdown.subParser('detab')(text, options, globals);\r\n\r\n    /**\r\n     * Strip any lines consisting only of spaces and tabs.\r\n     * This makes subsequent regexs easier to write, because we can\r\n     * match consecutive blank lines with /\\n+/ instead of something\r\n     * contorted like /[ \\t]*\\n+/\r\n     */\r\n    text = text.replace(/^[ \\t]+$/mg, '');\r\n\r\n    //run languageExtensions\r\n    showdown.helper.forEach(langExtensions, function (ext) {\r\n      text = showdown.subParser('runExtension')(ext, text, options, globals);\r\n    });\r\n\r\n    // run the sub parsers\r\n    text = showdown.subParser('hashPreCodeTags')(text, options, globals);\r\n    text = showdown.subParser('githubCodeBlocks')(text, options, globals);\r\n    text = showdown.subParser('hashHTMLBlocks')(text, options, globals);\r\n    text = showdown.subParser('hashCodeTags')(text, options, globals);\r\n    text = showdown.subParser('stripLinkDefinitions')(text, options, globals);\r\n    text = showdown.subParser('blockGamut')(text, options, globals);\r\n    text = showdown.subParser('unhashHTMLSpans')(text, options, globals);\r\n    text = showdown.subParser('unescapeSpecialChars')(text, options, globals);\r\n\r\n    // attacklab: Restore dollar signs\r\n    text = text.replace(/D/g, '$$');\r\n\r\n    // attacklab: Restore tremas\r\n    text = text.replace(/T/g, '');\r\n\r\n    // Run output modifiers\r\n    showdown.helper.forEach(outputModifiers, function (ext) {\r\n      text = showdown.subParser('runExtension')(ext, text, options, globals);\r\n    });\r\n\r\n    return text;\r\n  };\r\n\r\n  /**\r\n   * Set an option of this Converter instance\r\n   * @param {string} key\r\n   * @param {*} value\r\n   */\r\n  this.setOption = function (key, value) {\r\n    options[key] = value;\r\n  };\r\n\r\n  /**\r\n   * Get the option of this Converter instance\r\n   * @param {string} key\r\n   * @returns {*}\r\n   */\r\n  this.getOption = function (key) {\r\n    return options[key];\r\n  };\r\n\r\n  /**\r\n   * Get the options of this Converter instance\r\n   * @returns {{}}\r\n   */\r\n  this.getOptions = function () {\r\n    return options;\r\n  };\r\n\r\n  /**\r\n   * Add extension to THIS converter\r\n   * @param {{}} extension\r\n   * @param {string} [name=null]\r\n   */\r\n  this.addExtension = function (extension, name) {\r\n    name = name || null;\r\n    _parseExtension(extension, name);\r\n  };\r\n\r\n  /**\r\n   * Use a global registered extension with THIS converter\r\n   * @param {string} extensionName Name of the previously registered extension\r\n   */\r\n  this.useExtension = function (extensionName) {\r\n    _parseExtension(extensionName);\r\n  };\r\n\r\n  /**\r\n   * Set the flavor THIS converter should use\r\n   * @param {string} name\r\n   */\r\n  this.setFlavor = function (name) {\r\n    if (!flavor.hasOwnProperty(name)) {\r\n      throw Error(name + ' flavor was not found');\r\n    }\r\n    var preset = flavor[name];\r\n    setConvFlavor = name;\r\n    for (var option in preset) {\r\n      if (preset.hasOwnProperty(option)) {\r\n        options[option] = preset[option];\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the currently set flavor of this converter\r\n   * @returns {string}\r\n   */\r\n  this.getFlavor = function () {\r\n    return setConvFlavor;\r\n  };\r\n\r\n  /**\r\n   * Remove an extension from THIS converter.\r\n   * Note: This is a costly operation. It's better to initialize a new converter\r\n   * and specify the extensions you wish to use\r\n   * @param {Array} extension\r\n   */\r\n  this.removeExtension = function (extension) {\r\n    if (!showdown.helper.isArray(extension)) {\r\n      extension = [extension];\r\n    }\r\n    for (var a = 0; a < extension.length; ++a) {\r\n      var ext = extension[a];\r\n      for (var i = 0; i < langExtensions.length; ++i) {\r\n        if (langExtensions[i] === ext) {\r\n          langExtensions[i].splice(i, 1);\r\n        }\r\n      }\r\n      for (var ii = 0; ii < outputModifiers.length; ++i) {\r\n        if (outputModifiers[ii] === ext) {\r\n          outputModifiers[ii].splice(i, 1);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get all extension of THIS converter\r\n   * @returns {{language: Array, output: Array}}\r\n   */\r\n  this.getAllExtensions = function () {\r\n    return {\r\n      language: langExtensions,\r\n      output: outputModifiers\r\n    };\r\n  };\r\n};\r\n\r\n/**\r\n * Turn Markdown link shortcuts into XHTML <a> tags.\r\n */\r\nshowdown.subParser('anchors', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('anchors.before', text, options, globals);\r\n\r\n  var writeAnchorTag = function (wholeMatch, linkText, linkId, url, m5, m6, title) {\r\n    if (showdown.helper.isUndefined(title)) {\r\n      title = '';\r\n    }\r\n    linkId = linkId.toLowerCase();\r\n\r\n    // Special case for explicit empty url\r\n    if (wholeMatch.search(/\\(<?\\s*>? ?(['\"].*['\"])?\\)$/m) > -1) {\r\n      url = '';\r\n    } else if (!url) {\r\n      if (!linkId) {\r\n        // lower-case and turn embedded newlines into spaces\r\n        linkId = linkText.toLowerCase().replace(/ ?\\n/g, ' ');\r\n      }\r\n      url = '#' + linkId;\r\n\r\n      if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {\r\n        url = globals.gUrls[linkId];\r\n        if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {\r\n          title = globals.gTitles[linkId];\r\n        }\r\n      } else {\r\n        return wholeMatch;\r\n      }\r\n    }\r\n\r\n    //url = showdown.helper.escapeCharacters(url, '*_', false); // replaced line to improve performance\r\n    url = url.replace(showdown.helper.regexes.asteriskAndDash, showdown.helper.escapeCharactersCallback);\r\n\r\n    var result = '<a href=\"' + url + '\"';\r\n\r\n    if (title !== '' && title !== null) {\r\n      title = title.replace(/\"/g, '&quot;');\r\n      //title = showdown.helper.escapeCharacters(title, '*_', false); // replaced line to improve performance\r\n      title = title.replace(showdown.helper.regexes.asteriskAndDash, showdown.helper.escapeCharactersCallback);\r\n      result += ' title=\"' + title + '\"';\r\n    }\r\n\r\n    if (options.openLinksInNewWindow) {\r\n      // escaped _\r\n      result += ' target=\"E95Eblank\"';\r\n    }\r\n\r\n    result += '>' + linkText + '</a>';\r\n\r\n    return result;\r\n  };\r\n\r\n  // First, handle reference-style links: [link text] [id]\r\n  text = text.replace(/\\[((?:\\[[^\\]]*]|[^\\[\\]])*)] ?(?:\\n *)?\\[(.*?)]()()()()/g, writeAnchorTag);\r\n\r\n  // Next, inline-style links: [link text](url \"optional title\")\r\n  // cases with crazy urls like ./image/cat1).png\r\n  text = text.replace(/\\[((?:\\[[^\\]]*]|[^\\[\\]])*)]()[ \\t]*\\([ \\t]?<([^>]*)>(?:[ \\t]*(([\"'])([^\"]*?)\\5))?[ \\t]?\\)/g,\r\n    writeAnchorTag);\r\n\r\n  // normal cases\r\n  text = text.replace(/\\[((?:\\[[^\\]]*]|[^\\[\\]])*)]()[ \\t]*\\([ \\t]?<?([\\S]+?(?:\\([\\S]*?\\)[\\S]*?)?)>?(?:[ \\t]*(([\"'])([^\"]*?)\\5))?[ \\t]?\\)/g,\r\n                      writeAnchorTag);\r\n\r\n  // handle reference-style shortcuts: [link text]\r\n  // These must come last in case you've also got [link test][1]\r\n  // or [link test](/foo)\r\n  text = text.replace(/\\[([^\\[\\]]+)]()()()()()/g, writeAnchorTag);\r\n\r\n  // Lastly handle GithubMentions if option is enabled\r\n  if (options.ghMentions) {\r\n    text = text.replace(/(^|\\s)(\\\\)?(@([a-z\\d\\-]+))(?=[.!?;,[\\]()]|\\s|$)/gmi, function (wm, st, escape, mentions, username) {\r\n      if (escape === '\\\\') {\r\n        return st + mentions;\r\n      }\r\n\r\n      //check if options.ghMentionsLink is a string\r\n      if (!showdown.helper.isString(options.ghMentionsLink)) {\r\n        throw new Error('ghMentionsLink option must be a string');\r\n      }\r\n      var lnk = options.ghMentionsLink.replace(/\\{u}/g, username);\r\n      return st + '<a href=\"' + lnk + '\">' + mentions + '</a>';\r\n    });\r\n  }\r\n\r\n  text = globals.converter._dispatch('anchors.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n// url allowed chars [a-z\\d_.~:/?#[]@!$&'()*+,;=-]\r\n\r\nvar simpleURLRegex  = /\\b(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+\\.[^'\">\\s]+)()(?=\\s|$)(?![\"<>])/gi,\r\n    simpleURLRegex2 = /\\b(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+\\.[^'\">\\s]+?)([.!?,()\\[\\]]?)(?=\\s|$)(?![\"<>])/gi,\r\n    //simpleURLRegex3 = /\\b(((https?|ftp):\\/\\/|www\\.)[a-z\\d.-]+\\.[a-z\\d_.~:/?#\\[\\]@!$&'()*+,;=-]+?)([.!?()]?)(?=\\s|$)(?![\"<>])/gi,\r\n    delimUrlRegex   = /<(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+)()>/gi,\r\n    simpleMailRegex = /(^|\\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)(?=$|\\s)/gmi,\r\n    delimMailRegex  = /<()(?:mailto:)?([-.\\w]+@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi,\r\n\r\n    replaceLink = function (options) {\r\n      'use strict';\r\n\r\n      return function (wm, link, m2, m3, trailingPunctuation) {\r\n        var lnkTxt = link,\r\n            append = '',\r\n            target = '';\r\n        if (/^www\\./i.test(link)) {\r\n          link = link.replace(/^www\\./i, 'http://www.');\r\n        }\r\n        if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {\r\n          append = trailingPunctuation;\r\n        }\r\n        if (options.openLinksInNewWindow) {\r\n          target = ' target=\"E95Eblank\"';\r\n        }\r\n        return '<a href=\"' + link + '\"' + target + '>' + lnkTxt + '</a>' + append;\r\n      };\r\n    },\r\n\r\n    replaceMail = function (options, globals) {\r\n      'use strict';\r\n      return function (wholeMatch, b, mail) {\r\n        var href = 'mailto:';\r\n        b = b || '';\r\n        mail = showdown.subParser('unescapeSpecialChars')(mail, options, globals);\r\n        if (options.encodeEmails) {\r\n          href = showdown.helper.encodeEmailAddress(href + mail);\r\n          mail = showdown.helper.encodeEmailAddress(mail);\r\n        } else {\r\n          href = href + mail;\r\n        }\r\n        return b + '<a href=\"' + href + '\">' + mail + '</a>';\r\n      };\r\n    };\r\n\r\nshowdown.subParser('autoLinks', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('autoLinks.before', text, options, globals);\r\n\r\n  text = text.replace(delimUrlRegex, replaceLink(options));\r\n  text = text.replace(delimMailRegex, replaceMail(options, globals));\r\n\r\n  text = globals.converter._dispatch('autoLinks.after', text, options, globals);\r\n\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('simplifiedAutoLinks', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  if (!options.simplifiedAutoLink) {\r\n    return text;\r\n  }\r\n\r\n  text = globals.converter._dispatch('simplifiedAutoLinks.before', text, options, globals);\r\n\r\n  if (options.excludeTrailingPunctuationFromURLs) {\r\n    text = text.replace(simpleURLRegex2, replaceLink(options));\r\n  } else {\r\n    text = text.replace(simpleURLRegex, replaceLink(options));\r\n  }\r\n  text = text.replace(simpleMailRegex, replaceMail(options, globals));\r\n\r\n  text = globals.converter._dispatch('simplifiedAutoLinks.after', text, options, globals);\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * These are all the transformations that form block-level\r\n * tags like paragraphs, headers, and list items.\r\n */\r\nshowdown.subParser('blockGamut', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('blockGamut.before', text, options, globals);\r\n\r\n  // we parse blockquotes first so that we can have headings and hrs\r\n  // inside blockquotes\r\n  text = showdown.subParser('blockQuotes')(text, options, globals);\r\n  text = showdown.subParser('headers')(text, options, globals);\r\n\r\n  // Do Horizontal Rules:\r\n  text = showdown.subParser('horizontalRule')(text, options, globals);\r\n\r\n  text = showdown.subParser('lists')(text, options, globals);\r\n  text = showdown.subParser('codeBlocks')(text, options, globals);\r\n  text = showdown.subParser('tables')(text, options, globals);\r\n\r\n  // We already ran _HashHTMLBlocks() before, in Markdown(), but that\r\n  // was to escape raw HTML in the original Markdown source. This time,\r\n  // we're escaping the markup we've just created, so that we don't wrap\r\n  // <p> tags around block-level tags.\r\n  text = showdown.subParser('hashHTMLBlocks')(text, options, globals);\r\n  text = showdown.subParser('paragraphs')(text, options, globals);\r\n\r\n  text = globals.converter._dispatch('blockGamut.after', text, options, globals);\r\n\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('blockQuotes', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('blockQuotes.before', text, options, globals);\r\n\r\n  text = text.replace(/((^ {0,3}>[ \\t]?.+\\n(.+\\n)*\\n*)+)/gm, function (wholeMatch, m1) {\r\n    var bq = m1;\r\n\r\n    // attacklab: hack around Konqueror 3.5.4 bug:\r\n    // \"----------bug\".replace(/^-/g,\"\") == \"bug\"\r\n    bq = bq.replace(/^[ \\t]*>[ \\t]?/gm, '0'); // trim one level of quoting\r\n\r\n    // attacklab: clean up hack\r\n    bq = bq.replace(/0/g, '');\r\n\r\n    bq = bq.replace(/^[ \\t]+$/gm, ''); // trim whitespace-only lines\r\n    bq = showdown.subParser('githubCodeBlocks')(bq, options, globals);\r\n    bq = showdown.subParser('blockGamut')(bq, options, globals); // recurse\r\n\r\n    bq = bq.replace(/(^|\\n)/g, '$1  ');\r\n    // These leading spaces screw with <pre> content, so we need to fix that:\r\n    bq = bq.replace(/(\\s*<pre>[^\\r]+?<\\/pre>)/gm, function (wholeMatch, m1) {\r\n      var pre = m1;\r\n      // attacklab: hack around Konqueror 3.5.4 bug:\r\n      pre = pre.replace(/^  /mg, '0');\r\n      pre = pre.replace(/0/g, '');\r\n      return pre;\r\n    });\r\n\r\n    return showdown.subParser('hashBlock')('<blockquote>\\n' + bq + '\\n</blockquote>', options, globals);\r\n  });\r\n\r\n  text = globals.converter._dispatch('blockQuotes.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Process Markdown `<pre><code>` blocks.\r\n */\r\nshowdown.subParser('codeBlocks', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('codeBlocks.before', text, options, globals);\r\n\r\n  // sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\r\n  text += '0';\r\n\r\n  var pattern = /(?:\\n\\n|^)((?:(?:[ ]{4}|\\t).*\\n+)+)(\\n*[ ]{0,3}[^ \\t\\n]|(?=0))/g;\r\n  text = text.replace(pattern, function (wholeMatch, m1, m2) {\r\n    var codeblock = m1,\r\n        nextChar = m2,\r\n        end = '\\n';\r\n\r\n    codeblock = showdown.subParser('outdent')(codeblock, options, globals);\r\n    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);\r\n    codeblock = showdown.subParser('detab')(codeblock, options, globals);\r\n    codeblock = codeblock.replace(/^\\n+/g, ''); // trim leading newlines\r\n    codeblock = codeblock.replace(/\\n+$/g, ''); // trim trailing newlines\r\n\r\n    if (options.omitExtraWLInCodeBlocks) {\r\n      end = '';\r\n    }\r\n\r\n    codeblock = '<pre><code>' + codeblock + end + '</code></pre>';\r\n\r\n    return showdown.subParser('hashBlock')(codeblock, options, globals) + nextChar;\r\n  });\r\n\r\n  // strip sentinel\r\n  text = text.replace(/0/, '');\r\n\r\n  text = globals.converter._dispatch('codeBlocks.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n *\r\n *   *  Backtick quotes are used for <code></code> spans.\r\n *\r\n *   *  You can use multiple backticks as the delimiters if you want to\r\n *     include literal backticks in the code span. So, this input:\r\n *\r\n *         Just type ``foo `bar` baz`` at the prompt.\r\n *\r\n *       Will translate to:\r\n *\r\n *         <p>Just type <code>foo `bar` baz</code> at the prompt.</p>\r\n *\r\n *    There's no arbitrary limit to the number of backticks you\r\n *    can use as delimters. If you need three consecutive backticks\r\n *    in your code, use four for delimiters, etc.\r\n *\r\n *  *  You can use spaces to get literal backticks at the edges:\r\n *\r\n *         ... type `` `bar` `` ...\r\n *\r\n *       Turns to:\r\n *\r\n *         ... type <code>`bar`</code> ...\r\n */\r\nshowdown.subParser('codeSpans', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('codeSpans.before', text, options, globals);\r\n\r\n  if (typeof(text) === 'undefined') {\r\n    text = '';\r\n  }\r\n  text = text.replace(/(^|[^\\\\])(`+)([^\\r]*?[^`])\\2(?!`)/gm,\r\n    function (wholeMatch, m1, m2, m3) {\r\n      var c = m3;\r\n      c = c.replace(/^([ \\t]*)/g, '');\t// leading whitespace\r\n      c = c.replace(/[ \\t]*$/g, '');\t// trailing whitespace\r\n      c = showdown.subParser('encodeCode')(c, options, globals);\r\n      return m1 + '<code>' + c + '</code>';\r\n    }\r\n  );\r\n\r\n  text = globals.converter._dispatch('codeSpans.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Convert all tabs to spaces\r\n */\r\nshowdown.subParser('detab', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('detab.before', text, options, globals);\r\n\r\n  // expand first n-1 tabs\r\n  text = text.replace(/\\t(?=\\t)/g, '    '); // g_tab_width\r\n\r\n  // replace the nth with two sentinels\r\n  text = text.replace(/\\t/g, 'AB');\r\n\r\n  // use the sentinel to anchor our regex so it doesn't explode\r\n  text = text.replace(/B(.+?)A/g, function (wholeMatch, m1) {\r\n    var leadingText = m1,\r\n        numSpaces = 4 - leadingText.length % 4;  // g_tab_width\r\n\r\n    // there *must* be a better way to do this:\r\n    for (var i = 0; i < numSpaces; i++) {\r\n      leadingText += ' ';\r\n    }\r\n\r\n    return leadingText;\r\n  });\r\n\r\n  // clean up sentinels\r\n  text = text.replace(/A/g, '    ');  // g_tab_width\r\n  text = text.replace(/B/g, '');\r\n\r\n  text = globals.converter._dispatch('detab.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Smart processing for ampersands and angle brackets that need to be encoded.\r\n */\r\nshowdown.subParser('encodeAmpsAndAngles', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('encodeAmpsAndAngles.before', text, options, globals);\r\n\r\n  // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:\r\n  // http://bumppo.net/projects/amputator/\r\n  text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\\w+);)/g, '&amp;');\r\n\r\n  // Encode naked <'s\r\n  text = text.replace(/<(?![a-z\\/?$!])/gi, '&lt;');\r\n\r\n  // Encode <\r\n  text = text.replace(/</g, '&lt;');\r\n\r\n  // Encode >\r\n  text = text.replace(/>/g, '&gt;');\r\n\r\n  text = globals.converter._dispatch('encodeAmpsAndAngles.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Returns the string, with after processing the following backslash escape sequences.\r\n *\r\n * attacklab: The polite way to do this is with the new escapeCharacters() function:\r\n *\r\n *    text = escapeCharacters(text,\"\\\\\",true);\r\n *    text = escapeCharacters(text,\"`*_{}[]()>#+-.!\",true);\r\n *\r\n * ...but we're sidestepping its use of the (slow) RegExp constructor\r\n * as an optimization for Firefox.  This function gets called a LOT.\r\n */\r\nshowdown.subParser('encodeBackslashEscapes', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('encodeBackslashEscapes.before', text, options, globals);\r\n\r\n  text = text.replace(/\\\\(\\\\)/g, showdown.helper.escapeCharactersCallback);\r\n  text = text.replace(/\\\\([`*_{}\\[\\]()>#+.!~=|-])/g, showdown.helper.escapeCharactersCallback);\r\n\r\n  text = globals.converter._dispatch('encodeBackslashEscapes.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Encode/escape certain characters inside Markdown code runs.\r\n * The point is that in code, these characters are literals,\r\n * and lose their special Markdown meanings.\r\n */\r\nshowdown.subParser('encodeCode', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('encodeCode.before', text, options, globals);\r\n\r\n  // Encode all ampersands; HTML entities are not\r\n  // entities within a Markdown code span.\r\n  text = text\r\n    .replace(/&/g, '&amp;')\r\n  // Do the angle bracket song and dance:\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n  // Now, escape characters that are magic in Markdown:\r\n    .replace(/([*_{}\\[\\]\\\\=~-])/g, showdown.helper.escapeCharactersCallback);\r\n\r\n  text = globals.converter._dispatch('encodeCode.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Within tags -- meaning between < and > -- encode [\\ ` * _ ~ =] so they\r\n * don't conflict with their use in Markdown for code, italics and strong.\r\n */\r\nshowdown.subParser('escapeSpecialCharsWithinTagAttributes', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.before', text, options, globals);\r\n\r\n  // Build a regex to find HTML tags and comments.  See Friedl's\r\n  // \"Mastering Regular Expressions\", 2nd Ed., pp. 200-201.\r\n  var regex = /(<[a-z\\/!$](\"[^\"]*\"|'[^']*'|[^'\">])*>|<!(--.*?--\\s*)+>)/gi;\r\n\r\n  text = text.replace(regex, function (wholeMatch) {\r\n    return wholeMatch\r\n      .replace(/(.)<\\/?code>(?=.)/g, '$1`')\r\n      .replace(/([\\\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);\r\n  });\r\n\r\n  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Handle github codeblocks prior to running HashHTML so that\r\n * HTML contained within the codeblock gets escaped properly\r\n * Example:\r\n * ```ruby\r\n *     def hello_world(x)\r\n *       puts \"Hello, #{x}\"\r\n *     end\r\n * ```\r\n */\r\nshowdown.subParser('githubCodeBlocks', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  // early exit if option is not enabled\r\n  if (!options.ghCodeBlocks) {\r\n    return text;\r\n  }\r\n\r\n  text = globals.converter._dispatch('githubCodeBlocks.before', text, options, globals);\r\n\r\n  text += '0';\r\n\r\n  text = text.replace(/(?:^|\\n)```(.*)\\n([\\s\\S]*?)\\n```/g, function (wholeMatch, language, codeblock) {\r\n    var end = (options.omitExtraWLInCodeBlocks) ? '' : '\\n';\r\n\r\n    // First parse the github code block\r\n    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);\r\n    codeblock = showdown.subParser('detab')(codeblock, options, globals);\r\n    codeblock = codeblock.replace(/^\\n+/g, ''); // trim leading newlines\r\n    codeblock = codeblock.replace(/\\n+$/g, ''); // trim trailing whitespace\r\n\r\n    codeblock = '<pre><code' + (language ? ' class=\"' + language + ' language-' + language + '\"' : '') + '>' + codeblock + end + '</code></pre>';\r\n\r\n    codeblock = showdown.subParser('hashBlock')(codeblock, options, globals);\r\n\r\n    // Since GHCodeblocks can be false positives, we need to\r\n    // store the primitive text and the parsed text in a global var,\r\n    // and then return a token\r\n    return '\\n\\nG' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\\n\\n';\r\n  });\r\n\r\n  // attacklab: strip sentinel\r\n  text = text.replace(/0/, '');\r\n\r\n  return globals.converter._dispatch('githubCodeBlocks.after', text, options, globals);\r\n});\r\n\r\nshowdown.subParser('hashBlock', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('hashBlock.before', text, options, globals);\r\n  text = text.replace(/(^\\n+|\\n+$)/g, '');\r\n  text = '\\n\\nK' + (globals.gHtmlBlocks.push(text) - 1) + 'K\\n\\n';\r\n  text = globals.converter._dispatch('hashBlock.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Hash and escape <code> elements that should not be parsed as markdown\r\n */\r\nshowdown.subParser('hashCodeTags', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('hashCodeTags.before', text, options, globals);\r\n\r\n  var repFunc = function (wholeMatch, match, left, right) {\r\n    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;\r\n    return 'C' + (globals.gHtmlSpans.push(codeblock) - 1) + 'C';\r\n  };\r\n\r\n  // Hash naked <code>\r\n  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '<code\\\\b[^>]*>', '</code>', 'gim');\r\n\r\n  text = globals.converter._dispatch('hashCodeTags.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('hashElement', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  return function (wholeMatch, m1) {\r\n    var blockText = m1;\r\n\r\n    // Undo double lines\r\n    blockText = blockText.replace(/\\n\\n/g, '\\n');\r\n    blockText = blockText.replace(/^\\n/, '');\r\n\r\n    // strip trailing blank lines\r\n    blockText = blockText.replace(/\\n+$/g, '');\r\n\r\n    // Replace the element text with a marker (\"KxK\" where x is its key)\r\n    blockText = '\\n\\nK' + (globals.gHtmlBlocks.push(blockText) - 1) + 'K\\n\\n';\r\n\r\n    return blockText;\r\n  };\r\n});\r\n\r\nshowdown.subParser('hashHTMLBlocks', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('hashHTMLBlocks.before', text, options, globals);\r\n\r\n  var blockTags = [\r\n        'pre',\r\n        'div',\r\n        'h1',\r\n        'h2',\r\n        'h3',\r\n        'h4',\r\n        'h5',\r\n        'h6',\r\n        'blockquote',\r\n        'table',\r\n        'dl',\r\n        'ol',\r\n        'ul',\r\n        'script',\r\n        'noscript',\r\n        'form',\r\n        'fieldset',\r\n        'iframe',\r\n        'math',\r\n        'style',\r\n        'section',\r\n        'header',\r\n        'footer',\r\n        'nav',\r\n        'article',\r\n        'aside',\r\n        'address',\r\n        'audio',\r\n        'canvas',\r\n        'figure',\r\n        'hgroup',\r\n        'output',\r\n        'video',\r\n        'p'\r\n      ],\r\n      repFunc = function (wholeMatch, match, left, right) {\r\n        var txt = wholeMatch;\r\n        // check if this html element is marked as markdown\r\n        // if so, it's contents should be parsed as markdown\r\n        if (left.search(/\\bmarkdown\\b/) !== -1) {\r\n          txt = left + globals.converter.makeHtml(match) + right;\r\n        }\r\n        return '\\n\\nK' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\\n\\n';\r\n      };\r\n\r\n  for (var i = 0; i < blockTags.length; ++i) {\r\n\r\n    var opTagPos,\r\n        rgx1     = new RegExp('^ {0,3}<' + blockTags[i] + '\\\\b[^>]*>', 'im'),\r\n        patLeft  = '<' + blockTags[i] + '\\\\b[^>]*>',\r\n        patRight = '</' + blockTags[i] + '>';\r\n    // 1. Look for the first position of the first opening HTML tag in the text\r\n    while ((opTagPos = showdown.helper.regexIndexOf(text, rgx1)) !== -1) {\r\n      //2. Split the text in that position\r\n      var subTexts = showdown.helper.splitAtIndex(text, opTagPos),\r\n      //3. Match recursively\r\n          newSubText1 = showdown.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, 'im');\r\n\r\n      // prevent an infinite loop\r\n      if (newSubText1 === subTexts[1]) {\r\n        break;\r\n      }\r\n      text = subTexts[0].concat(newSubText1);\r\n    }\r\n  }\r\n  // HR SPECIAL CASE\r\n  text = text.replace(/(\\n {0,3}(<(hr)\\b([^<>])*?\\/?>)[ \\t]*(?=\\n{2,}))/g,\r\n    showdown.subParser('hashElement')(text, options, globals));\r\n\r\n  // Special case for standalone HTML comments\r\n  text = showdown.helper.replaceRecursiveRegExp(text, function (txt) {\r\n    return '\\n\\nK' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\\n\\n';\r\n  }, '^ {0,3}<!--', '-->', 'gm');\r\n\r\n  // PHP and ASP-style processor instructions (<?...?> and <%...%>)\r\n  text = text.replace(/(?:\\n\\n)( {0,3}(?:<([?%])[^\\r]*?\\2>)[ \\t]*(?=\\n{2,}))/g,\r\n    showdown.subParser('hashElement')(text, options, globals));\r\n\r\n  text = globals.converter._dispatch('hashHTMLBlocks.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Hash span elements that should not be parsed as markdown\r\n */\r\nshowdown.subParser('hashHTMLSpans', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('hashHTMLSpans.before', text, options, globals);\r\n\r\n  function hashHTMLSpan (html) {\r\n    return 'C' + (globals.gHtmlSpans.push(html) - 1) + 'C';\r\n  }\r\n\r\n  // Hash Self Closing tags\r\n  text = text.replace(/<[^>]+?\\/>/gi, function (wm) {\r\n    return hashHTMLSpan(wm);\r\n  });\r\n\r\n  // Hash tags without properties\r\n  text = text.replace(/<([^>]+?)>[\\s\\S]*?<\\/\\1>/g, function (wm) {\r\n    return hashHTMLSpan(wm);\r\n  });\r\n\r\n  // Hash tags with properties\r\n  text = text.replace(/<([^>]+?)\\s[^>]+?>[\\s\\S]*?<\\/\\1>/g, function (wm) {\r\n    return hashHTMLSpan(wm);\r\n  });\r\n\r\n  // Hash self closing tags without />\r\n  text = text.replace(/<[^>]+?>/gi, function (wm) {\r\n    return hashHTMLSpan(wm);\r\n  });\r\n\r\n  /*showdown.helper.matchRecursiveRegExp(text, '<code\\\\b[^>]*>', '</code>', 'gi');*/\r\n\r\n  text = globals.converter._dispatch('hashHTMLSpans.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Unhash HTML spans\r\n */\r\nshowdown.subParser('unhashHTMLSpans', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('unhashHTMLSpans.before', text, options, globals);\r\n\r\n  for (var i = 0; i < globals.gHtmlSpans.length; ++i) {\r\n    var repText = globals.gHtmlSpans[i],\r\n        // limiter to prevent infinite loop (assume 10 as limit for recurse)\r\n        limit = 0;\r\n\r\n    while (/C(\\d+)C/.test(repText)) {\r\n      var num = RegExp.$1;\r\n      repText = repText.replace('C' + num + 'C', globals.gHtmlSpans[num]);\r\n      if (limit === 10) {\r\n        break;\r\n      }\r\n      ++limit;\r\n    }\r\n    text = text.replace('C' + i + 'C', repText);\r\n  }\r\n\r\n  text = globals.converter._dispatch('unhashHTMLSpans.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Hash and escape <pre><code> elements that should not be parsed as markdown\r\n */\r\nshowdown.subParser('hashPreCodeTags', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('hashPreCodeTags.before', text, options, globals);\r\n\r\n  var repFunc = function (wholeMatch, match, left, right) {\r\n    // encode html entities\r\n    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;\r\n    return '\\n\\nG' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\\n\\n';\r\n  };\r\n\r\n  // Hash <pre><code>\r\n  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '^ {0,3}<pre\\\\b[^>]*>\\\\s*<code\\\\b[^>]*>', '^ {0,3}</code>\\\\s*</pre>', 'gim');\r\n\r\n  text = globals.converter._dispatch('hashPreCodeTags.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('headers', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('headers.before', text, options, globals);\r\n\r\n  var headerLevelStart = (isNaN(parseInt(options.headerLevelStart))) ? 1 : parseInt(options.headerLevelStart),\r\n      ghHeaderId = options.ghCompatibleHeaderId,\r\n\r\n  // Set text-style headers:\r\n  //\tHeader 1\r\n  //\t========\r\n  //\r\n  //\tHeader 2\r\n  //\t--------\r\n  //\r\n      setextRegexH1 = (options.smoothLivePreview) ? /^(.+)[ \\t]*\\n={2,}[ \\t]*\\n+/gm : /^(.+)[ \\t]*\\n=+[ \\t]*\\n+/gm,\r\n      setextRegexH2 = (options.smoothLivePreview) ? /^(.+)[ \\t]*\\n-{2,}[ \\t]*\\n+/gm : /^(.+)[ \\t]*\\n-+[ \\t]*\\n+/gm;\r\n\r\n  text = text.replace(setextRegexH1, function (wholeMatch, m1) {\r\n\r\n    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),\r\n        hID = (options.noHeaderId) ? '' : ' id=\"' + headerId(m1) + '\"',\r\n        hLevel = headerLevelStart,\r\n        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';\r\n    return showdown.subParser('hashBlock')(hashBlock, options, globals);\r\n  });\r\n\r\n  text = text.replace(setextRegexH2, function (matchFound, m1) {\r\n    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),\r\n        hID = (options.noHeaderId) ? '' : ' id=\"' + headerId(m1) + '\"',\r\n        hLevel = headerLevelStart + 1,\r\n        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';\r\n    return showdown.subParser('hashBlock')(hashBlock, options, globals);\r\n  });\r\n\r\n  // atx-style headers:\r\n  //  # Header 1\r\n  //  ## Header 2\r\n  //  ## Header 2 with closing hashes ##\r\n  //  ...\r\n  //  ###### Header 6\r\n  //\r\n  var atxStyle = (options.requireSpaceBeforeHeadingText) ? /^(#{1,6})[ \\t]+(.+?)[ \\t]*#*\\n+/gm : /^(#{1,6})[ \\t]*(.+?)[ \\t]*#*\\n+/gm;\r\n\r\n  text = text.replace(atxStyle, function (wholeMatch, m1, m2) {\r\n    var hText = m2;\r\n    if (options.customizedHeaderId) {\r\n      hText = m2.replace(/\\s?\\{([^{]+?)}\\s*$/, '');\r\n    }\r\n\r\n    var span = showdown.subParser('spanGamut')(hText, options, globals),\r\n        hID = (options.noHeaderId) ? '' : ' id=\"' + headerId(m2) + '\"',\r\n        hLevel = headerLevelStart - 1 + m1.length,\r\n        header = '<h' + hLevel + hID + '>' + span + '</h' + hLevel + '>';\r\n\r\n    return showdown.subParser('hashBlock')(header, options, globals);\r\n  });\r\n\r\n  function headerId (m) {\r\n    var title;\r\n\r\n    // It is separate from other options to allow combining prefix and customized\r\n    if (options.customizedHeaderId) {\r\n      var match = m.match(/\\{([^{]+?)}\\s*$/);\r\n      if (match && match[1]) {\r\n        m = match[1];\r\n      }\r\n    }\r\n\r\n    // Prefix id to prevent causing inadvertent pre-existing style matches.\r\n    if (showdown.helper.isString(options.prefixHeaderId)) {\r\n      title = options.prefixHeaderId + m;\r\n    } else if (options.prefixHeaderId === true) {\r\n      title = 'section ' + m;\r\n    } else {\r\n      title = m;\r\n    }\r\n\r\n    if (ghHeaderId) {\r\n      title = title\r\n        .replace(/ /g, '-')\r\n        // replace previously escaped chars (&,  and $)\r\n        .replace(/&amp;/g, '')\r\n        .replace(/T/g, '')\r\n        .replace(/D/g, '')\r\n        // replace rest of the chars (&~$ are repeated as they might have been escaped)\r\n        // borrowed from github's redcarpet (some they should produce similar results)\r\n        .replace(/[&+$,\\/:;=?@\"#{}|^~\\[\\]`\\\\*)(%.!'<>]/g, '')\r\n        .toLowerCase();\r\n    } else {\r\n      title = title\r\n        .replace(/[^\\w]/g, '')\r\n        .toLowerCase();\r\n    }\r\n\r\n    if (globals.hashLinkCounts[title]) {\r\n      title = title + '-' + (globals.hashLinkCounts[title]++);\r\n    } else {\r\n      globals.hashLinkCounts[title] = 1;\r\n    }\r\n    return title;\r\n  }\r\n\r\n  text = globals.converter._dispatch('headers.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Turn Markdown link shortcuts into XHTML <a> tags.\r\n */\r\nshowdown.subParser('horizontalRule', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('horizontalRule.before', text, options, globals);\r\n\r\n  var key = showdown.subParser('hashBlock')('<hr />', options, globals);\r\n  text = text.replace(/^ {0,2}( ?-){3,}[ \\t]*$/gm, key);\r\n  text = text.replace(/^ {0,2}( ?\\*){3,}[ \\t]*$/gm, key);\r\n  text = text.replace(/^ {0,2}( ?_){3,}[ \\t]*$/gm, key);\r\n\r\n  text = globals.converter._dispatch('horizontalRule.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Turn Markdown image shortcuts into <img> tags.\r\n */\r\nshowdown.subParser('images', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('images.before', text, options, globals);\r\n\r\n  var inlineRegExp      = /!\\[([^\\]]*?)][ \\t]*()\\([ \\t]?<?([\\S]+?(?:\\([\\S]*?\\)[\\S]*?)?)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*(?:([\"'])([^\"]*?)\\6)?[ \\t]?\\)/g,\r\n      crazyRegExp       = /!\\[([^\\]]*?)][ \\t]*()\\([ \\t]?<([^>]*)>(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*(?:(?:([\"'])([^\"]*?)\\6))?[ \\t]?\\)/g,\r\n      referenceRegExp   = /!\\[([^\\]]*?)] ?(?:\\n *)?\\[(.*?)]()()()()()/g,\r\n      refShortcutRegExp = /!\\[([^\\[\\]]+)]()()()()()/g;\r\n\r\n  function writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title) {\r\n\r\n    var gUrls   = globals.gUrls,\r\n        gTitles = globals.gTitles,\r\n        gDims   = globals.gDimensions;\r\n\r\n    linkId = linkId.toLowerCase();\r\n\r\n    if (!title) {\r\n      title = '';\r\n    }\r\n    // Special case for explicit empty url\r\n    if (wholeMatch.search(/\\(<?\\s*>? ?(['\"].*['\"])?\\)$/m) > -1) {\r\n      url = '';\r\n\r\n    } else if (url === '' || url === null) {\r\n      if (linkId === '' || linkId === null) {\r\n        // lower-case and turn embedded newlines into spaces\r\n        linkId = altText.toLowerCase().replace(/ ?\\n/g, ' ');\r\n      }\r\n      url = '#' + linkId;\r\n\r\n      if (!showdown.helper.isUndefined(gUrls[linkId])) {\r\n        url = gUrls[linkId];\r\n        if (!showdown.helper.isUndefined(gTitles[linkId])) {\r\n          title = gTitles[linkId];\r\n        }\r\n        if (!showdown.helper.isUndefined(gDims[linkId])) {\r\n          width = gDims[linkId].width;\r\n          height = gDims[linkId].height;\r\n        }\r\n      } else {\r\n        return wholeMatch;\r\n      }\r\n    }\r\n\r\n    altText = altText\r\n      .replace(/\"/g, '&quot;')\r\n    //altText = showdown.helper.escapeCharacters(altText, '*_', false);\r\n      .replace(showdown.helper.regexes.asteriskAndDash, showdown.helper.escapeCharactersCallback);\r\n    //url = showdown.helper.escapeCharacters(url, '*_', false);\r\n    url = url.replace(showdown.helper.regexes.asteriskAndDash, showdown.helper.escapeCharactersCallback);\r\n    var result = '<img src=\"' + url + '\" alt=\"' + altText + '\"';\r\n\r\n    if (title) {\r\n      title = title\r\n        .replace(/\"/g, '&quot;')\r\n      //title = showdown.helper.escapeCharacters(title, '*_', false);\r\n        .replace(showdown.helper.regexes.asteriskAndDash, showdown.helper.escapeCharactersCallback);\r\n      result += ' title=\"' + title + '\"';\r\n    }\r\n\r\n    if (width && height) {\r\n      width  = (width === '*') ? 'auto' : width;\r\n      height = (height === '*') ? 'auto' : height;\r\n\r\n      result += ' width=\"' + width + '\"';\r\n      result += ' height=\"' + height + '\"';\r\n    }\r\n\r\n    result += ' />';\r\n\r\n    return result;\r\n  }\r\n\r\n  // First, handle reference-style labeled images: ![alt text][id]\r\n  text = text.replace(referenceRegExp, writeImageTag);\r\n\r\n  // Next, handle inline images:  ![alt text](url =<width>x<height> \"optional title\")\r\n  // cases with crazy urls like ./image/cat1).png\r\n  text = text.replace(crazyRegExp, writeImageTag);\r\n\r\n  // normal cases\r\n  text = text.replace(inlineRegExp, writeImageTag);\r\n\r\n  // handle reference-style shortcuts: |[img text]\r\n  text = text.replace(refShortcutRegExp, writeImageTag);\r\n\r\n  text = globals.converter._dispatch('images.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('italicsAndBold', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('italicsAndBold.before', text, options, globals);\r\n\r\n  // it's faster to have 3 separate regexes for each case than have just one\r\n  // because of backtracing, in some cases, it could lead to an exponential effect\r\n  // called \"catastrophic backtrace\". Ominous!\r\n\r\n  function parseInside (txt, left, right) {\r\n    if (options.simplifiedAutoLink) {\r\n      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);\r\n    }\r\n    return left + txt + right;\r\n  }\r\n\r\n  // Parse underscores\r\n  if (options.literalMidWordUnderscores) {\r\n    text = text.replace(/\\b___(\\S[\\s\\S]*)___\\b/g, function (wm, txt) {\r\n      return parseInside (txt, '<strong><em>', '</em></strong>');\r\n    });\r\n    text = text.replace(/\\b__(\\S[\\s\\S]*)__\\b/g, function (wm, txt) {\r\n      return parseInside (txt, '<strong>', '</strong>');\r\n    });\r\n    text = text.replace(/\\b_(\\S[\\s\\S]*?)_\\b/g, function (wm, txt) {\r\n      return parseInside (txt, '<em>', '</em>');\r\n    });\r\n  } else {\r\n    text = text.replace(/___(\\S[\\s\\S]*?)___/g, function (wm, m) {\r\n      return (/\\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;\r\n    });\r\n    text = text.replace(/__(\\S[\\s\\S]*?)__/g, function (wm, m) {\r\n      return (/\\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;\r\n    });\r\n    text = text.replace(/_([^\\s_][\\s\\S]*?)_/g, function (wm, m) {\r\n      // !/^_[^_]/.test(m) - test if it doesn't start with __ (since it seems redundant, we removed it)\r\n      return (/\\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;\r\n    });\r\n  }\r\n\r\n  // Now parse asterisks\r\n  if (options.literalMidWordAsterisks) {\r\n    text = text.trim().replace(/(?:^| +)\\*{3}(\\S[\\s\\S]*?)\\*{3}(?: +|$)/g, function (wm, txt) {\r\n      return parseInside (txt, ' <strong><em>', '</em></strong> ');\r\n    });\r\n    text = text.trim().replace(/(?:^| +)\\*{2}(\\S[\\s\\S]*?)\\*{2}(?: +|$)/g, function (wm, txt) {\r\n      return parseInside (txt, ' <strong>', '</strong> ');\r\n    });\r\n    text = text.trim().replace(/(?:^| +)\\*{1}(\\S[\\s\\S]*?)\\*{1}(?: +|$)/g, function (wm, txt) {\r\n      return parseInside (txt, ' <em>', '</em>' + (wm.slice(-1) === ' ' ? ' ' : ''));\r\n    });\r\n  } else {\r\n    text = text.replace(/\\*\\*\\*(\\S[\\s\\S]*?)\\*\\*\\*/g, function (wm, m) {\r\n      return (/\\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;\r\n    });\r\n    text = text.replace(/\\*\\*(\\S[\\s\\S]*?)\\*\\*/g, function (wm, m) {\r\n      return (/\\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;\r\n    });\r\n    text = text.replace(/\\*([^\\s*][\\s\\S]*?)\\*/g, function (wm, m) {\r\n      // !/^\\*[^*]/.test(m) - test if it doesn't start with ** (since it seems redundant, we removed it)\r\n      return (/\\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;\r\n    });\r\n  }\r\n\r\n\r\n  text = globals.converter._dispatch('italicsAndBold.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Form HTML ordered (numbered) and unordered (bulleted) lists.\r\n */\r\nshowdown.subParser('lists', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('lists.before', text, options, globals);\r\n\r\n  /**\r\n   * Process the contents of a single ordered or unordered list, splitting it\r\n   * into individual list items.\r\n   * @param {string} listStr\r\n   * @param {boolean} trimTrailing\r\n   * @returns {string}\r\n   */\r\n  function processListItems (listStr, trimTrailing) {\r\n    // The $g_list_level global keeps track of when we're inside a list.\r\n    // Each time we enter a list, we increment it; when we leave a list,\r\n    // we decrement. If it's zero, we're not in a list anymore.\r\n    //\r\n    // We do this because when we're not inside a list, we want to treat\r\n    // something like this:\r\n    //\r\n    //    I recommend upgrading to version\r\n    //    8. Oops, now this line is treated\r\n    //    as a sub-list.\r\n    //\r\n    // As a single paragraph, despite the fact that the second line starts\r\n    // with a digit-period-space sequence.\r\n    //\r\n    // Whereas when we're inside a list (or sub-list), that line will be\r\n    // treated as the start of a sub-list. What a kludge, huh? This is\r\n    // an aspect of Markdown's syntax that's hard to parse perfectly\r\n    // without resorting to mind-reading. Perhaps the solution is to\r\n    // change the syntax rules such that sub-lists must start with a\r\n    // starting cardinal number; e.g. \"1.\" or \"a.\".\r\n    globals.gListLevel++;\r\n\r\n    // trim trailing blank lines:\r\n    listStr = listStr.replace(/\\n{2,}$/, '\\n');\r\n\r\n    // attacklab: add sentinel to emulate \\z\r\n    listStr += '0';\r\n\r\n    var rgx = /(\\n)?(^ {0,3})([*+-]|\\d+[.])[ \\t]+((\\[(x|X| )?])?[ \\t]*[^\\r]+?(\\n{1,2}))(?=\\n*(0| {0,3}([*+-]|\\d+[.])[ \\t]+))/gm,\r\n        isParagraphed = (/\\n[ \\t]*\\n(?!0)/.test(listStr));\r\n\r\n    // Since version 1.5, nesting sublists requires 4 spaces (or 1 tab) indentation,\r\n    // which is a syntax breaking change\r\n    // activating this option reverts to old behavior\r\n    if (options.disableForced4SpacesIndentedSublists) {\r\n      rgx = /(\\n)?(^ {0,3})([*+-]|\\d+[.])[ \\t]+((\\[(x|X| )?])?[ \\t]*[^\\r]+?(\\n{1,2}))(?=\\n*(0|\\2([*+-]|\\d+[.])[ \\t]+))/gm;\r\n    }\r\n\r\n    listStr = listStr.replace(rgx, function (wholeMatch, m1, m2, m3, m4, taskbtn, checked) {\r\n      checked = (checked && checked.trim() !== '');\r\n\r\n      var item = showdown.subParser('outdent')(m4, options, globals),\r\n          bulletStyle = '';\r\n\r\n      // Support for github tasklists\r\n      if (taskbtn && options.tasklists) {\r\n        bulletStyle = ' class=\"task-list-item\" style=\"list-style-type: none;\"';\r\n        item = item.replace(/^[ \\t]*\\[(x|X| )?]/m, function () {\r\n          var otp = '<input type=\"checkbox\" disabled style=\"margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;\"';\r\n          if (checked) {\r\n            otp += ' checked';\r\n          }\r\n          otp += '>';\r\n          return otp;\r\n        });\r\n      }\r\n\r\n      // ISSUE #312\r\n      // This input: - - - a\r\n      // causes trouble to the parser, since it interprets it as:\r\n      // <ul><li><li><li>a</li></li></li></ul>\r\n      // instead of:\r\n      // <ul><li>- - a</li></ul>\r\n      // So, to prevent it, we will put a marker (A)in the beginning of the line\r\n      // Kind of hackish/monkey patching, but seems more effective than overcomplicating the list parser\r\n      item = item.replace(/^([-*+]|\\d\\.)[ \\t]+[\\S\\n ]*/g, function (wm2) {\r\n        return 'A' + wm2;\r\n      });\r\n\r\n      // m1 - Leading line or\r\n      // Has a double return (multi paragraph) or\r\n      // Has sublist\r\n      if (m1 || (item.search(/\\n{2,}/) > -1)) {\r\n        item = showdown.subParser('githubCodeBlocks')(item, options, globals);\r\n        item = showdown.subParser('blockGamut')(item, options, globals);\r\n      } else {\r\n        // Recursion for sub-lists:\r\n        item = showdown.subParser('lists')(item, options, globals);\r\n        item = item.replace(/\\n$/, ''); // chomp(item)\r\n        item = showdown.subParser('hashHTMLBlocks')(item, options, globals);\r\n        // Colapse double linebreaks\r\n        item = item.replace(/\\n\\n+/g, '\\n\\n');\r\n        // replace double linebreaks with a placeholder\r\n        item = item.replace(/\\n\\n/g, 'B');\r\n        if (isParagraphed) {\r\n          item = showdown.subParser('paragraphs')(item, options, globals);\r\n        } else {\r\n          item = showdown.subParser('spanGamut')(item, options, globals);\r\n        }\r\n        item = item.replace(/B/g, '\\n\\n');\r\n      }\r\n\r\n      // now we need to remove the marker (A)\r\n      item = item.replace('A', '');\r\n      // we can finally wrap the line in list item tags\r\n      item =  '<li' + bulletStyle + '>' + item + '</li>\\n';\r\n\r\n      return item;\r\n    });\r\n\r\n    // attacklab: strip sentinel\r\n    listStr = listStr.replace(/0/g, '');\r\n\r\n    globals.gListLevel--;\r\n\r\n    if (trimTrailing) {\r\n      listStr = listStr.replace(/\\s+$/, '');\r\n    }\r\n\r\n    return listStr;\r\n  }\r\n\r\n  /**\r\n   * Check and parse consecutive lists (better fix for issue #142)\r\n   * @param {string} list\r\n   * @param {string} listType\r\n   * @param {boolean} trimTrailing\r\n   * @returns {string}\r\n   */\r\n  function parseConsecutiveLists (list, listType, trimTrailing) {\r\n    // check if we caught 2 or more consecutive lists by mistake\r\n    // we use the counterRgx, meaning if listType is UL we look for OL and vice versa\r\n    var olRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?\\d+\\.[ \\t]/gm : /^ {0,3}\\d+\\.[ \\t]/gm,\r\n        ulRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?[*+-][ \\t]/gm : /^ {0,3}[*+-][ \\t]/gm,\r\n        counterRxg = (listType === 'ul') ? olRgx : ulRgx,\r\n        result = '';\r\n\r\n    if (list.search(counterRxg) !== -1) {\r\n      (function parseCL (txt) {\r\n        var pos = txt.search(counterRxg);\r\n        if (pos !== -1) {\r\n          // slice\r\n          result += '\\n<' + listType + '>\\n' + processListItems(txt.slice(0, pos), !!trimTrailing) + '</' + listType + '>\\n';\r\n\r\n          // invert counterType and listType\r\n          listType = (listType === 'ul') ? 'ol' : 'ul';\r\n          counterRxg = (listType === 'ul') ? olRgx : ulRgx;\r\n\r\n          //recurse\r\n          parseCL(txt.slice(pos));\r\n        } else {\r\n          result += '\\n<' + listType + '>\\n' + processListItems(txt, !!trimTrailing) + '</' + listType + '>\\n';\r\n        }\r\n      })(list);\r\n    } else {\r\n      result = '\\n<' + listType + '>\\n' + processListItems(list, !!trimTrailing) + '</' + listType + '>\\n';\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // add sentinel to hack around khtml/safari bug:\r\n  // http://bugs.webkit.org/show_bug.cgi?id=11231\r\n  text += '0';\r\n\r\n  if (globals.gListLevel) {\r\n    text = text.replace(/^(( {0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm,\r\n      function (wholeMatch, list, m2) {\r\n        var listType = (m2.search(/[*+-]/g) > -1) ? 'ul' : 'ol';\r\n        return parseConsecutiveLists(list, listType, true);\r\n      }\r\n    );\r\n  } else {\r\n    text = text.replace(/(\\n\\n|^\\n?)(( {0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm,\r\n      function (wholeMatch, m1, list, m3) {\r\n        var listType = (m3.search(/[*+-]/g) > -1) ? 'ul' : 'ol';\r\n        return parseConsecutiveLists(list, listType, false);\r\n      }\r\n    );\r\n  }\r\n\r\n  // strip sentinel\r\n  text = text.replace(/0/, '');\r\n  text = globals.converter._dispatch('lists.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Remove one level of line-leading tabs or spaces\r\n */\r\nshowdown.subParser('outdent', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('outdent.before', text, options, globals);\r\n\r\n  // attacklab: hack around Konqueror 3.5.4 bug:\r\n  // \"----------bug\".replace(/^-/g,\"\") == \"bug\"\r\n  text = text.replace(/^(\\t|[ ]{1,4})/gm, '0'); // attacklab: g_tab_width\r\n\r\n  // attacklab: clean up hack\r\n  text = text.replace(/0/g, '');\r\n\r\n  text = globals.converter._dispatch('outdent.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\n/**\r\n *\r\n */\r\nshowdown.subParser('paragraphs', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('paragraphs.before', text, options, globals);\r\n  // Strip leading and trailing lines:\r\n  text = text.replace(/^\\n+/g, '');\r\n  text = text.replace(/\\n+$/g, '');\r\n\r\n  var grafs = text.split(/\\n{2,}/g),\r\n      grafsOut = [],\r\n      end = grafs.length; // Wrap <p> tags\r\n\r\n  for (var i = 0; i < end; i++) {\r\n    var str = grafs[i];\r\n    // if this is an HTML marker, copy it\r\n    if (str.search(/(K|G)(\\d+)\\1/g) >= 0) {\r\n      grafsOut.push(str);\r\n\r\n    // test for presence of characters to prevent empty lines being parsed\r\n    // as paragraphs (resulting in undesired extra empty paragraphs)\r\n    } else if (str.search(/\\S/) >= 0) {\r\n      str = showdown.subParser('spanGamut')(str, options, globals);\r\n      str = str.replace(/^([ \\t]*)/g, '<p>');\r\n      str += '</p>';\r\n      grafsOut.push(str);\r\n    }\r\n  }\r\n\r\n  /** Unhashify HTML blocks */\r\n  end = grafsOut.length;\r\n  for (i = 0; i < end; i++) {\r\n    var blockText = '',\r\n        grafsOutIt = grafsOut[i],\r\n        codeFlag = false;\r\n    // if this is a marker for an html block...\r\n    // use RegExp.test instead of string.search because of QML bug\r\n    while (/(K|G)(\\d+)\\1/.test(grafsOutIt)) {\r\n      var delim = RegExp.$1,\r\n          num   = RegExp.$2;\r\n\r\n      if (delim === 'K') {\r\n        blockText = globals.gHtmlBlocks[num];\r\n      } else {\r\n        // we need to check if ghBlock is a false positive\r\n        if (codeFlag) {\r\n          // use encoded version of all text\r\n          blockText = showdown.subParser('encodeCode')(globals.ghCodeBlocks[num].text, options, globals);\r\n        } else {\r\n          blockText = globals.ghCodeBlocks[num].codeblock;\r\n        }\r\n      }\r\n      blockText = blockText.replace(/\\$/g, '$$$$'); // Escape any dollar signs\r\n\r\n      grafsOutIt = grafsOutIt.replace(/(\\n\\n)?(K|G)\\d+\\2(\\n\\n)?/, blockText);\r\n      // Check if grafsOutIt is a pre->code\r\n      if (/^<pre\\b[^>]*>\\s*<code\\b[^>]*>/.test(grafsOutIt)) {\r\n        codeFlag = true;\r\n      }\r\n    }\r\n    grafsOut[i] = grafsOutIt;\r\n  }\r\n  text = grafsOut.join('\\n');\r\n  // Strip leading and trailing lines:\r\n  text = text.replace(/^\\n+/g, '');\r\n  text = text.replace(/\\n+$/g, '');\r\n  return globals.converter._dispatch('paragraphs.after', text, options, globals);\r\n});\r\n\r\n/**\r\n * Run extension\r\n */\r\nshowdown.subParser('runExtension', function (ext, text, options, globals) {\r\n  'use strict';\r\n\r\n  if (ext.filter) {\r\n    text = ext.filter(text, globals.converter, options);\r\n\r\n  } else if (ext.regex) {\r\n    // TODO remove this when old extension loading mechanism is deprecated\r\n    var re = ext.regex;\r\n    if (!(re instanceof RegExp)) {\r\n      re = new RegExp(re, 'g');\r\n    }\r\n    text = text.replace(re, ext.replace);\r\n  }\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * These are all the transformations that occur *within* block-level\r\n * tags like paragraphs, headers, and list items.\r\n */\r\nshowdown.subParser('spanGamut', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('spanGamut.before', text, options, globals);\r\n  text = showdown.subParser('codeSpans')(text, options, globals);\r\n  text = showdown.subParser('escapeSpecialCharsWithinTagAttributes')(text, options, globals);\r\n  text = showdown.subParser('encodeBackslashEscapes')(text, options, globals);\r\n\r\n  // Process anchor and image tags. Images must come first,\r\n  // because ![foo][f] looks like an anchor.\r\n  text = showdown.subParser('images')(text, options, globals);\r\n  text = showdown.subParser('anchors')(text, options, globals);\r\n\r\n  // Make links out of things like `<http://example.com/>`\r\n  // Must come after anchors, because you can use < and >\r\n  // delimiters in inline links like [this](<url>).\r\n  text = showdown.subParser('autoLinks')(text, options, globals);\r\n  text = showdown.subParser('italicsAndBold')(text, options, globals);\r\n  text = showdown.subParser('strikethrough')(text, options, globals);\r\n  text = showdown.subParser('simplifiedAutoLinks')(text, options, globals);\r\n\r\n  // we need to hash HTML tags inside spans\r\n  text = showdown.subParser('hashHTMLSpans')(text, options, globals);\r\n\r\n  // now we encode amps and angles\r\n  text = showdown.subParser('encodeAmpsAndAngles')(text, options, globals);\r\n\r\n  // Do hard breaks\r\n  if (options.simpleLineBreaks) {\r\n    // GFM style hard breaks\r\n    text = text.replace(/\\n/g, '<br />\\n');\r\n  } else {\r\n    // Vanilla hard breaks\r\n    text = text.replace(/  +\\n/g, '<br />\\n');\r\n  }\r\n\r\n  text = globals.converter._dispatch('spanGamut.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('strikethrough', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  function parseInside (txt) {\r\n    if (options.simplifiedAutoLink) {\r\n      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);\r\n    }\r\n    return '<del>' + txt + '</del>';\r\n  }\r\n\r\n  if (options.strikethrough) {\r\n    text = globals.converter._dispatch('strikethrough.before', text, options, globals);\r\n    text = text.replace(/(?:~){2}([\\s\\S]+?)(?:~){2}/g, function (wm, txt) { return parseInside(txt); });\r\n    text = globals.converter._dispatch('strikethrough.after', text, options, globals);\r\n  }\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * Strips link definitions from text, stores the URLs and titles in\r\n * hash references.\r\n * Link defs are in the form: ^[id]: url \"optional title\"\r\n */\r\nshowdown.subParser('stripLinkDefinitions', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  var regex = /^ {0,3}\\[(.+)]:[ \\t]*\\n?[ \\t]*<?([^>\\s]+)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"|'(](.+?)[\"|')][ \\t]*)?(?:\\n+|(?=0))/gm;\r\n\r\n  // attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\r\n  text += '0';\r\n\r\n  text = text.replace(regex, function (wholeMatch, linkId, url, width, height, blankLines, title) {\r\n    linkId = linkId.toLowerCase();\r\n    globals.gUrls[linkId] = showdown.subParser('encodeAmpsAndAngles')(url, options, globals);  // Link IDs are case-insensitive\r\n\r\n    if (blankLines) {\r\n      // Oops, found blank lines, so it's not a title.\r\n      // Put back the parenthetical statement we stole.\r\n      return blankLines + title;\r\n\r\n    } else {\r\n      if (title) {\r\n        globals.gTitles[linkId] = title.replace(/\"|'/g, '&quot;');\r\n      }\r\n      if (options.parseImgDimensions && width && height) {\r\n        globals.gDimensions[linkId] = {\r\n          width:  width,\r\n          height: height\r\n        };\r\n      }\r\n    }\r\n    // Completely remove the definition from the text\r\n    return '';\r\n  });\r\n\r\n  // attacklab: strip sentinel\r\n  text = text.replace(/0/, '');\r\n\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('tables', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  if (!options.tables) {\r\n    return text;\r\n  }\r\n\r\n  var tableRgx = /^ {0,3}\\|?.+\\|.+\\n[ \\t]{0,3}\\|?[ \\t]*:?[ \\t]*(?:-|=){2,}[ \\t]*:?[ \\t]*\\|[ \\t]*:?[ \\t]*(?:-|=){2,}[\\s\\S]+?(?:\\n\\n|0)/gm;\r\n\r\n  function parseStyles (sLine) {\r\n    if (/^:[ \\t]*--*$/.test(sLine)) {\r\n      return ' style=\"text-align:left;\"';\r\n    } else if (/^--*[ \\t]*:[ \\t]*$/.test(sLine)) {\r\n      return ' style=\"text-align:right;\"';\r\n    } else if (/^:[ \\t]*--*[ \\t]*:$/.test(sLine)) {\r\n      return ' style=\"text-align:center;\"';\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n\r\n  function parseHeaders (header, style) {\r\n    var id = '';\r\n    header = header.trim();\r\n    if (options.tableHeaderId) {\r\n      id = ' id=\"' + header.replace(/ /g, '_').toLowerCase() + '\"';\r\n    }\r\n    header = showdown.subParser('spanGamut')(header, options, globals);\r\n\r\n    return '<th' + id + style + '>' + header + '</th>\\n';\r\n  }\r\n\r\n  function parseCells (cell, style) {\r\n    var subText = showdown.subParser('spanGamut')(cell, options, globals);\r\n    return '<td' + style + '>' + subText + '</td>\\n';\r\n  }\r\n\r\n  function buildTable (headers, cells) {\r\n    var tb = '<table>\\n<thead>\\n<tr>\\n',\r\n        tblLgn = headers.length;\r\n\r\n    for (var i = 0; i < tblLgn; ++i) {\r\n      tb += headers[i];\r\n    }\r\n    tb += '</tr>\\n</thead>\\n<tbody>\\n';\r\n\r\n    for (i = 0; i < cells.length; ++i) {\r\n      tb += '<tr>\\n';\r\n      for (var ii = 0; ii < tblLgn; ++ii) {\r\n        tb += cells[i][ii];\r\n      }\r\n      tb += '</tr>\\n';\r\n    }\r\n    tb += '</tbody>\\n</table>\\n';\r\n    return tb;\r\n  }\r\n\r\n  text = globals.converter._dispatch('tables.before', text, options, globals);\r\n\r\n  // find escaped pipe characters\r\n  text = text.replace(/\\\\(\\|)/g, showdown.helper.escapeCharactersCallback);\r\n\r\n  // parse tables\r\n  text = text.replace(tableRgx, function (rawTable) {\r\n\r\n    var i, tableLines = rawTable.split('\\n');\r\n\r\n    // strip wrong first and last column if wrapped tables are used\r\n    for (i = 0; i < tableLines.length; ++i) {\r\n      if (/^ {0,3}\\|/.test(tableLines[i])) {\r\n        tableLines[i] = tableLines[i].replace(/^ {0,3}\\|/, '');\r\n      }\r\n      if (/\\|[ \\t]*$/.test(tableLines[i])) {\r\n        tableLines[i] = tableLines[i].replace(/\\|[ \\t]*$/, '');\r\n      }\r\n    }\r\n\r\n    var rawHeaders = tableLines[0].split('|').map(function (s) { return s.trim();}),\r\n        rawStyles = tableLines[1].split('|').map(function (s) { return s.trim();}),\r\n        rawCells = [],\r\n        headers = [],\r\n        styles = [],\r\n        cells = [];\r\n\r\n    tableLines.shift();\r\n    tableLines.shift();\r\n\r\n    for (i = 0; i < tableLines.length; ++i) {\r\n      if (tableLines[i].trim() === '') {\r\n        continue;\r\n      }\r\n      rawCells.push(\r\n        tableLines[i]\r\n          .split('|')\r\n          .map(function (s) {\r\n            return s.trim();\r\n          })\r\n      );\r\n    }\r\n\r\n    if (rawHeaders.length < rawStyles.length) {\r\n      return rawTable;\r\n    }\r\n\r\n    for (i = 0; i < rawStyles.length; ++i) {\r\n      styles.push(parseStyles(rawStyles[i]));\r\n    }\r\n\r\n    for (i = 0; i < rawHeaders.length; ++i) {\r\n      if (showdown.helper.isUndefined(styles[i])) {\r\n        styles[i] = '';\r\n      }\r\n      headers.push(parseHeaders(rawHeaders[i], styles[i]));\r\n    }\r\n\r\n    for (i = 0; i < rawCells.length; ++i) {\r\n      var row = [];\r\n      for (var ii = 0; ii < headers.length; ++ii) {\r\n        if (showdown.helper.isUndefined(rawCells[i][ii])) {\r\n\r\n        }\r\n        row.push(parseCells(rawCells[i][ii], styles[ii]));\r\n      }\r\n      cells.push(row);\r\n    }\r\n\r\n    return buildTable(headers, cells);\r\n  });\r\n\r\n  text = globals.converter._dispatch('tables.after', text, options, globals);\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * Swap back in all the special characters we've hidden.\r\n */\r\nshowdown.subParser('unescapeSpecialChars', function (text, options, globals) {\r\n  'use strict';\r\n  text = globals.converter._dispatch('unescapeSpecialChars.before', text, options, globals);\r\n\r\n  text = text.replace(/E(\\d+)E/g, function (wholeMatch, m1) {\r\n    var charCodeToReplace = parseInt(m1);\r\n    return String.fromCharCode(charCodeToReplace);\r\n  });\r\n\r\n  text = globals.converter._dispatch('unescapeSpecialChars.after', text, options, globals);\r\n  return text;\r\n});\r\n\r\nvar root = this;\r\n\r\n// CommonJS/nodeJS Loader\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = showdown;\r\n\r\n// AMD Loader\r\n} else if (typeof define === 'function' && define.amd) {\r\n  define(function () {\r\n    'use strict';\r\n    return showdown;\r\n  });\r\n\r\n// Regular Browser loader\r\n} else {\r\n  root.showdown = showdown;\r\n}\r\n}).call(this);\r\n\r\n//# sourceMappingURL=showdown.js.map\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/showdown/dist/showdown.js\n// module id = 1280\n// module chunks = 103"],"sourceRoot":""}